!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    EmField                    *A;$/;"	m	class:TChargedProp
A	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    EmField                    *A;$/;"	m	class:TChargedProp
A	lib/algorithms/CoarsenedMatrix.h	/^    std::vector<CoarseMatrix> A;$/;"	m	class:Grid::CoarsenedMatrix
A	lib/algorithms/approx/Zolotarev.h	/^    A,		      \/* overall factor *\/$/;"	m	struct:Grid::Approx::__anon695
ABx_lx	lib/Eigen/src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
ACTION_BASE_H	lib/qcd/action/ActionBase.h	33;"	d
ACTION_MODULES_H	lib/qcd/modules/ActionModules.h	30;"	d
ACTION_SET_H	lib/qcd/action/ActionSet.h	31;"	d
ADD_RESULT	lib/simd/Intel512wilson.h	110;"	d
ADD_RESULTi	lib/simd/IBM_qpx.h	577;"	d
ADD_RESULTi	lib/simd/Intel512wilson.h	588;"	d
ADD_RESULTia	lib/simd/Intel512wilson.h	598;"	d
ADJOINT_H	lib/qcd/representations/adjoint.h	7;"	d
AGM	lib/algorithms/approx/Zolotarev.cc	/^static INTERNAL_PRECISION AGM(INTERNAL_PRECISION a,$/;"	f	namespace:Grid::Approx
ALIVE	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	108;"	d
AMDOrdering	lib/Eigen/src/OrderingMethods/Ordering.h	/^class AMDOrdering$/;"	c	namespace:Eigen
AMatrix	lib/qcd/utils/SUnAdjoint.h	/^  typedef iSUnAdjointMatrix<Complex> AMatrix;$/;"	t	class:Grid::QCD::SU_Adjoint
AMatrixD	lib/qcd/utils/SUnAdjoint.h	/^  typedef iSUnAdjointMatrix<ComplexD> AMatrixD;$/;"	t	class:Grid::QCD::SU_Adjoint
AMatrixF	lib/qcd/utils/SUnAdjoint.h	/^  typedef iSUnAdjointMatrix<ComplexF> AMatrixF;$/;"	t	class:Grid::QCD::SU_Adjoint
APE_SMEAR_	lib/qcd/smearing/APEsmearing.h	34;"	d
APIBase	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef SparseSolverBase<SparseLU<_MatrixType,_OrderingType> > APIBase;$/;"	t	class:Eigen::SparseLU
APar	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^ 	typedef QCD::CheckpointerParameters APar;$/;"	t	class:Grid::CheckPointerModule
ARG	extras/Hadrons/Module.hpp	89;"	d
ARG	lib/Hadrons/Module.hpp	89;"	d
ASM_LEG	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	103;"	d
ASM_LEG	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	194;"	d
ASM_LEG	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	42;"	d
ASM_LEG	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	72;"	d
ASM_LEG_XP	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	113;"	d
ASM_LEG_XP	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	195;"	d
ASM_LEG_XP	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	57;"	d
ASM_LEG_XP	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	87;"	d
AVERAGE	lib/stencil/Stencil.h	1010;"	d
AVERAGE	lib/stencil/Stencil.h	1033;"	d
AVX512_PF_L1	lib/simd/Intel512wilson.h	537;"	d
AVX512_PF_L2_GAUGE	lib/simd/Intel512wilson.h	538;"	d
AVX512_PF_L2_LINEAR	lib/simd/Intel512wilson.h	540;"	d
AVX512_PF_L2_TABLE	lib/simd/Intel512wilson.h	539;"	d
AVX512_PF_L2_WRITE	lib/simd/Intel512common.h	34;"	d
AVector	lib/qcd/utils/CovariantLaplacian.h	/^  typedef SU<Nc>::LatticeAlgebraVector AVector;$/;"	t	class:Grid::QCD::LaplacianAlgebraField
Abs2ReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived> Abs2ReturnType;$/;"	t
AbsRealFunctor	lib/simd/Grid_vector_unops.h	/^struct AbsRealFunctor {$/;"	s	namespace:Grid
AbsReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived> AbsReturnType;$/;"	t
AccPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
AccPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
AccPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacketType,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
AcceptReject	tests/core/Test_GaugeAction.cc	/^  bool AcceptReject(const RealD Delta)$/;"	f	class:Metropolis
AcceptReject	tests/core/Test_RectPlaq.cc	/^  bool AcceptReject(const RealD Delta)$/;"	f	class:Metropolis
AccessorLevels	lib/Eigen/src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
AcosRealFunctor	lib/simd/Grid_vector_unops.h	/^struct AcosRealFunctor {$/;"	s	namespace:Grid
AcosReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_acos_op<Scalar>, const Derived> AcosReturnType;$/;"	t
ActPtr	lib/qcd/action/ActionSet.h	/^  typedef Action<Field>* ActPtr;$/;"	t	struct:Grid::QCD::ActionLevel
Action	lib/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
Action	lib/qcd/action/ActionBase.h	/^class Action $/;"	c	namespace:Grid::QCD
ActionBase	lib/qcd/modules/ActionModules.h	/^  typedef ActionModule<DBW2GaugeAction<Impl>, BetaGaugeActionParameters> ActionBase;$/;"	t	class:Grid::QCD::DBW2GModule
ActionBase	lib/qcd/modules/ActionModules.h	/^  typedef ActionModule<FermionA<Impl>, Params> ActionBase;$/;"	t	class:Grid::QCD::PseudoFermionModuleBase
ActionBase	lib/qcd/modules/ActionModules.h	/^  typedef ActionModule<IwasakiGaugeAction<Impl>, BetaGaugeActionParameters> ActionBase;$/;"	t	class:Grid::QCD::IwasakiGModule
ActionBase	lib/qcd/modules/ActionModules.h	/^  typedef ActionModule<PlaqPlusRectangleAction<Impl>, PlaqPlusRectangleGaugeActionParameters> ActionBase;$/;"	t	class:Grid::QCD::PlaqPlusRectangleGModule
ActionBase	lib/qcd/modules/ActionModules.h	/^  typedef ActionModule<RBCGaugeAction<Impl>, RBCGaugeActionParameters> ActionBase;$/;"	t	class:Grid::QCD::RBCGModule
ActionBase	lib/qcd/modules/ActionModules.h	/^  typedef ActionModule<SymanzikGaugeAction<Impl>, BetaGaugeActionParameters> ActionBase;$/;"	t	class:Grid::QCD::SymanzikGModule
ActionBase	lib/qcd/modules/ActionModules.h	/^  typedef ActionModule<WilsonGaugeAction<Impl>, BetaGaugeActionParameters> ActionBase;$/;"	t	class:Grid::QCD::WilsonGModule
ActionBaseModule	lib/qcd/hmc/HMCResourceManager.h	/^  typedef ActionModuleBase< QCD::Action<typename ImplementationPolicy::Field>, GridModule > ActionBaseModule;$/;"	t	class:Grid::QCD::HMCResourceManager
ActionLevel	lib/qcd/action/ActionSet.h	/^  explicit ActionLevel(unsigned int mul = 1) : $/;"	f	struct:Grid::QCD::ActionLevel
ActionLevel	lib/qcd/action/ActionSet.h	/^struct ActionLevel {$/;"	s	namespace:Grid::QCD
ActionModule	lib/qcd/modules/ActionModules.h	/^  ActionModule(APar Par) : Parametrized<APar>(Par) {}$/;"	f	class:Grid::ActionModule
ActionModule	lib/qcd/modules/ActionModules.h	/^  ActionModule(Reader<ReaderClass>& Reader) : Parametrized<APar>(Reader){};$/;"	f	class:Grid::ActionModule
ActionModule	lib/qcd/modules/ActionModules.h	/^class ActionModule$/;"	c	namespace:Grid
ActionModuleBase	lib/qcd/modules/ActionModules.h	/^class ActionModuleBase: public HMCModuleBase<Product>{$/;"	c	namespace:Grid
ActionPtr	lib/qcd/modules/ActionModules.h	/^  std::unique_ptr<ActionType> ActionPtr;$/;"	m	class:Grid::ActionModule
ActionSolver	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  OperatorFunction<FermionField> &ActionSolver;$/;"	m	class:Grid::QCD::TwoFlavourPseudoFermionAction
ActionSolver	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      OperatorFunction<FermionField> &ActionSolver;$/;"	m	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
ActionSolver	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      OperatorFunction<FermionField> &ActionSolver;$/;"	m	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
ActionSolver	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      OperatorFunction<FermionField> &ActionSolver;$/;"	m	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
ActionsList	lib/qcd/hmc/HMCResourceManager.h	/^  std::multimap<int, std::unique_ptr<ActionBaseModule> > ActionsList;$/;"	m	class:Grid::QCD::HMCResourceManager
Active	lib/log/Log.h	/^  void Active(bool activate){$/;"	f	class:Grid::Colours
Active	lib/log/Log.h	/^  void Active(int on) {active = on;};$/;"	f	class:Grid::Logger
ActualCols	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon361
ActualIndex	lib/Eigen/src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon387
ActualLhs	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^            Lhs1, SparseView<Lhs1> >::type ActualLhs;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
ActualLhsType	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualLhsType	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualLhsType	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualLhsType	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualLhsType	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualLhsTypeCleaned	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename internal::remove_all<ActualLhsType>::type ActualLhsTypeCleaned;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualLhsTypeCleaned	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename internal::remove_all<ActualLhsType>::type ActualLhsTypeCleaned;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualMatrixType	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef MatrixType ActualMatrixType;$/;"	t	class:Eigen::internal::generic_matrix_wrapper
ActualMatrixType	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef Ref<const MatrixType> ActualMatrixType;$/;"	t	class:Eigen::internal::generic_matrix_wrapper
ActualMatrixType	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixWrapper::ActualMatrixType ActualMatrixType;$/;"	t	class:Eigen::IterativeSolverBase
ActualMatrixType	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^  typedef typename conditional<(MatrixType::Flags&LinearAccessBit),MatrixType const &,typename MatrixType::PlainObject>::type ActualMatrixType;$/;"	t	struct:Eigen::internal::compute_inverse_size4
ActualPacketAccessBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
ActualPacketAccessBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
ActualPacketSize	lib/Eigen/src/Core/AssignEvaluator.h	/^    ActualPacketSize    = int(Traversal)==LinearVectorizedTraversal ? LinearPacketSize$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon144
ActualRhs	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename conditional<NeedToTranspose,LhsT,RhsT>::type ActualRhs;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
ActualRhsType	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualRhsType	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualRhsType	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualRhsTypeCleaned	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualRhsTypeCleaned	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualRows	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon361
AddCost	lib/Eigen/src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon136
AddDecompress	lib/stencil/Stencil.h	/^  void AddDecompress(cobj *k_p,cobj *m_p,Integer buffer_size,std::vector<Decompress> &dv) {$/;"	f	class:Grid::CartesianStencil
AddFourDimGrid	lib/qcd/hmc/HMCResourceManager.h	/^  void AddFourDimGrid(std::string s) {$/;"	f	class:Grid::QCD::HMCResourceManager
AddGrid	lib/qcd/hmc/HMCResourceManager.h	/^  void AddGrid(std::string s, GridModule& M) {$/;"	f	class:Grid::QCD::HMCResourceManager
AddGridPair	lib/qcd/modules/FermionOperatorModules.h	/^  void AddGridPair(QCD::GridModule &Mod){$/;"	f	class:Grid::FermionOperatorModule
AddLink	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline void AddLink(Field &U, LinkField &W,$/;"	f	class:Grid::QCD::GaugeImplTypes
AddMerge	lib/stencil/Stencil.h	/^  void AddMerge(cobj *merge_p,std::vector<cobj *> &rpointers,Integer buffer_size,Integer type,std::vector<Merge> &mv) {$/;"	f	class:Grid::CartesianStencil
AddObservable	lib/qcd/hmc/HMCResourceManager.h	/^  void AddObservable(Types&&... Args){$/;"	f	class:Grid::QCD::HMCResourceManager
AddPacket	lib/stencil/Stencil.h	/^  void AddPacket(void *xmit,void * rcv, Integer to,Integer from,Integer bytes){$/;"	f	class:Grid::CartesianStencil
AddRNGs	lib/qcd/hmc/HMCResourceManager.h	/^  void AddRNGs(std::string s = "") {$/;"	f	class:Grid::QCD::HMCResourceManager
AdjOp	lib/algorithms/LinearOperator.h	/^      void AdjOp     (const Field &in, Field &out){ $/;"	f	class:Grid::SchurOperatorBase
AdjOp	lib/algorithms/LinearOperator.h	/^      void AdjOp     (const Field &in, Field &out){$/;"	f	class:Grid::HermitianLinearOperator
AdjOp	lib/algorithms/LinearOperator.h	/^      void AdjOp     (const Field &in, Field &out){$/;"	f	class:Grid::MdagMLinearOperator
AdjOp	lib/algorithms/LinearOperator.h	/^      void AdjOp     (const Field &in, Field &out){$/;"	f	class:Grid::ShiftedMdagMLinearOperator
AdjOp	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void AdjOp     (const Field &in, Field &out){$/;"	f	class:Grid::QCD::Gamma5HermitianLinearOperator
AdjOp	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void AdjOp     (const Field &in, Field &out){$/;"	f	class:Grid::QCD::Gamma5R5HermitianLinearOperator
AdjOp	tests/debug/Test_synthetic_lanczos.cc	/^  void AdjOp  (const Field &in, Field &out){$/;"	f	class:DumbOperator
AdjOp	tests/hmc/Test_multishift_sqrt.cc	/^  void AdjOp  (const Field &in, Field &out){$/;"	f	class:DumbOperator
AdjointDimension	lib/qcd/utils/SUn.h	/^  static const int AdjointDimension = ncolour * ncolour - 1;$/;"	m	class:Grid::QCD::SU
AdjointFermOpTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	67;"	d
AdjointLieAlgebraMatrix	lib/qcd/utils/SUnAdjoint.h	/^  static void AdjointLieAlgebraMatrix($/;"	f	class:Grid::QCD::SU_Adjoint
AdjointMatrices	lib/qcd/utils/SUnAdjoint.h	/^typedef SU_Adjoint<Nc> AdjointMatrices;$/;"	t	namespace:Grid::QCD
AdjointRep	lib/qcd/representations/adjoint.h	/^  explicit AdjointRep(GridBase *grid) : U(grid) {}$/;"	f	class:Grid::QCD::AdjointRep
AdjointRep	lib/qcd/representations/adjoint.h	/^class AdjointRep {$/;"	c	namespace:Grid::QCD
AdjointRepresentation	lib/qcd/representations/adjoint.h	/^typedef AdjointRep<Nc> AdjointRepresentation;$/;"	t	namespace:Grid::QCD
AdjointReturnType	lib/Eigen/src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase
AdjointReturnType	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<const typename MatrixType::AdjointReturnType,TransposeMode> AdjointReturnType;$/;"	t	class:Eigen::SelfAdjointView
AdjointReturnType	lib/Eigen/src/Core/SolverBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SolverBase
AdjointReturnType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> AdjointReturnType;$/;"	t	class:Eigen::TriangularView
AdjointReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase
Aee	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      std::vector<double> Aee;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
Affine	lib/Eigen/src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
Affine2d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Affine2f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Affine3d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Affine3f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
AffineCompact	lib/Eigen/src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
AffineCompact2d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
AffineCompact2f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
AffineCompact3d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
AffineCompact3f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
AffinePart	lib/Eigen/src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform
AffinePart	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
AffineTransformType	lib/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation
Aggregates	tests/solver/Test_dwf_hdcr.cc	/^  typedef Aggregation<Fobj,CComplex,nbasis> Aggregates;$/;"	t	class:MultiGridPreconditioner	file:
Aggregation	lib/algorithms/CoarsenedMatrix.h	/^    Aggregation(GridBase *_CoarseGrid,GridBase *_FineGrid) : $/;"	f	class:Grid::Aggregation
Aggregation	lib/algorithms/CoarsenedMatrix.h	/^  class Aggregation   {$/;"	c	namespace:Grid
AlgRemez	lib/algorithms/approx/Remez.cc	/^AlgRemez::AlgRemez(double lower, double upper, long precision) $/;"	f	class:AlgRemez
AlgRemez	lib/algorithms/approx/Remez.h	/^class AlgRemez$/;"	c
Algebra	lib/qcd/spin/Dirac.h	/^  typedef Gamma::Algebra Algebra;$/;"	t	class:Grid::QCD::GammaL
AlgebraVector	lib/qcd/utils/SUn.h	/^  typedef iSUnAlgebraVector<Complex> AlgebraVector;$/;"	t	class:Grid::QCD::SU
AlgebraVectorD	lib/qcd/utils/SUn.h	/^  typedef iSUnAlgebraVector<ComplexD> AlgebraVectorD;$/;"	t	class:Grid::QCD::SU
AlgebraVectorF	lib/qcd/utils/SUn.h	/^  typedef iSUnAlgebraVector<ComplexF> AlgebraVectorF;$/;"	t	class:Grid::QCD::SU
Algorithm	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^      Algorithm;$/;"	t	class:Grid::QCD::ImplicitLeapFrog
Algorithm	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^      Algorithm;$/;"	t	class:Grid::QCD::LeapFrog
AliasFreeProduct	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
Aligned	lib/Eigen/src/Core/util/Constants.h	/^  Aligned=16,         \/**< \\deprecated Synonym for Aligned16. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned128	lib/Eigen/src/Core/util/Constants.h	/^  Aligned128=128,     \/**< Data pointer is aligned on a 128 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned16	lib/Eigen/src/Core/util/Constants.h	/^  Aligned16=16,       \/**< Data pointer is aligned on a 16 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned32	lib/Eigen/src/Core/util/Constants.h	/^  Aligned32=32,       \/**< Data pointer is aligned on a 32 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned64	lib/Eigen/src/Core/util/Constants.h	/^  Aligned64=64,       \/**< Data pointer is aligned on a 64 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned8	lib/Eigen/src/Core/util/Constants.h	/^  Aligned8=8,         \/**< Data pointer is aligned on a 8 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
AlignedBit	lib/Eigen/src/Core/util/Constants.h	/^EIGEN_DEPRECATED const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
AlignedBox	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox()$/;"	f	class:Eigen::AlignedBox
AlignedBox	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox
AlignedBox	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox
AlignedBox	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline explicit AlignedBox(const MatrixBase<Derived>& p) : m_min(p), m_max(m_min)$/;"	f	class:Eigen::AlignedBox
AlignedBox	lib/Eigen/src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedMapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, AlignedMax> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
AlignedMask	lib/Eigen/src/Core/util/Constants.h	/^  AlignedMask=255,$/;"	e	enum:Eigen::AlignmentType
AlignedMax	lib/Eigen/src/Core/util/Constants.h	/^  AlignedMax = Aligned128$/;"	e	enum:Eigen::AlignmentType
AlignedOnScalar	lib/Eigen/src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon507
AlignedOnScalar	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
AlignedOnScalar	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
AlignedOnScalar	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
AlignedOnScalar	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
AlignedOnScalar	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
AlignedOnScalar	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon353
AlignedOnScalar	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
AlignedOnScalar	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
AlignedOnScalar	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
AlignedOnScalar	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
AlignedOnScalar	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
AlignedOnScalar	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
AlignedOnScalar	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
AlignedOnScalar	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
AlignedOnScalar	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
AlignedOnScalar	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
AlignedOnScalar	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
AlignedOnScalar	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon282
AlignedOnScalar	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
AlignedOnScalar	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
AlignedOnScalar	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
AlignedOnScalar	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
AlignedOnScalar	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
AlignedOnScalar	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon335
AlignedOnScalar	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
AlignedOnScalar	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
AlignedOnScalar	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
AlignedOnScalar	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
AlignedOnScalar	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
AlignedScaling2d	lib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
AlignedScaling2f	lib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
AlignedScaling3d	lib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
AlignedScaling3f	lib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
Alignment	lib/Eigen/src/Core/Block.h	/^    Alignment = 0$/;"	e	enum:Eigen::internal::traits::__anon213
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0 \/\/ FIXME in some rare cases, Alignment could be preserved, like a Vector4f.$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0 \/\/ FIXME it is not very clear why alignment is necessarily lost...$/;"	e	enum:Eigen::internal::unary_evaluator::__anon233
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0 \/\/ FIXME this will need to be improved once PartialReduxExpr is vectorized$/;"	e	enum:Eigen::internal::evaluator::__anon243
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0$/;"	e	enum:Eigen::internal::evaluator::__anon246
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0$/;"	e	enum:Eigen::internal::evaluator_base::__anon226
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = AlignedMax$/;"	e	enum:Eigen::internal::evaluator::__anon229
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN($/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ArgType>::Alignment, Alignment0)$/;"	e	enum:Eigen::internal::evaluator::__anon237
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<Lhs>::Alignment,evaluator<Rhs>::Alignment)$/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ThenMatrixType>::Alignment, evaluator<ElseMatrixType>::Alignment)$/;"	e	enum:Eigen::internal::evaluator::__anon239
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgType>::Alignment$/;"	e	enum:Eigen::internal::evaluator_wrapper_base::__anon244
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgType>::Alignment$/;"	e	enum:Eigen::internal::unary_evaluator::__anon228
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgType>::Alignment$/;"	e	enum:Eigen::internal::unary_evaluator::__anon230
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgTypeNestedCleaned>::Alignment$/;"	e	enum:Eigen::internal::unary_evaluator::__anon241
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Alignment$/;"	e	enum:Eigen::internal::evaluator::__anon236
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = int(MapOptions)&int(AlignedMask)$/;"	e	enum:Eigen::internal::evaluator::__anon235
Alignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment = traits<Derived>::Alignment$/;"	e	enum:Eigen::internal::evaluator::__anon227
Alignment	lib/Eigen/src/Core/Map.h	/^    Alignment = int(MapOptions)&int(AlignedMask),$/;"	e	enum:Eigen::internal::traits::__anon134
Alignment	lib/Eigen/src/Core/Matrix.h	/^    Alignment = actual_alignment$/;"	e	enum:Eigen::internal::traits::__anon172
Alignment	lib/Eigen/src/Core/ProductEvaluators.h	/^    Alignment = bool(CanVectorizeLhs) ? (LhsOuterStrideBytes<=0 || (int(LhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,LhsAlignment))!=0 ? 0 : LhsAlignment)$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
Alignment	lib/Eigen/src/Core/ProductEvaluators.h	/^    Alignment = evaluator<MatrixType>::Alignment$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
Alignment	lib/Eigen/src/Core/Redux.h	/^    Alignment = evaluator<XprType>::Alignment$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
Alignment	lib/Eigen/src/Core/Ref.h	/^    Alignment = traits<Map<_PlainObjectType, _Options, _StrideType> >::Alignment$/;"	e	enum:Eigen::internal::traits::__anon149
Alignment	lib/Eigen/src/Geometry/Quaternion.h	/^    Alignment = internal::traits<Coefficients>::Alignment,$/;"	e	enum:Eigen::internal::traits::__anon602
Alignment	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Lhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon546
Alignment	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Rhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon545
Alignment0	lib/Eigen/src/Core/CoreEvaluators.h	/^    Alignment0 = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % int(PacketAlignment)) == 0)) ? int(PacketAlignment) : 0,$/;"	e	enum:Eigen::internal::evaluator::__anon237
AlignmentMask	lib/Eigen/src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon632
AlignmentMatch	lib/Eigen/src/Core/Ref.h	/^      AlignmentMatch = (int(traits<PlainObjectType>::Alignment)==int(Unaligned)) || (DerivedAlignment >= int(Alignment)), \/\/ FIXME the first condition is not very clear, it should be replaced by the required alignment$/;"	e	enum:Eigen::internal::traits::match::__anon150
AlignmentType	lib/Eigen/src/Core/util/Constants.h	/^enum AlignmentType {$/;"	g	namespace:Eigen
AllAtOnceTraversal	lib/Eigen/src/Core/util/Constants.h	/^  AllAtOnceTraversal$/;"	e	enum:Eigen::TraversalType
AllReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_all>::Type AllReturnType;$/;"	t	class:Eigen::VectorwiseOp
AllZero	tests/solver/Test_dwf_lanczos.cc	/^RealD AllZero(RealD x){ return 0.;}$/;"	f
AllZero	tests/solver/Test_wilson_lanczos.cc	/^RealD AllZero(RealD x) { return 0.; }$/;"	f
AltiVec	lib/Eigen/src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
AmbiVector	lib/Eigen/src/SparseCore/AmbiVector.h	/^    explicit AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector
AmbiVector	lib/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
AmbiVectorMode	lib/Eigen/src/Core/util/Constants.h	/^enum AmbiVectorMode {$/;"	g	namespace:Eigen
AmbientDimAtCompileTime	lib/Eigen/src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon611
AmbientDimAtCompileTime	lib/Eigen/src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon606
AmbientDimAtCompileTime	lib/Eigen/src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon605
AminusMuSq	lib/algorithms/approx/Chebyshev.h	/^    void AminusMuSq(LinearOperatorBase<Field> &Linop, const Field &in, Field &out) $/;"	f	class:Grid::ChebyshevLanczos
AnalyticSmearedForce	lib/qcd/smearing/GaugeConfiguration.h	/^  GaugeField AnalyticSmearedForce(const GaugeField& SigmaKPrime,$/;"	f	class:Grid::QCD::SmearedConfiguration
Ancestor	lib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits
Ancestor	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_all<Arg1>::type Ancestor;$/;"	t	struct:Eigen::internal::traits
AndAndFunctor	lib/simd/Grid_vector_unops.h	/^struct AndAndFunctor {$/;"	s	namespace:Grid
AndFunctor	lib/simd/Grid_vector_unops.h	/^struct AndFunctor {$/;"	s	namespace:Grid
AngleAxis	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC AngleAxis() {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis
AngleAxis	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	lib/Eigen/src/Geometry/AngleAxis.h	/^  inline AngleAxis(const Scalar& angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	lib/Eigen/src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen
AngleAxisType	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase
AngleAxisType	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion
AngleAxisd	lib/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisf	lib/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AntiSymmetric	lib/qcd/utils/SUnTwoIndex.h	/^enum TwoIndexSymmetry { Symmetric = 1, AntiSymmetric = -1 };$/;"	e	enum:Grid::QCD::TwoIndexSymmetry
AnyReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_any>::Type AnyReturnType;$/;"	t	class:Eigen::VectorwiseOp
Application	extras/Hadrons/Application.cc	/^Application::Application(const Application::GlobalPar &par)$/;"	f	class:Application
Application	extras/Hadrons/Application.cc	/^Application::Application(const std::string parameterFileName)$/;"	f	class:Application
Application	extras/Hadrons/Application.cc	/^Application::Application(void)$/;"	f	class:Application
Application	extras/Hadrons/Application.hpp	/^class Application$/;"	c
Application	lib/Hadrons/Application.cc	/^Application::Application(const Application::GlobalPar &par)$/;"	f	class:Application
Application	lib/Hadrons/Application.cc	/^Application::Application(const std::string parameterFileName)$/;"	f	class:Application
Application	lib/Hadrons/Application.cc	/^Application::Application(void)$/;"	f	class:Application
Application	lib/Hadrons/Application.hpp	/^class Application$/;"	c
ApplyInverse	tests/hmc/Test_multishift_sqrt.cc	/^  void ApplyInverse(const Field &in, Field &out){$/;"	f	class:DumbOperator
ApplySqrt	tests/hmc/Test_multishift_sqrt.cc	/^  void ApplySqrt(const Field &in, Field &out){$/;"	f	class:DumbOperator
Approx	lib/algorithms/approx/Zolotarev.cc	/^namespace Approx {$/;"	n	namespace:Grid	file:
Approx	lib/algorithms/approx/Zolotarev.h	/^namespace Approx {$/;"	n	namespace:Grid
Architecture	lib/Eigen/src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
Arg1	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_all<Arg1Type>::type Arg1;$/;"	t	class:Eigen::CwiseTernaryOp
Arg1Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Arg1Flags = evaluator<Arg1>::Flags,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
Arg1Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename Arg1::Nested Arg1Nested;$/;"	t	struct:Eigen::internal::traits
Arg1Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::ref_selector<Arg1Type>::type Arg1Nested;$/;"	t	class:Eigen::CwiseTernaryOp
Arg2	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_all<Arg2Type>::type Arg2;$/;"	t	class:Eigen::CwiseTernaryOp
Arg2Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Arg2Flags = evaluator<Arg2>::Flags,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
Arg2Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename Arg2::Nested Arg2Nested;$/;"	t	struct:Eigen::internal::traits
Arg2Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::ref_selector<Arg2Type>::type Arg2Nested;$/;"	t	class:Eigen::CwiseTernaryOp
Arg3	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_all<Arg3Type>::type Arg3;$/;"	t	class:Eigen::CwiseTernaryOp
Arg3Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Arg3Flags = evaluator<Arg3>::Flags,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
Arg3Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename Arg3::Nested Arg3Nested;$/;"	t	struct:Eigen::internal::traits
Arg3Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::ref_selector<Arg3Type>::type Arg3Nested;$/;"	t	class:Eigen::CwiseTernaryOp
ArgReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_arg_op<Scalar>, const Derived> ArgReturnType;$/;"	t
ArgType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename remove_all<typename XprType::NestedExpressionType>::type ArgType;$/;"	t	struct:Eigen::internal::evaluator_wrapper_base
ArgTypeIsRowMajor	lib/Eigen/src/Core/CoreEvaluators.h	/^    ArgTypeIsRowMajor = (int(evaluator<ArgType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::evaluator::__anon237
ArgTypeNested	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::nested_eval<ArgType,1>::type ArgTypeNested;$/;"	t	struct:Eigen::internal::evaluator
ArgTypeNested	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::nested_eval<ArgType,Factor>::type ArgTypeNested;$/;"	t	struct:Eigen::internal::unary_evaluator
ArgTypeNestedCleaned	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;$/;"	t	struct:Eigen::internal::evaluator
ArgTypeNestedCleaned	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;$/;"	t	struct:Eigen::internal::unary_evaluator
Array	lib/Eigen/src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array() : Base()$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2)$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& val0, const T1& val1)$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(const T& x)$/;"	f	class:Eigen::Array
Array	lib/Eigen/src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen
ArrayBase	lib/Eigen/src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase
ArrayBase	lib/Eigen/src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen
ArrayRef	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef Ref<ArrayXr> ArrayRef;$/;"	t	class:Eigen::BDCSVD
ArrayWrapper	lib/Eigen/src/Core/ArrayWrapper.h	/^    explicit EIGEN_STRONG_INLINE ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper
ArrayWrapper	lib/Eigen/src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen
ArrayXI	lib/Eigen/src/SparseCore/SparseAssign.h	/^  typedef Array<StorageIndex,Dynamic,1> ArrayXI;$/;"	t	struct:Eigen::internal::Assignment
ArrayXS	lib/Eigen/src/SparseCore/SparseAssign.h	/^  typedef Array<Scalar,Dynamic,1> ArrayXS;$/;"	t	struct:Eigen::internal::Assignment
ArrayXi	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef Array<Index,1,Dynamic> ArrayXi;$/;"	t	class:Eigen::BDCSVD
ArrayXpr	lib/Eigen/src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
ArrayXr	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef Array<RealScalar, Dynamic, 1> ArrayXr;$/;"	t	class:Eigen::BDCSVD
AsinRealFunctor	lib/simd/Grid_vector_unops.h	/^struct AsinRealFunctor {$/;"	s	namespace:Grid
AsinReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_asin_op<Scalar>, const Derived> AsinReturnType;$/;"	t
AsmDhopSite	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^WilsonKernels<Impl >::AsmDhopSite(StencilImpl &st,LebesgueOrder & lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
AsmDhopSiteDag	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^WilsonKernels<Impl >::AsmDhopSiteDag(StencilImpl &st,LebesgueOrder & lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
AsmDhopSiteDagExt	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^WilsonKernels<Impl >::AsmDhopSiteDagExt(StencilImpl &st,LebesgueOrder & lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
AsmDhopSiteDagInt	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^WilsonKernels<Impl >::AsmDhopSiteDagInt(StencilImpl &st,LebesgueOrder & lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
AsmDhopSiteExt	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^WilsonKernels<Impl >::AsmDhopSiteExt(StencilImpl &st,LebesgueOrder & lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
AsmDhopSiteInt	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^WilsonKernels<Impl >::AsmDhopSiteInt(StencilImpl &st,LebesgueOrder & lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
AssertHermitian	lib/algorithms/CoarsenedMatrix.h	/^    void AssertHermitian(void) {$/;"	f	class:Grid::CoarsenedMatrix
AssignOpType	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> AssignOpType;$/;"	t	struct:Eigen::internal::Assignment
Assignment	lib/Eigen/src/Core/AssignEvaluator.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Dense2Dense, Weak>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/AssignEvaluator.h	/^struct Assignment<DstXprType, SrcXprType, Functor, EigenBase2EigenBase, Weak>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/DiagonalMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Diagonal2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>, const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::add_assign_op<Scalar,Scalar>, Dense2Dense,$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::assign_op<Scalar,Scalar>, Dense2Dense,$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::sub_assign_op<Scalar,Scalar>, Dense2Dense,$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/Solve.h	/^struct Assignment<DstXprType, Solve<CwiseUnaryOp<internal::scalar_conjugate_op<typename DecType::Scalar>, const Transpose<const DecType> >,RhsType>,$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/Solve.h	/^struct Assignment<DstXprType, Solve<DecType,RhsType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/Solve.h	/^struct Assignment<DstXprType, Solve<Transpose<const DecType>,RhsType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::add_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::sub_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Geometry/Homogeneous.h	/^struct Assignment<DstXprType, Homogeneous<ArgType,Horizontal>, internal::assign_op<Scalar,typename ArgType::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/Geometry/Homogeneous.h	/^struct Assignment<DstXprType, Homogeneous<ArgType,Vertical>, internal::assign_op<Scalar,typename ArgType::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^struct Assignment<DstXprType, SolveWithGuess<DecType,RhsType,GuessType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/LU/FullPivLU.h	/^struct Assignment<DstXprType, Inverse<FullPivLU<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename FullPivLU<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/LU/InverseImpl.h	/^struct Assignment<DstXprType, Inverse<XprType>, internal::assign_op<typename DstXprType::Scalar,typename XprType::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/LU/PartialPivLU.h	/^struct Assignment<DstXprType, Inverse<PartialPivLU<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename PartialPivLU<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^struct Assignment<DstXprType, Inverse<ColPivHouseholderQR<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename ColPivHouseholderQR<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^struct Assignment<DstXprType, Inverse<CompleteOrthogonalDecomposition<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^struct Assignment<DstXprType, Inverse<FullPivHouseholderQR<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename FullPivHouseholderQR<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, Solve<DecType,RhsType>, internal::assign_op<Scalar,Scalar>, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Diagonal2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseProduct.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, internal::add_assign_op<typename DstXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseProduct.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, internal::assign_op<typename DstXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseProduct.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, internal::sub_assign_op<typename DstXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct Assignment<DstXprType, SparseSymmetricPermutationProduct<MatrixType,Mode>, internal::assign_op<Scalar,typename MatrixType::Scalar>, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct Assignment<DstXprType, SrcXprType, Functor, SparseSelfAdjoint2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseQR/SparseQR.h	/^struct Assignment<DstXprType, SparseQRMatrixQReturnType<SparseQRType>, internal::assign_op<typename DstXprType::Scalar,typename DstXprType::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	lib/Eigen/src/SparseQR/SparseQR.h	/^struct Assignment<DstXprType, SparseQRMatrixQReturnType<SparseQRType>, internal::assign_op<typename DstXprType::Scalar,typename DstXprType::Scalar>, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/AssignEvaluator.h	/^template<> struct AssignmentKind<DenseShape,DenseShape> { typedef Dense2Dense Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/AssignEvaluator.h	/^template<typename,typename> struct AssignmentKind { typedef EigenBase2EigenBase Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/BandMatrix.h	/^template<> struct AssignmentKind<DenseShape,BandShape> { typedef EigenBase2EigenBase Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/DiagonalMatrix.h	/^template<> struct AssignmentKind<DenseShape,DiagonalShape> { typedef Diagonal2Dense Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/PermutationMatrix.h	/^template<> struct AssignmentKind<DenseShape,PermutationShape> { typedef EigenBase2EigenBase Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<DenseShape,TriangularShape>      { typedef Triangular2Dense      Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,DenseShape>      { typedef Dense2Triangular      Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,TriangularShape> { typedef Triangular2Triangular Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/Geometry/Homogeneous.h	/^template<> struct AssignmentKind<DenseShape,HomogeneousShape> { typedef Dense2Dense Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseShape>           { typedef Sparse2Dense  Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseTriangularShape> { typedef Sparse2Dense  Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseShape>           { typedef Sparse2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseTriangularShape> { typedef Sparse2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape,DiagonalShape> { typedef Diagonal2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseSelfAdjointShape,SparseShape> { typedef Sparse2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseShape,SparseSelfAdjointShape> { typedef SparseSelfAdjoint2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentTraits	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor> AssignmentTraits;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
AssignmentTraits	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::AssignmentTraits AssignmentTraits;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
AssignmentTraits	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::AssignmentTraits AssignmentTraits;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
AtanReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_atan_op<Scalar>, const Derived> AtanReturnType;$/;"	t
AutoAlign	lib/Eigen/src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::StorageOptions
AuxField	lib/qcd/utils/Metric.h	/^  MomentaField AuxField;$/;"	m	class:Grid::QCD::GeneralisedMomenta
AuxMom	lib/qcd/utils/Metric.h	/^  MomentaField AuxMom;$/;"	m	class:Grid::QCD::GeneralisedMomenta
AuxiliaryFieldsDerivative	lib/qcd/utils/Metric.h	/^  void AuxiliaryFieldsDerivative(MomentaField& der){$/;"	f	class:Grid::QCD::GeneralisedMomenta
Ax_lBx	lib/Eigen/src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
BACKTRACE	lib/log/Log.h	178;"	d
BACKTRACEFILE	lib/log/Log.h	152;"	d
BACKTRACEFP	lib/log/Log.h	162;"	d
BACKTRACEFP	lib/log/Log.h	170;"	d
BASE_CHECKPOINTER	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	30;"	d
BASE_SMEAR_	lib/qcd/smearing/BaseSmearing.h	33;"	d
BAx_lx	lib/Eigen/src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
BDCSVD	lib/Eigen/src/SVD/BDCSVD.h	/^  BDCSVD() : m_algoswap(16), m_numIters(0)$/;"	f	class:Eigen::BDCSVD
BDCSVD	lib/Eigen/src/SVD/BDCSVD.h	/^  BDCSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::BDCSVD
BDCSVD	lib/Eigen/src/SVD/BDCSVD.h	/^  BDCSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::BDCSVD
BDCSVD	lib/Eigen/src/SVD/BDCSVD.h	/^class BDCSVD : public SVDBase<BDCSVD<_MatrixType> >$/;"	c	namespace:Eigen
BEGIN_HADRONS_NAMESPACE	extras/Hadrons/Global.hpp	38;"	d
BEGIN_HADRONS_NAMESPACE	lib/Hadrons/Global.hpp	38;"	d
BEGIN_MODULE_NAMESPACE	extras/Hadrons/Global.hpp	45;"	d
BEGIN_MODULE_NAMESPACE	lib/Hadrons/Global.hpp	45;"	d
BEGIN_QEDFVOL_NAMESPACE	extras/qed-fvol/Global.hpp	6;"	d
BENCH_DW	benchmarks/Benchmark_mooee.cc	102;"	d	file:
BENCH_DW_MEO	benchmarks/Benchmark_mooee.cc	146;"	d	file:
BENCH_DW_SSC	benchmarks/Benchmark_mooee.cc	130;"	d	file:
BENCH_ZDW	benchmarks/Benchmark_mooee.cc	116;"	d	file:
BIG_CRUSH	tests/testu01/Test_smallcrush.cc	35;"	d	file:
BIG_SEP	extras/Hadrons/Application.cc	37;"	d	file:
BIG_SEP	extras/Hadrons/Environment.cc	326;"	d	file:
BIG_SEP	lib/Hadrons/Application.cc	37;"	d	file:
BIG_SEP	lib/Hadrons/Environment.cc	326;"	d	file:
BINARYIO_LEXICOGRAPHIC	lib/parallelIO/BinaryIO.h	/^  static const int BINARYIO_LEXICOGRAPHIC = 0x04;$/;"	m	class:Grid::BinaryIO
BINARYIO_MASTER_APPEND	lib/parallelIO/BinaryIO.h	/^  static const int BINARYIO_MASTER_APPEND = 0x10;$/;"	m	class:Grid::BinaryIO
BINARYIO_READ	lib/parallelIO/BinaryIO.h	/^  static const int BINARYIO_READ          = 0x02;$/;"	m	class:Grid::BinaryIO
BINARYIO_UNORDERED	lib/parallelIO/BinaryIO.h	/^  static const int BINARYIO_UNORDERED     = 0x08;$/;"	m	class:Grid::BinaryIO
BINARYIO_WRITE	lib/parallelIO/BinaryIO.h	/^  static const int BINARYIO_WRITE         = 0x01;$/;"	m	class:Grid::BinaryIO
BINARY_CHECKPOINTER	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	30;"	d
BINARY_RSCALAR	lib/tensors/Tensor_unary.h	150;"	d
BINARY_RSCALAR	lib/tensors/Tensor_unary.h	60;"	d
BLASFUNC	lib/Eigen/src/misc/blas.h	9;"	d
BLASLONG	lib/Eigen/src/misc/blas.h	/^typedef long BLASLONG;$/;"	t
BLASLONG	lib/Eigen/src/misc/blas.h	/^typedef long long BLASLONG;$/;"	t
BLASULONG	lib/Eigen/src/misc/blas.h	/^typedef unsigned long BLASULONG;$/;"	t
BLASULONG	lib/Eigen/src/misc/blas.h	/^typedef unsigned long long BLASULONG;$/;"	t
BLAS_H	lib/Eigen/src/misc/blas.h	2;"	d
BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	lib/Eigen/src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
BandMatrix	lib/Eigen/src/Core/BandMatrix.h	/^    explicit inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix
BandMatrix	lib/Eigen/src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal
BandMatrixBase	lib/Eigen/src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal
BandMatrixWrapper	lib/Eigen/src/Core/BandMatrix.h	/^    explicit inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper
BandMatrixWrapper	lib/Eigen/src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal
BandShape	lib/Eigen/src/Core/BandMatrix.h	/^struct BandShape {};$/;"	s	namespace:Eigen::internal
BandShape	lib/Eigen/src/Core/util/Constants.h	/^struct BandShape              { static std::string debugName() { return "BandShape"; } };$/;"	s	namespace:Eigen
Barrier	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::Barrier(void)$/;"	f	class:Grid::CartesianCommunicator
Barrier	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::Barrier(void)$/;"	f	class:Grid::CartesianCommunicator
Barrier	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::Barrier(void)$/;"	f	class:Grid::CartesianCommunicator
Barrier	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::Barrier(void){}$/;"	f	class:Grid::CartesianCommunicator
Barrier	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::Barrier(void)$/;"	f	class:Grid::CartesianCommunicator
BaryonPar	extras/Hadrons/Modules/MContraction/Baryon.hpp	/^class BaryonPar: Serializable$/;"	c
BaryonPar	lib/Hadrons/Modules/MContraction/Baryon.hpp	/^class BaryonPar: Serializable$/;"	c
Base	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition
Base	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT
Base	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT
Base	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT
Base	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::CholmodBase
Base	lib/Eigen/src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array
Base	lib/Eigen/src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase
Base	lib/Eigen/src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper
Base	lib/Eigen/src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper
Base	lib/Eigen/src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix
Base	lib/Eigen/src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase
Base	lib/Eigen/src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::Block
Base	lib/Eigen/src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::BlockImpl
Base	lib/Eigen/src/Core/Block.h	/^    typedef MapBase<BlockType> Base;$/;"	t	class:Eigen::internal::BlockImpl_dense
Base	lib/Eigen/src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<BlockType>::type Base;$/;"	t	class:Eigen::internal::BlockImpl_dense
Base	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef ternary_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename dense_xpr_base<EvalToTemp>::type Base;$/;"	t	class:Eigen::internal::EvalToTemp
Base	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef unary_evaluator<T> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/CoreIterators.h	/^  typedef typename evaluator<XprType>::InnerIterator Base;$/;"	t	class:Eigen::internal::inner_iterator_selector
Base	lib/Eigen/src/Core/CwiseBinaryOp.h	/^                                                      BinaryOp>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp
Base	lib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename internal::generic_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Base	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp
Base	lib/Eigen/src/Core/CwiseTernaryOp.h	/^      CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >::type Base;$/;"	t	class:Eigen::CwiseTernaryOpImpl
Base	lib/Eigen/src/Core/CwiseTernaryOp.h	/^      typename internal::traits<Arg1Type>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseTernaryOp
Base	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp
Base	lib/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename internal::generic_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Base	lib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView
Base	lib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Base	lib/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename internal::generic_xpr_base<CwiseUnaryView<ViewOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Base	lib/Eigen/src/Core/DenseBase.h	/^    typedef DenseCoeffsBase<Derived> Base;$/;"	t	class:Eigen::DenseBase
Base	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	lib/Eigen/src/Core/Diagonal.h	/^    typedef typename internal::dense_xpr_base<Diagonal>::type Base;$/;"	t	class:Eigen::Diagonal
Base	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess
Base	lib/Eigen/src/Core/Inverse.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	lib/Eigen/src/Core/Inverse.h	/^  typedef typename internal::generic_xpr_base<Inverse<XprType> >::type Base;$/;"	t	class:Eigen::InverseImpl
Base	lib/Eigen/src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map
Base	lib/Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase
Base	lib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase
Base	lib/Eigen/src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix
Base	lib/Eigen/src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase
Base	lib/Eigen/src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue
Base	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase
Base	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map
Base	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix
Base	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper
Base	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase
Base	lib/Eigen/src/Core/Product.h	/^                                                        internal::product_type<Lhs,Rhs>::ret>::ret>::Base Base;$/;"	t	class:Eigen::Product
Base	lib/Eigen/src/Core/Product.h	/^    typedef typename internal::dense_product_base<Lhs, Rhs, Option> Base;$/;"	t	class:Eigen::ProductImpl
Base	lib/Eigen/src/Core/Product.h	/^    typedef typename internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type Base;$/;"	t	class:Eigen::ProductImpl
Base	lib/Eigen/src/Core/Product.h	/^  typedef typename internal::dense_xpr_base<ProductXpr>::type Base;$/;"	t	class:Eigen::internal::dense_product_base
Base	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef diagonal_product_evaluator_base<Lhs, typename Rhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheRight> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef diagonal_product_evaluator_base<Rhs, typename Lhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheLeft> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<Product<EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar1,Lhs,product), Rhs, DefaultProduct> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef product_evaluator<BaseProduct, CoeffBasedProductMode, DenseShape, DenseShape> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef product_evaluator<XprType> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/Ref.h	/^    typedef RefBase<Ref> Base;$/;"	t	class:Eigen::Ref
Base	lib/Eigen/src/Core/Ref.h	/^  typedef MapBase<Derived> Base;$/;"	t	class:Eigen::RefBase
Base	lib/Eigen/src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate
Base	lib/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue
Base	lib/Eigen/src/Core/ReturnByValue.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse
Base	lib/Eigen/src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select
Base	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView
Base	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version> Base;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Base	lib/Eigen/src/Core/Solve.h	/^    typedef typename internal::generic_xpr_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type Base;$/;"	t	class:Eigen::SolveImpl
Base	lib/Eigen/src/Core/Solve.h	/^  typedef MatrixBase<Solve<Decomposition,RhsType> > Base;$/;"	t	class:Eigen::SolveImpl
Base	lib/Eigen/src/Core/Solve.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval
Base	lib/Eigen/src/Core/SolverBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::SolverBase
Base	lib/Eigen/src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride
Base	lib/Eigen/src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride
Base	lib/Eigen/src/Core/Swap.h	/^  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, swap_assign_op<typename DstEvaluatorTypeT::Scalar>, BuiltIn> Base;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
Base	lib/Eigen/src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose
Base	lib/Eigen/src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl
Base	lib/Eigen/src/Core/Transpose.h	/^  typedef typename internal::generic_xpr_base<Transpose<XprType> >::type Base;$/;"	t	class:Eigen::TransposeImpl
Base	lib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map
Base	lib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions
Base	lib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper
Base	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularViewType> Base;$/;"	t	class:Eigen::TriangularViewImpl
Base	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularViewImpl<_MatrixType, _Mode, typename internal::traits<_MatrixType>::StorageKind > Base;$/;"	t	class:Eigen::TriangularView
Base	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef evaluator<typename internal::remove_all<MatrixType>::type> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version> Base;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Base	lib/Eigen/src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock
Base	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr
Base	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits
Base	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
Base	lib/Eigen/src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis
Base	lib/Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous
Base	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef evaluator<RefactoredXpr> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	lib/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion
Base	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase
Base	lib/Eigen/src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D
Base	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef DiagonalPreconditioner<_Scalar> Base;$/;"	t	class:Eigen::LeastSquareDiagonalPreconditioner
Base	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB
Base	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient
Base	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef SparseSolverBase<IncompleteCholesky<Scalar,_UpLo,_OrderingType> > Base;$/;"	t	class:Eigen::IncompleteCholesky
Base	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseSolverBase<IncompleteLUT> Base;$/;"	t	class:Eigen::IncompleteLUT
Base	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::IterativeSolverBase
Base	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef IterativeSolverBase<LeastSquaresConjugateGradient> Base;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
Base	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::generic_xpr_base<SolveWithGuess<Decomposition,RhsType,GuessType>, MatrixXpr, typename internal::traits<RhsType>::StorageKind>::type Base;$/;"	t	class:Eigen::SolveWithGuess
Base	lib/Eigen/src/LU/FullPivLU.h	/^    typedef SolverBase<FullPivLU> Base;$/;"	t	class:Eigen::FullPivLU
Base	lib/Eigen/src/LU/PartialPivLU.h	/^    typedef SolverBase<PartialPivLU> Base;$/;"	t	class:Eigen::PartialPivLU
Base	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT
Base	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT
Base	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU
Base	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::PastixBase
Base	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT
Base	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT
Base	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl<PardisoLU> Base;$/;"	t	class:Eigen::PardisoLU
Base	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::PardisoImpl
Base	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SparseSolverBase<SPQR<_MatrixType> > Base;$/;"	t	class:Eigen::SPQR
Base	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef SVDBase<BDCSVD> Base;$/;"	t	class:Eigen::BDCSVD
Base	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef SVDBase<JacobiSVD> Base;$/;"	t	class:Eigen::JacobiSVD
Base	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky
Base	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT
Base	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT
Base	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::SimplicialCholeskyBase
Base	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    typedef Map<SparseMatrix<_Scalar, _Flags, _StorageIndex> > Base;$/;"	t	class:Eigen::MappedSparseMatrix
Base	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^  typedef evaluator<SparseCompressedBase<XprType> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseCompressedBase<Block<SparseMatrixType,BlockRows,BlockCols,true> > Base;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
Base	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseMatrixBase<BlockType> Base;$/;"	t	class:Eigen::BlockImpl
Base	lib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef evaluator<SparseCompressedBase<XprType> > Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	lib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef internal::sparse_matrix_block_impl<SparseMatrixType,BlockRows,BlockCols> Base;$/;"	t	class:Eigen::BlockImpl
Base	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef SparseMatrixBase<Derived> Base;$/;"	t	class:Eigen::SparseCompressedBase
Base	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef SparseMatrixBase<Derived> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Base	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef sparse_conjunction_evaluator<XprType> Base;$/;"	t	struct:Eigen::internal::binary_evaluator
Base	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>::EvalIterator Base;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Base	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>::EvalIterator Base;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Base	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef sparse_dense_outer_product_evaluator<Lhs,Rhs, Lhs::IsRowMajor> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef sparse_dense_outer_product_evaluator<Lhs,Rhs, Rhs::IsRowMajor> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef sparse_diagonal_product_evaluator<Lhs, Transpose<const typename Rhs::DiagonalVectorType>, Lhs::Flags&RowMajorBit?SDP_AsCwiseProduct:SDP_AsScalarProduct> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef sparse_diagonal_product_evaluator<Rhs, typename Lhs::DiagonalVectorType, Rhs::Flags&RowMajorBit?SDP_AsScalarProduct:SDP_AsCwiseProduct> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/SparseCore/SparseMap.h	/^    typedef SparseCompressedBase<Derived> Base;$/;"	t	class:Eigen::SparseMapBase
Base	lib/Eigen/src/SparseCore/SparseMap.h	/^    typedef SparseMapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::SparseMapBase
Base	lib/Eigen/src/SparseCore/SparseMap.h	/^    typedef SparseMapBase<Map> Base;$/;"	t	class:Eigen::Map
Base	lib/Eigen/src/SparseCore/SparseMap.h	/^  typedef evaluator<SparseCompressedBase<Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseMap.h	/^  typedef evaluator<SparseCompressedBase<Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseCompressedBase<SparseMatrix> Base;$/;"	t	class:Eigen::SparseMatrix
Base	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef evaluator<SparseCompressedBase<SparseMatrix<_Scalar,_Options,_StorageIndex> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::SparseMatrixBase
Base	lib/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	lib/Eigen/src/SparseCore/SparseRef.h	/^    typedef internal::SparseRefBase<Ref> Base;$/;"	t	class:Eigen::Ref
Base	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef SparseMapBase<Derived> Base;$/;"	t	class:Eigen::internal::SparseRefBase
Base	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef EigenBase<SparseSelfAdjointView> Base;$/;"	t	class:Eigen::SparseSelfAdjointView
Base	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef SparseCompressedBase<Transpose<MatrixType> > Base;$/;"	t	class:Eigen::internal::SparseTransposeImpl
Base	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef internal::SparseTransposeImpl<MatrixType> Base;$/;"	t	class:Eigen::TransposeImpl
Base	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      typedef EvalIterator Base;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Base	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef SparseMatrixBase<TriangularViewType> Base;$/;"	t	class:Eigen::TriangularViewImpl
Base	lib/Eigen/src/SparseCore/SparseVector.h	/^    typedef SparseCompressedBase<SparseVector> Base;$/;"	t	class:Eigen::SparseVector
Base	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef evaluator_base<SparseVectorType> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	lib/Eigen/src/SparseCore/SparseView.h	/^  typedef SparseMatrixBase<SparseView > Base;$/;"	t	class:Eigen::SparseView
Base	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef internal::SparseLUImpl<Scalar, StorageIndex> Base;$/;"	t	class:Eigen::SparseLU
Base	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef SparseSolverBase<SparseQR<_MatrixType,_OrderingType> > Base;$/;"	t	class:Eigen::SparseQR
Base	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::SuperLUBase
Base	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU
Base	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU
Base	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseSolverBase<UmfPackLU<_MatrixType> > Base;$/;"	t	class:Eigen::UmfPackLU
Base	lib/Eigen/src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base
Base	lib/Eigen/src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base
Base	lib/qcd/action/fermion/StaggeredKernels.h	/^  typedef FermionOperator<Impl> Base;$/;"	t	class:Grid::QCD::StaggeredKernels
Base	lib/qcd/action/fermion/WilsonKernels.h	/^  typedef FermionOperator<Impl> Base;$/;"	t	class:Grid::QCD::WilsonKernels
Base	lib/qcd/hmc/HMCRunnerModule.h	/^  typedef HMCModuleBase< QCD::HMCRunnerBase<ReaderClass> > Base;$/;"	t	class:Grid::HMCModule
Base	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  typedef HMCModuleBase< QCD::BaseHmcCheckpointer<ImplementationPolicy> > Base;$/;"	t	class:Grid::CheckPointerModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef ActionModuleBase< QCD::Action<typename ActionType::GaugeField>, QCD::GridModule > Base;$/;"	t	class:Grid::ActionModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, OneFlavourEvenOddRatioRationalPseudoFermionAction, OneFlavourRationalParams> Base;$/;"	t	class:Grid::QCD::OneFlavourRatioEOFModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, OneFlavourEvenOddRationalPseudoFermionAction, OneFlavourRationalParams> Base;$/;"	t	class:Grid::QCD::OneFlavourEOFModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, OneFlavourRatioRationalPseudoFermionAction, OneFlavourRationalParams> Base;$/;"	t	class:Grid::QCD::OneFlavourRatioFModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, OneFlavourRationalPseudoFermionAction, OneFlavourRationalParams> Base;$/;"	t	class:Grid::QCD::OneFlavourFModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, TwoFlavourEvenOddPseudoFermionAction> Base;$/;"	t	class:Grid::QCD::TwoFlavourEOFModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, TwoFlavourEvenOddRatioPseudoFermionAction> Base;$/;"	t	class:Grid::QCD::TwoFlavourRatioEOFModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, TwoFlavourPseudoFermionAction> Base;$/;"	t	class:Grid::QCD::TwoFlavourFModule
Base	lib/qcd/modules/ActionModules.h	/^  typedef PseudoFermionModuleBase<Impl, TwoFlavourRatioPseudoFermionAction> Base;$/;"	t	class:Grid::QCD::TwoFlavourRatioFModule
Base	lib/qcd/modules/FermionOperatorModules.h	/^  typedef HMCModuleBase< QCD::FermionOperator<FermionImpl> > Base;$/;"	t	class:Grid::FermionOperatorModule
Base	lib/qcd/modules/ObservableModules.h	/^  typedef HMCModuleBase< QCD::HmcObservable< typename ObservableType::Field> > Base;$/;"	t	class:Grid::ObservableModule
Base	lib/qcd/modules/SolverModules.h	/^  typedef HMCModuleBase< OperatorFunction<Field> > Base;$/;"	t	class:Grid::SolverModule
BaseHmcCheckpointer	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	/^class BaseHmcCheckpointer : public HmcObservable<typename Impl::Field> {$/;"	c	namespace:Grid::QCD
BaseProduct	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, LazyProduct> BaseProduct;$/;"	t	struct:Eigen::internal::product_evaluator
BaseSmear	lib/qcd/smearing/StoutSmearing.h	/^  void BaseSmear(GaugeField& C, const GaugeField& U) const {$/;"	f	class:Grid::QCD::Smear_Stout
BaseTraits	lib/Eigen/src/Core/Inverse.h	/^  typedef traits<PlainObject> BaseTraits;$/;"	t	struct:Eigen::internal::traits
BaseTraits	lib/Eigen/src/Core/Solve.h	/^  typedef traits<PlainObject> BaseTraits;$/;"	t	struct:Eigen::internal::traits
BaseTraits	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef traits<_MatrixType> BaseTraits;$/;"	t	struct:Eigen::internal::traits
BasisReturnType	lib/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase
Beta	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      std::vector<double> Beta;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
BetaGaugeActionParameters	lib/qcd/modules/ActionModules.h	/^class BetaGaugeActionParameters : Serializable {$/;"	c	namespace:Grid::QCD
BiCGSTAB	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  explicit BiCGSTAB(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
BidiagonalType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0, RowMajor> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
BinaryCPModule	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^class BinaryCPModule: public CheckPointerModule< ImplementationPolicy> {$/;"	c	namespace:Grid::QCD
BinaryHmcCheckpointer	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  BinaryHmcCheckpointer(const CheckpointerParameters &Params_) {$/;"	f	class:Grid::QCD::BinaryHmcCheckpointer
BinaryHmcCheckpointer	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^class BinaryHmcCheckpointer : public BaseHmcCheckpointer<Impl> {$/;"	c	namespace:Grid::QCD
BinaryIO	lib/parallelIO/BinaryIO.h	/^class BinaryIO {$/;"	c	namespace:Grid
BinaryOp	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::Functor BinaryOp;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
BinaryReader	lib/serialisation/BinaryIO.cc	/^BinaryReader::BinaryReader(const string &fileName)$/;"	f	class:BinaryReader
BinaryReader	lib/serialisation/BinaryIO.h	/^  class BinaryReader: public Reader<BinaryReader>$/;"	c	namespace:Grid
BinarySimpleMunger	lib/parallelIO/MetaData.h	/^struct BinarySimpleMunger {$/;"	s	namespace:Grid::QCD
BinarySimpleUnmunger	lib/parallelIO/MetaData.h	/^struct BinarySimpleUnmunger {$/;"	s	namespace:Grid::QCD
BinaryWriter	lib/serialisation/BinaryIO.cc	/^BinaryWriter::BinaryWriter(const string &fileName)$/;"	f	class:BinaryWriter
BinaryWriter	lib/serialisation/BinaryIO.h	/^  class BinaryWriter: public Writer<BinaryWriter>$/;"	c	namespace:Grid
BlasIndex	lib/Eigen/src/Core/util/MKL_support.h	/^typedef MKL_INT BlasIndex;$/;"	t	namespace:Eigen
BlasIndex	lib/Eigen/src/Core/util/MKL_support.h	/^typedef int BlasIndex;$/;"	t	namespace:Eigen
BlasLinearMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasLinearMapper(Scalar *data) : m_data(data) {}$/;"	f	class:Eigen::internal::BlasLinearMapper
BlasLinearMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^class BlasLinearMapper {$/;"	c	namespace:Eigen::internal
BlasVectorMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasVectorMapper(Scalar *data) : m_data(data) {}$/;"	f	class:Eigen::internal::BlasVectorMapper
BlasVectorMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^class BlasVectorMapper {$/;"	c	namespace:Eigen::internal
Block	lib/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index i) : Impl(xpr,i)$/;"	f	class:Eigen::Block
Block	lib/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::Block
Block	lib/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block
Block	lib/Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel> class Block$/;"	c	namespace:Eigen
Block	lib/stencil/Lebesgue.h	/^    static std::vector<int> Block;$/;"	m	class:Grid::LebesgueOrder
BlockCG	lib/algorithms/iterative/BlockConjugateGradient.h	/^enum BlockCGtype { BlockCG, BlockCGrQ, CGmultiRHS };$/;"	e	enum:Grid::BlockCGtype
BlockCGrQ	lib/algorithms/iterative/BlockConjugateGradient.h	/^enum BlockCGtype { BlockCG, BlockCGrQ, CGmultiRHS };$/;"	e	enum:Grid::BlockCGtype
BlockCGrQsolve	lib/algorithms/iterative/BlockConjugateGradient.h	/^void BlockCGrQsolve(LinearOperatorBase<Field> &Linop, const Field &B, Field &X) $/;"	f	class:Grid::BlockConjugateGradient
BlockCGsolve	lib/algorithms/iterative/BlockConjugateGradient.h	/^void BlockCGsolve(LinearOperatorBase<Field> &Linop, const Field &Src, Field &Psi) $/;"	f	class:Grid::BlockConjugateGradient
BlockCGtype	lib/algorithms/iterative/BlockConjugateGradient.h	/^enum BlockCGtype { BlockCG, BlockCGrQ, CGmultiRHS };$/;"	g	namespace:Grid
BlockConjugateGradient	lib/algorithms/iterative/BlockConjugateGradient.h	/^  BlockConjugateGradient(BlockCGtype cgtype,int _Orthog,RealD tol, Integer maxit, bool err_on_no_conv = true)$/;"	f	class:Grid::BlockConjugateGradient
BlockConjugateGradient	lib/algorithms/iterative/BlockConjugateGradient.h	/^class BlockConjugateGradient : public OperatorFunction<Field> {$/;"	c	namespace:Grid
BlockImpl	lib/Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}$/;"	f	class:Eigen::BlockImpl
BlockImpl	lib/Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline BlockImpl(XprType& xpr, Index startRow, Index startCol) : Impl(xpr, startRow, startCol) {}$/;"	f	class:Eigen::BlockImpl
BlockImpl	lib/Eigen/src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	lib/Eigen/src/Core/Block.h	/^class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>$/;"	c	namespace:Eigen
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(XprType& xpr, Index i)$/;"	f	class:Eigen::BlockImpl
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline BlockImpl(SparseMatrixType& xpr, Index i)$/;"	f	class:Eigen::BlockImpl
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline BlockImpl(SparseMatrixType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,InnerPanel,Sparse>$/;"	c	namespace:Eigen
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<const SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl_dense	lib/Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index i)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	lib/Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	lib/Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	lib/Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr,$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	lib/Eigen/src/Core/Block.h	/^class BlockImpl_dense<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen::internal
BlockImpl_dense	lib/Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class BlockImpl_dense$/;"	c	namespace:Eigen::internal
BlockIndexVector	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<StorageIndex,Dynamic,1> > BlockIndexVector;$/;"	t	class:Eigen::internal::SparseLUImpl
BlockScalarVector	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Scalar,Dynamic,1> > BlockScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl
BlockSize	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = meta_least_common_multiple<EIGEN_PLAIN_ENUM_MAX(mr,nr),EIGEN_PLAIN_ENUM_MIN(mr,nr)>::ret$/;"	e	enum:Eigen::internal::tribb_kernel::__anon384
BlockType	lib/Eigen/src/Core/Block.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::internal::BlockImpl_dense
BlockType	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl
BlockType	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
BlockType	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::BlockImpl
BlockType	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl
BlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived> BlockXpr;$/;"	t
BlueNormReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_blueNorm,RealScalar>::Type BlueNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
BooleanNotReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_boolean_not_op<Scalar>, const Derived> BooleanNotReturnType;$/;"	t
BossRank	lib/communicator/Communicator_base.cc	/^int                      CartesianCommunicator::BossRank(void)          { return 0; };$/;"	f	class:Grid::CartesianCommunicator
BothDirections	lib/Eigen/src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
BottomLeft	lib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomLeft	lib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftCeil	lib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftFloor	lib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRight	lib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomRight	lib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightCeil	lib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightFloor	lib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Broadcast	lib/communicator/Communicator_base.h	/^  template<class obj> void Broadcast(int root,obj &data)$/;"	f	class:Grid::CartesianCommunicator
Broadcast	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::Broadcast(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
Broadcast	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::Broadcast(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
Broadcast	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::Broadcast(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
Broadcast	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::Broadcast(int root,void* data, int bytes) {}$/;"	f	class:Grid::CartesianCommunicator
Broadcast	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::Broadcast(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
BroadcastWorld	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::BroadcastWorld(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
BroadcastWorld	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::BroadcastWorld(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
BroadcastWorld	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::BroadcastWorld(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
BroadcastWorld	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::BroadcastWorld(int root,void* data, int bytes) { }$/;"	f	class:Grid::CartesianCommunicator
BroadcastWorld	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::BroadcastWorld(int root,void* data, int bytes)$/;"	f	class:Grid::CartesianCommunicator
BuildSurfaceList	lib/qcd/action/fermion/WilsonCompressor.h	/^  void BuildSurfaceList(int Ls,int vol4){$/;"	f	class:Grid::QCD::WilsonStencil
BuildType	lib/Eigen/src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
BuiltIn	lib/Eigen/src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::SpecializedType
CACHE_FLUSH	lib/simd/BGQQPX.h	60;"	d
CACHE_LOCK	lib/simd/BGQQPX.h	58;"	d
CACHE_MISSES	lib/perfmon/PerfCount.h	/^    CACHE_MISSES=1,$/;"	e	enum:Grid::PerformanceCounter::PerformanceCounterType
CACHE_REFERENCES	lib/perfmon/PerfCount.h	/^    CACHE_REFERENCES=0,$/;"	e	enum:Grid::PerformanceCounter::PerformanceCounterType
CACHE_TOUCH	lib/simd/BGQQPX.h	61;"	d
CACHE_UNLOCK	lib/simd/BGQQPX.h	59;"	d
CAYLEY_DPERP_CACHE	lib/qcd/action/fermion/CayleyFermion5D.h	198;"	d
CAYLEY_DPERP_DENSE	lib/qcd/action/fermion/CayleyFermion5D.h	197;"	d
CAYLEY_DPERP_LINALG	lib/qcd/action/fermion/CayleyFermion5D.h	199;"	d
CAYLEY_DPERP_VEC	lib/qcd/action/fermion/CayleyFermion5D.h	200;"	d
CBFromExpression	lib/lattice/Lattice_ET.h	/^inline void CBFromExpression($/;"	f	namespace:Grid
CBFromExpression	lib/lattice/Lattice_ET.h	/^inline void CBFromExpression(int &cb, const T1 &lat)  \/\/ Lattice leaf$/;"	f	namespace:Grid
CBFromExpression	lib/lattice/Lattice_ET.h	/^inline void CBFromExpression(int &cb, const T1 &notlat)  \/\/ non-lattice leaf$/;"	f	namespace:Grid
CBFromExpression	lib/lattice/Lattice_ET.h	/^inline void CBFromExpression(int &cb,$/;"	f	namespace:Grid
CBfactorise	lib/algorithms/iterative/SchurRedBlack.h	/^    int CBfactorise;$/;"	m	class:Grid::SchurRedBlackDiagMooeeSolve
CGmultiRHS	lib/algorithms/iterative/BlockConjugateGradient.h	/^enum BlockCGtype { BlockCG, BlockCGrQ, CGmultiRHS };$/;"	e	enum:Grid::BlockCGtype
CGmultiRHSsolve	lib/algorithms/iterative/BlockConjugateGradient.h	/^void CGmultiRHSsolve(LinearOperatorBase<Field> &Linop, const Field &Src, Field &Psi) $/;"	f	class:Grid::BlockConjugateGradient
CGtype	lib/algorithms/iterative/BlockConjugateGradient.h	/^  BlockCGtype CGtype;$/;"	m	class:Grid::BlockConjugateGradient
CHECK	benchmarks/Benchmark_dwf_sweep.cc	102;"	d	file:
CHECKPOINTERS_H	lib/qcd/hmc/checkpointers/CheckPointers.h	31;"	d
CHECK_PROJ	tests/core/Test_gamma.cc	194;"	d	file:
CHECK_PROJ	tests/core/Test_gamma.cc	212;"	d	file:
CHECK_SDW	benchmarks/Benchmark_dwf_sweep.cc	237;"	d	file:
CHOLMOD_SUPPORTS_DOUBLE_PRECISION_ONLY	lib/Eigen/src/Core/util/StaticAssert.h	/^        CHOLMOD_SUPPORTS_DOUBLE_PRECISION_ONLY$/;"	e	enum:Eigen::internal::static_assertion::__anon24
CJMADD	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1672;"	d
CJMADD	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	311;"	d
CJMADD	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	336;"	d
CLANG_VERSION	lib/json/json.hpp	61;"	d
COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	lib/Eigen/src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
COLAMDOrdering	lib/Eigen/src/OrderingMethods/Ordering.h	/^class COLAMDOrdering$/;"	c	namespace:Eigen
COLAMD_ASSERT	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	239;"	d
COLAMD_DEBUG0	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	233;"	d
COLAMD_DEBUG1	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	234;"	d
COLAMD_DEBUG2	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	235;"	d
COLAMD_DEBUG3	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	236;"	d
COLAMD_DEBUG4	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	237;"	d
COLAMD_DEFRAG_COUNT	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	72;"	d
COLAMD_DENSE_COL	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	69;"	d
COLAMD_DENSE_ROW	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	66;"	d
COLAMD_EMPTY	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	105;"	d
COLAMD_ERROR_A_not_present	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	85;"	d
COLAMD_ERROR_A_too_small	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	91;"	d
COLAMD_ERROR_col_length_negative	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	92;"	d
COLAMD_ERROR_internal_error	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	95;"	d
COLAMD_ERROR_ncol_negative	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	88;"	d
COLAMD_ERROR_nnz_negative	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	89;"	d
COLAMD_ERROR_nrow_negative	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	87;"	d
COLAMD_ERROR_out_of_memory	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	94;"	d
COLAMD_ERROR_p0_nonzero	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	90;"	d
COLAMD_ERROR_p_not_present	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	86;"	d
COLAMD_ERROR_row_index_out_of_bounds	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	93;"	d
COLAMD_INFO1	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	78;"	d
COLAMD_INFO2	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	79;"	d
COLAMD_INFO3	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	80;"	d
COLAMD_KNOBS	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	60;"	d
COLAMD_NDEBUG	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	53;"	d
COLAMD_OK	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	83;"	d
COLAMD_OK_BUT_JUMBLED	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	84;"	d
COLAMD_STATS	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	63;"	d
COLAMD_STATUS	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	75;"	d
COLOUR	lib/log/Log.h	/^  std::string COLOUR;$/;"	m	class:Grid::Logger
COL_IS_ALIVE	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	120;"	d
COL_IS_DEAD	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	119;"	d
COL_IS_DEAD_PRINCIPAL	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	121;"	d
COMMAND_IRECV	lib/communicator/Communicator_mpi3_leader.cc	/^enum { COMMAND_ISEND, COMMAND_IRECV, COMMAND_WAITALL, COMMAND_SENDRECV };$/;"	e	enum:Grid::__anon694	file:
COMMAND_ISEND	lib/communicator/Communicator_mpi3_leader.cc	/^enum { COMMAND_ISEND, COMMAND_IRECV, COMMAND_WAITALL, COMMAND_SENDRECV };$/;"	e	enum:Grid::__anon694	file:
COMMAND_SENDRECV	lib/communicator/Communicator_mpi3_leader.cc	/^enum { COMMAND_ISEND, COMMAND_IRECV, COMMAND_WAITALL, COMMAND_SENDRECV };$/;"	e	enum:Grid::__anon694	file:
COMMAND_WAITALL	lib/communicator/Communicator_mpi3_leader.cc	/^enum { COMMAND_ISEND, COMMAND_IRECV, COMMAND_WAITALL, COMMAND_SENDRECV };$/;"	e	enum:Grid::__anon694	file:
COMPLEX_SIGNS	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	347;"	d
COMPLEX_SIGNS	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	364;"	d
COMPLEX_SIGNS	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	55;"	d
COMPLEX_SIGNS	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	646;"	d
COMPLEX_SIGNS	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	44;"	d
COMPLEX_TYPE	lib/simd/BGQQPX.h	535;"	d
CONDITIONAL_MOVE	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	595;"	d	file:
COVARIANT_LAPLACIAN_H	lib/qcd/utils/CovariantLaplacian.h	31;"	d
CP	lib/qcd/hmc/HMCResourceManager.h	/^  std::unique_ptr<CheckpointerBaseModule> CP;$/;"	m	class:Grid::QCD::HMCResourceManager
CPBase	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  typedef CheckPointerModule< ImplementationPolicy> CPBase;$/;"	t	class:Grid::QCD::BinaryCPModule
CPBase	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  typedef CheckPointerModule< ImplementationPolicy> CPBase;$/;"	t	class:Grid::QCD::ILDGCPModule
CPBase	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  typedef CheckPointerModule< ImplementationPolicy> CPBase;$/;"	t	class:Grid::QCD::NerscCPModule
CPUCYCLES	lib/perfmon/PerfCount.h	/^    CPUCYCLES=2,$/;"	e	enum:Grid::PerformanceCounter::PerformanceCounterType
CP_MODULES_H	lib/qcd/hmc/checkpointers/CheckPointerModules.h	31;"	d
C_diag	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	/^    C_diag = 1,$/;"	e	enum:__anon6
C_diag	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	/^    C_diag = 1,$/;"	e	enum:__anon689
CacheControl	lib/perfmon/PerfCount.cc	34;"	d	file:
CacheSizes	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  CacheSizes(): m_l1(-1),m_l2(-1),m_l3(-1) {$/;"	f	struct:Eigen::internal::CacheSizes
CacheSizes	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct CacheSizes {$/;"	s	namespace:Eigen::internal
CachedGroup	lib/communicator/Communicator_mpi3_leader.cc	/^  static MPI_Group WorldGroup, CachedGroup;$/;"	m	class:Grid::MPIoffloadEngine	file:
CachedGroup	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Group MPIoffloadEngine::CachedGroup;$/;"	m	class:Grid::MPIoffloadEngine	file:
CanVectorizeInner	lib/Eigen/src/Core/ProductEvaluators.h	/^    CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
CanVectorizeLhs	lib/Eigen/src/Core/ProductEvaluators.h	/^    CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit) && (RowsAtCompileTime!=1),$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
CanVectorizeRhs	lib/Eigen/src/Core/ProductEvaluators.h	/^    CanVectorizeRhs = bool(RhsRowMajor) && (RhsFlags & PacketAccessBit) && (ColsAtCompileTime!=1),$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
CartesianBlocking	lib/stencil/Lebesgue.cc	/^void LebesgueOrder::CartesianBlocking(void) $/;"	f	class:Grid::LebesgueOrder
CartesianCommunicator	lib/communicator/Communicator_base.h	/^class CartesianCommunicator {$/;"	c	namespace:Grid
CartesianCommunicator	lib/communicator/Communicator_mpi.cc	/^CartesianCommunicator::CartesianCommunicator(const std::vector<int> &processors)$/;"	f	class:Grid::CartesianCommunicator
CartesianCommunicator	lib/communicator/Communicator_mpi3.cc	/^CartesianCommunicator::CartesianCommunicator(const std::vector<int> &processors)$/;"	f	class:Grid::CartesianCommunicator
CartesianCommunicator	lib/communicator/Communicator_mpi3_leader.cc	/^CartesianCommunicator::CartesianCommunicator(const std::vector<int> &processors)$/;"	f	class:Grid::CartesianCommunicator
CartesianCommunicator	lib/communicator/Communicator_none.cc	/^CartesianCommunicator::CartesianCommunicator(const std::vector<int> &processors)$/;"	f	class:Grid::CartesianCommunicator
CartesianCommunicator	lib/communicator/Communicator_shmem.cc	/^CartesianCommunicator::CartesianCommunicator(const std::vector<int> &processors)$/;"	f	class:Grid::CartesianCommunicator
CartesianStencil	lib/stencil/Stencil.h	/^ CartesianStencil(GridBase *grid,$/;"	f	class:Grid::CartesianStencil
CartesianStencil	lib/stencil/Stencil.h	/^class CartesianStencil { \/\/ Stencil runs along coordinate axes only; NO diagonal fill in.$/;"	c	namespace:Grid
CastXpr	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^template<class NewType> struct CastXpr { typedef typename internal::cast_return_type<Derived,const CwiseUnaryOp<internal::scalar_cast_op<Scalar, NewType>, const Derived> >::type Type; };$/;"	s
CayleyFermion5D	lib/qcd/action/fermion/CayleyFermion5D.cc	/^ CayleyFermion5D<Impl>::CayleyFermion5D(GaugeField &_Umu,$/;"	f	class:Grid::QCD::CayleyFermion5D
CayleyFermion5D	lib/qcd/action/fermion/CayleyFermion5D.h	/^    class CayleyFermion5D : public WilsonFermion5D<Impl>$/;"	c	namespace:Grid::QCD
CayleyReport	lib/qcd/action/fermion/CayleyFermion5D.cc	/^template<class Impl> void CayleyFermion5D<Impl>::CayleyReport(void)$/;"	f	class:Grid::QCD::CayleyFermion5D
CayleyZeroCounters	lib/qcd/action/fermion/CayleyFermion5D.cc	/^template<class Impl> void CayleyFermion5D<Impl>::CayleyZeroCounters(void)$/;"	f	class:Grid::QCD::CayleyFermion5D
CbBlack	lib/cartesian/Cartesian_red_black.h	/^  static const int CbBlack=1;$/;"	m	namespace:Grid
CbRed	lib/cartesian/Cartesian_red_black.h	/^  static const int CbRed  =0;$/;"	m	namespace:Grid
CeilReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_ceil_op<Scalar>, const Derived> CeilReturnType;$/;"	t
ChargedPropPar	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^class ChargedPropPar: Serializable$/;"	c
ChargedPropPar	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^class ChargedPropPar: Serializable$/;"	c
Chebyshev	lib/algorithms/approx/Chebyshev.h	/^    Chebyshev(){};$/;"	f	class:Grid::Chebyshev
Chebyshev	lib/algorithms/approx/Chebyshev.h	/^    Chebyshev(RealD _lo,RealD _hi,int _order) {Init(_lo,_hi,_order);};$/;"	f	class:Grid::Chebyshev
Chebyshev	lib/algorithms/approx/Chebyshev.h	/^    Chebyshev(RealD _lo,RealD _hi,int _order, RealD (* func)(RealD) ) {Init(_lo,_hi,_order,func);};$/;"	f	class:Grid::Chebyshev
Chebyshev	lib/algorithms/approx/Chebyshev.h	/^  class Chebyshev : public OperatorFunction<Field> {$/;"	c	namespace:Grid
ChebyshevLanczos	lib/algorithms/approx/Chebyshev.h	/^    ChebyshevLanczos(RealD _alpha,RealD _beta,RealD _mu,int _order) :$/;"	f	class:Grid::ChebyshevLanczos
ChebyshevLanczos	lib/algorithms/approx/Chebyshev.h	/^  class ChebyshevLanczos : public Chebyshev<Field> {$/;"	c	namespace:Grid
CheckOrthogonal	lib/algorithms/CoarsenedMatrix.h	/^    void CheckOrthogonal(void){$/;"	f	class:Grid::Aggregation
CheckPointPtr	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^ 	std::unique_ptr<QCD::BaseHmcCheckpointer<ImplementationPolicy> > CheckPointPtr;$/;"	m	class:Grid::CheckPointerModule
CheckPointerModule	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  CheckPointerModule(APar Par): Parametrized<APar>(Par) {}$/;"	f	class:Grid::CheckPointerModule
CheckPointerModule	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  CheckPointerModule(Reader<ReaderClass>& Reader) : Parametrized<APar>(Reader){};$/;"	f	class:Grid::CheckPointerModule
CheckPointerModule	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^class CheckPointerModule: public Parametrized<QCD::CheckpointerParameters>, public HMCModuleBase< QCD::BaseHmcCheckpointer<ImplementationPolicy> >  {$/;"	c	namespace:Grid
CheckerBoard	lib/cartesian/Cartesian_full.h	/^    virtual int CheckerBoard(const std::vector<int> &site){$/;"	f	class:Grid::GridCartesian
CheckerBoard	lib/cartesian/Cartesian_red_black.h	/^    virtual int CheckerBoard(const std::vector<int> &site){$/;"	f	class:Grid::GridRedBlackCartesian
CheckerBoardDestination	lib/cartesian/Cartesian_full.h	/^    virtual int CheckerBoardDestination(int cb,int shift,int dim){$/;"	f	class:Grid::GridCartesian
CheckerBoardDestination	lib/cartesian/Cartesian_red_black.h	/^    virtual int CheckerBoardDestination(int source_cb,int shift,int dim){$/;"	f	class:Grid::GridRedBlackCartesian
CheckerBoardFromOindex	lib/cartesian/Cartesian_full.h	/^    virtual int  CheckerBoardFromOindex (int Oindex)$/;"	f	class:Grid::GridCartesian
CheckerBoardFromOindex	lib/cartesian/Cartesian_red_black.h	/^    virtual int  CheckerBoardFromOindex (int Oindex)$/;"	f	class:Grid::GridRedBlackCartesian
CheckerBoardFromOindexTable	lib/cartesian/Cartesian_full.h	/^    virtual int  CheckerBoardFromOindexTable (int Oindex) {$/;"	f	class:Grid::GridCartesian
CheckerBoardFromOindexTable	lib/cartesian/Cartesian_red_black.h	/^    virtual int  CheckerBoardFromOindexTable (int Oindex) {$/;"	f	class:Grid::GridRedBlackCartesian
CheckerBoardShift	lib/cartesian/Cartesian_full.h	/^    virtual int CheckerBoardShift(int source_cb,int dim,int shift, int osite){$/;"	f	class:Grid::GridCartesian
CheckerBoardShift	lib/cartesian/Cartesian_red_black.h	/^    virtual int CheckerBoardShift(int source_cb,int dim,int shift,int osite){$/;"	f	class:Grid::GridRedBlackCartesian
CheckerBoardShiftForCB	lib/cartesian/Cartesian_full.h	/^    virtual int CheckerBoardShiftForCB(int source_cb,int dim,int shift, int ocb){$/;"	f	class:Grid::GridCartesian
CheckerBoardShiftForCB	lib/cartesian/Cartesian_red_black.h	/^    virtual int CheckerBoardShiftForCB(int source_cb,int dim,int shift,int ocb){$/;"	f	class:Grid::GridRedBlackCartesian
CheckerBoarded	lib/cartesian/Cartesian_full.h	/^    virtual int CheckerBoarded(int dim){$/;"	f	class:Grid::GridCartesian
CheckerBoarded	lib/cartesian/Cartesian_red_black.h	/^    virtual int CheckerBoarded(int dim){$/;"	f	class:Grid::GridRedBlackCartesian
CheckerBoardedSparseMatrixBase	lib/algorithms/SparseMatrix.h	/^    template<class Field> class CheckerBoardedSparseMatrixBase : public SparseMatrixBase<Field> {$/;"	c	namespace:Grid
CheckpointRestore	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  void CheckpointRestore(int traj, Field &U, GridSerialRNG &sRNG, GridParallelRNG &pRNG) {$/;"	f	class:Grid::QCD::BinaryHmcCheckpointer
CheckpointRestore	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^  void CheckpointRestore(int traj, GaugeField &U, GridSerialRNG &sRNG,$/;"	f	class:Grid::QCD::ILDGHmcCheckpointer
CheckpointRestore	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^  void CheckpointRestore(int traj, GaugeField &U, GridSerialRNG &sRNG,$/;"	f	class:Grid::QCD::NerscHmcCheckpointer
CheckpointerBaseModule	lib/qcd/hmc/HMCResourceManager.h	/^  typedef HMCModuleBase< QCD::BaseHmcCheckpointer<ImplementationPolicy> > CheckpointerBaseModule;$/;"	t	class:Grid::QCD::HMCResourceManager
CheckpointerParameters	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	/^  CheckpointerParameters(Reader<ReaderClass> &Reader) {$/;"	f	class:Grid::QCD::CheckpointerParameters
CheckpointerParameters	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	/^  CheckpointerParameters(std::string cf = "cfg", std::string rn = "rng",$/;"	f	class:Grid::QCD::CheckpointerParameters
CheckpointerParameters	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	/^class CheckpointerParameters : Serializable {$/;"	c	namespace:Grid::QCD
Chi_00	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	39;"	d	file:
Chi_00	lib/simd/BGQQPX.h	89;"	d
Chi_00	lib/simd/IBM_qpx.h	52;"	d
Chi_00	lib/simd/Intel512wilson.h	50;"	d
Chi_01	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	40;"	d	file:
Chi_01	lib/simd/BGQQPX.h	90;"	d
Chi_01	lib/simd/IBM_qpx.h	53;"	d
Chi_01	lib/simd/Intel512wilson.h	51;"	d
Chi_02	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	41;"	d	file:
Chi_02	lib/simd/BGQQPX.h	91;"	d
Chi_02	lib/simd/IBM_qpx.h	54;"	d
Chi_02	lib/simd/Intel512wilson.h	52;"	d
Chi_10	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	42;"	d	file:
Chi_10	lib/simd/BGQQPX.h	93;"	d
Chi_10	lib/simd/IBM_qpx.h	56;"	d
Chi_10	lib/simd/Intel512wilson.h	54;"	d
Chi_11	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	43;"	d	file:
Chi_11	lib/simd/BGQQPX.h	94;"	d
Chi_11	lib/simd/IBM_qpx.h	57;"	d
Chi_11	lib/simd/Intel512wilson.h	55;"	d
Chi_12	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	44;"	d	file:
Chi_12	lib/simd/BGQQPX.h	95;"	d
Chi_12	lib/simd/IBM_qpx.h	58;"	d
Chi_12	lib/simd/Intel512wilson.h	56;"	d
Chi_20	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	45;"	d	file:
Chi_20	lib/simd/IBM_qpx.h	89;"	d
Chi_21	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	46;"	d	file:
Chi_21	lib/simd/IBM_qpx.h	90;"	d
Chi_22	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	47;"	d	file:
Chi_22	lib/simd/IBM_qpx.h	91;"	d
Chi_30	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	48;"	d	file:
Chi_30	lib/simd/IBM_qpx.h	92;"	d
Chi_31	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	49;"	d	file:
Chi_31	lib/simd/IBM_qpx.h	93;"	d
Chi_32	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	50;"	d	file:
Chi_32	lib/simd/IBM_qpx.h	94;"	d
Chimu_00	lib/qcd/action/fermion/WilsonKernelsHand.cc	437;"	d	file:
Chimu_00	lib/simd/BGQQPX.h	114;"	d
Chimu_00	lib/simd/Intel512wilson.h	80;"	d
Chimu_01	lib/qcd/action/fermion/WilsonKernelsHand.cc	438;"	d	file:
Chimu_01	lib/simd/BGQQPX.h	115;"	d
Chimu_01	lib/simd/Intel512wilson.h	81;"	d
Chimu_02	lib/qcd/action/fermion/WilsonKernelsHand.cc	439;"	d	file:
Chimu_02	lib/simd/BGQQPX.h	116;"	d
Chimu_02	lib/simd/Intel512wilson.h	82;"	d
Chimu_10	lib/qcd/action/fermion/WilsonKernelsHand.cc	440;"	d	file:
Chimu_10	lib/simd/BGQQPX.h	117;"	d
Chimu_10	lib/simd/Intel512wilson.h	83;"	d
Chimu_11	lib/qcd/action/fermion/WilsonKernelsHand.cc	441;"	d	file:
Chimu_11	lib/simd/BGQQPX.h	118;"	d
Chimu_11	lib/simd/Intel512wilson.h	84;"	d
Chimu_12	lib/qcd/action/fermion/WilsonKernelsHand.cc	442;"	d	file:
Chimu_12	lib/simd/BGQQPX.h	119;"	d
Chimu_12	lib/simd/Intel512wilson.h	85;"	d
Chimu_20	lib/qcd/action/fermion/WilsonKernelsHand.cc	443;"	d	file:
Chimu_20	lib/simd/BGQQPX.h	120;"	d
Chimu_20	lib/simd/Intel512wilson.h	86;"	d
Chimu_21	lib/qcd/action/fermion/WilsonKernelsHand.cc	444;"	d	file:
Chimu_21	lib/simd/BGQQPX.h	121;"	d
Chimu_21	lib/simd/Intel512wilson.h	87;"	d
Chimu_22	lib/qcd/action/fermion/WilsonKernelsHand.cc	445;"	d	file:
Chimu_22	lib/simd/BGQQPX.h	122;"	d
Chimu_22	lib/simd/Intel512wilson.h	88;"	d
Chimu_30	lib/qcd/action/fermion/WilsonKernelsHand.cc	446;"	d	file:
Chimu_30	lib/simd/BGQQPX.h	123;"	d
Chimu_30	lib/simd/Intel512wilson.h	89;"	d
Chimu_31	lib/qcd/action/fermion/WilsonKernelsHand.cc	447;"	d	file:
Chimu_31	lib/simd/BGQQPX.h	124;"	d
Chimu_31	lib/simd/Intel512wilson.h	90;"	d
Chimu_32	lib/qcd/action/fermion/WilsonKernelsHand.cc	448;"	d	file:
Chimu_32	lib/simd/BGQQPX.h	125;"	d
Chimu_32	lib/simd/Intel512wilson.h	91;"	d
CholMatrixType	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase
CholMatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT
CholMatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky
CholMatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
CholMatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT
CholMatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, StorageIndex>            CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholMatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, StorageIndex>        CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholmodAuto	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodBase	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase
CholmodBase	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    explicit CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
CholmodBase	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
CholmodDecomposition	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodLDLt	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodMode	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
CholmodSimplicialLDLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLt	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodSupernodalLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSupernodalLLt	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
Chroma	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^namespace Chroma { $/;"	n	file:
Chroma	tests/qdpxx/Test_qdpxx_munprec.cc	/^namespace Chroma { $/;"	n	file:
Chroma	tests/qdpxx/Test_qdpxx_stag.cc	/^namespace Chroma { $/;"	n	file:
ChromaAction	tests/qdpxx/Test_qdpxx_munprec.cc	/^enum ChromaAction {$/;"	g	file:
ChromaWrapper	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^class ChromaWrapper {$/;"	c	namespace:Chroma	file:
ChromaWrapper	tests/qdpxx/Test_qdpxx_munprec.cc	/^class ChromaWrapper {$/;"	c	namespace:Chroma	file:
ChromaWrapper	tests/qdpxx/Test_qdpxx_stag.cc	/^class ChromaWrapper {$/;"	c	namespace:Chroma	file:
CoarseGrid	lib/algorithms/CoarsenedMatrix.h	/^    GridBase *CoarseGrid;$/;"	m	class:Grid::Aggregation
CoarseMatrix	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice<iMatrix<CComplex,nbasis > > CoarseMatrix;$/;"	t	class:Grid::Aggregation
CoarseMatrix	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice<iMatrix<CComplex,nbasis > > CoarseMatrix;$/;"	t	class:Grid::CoarsenedMatrix
CoarseMatrix	tests/solver/Test_dwf_hdcr.cc	/^  typedef typename Aggregation<Fobj,CComplex,nbasis>::CoarseMatrix CoarseMatrix;$/;"	t	class:MultiGridPreconditioner	file:
CoarseOperator	tests/solver/Test_dwf_hdcr.cc	/^  typedef CoarsenedMatrix<Fobj,CComplex,nbasis> CoarseOperator;$/;"	t	class:MultiGridPreconditioner	file:
CoarseScalar	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice< CComplex >   CoarseScalar; \/\/ used for inner products on fine field$/;"	t	class:Grid::Aggregation
CoarseScalar	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice< CComplex >   CoarseScalar; \/\/ used for inner products on fine field$/;"	t	class:Grid::CoarsenedMatrix
CoarseScalar	tests/solver/Test_dwf_hdcr.cc	/^  typedef typename Aggregation<Fobj,CComplex,nbasis>::CoarseScalar CoarseScalar;$/;"	t	class:MultiGridPreconditioner	file:
CoarseVector	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice<siteVector>                 CoarseVector;$/;"	t	class:Grid::Aggregation
CoarseVector	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice<siteVector>                 CoarseVector;$/;"	t	class:Grid::CoarsenedMatrix
CoarseVector	tests/solver/Test_dwf_hdcr.cc	/^  typedef typename Aggregation<Fobj,CComplex,nbasis>::CoarseVector CoarseVector;$/;"	t	class:MultiGridPreconditioner	file:
CoarsenOperator	lib/algorithms/CoarsenedMatrix.h	/^    void CoarsenOperator(GridBase *FineGrid,LinearOperatorBase<Lattice<Fobj> > &linop,$/;"	f	class:Grid::CoarsenedMatrix
CoarsenedMatrix	lib/algorithms/CoarsenedMatrix.h	/^    CoarsenedMatrix(GridCartesian &CoarseGrid) 	: $/;"	f	class:Grid::CoarsenedMatrix
CoarsenedMatrix	lib/algorithms/CoarsenedMatrix.h	/^  class CoarsenedMatrix : public SparseMatrixBase<Lattice<iVector<CComplex,nbasis > > >  {$/;"	c	namespace:Grid
CodType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef CompleteOrthogonalDecomposition<MatrixType> CodType;$/;"	t	struct:Eigen::internal::Assignment
CoeffBasedProductMode	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
CoeffComplex	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  struct CoeffComplex {$/;"	s	namespace:Grid::QCD
CoeffComplexHalfComms	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  struct CoeffComplexHalfComms {$/;"	s	namespace:Grid::QCD
CoeffReadCost	lib/Eigen/src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
CoeffReadCost	lib/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon388
CoeffReadCost	lib/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon389
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost$/;"	e	enum:Eigen::internal::mapbase_evaluator::__anon234
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon227
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = TraversalSize==Dynamic ? HugeCost$/;"	e	enum:Eigen::internal::evaluator::__anon243
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<Arg1>::CoeffReadCost + evaluator<Arg2>::CoeffReadCost + evaluator<Arg3>::CoeffReadCost + functor_traits<TernaryOp>::Cost,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon230
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon233
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,    $/;"	e	enum:Eigen::internal::unary_evaluator::__anon228
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon237
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon246
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::evaluator_wrapper_base::__anon244
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgTypeNestedCleaned>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon241
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ConditionMatrixType>::CoeffReadCost$/;"	e	enum:Eigen::internal::evaluator::__anon239
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
CoeffReadCost	lib/Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = internal::functor_traits<NullaryOp>::Cost,$/;"	e	enum:Eigen::internal::evaluator::__anon229
CoeffReadCost	lib/Eigen/src/Core/ProductEvaluators.h	/^    CoeffReadCost = InnerSize==0 ? NumTraits<Scalar>::ReadCost$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
CoeffReadCost	lib/Eigen/src/Core/ProductEvaluators.h	/^    CoeffReadCost = NumTraits<Scalar>::MulCost + evaluator<MatrixType>::CoeffReadCost + evaluator<DiagonalType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
CoeffReadCost	lib/Eigen/src/Core/Redux.h	/^    CoeffReadCost = evaluator<XprType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
CoeffReadCost	lib/Eigen/src/Core/Solve.h	/^    CoeffReadCost = HugeCost$/;"	e	enum:Eigen::internal::traits::__anon256
CoeffReadCost	lib/Eigen/src/Core/Visitor.h	/^    CoeffReadCost = internal::evaluator<XprType>::CoeffReadCost$/;"	e	enum:Eigen::internal::visitor_evaluator::__anon222
CoeffReadCost	lib/Eigen/src/LU/PartialPivLU.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon673
CoeffReadCost	lib/Eigen/src/SparseCore/SparseBlock.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon553
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon538
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon521
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon523
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon525
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon526
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon528
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon530
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon517
CoeffReadCost	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<ViewOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon518
CoeffReadCost	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = HugeCost$/;"	e	enum:Eigen::internal::sparse_dense_outer_product_evaluator::__anon547
CoeffReadCost	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Lhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon546
CoeffReadCost	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Rhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon545
CoeffReadCost	lib/Eigen/src/SparseCore/SparseTranspose.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon562
CoeffReadCost	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon561
CoeffReadCost	lib/Eigen/src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<_Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon543
CoeffReadCost	lib/Eigen/src/SparseCore/SparseView.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon564
CoeffReadCost	lib/Eigen/src/SparseCore/SparseView.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon566
CoeffReal	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  struct CoeffReal {$/;"	s	namespace:Grid::QCD
CoeffRealHalfComms	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  struct CoeffRealHalfComms {$/;"	s	namespace:Grid::QCD
CoeffReturnType	lib/Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase
CoeffReturnType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator_wrapper_base
CoeffReturnType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename PlainObjectType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator
CoeffReturnType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::binary_evaluator
CoeffReturnType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator
CoeffReturnType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::mapbase_evaluator
CoeffReturnType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::ternary_evaluator
CoeffReturnType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::unary_evaluator
CoeffReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase
CoeffReturnType	lib/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
CoeffReturnType	lib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase
CoeffReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase
CoeffReturnType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::product_evaluator
CoeffReturnType	lib/Eigen/src/Core/Redux.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::internal::redux_evaluator
CoeffReturnType	lib/Eigen/src/Core/SolverBase.h	/^    typedef Scalar CoeffReturnType;$/;"	t	class:Eigen::SolverBase
CoeffReturnType	lib/Eigen/src/Core/Visitor.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::internal::visitor_evaluator
CoeffReturnType	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  typedef typename DenseCoeffsBase<Derived,ReadOnlyAccessors>::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator
CoeffReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase
CoeffVectorType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition
CoeffVectorType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization
CoeffVectorType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef RealD   Coeff_t ;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef _Coeff_t Coeff_t;$/;"	t	class:Grid::QCD::StaggeredImpl
Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef typename Options::_Coeff_t Coeff_t;$/;"	t	class:Grid::QCD::WilsonImpl
Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef typename Options::_Coeff_t Coeff_t;      $/;"	t	class:Grid::QCD::DomainWallVec5dImpl
Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef typename Options::_Coeff_t Coeff_t;$/;"	t	class:Grid::QCD::GparityWilsonImpl
Coefficients	lib/Eigen/src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane
Coefficients	lib/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	lib/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	lib/Eigen/src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map
Coefficients	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase
Coefficients	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion
CoefficientsType	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix
CoefficientsType	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper
CoefficientsType	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase
CoefficientsType	lib/Eigen/src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits
CoefficientsType	lib/Eigen/src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits
Coeffs	lib/algorithms/approx/Chebyshev.h	/^    std::vector<RealD> Coeffs;$/;"	m	class:Grid::Chebyshev
Coeffs	lib/algorithms/approx/Chebyshev.h	/^    std::vector<RealD> Coeffs;$/;"	m	class:Grid::ChebyshevLanczos
Coeffs	lib/algorithms/approx/Chebyshev.h	/^    std::vector<RealD> Coeffs;$/;"	m	class:Grid::Polynomial
CoherentAccessPattern	lib/Eigen/src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
ColMajor	lib/Eigen/src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::StorageOptions
ColPivHouseholderQR	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    explicit ColPivHouseholderQR(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    explicit ColPivHouseholderQR(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
ColPivHouseholderQRPreconditioner	lib/Eigen/src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
ColSpMatrix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase
ColSpMatrix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT
ColSpMatrix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT
ColSpMatrix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU
ColType	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD
ColVectorType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
ColVectorType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
ColXpr	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase
ColXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ColXpr;$/;"	t
Colamd_Row	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^struct Colamd_Row$/;"	s	namespace:internal
ColdConfiguration	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline void ColdConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::QCD::GaugeImplTypes
ColdConfiguration	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void ColdConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::ScalarAdjMatrixImplTypes
ColdConfiguration	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void ColdConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::ScalarImplTypes
ColdConfiguration	lib/qcd/utils/SUn.h	/^  static void ColdConfiguration(GridParallelRNG &pRNG,GaugeField &out){$/;"	f	class:Grid::QCD::SU
ColourIndex	lib/qcd/QCD.h	64;"	d
ColourMatrix	lib/qcd/LatticeTheories.h	/^  typedef iColourMatrix<Complex> ColourMatrix;$/;"	t	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
ColourMatrix	lib/qcd/QCD.h	/^    typedef iColourMatrix<Complex  >        ColourMatrix;$/;"	t	namespace:Grid::QCD
ColourMatrixD	lib/qcd/LatticeTheories.h	/^  typedef iColourMatrix<ComplexD> ColourMatrixD;$/;"	t	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
ColourMatrixD	lib/qcd/QCD.h	/^    typedef iColourMatrix<ComplexD >        ColourMatrixD;$/;"	t	namespace:Grid::QCD
ColourMatrixF	lib/qcd/LatticeTheories.h	/^  typedef iColourMatrix<ComplexF> ColourMatrixF;$/;"	t	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
ColourMatrixF	lib/qcd/QCD.h	/^    typedef iColourMatrix<ComplexF >        ColourMatrixF;$/;"	t	namespace:Grid::QCD
ColourVector	lib/qcd/QCD.h	/^    typedef iColourVector<Complex >         ColourVector;$/;"	t	namespace:Grid::QCD
ColourVectorD	lib/qcd/QCD.h	/^    typedef iColourVector<ComplexD>         ColourVectorD;$/;"	t	namespace:Grid::QCD
ColourVectorF	lib/qcd/QCD.h	/^    typedef iColourVector<ComplexF>         ColourVectorF;$/;"	t	namespace:Grid::QCD
ColourWilsonLoops	lib/qcd/utils/WilsonLoops.h	/^typedef WilsonLoops<PeriodicGimplR> ColourWilsonLoops;$/;"	t	namespace:Grid::QCD
Colours	lib/log/Log.h	/^  Colours(bool activate=false){$/;"	f	class:Grid::Colours
Colours	lib/log/Log.h	/^class Colours{$/;"	c	namespace:Grid
Cols	lib/Eigen/src/Core/GeneralProduct.h	/^    Cols    = traits<_Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon185
Cols	lib/Eigen/src/Geometry/Homogeneous.h	/^    Cols = Rhs::ColsAtCompileTime$/;"	e	enum:Eigen::internal::homogeneous_left_product_refactoring_helper::__anon610
ColsAtCompileTime	lib/Eigen/src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon630
ColsAtCompileTime	lib/Eigen/src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon631
ColsAtCompileTime	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::CholmodBase::__anon14
ColsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
ColsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon388
ColsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon389
ColsAtCompileTime	lib/Eigen/src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon213
ColsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    ColsAtCompileTime = PlainObjectType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon227
ColsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    ColsAtCompileTime = XprType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::mapbase_evaluator::__anon234
ColsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    ColsAtCompileTime = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon237
ColsAtCompileTime	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon504
ColsAtCompileTime	lib/Eigen/src/Core/CwiseTernaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon219
ColsAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon129
ColsAtCompileTime	lib/Eigen/src/Core/Diagonal.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon401
ColsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon398
ColsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon400
ColsAtCompileTime	lib/Eigen/src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon250
ColsAtCompileTime	lib/Eigen/src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon172
ColsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = PermTraits::ColsAtCompileTime,$/;"	e	enum:Eigen::InverseImpl::__anon502
ColsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon500
ColsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon501
ColsAtCompileTime	lib/Eigen/src/Core/Product.h	/^    ColsAtCompileTime    = RhsTraits::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon126
ColsAtCompileTime	lib/Eigen/src/Core/ProductEvaluators.h	/^    ColsAtCompileTime = RhsNestedCleaned::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_evaluator::__anon176
ColsAtCompileTime	lib/Eigen/src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon225
ColsAtCompileTime	lib/Eigen/src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
ColsAtCompileTime	lib/Eigen/src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon128
ColsAtCompileTime	lib/Eigen/src/Core/SolverBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon247
ColsAtCompileTime	lib/Eigen/src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon391
ColsAtCompileTime	lib/Eigen/src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon19
ColsAtCompileTime	lib/Eigen/src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon156
ColsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon581
ColsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon583
ColsAtCompileTime	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon576
ColsAtCompileTime	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon577
ColsAtCompileTime	lib/Eigen/src/Eigenvalues/RealQZ.h	/^        ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon582
ColsAtCompileTime	lib/Eigen/src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon580
ColsAtCompileTime	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon584
ColsAtCompileTime	lib/Eigen/src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon607
ColsAtCompileTime	lib/Eigen/src/Geometry/Transform.h	/^    ColsAtCompileTime = Dim1,$/;"	e	enum:Eigen::internal::traits::__anon592
ColsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon652
ColsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon651
ColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::DiagonalPreconditioner::__anon666
ColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::IncompleteCholesky::__anon665
ColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::IncompleteLUT::__anon672
ColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::IterativeSolverBase::__anon671
ColsAtCompileTime	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PastixBase::__anon648
ColsAtCompileTime	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::PardisoImpl::__anon654
ColsAtCompileTime	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon644
ColsAtCompileTime	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon642
ColsAtCompileTime	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon646
ColsAtCompileTime	lib/Eigen/src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon647
ColsAtCompileTime	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::SPQR::__anon18
ColsAtCompileTime	lib/Eigen/src/SVD/BDCSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon622
ColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon620
ColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon617
ColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon618
ColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon619
ColsAtCompileTime	lib/Eigen/src/SVD/SVDBase.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon621
ColsAtCompileTime	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon613
ColsAtCompileTime	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon634
ColsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon514
ColsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon513
ColsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
ColsAtCompileTime	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      ColsAtCompileTime = internal::traits<SparseSelfAdjointView>::ColsAtCompileTime$/;"	e	enum:Eigen::SparseSelfAdjointView::__anon574
ColsAtCompileTime	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      ColsAtCompileTime = internal::traits<SparseSymmetricPermutationProduct>::ColsAtCompileTime$/;"	e	enum:Eigen::SparseSymmetricPermutationProduct::__anon575
ColsAtCompileTime	lib/Eigen/src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon539
ColsAtCompileTime	lib/Eigen/src/SparseLU/SparseLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseLU::__anon660
ColsAtCompileTime	lib/Eigen/src/SparseQR/SparseQR.h	/^      ColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon510
ColsAtCompileTime	lib/Eigen/src/SparseQR/SparseQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseQR::__anon511
ColsAtCompileTime	lib/Eigen/src/SparseQR/SparseQR.h	/^    ColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::SparseQRMatrixQReturnType::__anon512
ColsAtCompileTime	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SuperLUBase::__anon17
ColsAtCompileTime	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::UmfPackLU::__anon629
ColsAtCompileTimeMinusOne	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon613
ColsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ColsBlockXpr;$/;"	t
ColsPlusOne	lib/Eigen/src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon607
ColumnVectorType	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver
ColumnVectorType	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealQZ
ColumnVectorType	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur
ColwiseReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase
CommBuf	lib/stencil/Stencil.h	/^  cobj *CommBuf(void) { return u_recv_buf_p; }$/;"	f	class:Grid::CartesianStencil
CommDatumSize	lib/qcd/action/fermion/WilsonCompressor.h	/^  inline int CommDatumSize(void) {$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
CommDatumSize	lib/stencil/SimpleCompressor.h	/^  inline int  CommDatumSize(void) { return sizeof(vobj); }$/;"	f	class:Grid::SimpleCompressor
CommaInitializer	lib/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	lib/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	lib/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(const CommaInitializer& o)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	lib/Eigen/src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
Comms	lib/qcd/action/fermion/WilsonKernels.cc	/^int WilsonKernelsStatic::Comms = WilsonKernelsStatic::CommsAndCompute;$/;"	m	class:Grid::QCD::WilsonKernelsStatic	file:
Comms	lib/qcd/action/fermion/WilsonKernels.h	/^  static int Comms;$/;"	m	class:Grid::QCD::WilsonKernelsStatic
Comms	lib/stencil/Stencil.h	/^  void Comms     (int point,int dimension,int shiftpm,int cbmask)$/;"	f	class:Grid::CartesianStencil
CommsAndCompute	lib/qcd/action/fermion/WilsonKernels.h	/^  enum { CommsAndCompute, CommsThenCompute };$/;"	e	enum:Grid::QCD::WilsonKernelsStatic::__anon10
CommsMerge	lib/stencil/Stencil.h	/^  template<class decompressor>  void CommsMerge(decompressor decompress)    {$/;"	f	class:Grid::CartesianStencil
CommsMerge	lib/stencil/Stencil.h	/^  void CommsMerge(decompressor decompress,std::vector<Merge> &mm,std::vector<Decompress> &dd) { $/;"	f	class:Grid::CartesianStencil
CommsMergeSHM	lib/stencil/Stencil.h	/^  template<class decompressor>  void CommsMergeSHM(decompressor decompress) {$/;"	f	class:Grid::CartesianStencil
CommsRequest_t	lib/communicator/Communicator_base.h	/^  typedef MPI_Request CommsRequest_t;$/;"	t	class:Grid::CartesianCommunicator
CommsRequest_t	lib/communicator/Communicator_base.h	/^  typedef int CommsRequest_t;$/;"	t	class:Grid::CartesianCommunicator
CommsRequest_t	lib/qcd/action/fermion/WilsonCompressor.h	/^  typedef CartesianCommunicator::CommsRequest_t CommsRequest_t;$/;"	t	class:Grid::QCD::WilsonStencil
CommsRequest_t	lib/stencil/Stencil.h	/^  typedef CartesianCommunicator::CommsRequest_t CommsRequest_t;$/;"	t	class:Grid::CartesianStencil
CommsThenCompute	lib/qcd/action/fermion/WilsonKernels.h	/^  enum { CommsAndCompute, CommsThenCompute };$/;"	e	enum:Grid::QCD::WilsonKernelsStatic::__anon10
CommunicateBegin	lib/stencil/Stencil.h	/^  void CommunicateBegin(std::vector<std::vector<CommsRequest_t> > &reqs)$/;"	f	class:Grid::CartesianStencil
CommunicateComplete	lib/stencil/Stencil.h	/^  void CommunicateComplete(std::vector<std::vector<CommsRequest_t> > &reqs)$/;"	f	class:Grid::CartesianStencil
CommunicatorInit	lib/communicator/Communicator_mpi3_leader.cc	/^void MPIoffloadEngine::CommunicatorInit (MPI_Comm &communicator_world,$/;"	f	class:Grid::MPIoffloadEngine
CommunicatorPolicy	lib/communicator/Communicator_base.cc	/^CartesianCommunicator::CommunicatorPolicy_t  CartesianCommunicator::CommunicatorPolicy= CartesianCommunicator::CommunicatorPolicyConcurrent;$/;"	m	class:Grid::CartesianCommunicator	file:
CommunicatorPolicy	lib/communicator/Communicator_base.h	/^  static CommunicatorPolicy_t CommunicatorPolicy;$/;"	m	class:Grid::CartesianCommunicator
CommunicatorPolicyConcurrent	lib/communicator/Communicator_base.h	/^  enum CommunicatorPolicy_t { CommunicatorPolicyConcurrent, CommunicatorPolicySequential };$/;"	e	enum:Grid::CartesianCommunicator::CommunicatorPolicy_t
CommunicatorPolicySequential	lib/communicator/Communicator_base.h	/^  enum CommunicatorPolicy_t { CommunicatorPolicyConcurrent, CommunicatorPolicySequential };$/;"	e	enum:Grid::CartesianCommunicator::CommunicatorPolicy_t
CommunicatorPolicy_t	lib/communicator/Communicator_base.h	/^  enum CommunicatorPolicy_t { CommunicatorPolicyConcurrent, CommunicatorPolicySequential };$/;"	g	class:Grid::CartesianCommunicator
Comparison	lib/lattice/Lattice_comparison_utils.h	/^    inline vInteger Comparison(sfunctor sop,const typename vsimd::scalar_type & lhs, const vsimd & rhs)$/;"	f	namespace:Grid
Comparison	lib/lattice/Lattice_comparison_utils.h	/^    inline vInteger Comparison(sfunctor sop,const vsimd & lhs, const typename vsimd::scalar_type & rhs)$/;"	f	namespace:Grid
Comparison	lib/lattice/Lattice_comparison_utils.h	/^    inline vInteger Comparison(sfunctor sop,const vsimd & lhs, const vsimd & rhs)$/;"	f	namespace:Grid
ComparisonName	lib/Eigen/src/Core/util/Constants.h	/^enum ComparisonName {$/;"	g	namespace:Eigen::internal
CompleteOrthogonalDecomposition	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition() : m_cpqr(), m_zCoeffs(), m_temp() {}$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition(Index rows, Index cols)$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  explicit CompleteOrthogonalDecomposition(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  explicit CompleteOrthogonalDecomposition(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^class CompleteOrthogonalDecomposition {$/;"	c	namespace:Eigen
CompleteUnrolling	lib/Eigen/src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::UnrollingType
Complex	lib/simd/Simd.h	/^  typedef std::complex<Real>  Complex;$/;"	t	namespace:Grid
ComplexD	gcc-bug-report/broken.cc	/^typedef std::complex<double> ComplexD;$/;"	t	file:
ComplexD	lib/simd/Simd.h	/^  typedef std::complex<RealD> ComplexD;$/;"	t	namespace:Grid
ComplexEigenSolver	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    explicit ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    explicit ComplexEigenSolver(const EigenBase<InputType>& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
ComplexF	lib/simd/Simd.h	/^  typedef std::complex<RealF> ComplexF;$/;"	t	namespace:Grid
ComplexField	lib/qcd/action/gauge/GaugeImplTypes.h	/^  typedef Lattice<SiteComplex> ComplexField;$/;"	t	class:Grid::QCD::GaugeImplTypes
ComplexField	lib/qcd/action/gauge/Photon.h	/^    typedef Field              ComplexField;$/;"	t	class:Grid::QCD::QedGimpl
ComplexField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Field              ComplexField;$/;"	t	class:Grid::ScalarImplTypes
ComplexField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Lattice<SiteComplex> ComplexField;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
ComplexMatrixType	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function
ComplexScalar	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver
ComplexScalar	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver
ComplexScalar	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
ComplexScalar	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealQZ
ComplexScalar	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur
ComplexSchur	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    explicit ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    explicit ComplexSchur(const EigenBase<InputType>& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
ComplexVectorType	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ComplexVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver
Complexified	lib/tensors/Tensor_class.h	/^  typedef iMatrix<typename GridTypeMapper<vtype>::Complexified, N> Complexified;$/;"	t	class:Grid::iMatrix
Complexified	lib/tensors/Tensor_class.h	/^  typedef iScalar<typename GridTypeMapper<vtype>::Complexified> Complexified;$/;"	t	class:Grid::iScalar
Complexified	lib/tensors/Tensor_class.h	/^  typedef iVector<typename GridTypeMapper<vtype>::Complexified, N> Complexified;$/;"	t	class:Grid::iVector
Complexified	lib/tensors/Tensor_traits.h	/^    typedef ComplexD Complexified;$/;"	t	class:Grid::GridTypeMapper
Complexified	lib/tensors/Tensor_traits.h	/^    typedef ComplexF Complexified;$/;"	t	class:Grid::GridTypeMapper
Complexified	lib/tensors/Tensor_traits.h	/^    typedef typename T::Complexified Complexified;$/;"	t	class:Grid::GridTypeMapper
Complexified	lib/tensors/Tensor_traits.h	/^    typedef vComplexD Complexified;$/;"	t	class:Grid::GridTypeMapper
Complexified	lib/tensors/Tensor_traits.h	/^    typedef vComplexF Complexified;$/;"	t	class:Grid::GridTypeMapper
Complexified	lib/tensors/Tensor_traits.h	/^    typedef vComplexH Complexified;$/;"	t	class:Grid::GridTypeMapper
Complexified	lib/tensors/Tensor_traits.h	/^    typedef void Complexified;$/;"	t	class:Grid::GridTypeMapper
Compress	lib/qcd/action/fermion/WilsonCompressor.h	/^  inline void Compress(SiteHalfSpinor *buf,Integer o,const SiteSpinor &in) {$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
Compress	lib/stencil/SimpleCompressor.h	/^  inline void Compress(vobj *buf,int o,const vobj &in) { buf[o]=in; }$/;"	f	class:Grid::SimpleCompressor
CompressExchange	lib/qcd/action/fermion/WilsonCompressor.h	/^  inline void CompressExchange(SiteHalfSpinor *out0,$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
CompressExchange	lib/stencil/SimpleCompressor.h	/^  inline void CompressExchange(vobj *out0,vobj *out1,const vobj *in,$/;"	f	class:Grid::SimpleCompressor
CompressedAccessBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int CompressedAccessBit = 0x400;$/;"	m	namespace:Eigen
CompressedStorage	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    explicit CompressedStorage(Index size)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	lib/Eigen/src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
Compressor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef SimpleCompressor<SiteSpinor> Compressor;$/;"	t	class:Grid::QCD::StaggeredImpl
Compressor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef SimpleCompressor<SiteSpinor> Compressor;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
Compressor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef WilsonCompressor<SiteHalfCommSpinor,SiteHalfSpinor, SiteSpinor> Compressor;$/;"	t	class:Grid::QCD::WilsonImpl
Compressor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef WilsonCompressor<SiteHalfCommSpinor,SiteHalfSpinor, SiteSpinor> Compressor;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
Compressor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef WilsonCompressor<SiteHalfCommSpinor,SiteHalfSpinor, SiteSpinor> Compressor;$/;"	t	class:Grid::QCD::GparityWilsonImpl
ComputationInfo	lib/Eigen/src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
ComputeEigenvectors	lib/Eigen/src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullU	lib/Eigen/src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullV	lib/Eigen/src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinU	lib/Eigen/src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinV	lib/Eigen/src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
ConditionMatrixNested	lib/Eigen/src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits
ConfParameters	tests/smearing/Test_WilsonFlow.cc	/^    ConfParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::ConfParameters
ConfParameters	tests/smearing/Test_WilsonFlow.cc	/^  struct ConfParameters: Serializable {$/;"	s	namespace:Grid	file:
Conj	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon405
Conj	lib/simd/Grid_avx.h	/^  struct Conj{$/;"	s	namespace:Grid::Optimization
Conj	lib/simd/Grid_avx512.h	/^  struct Conj{$/;"	s	namespace:Grid::Optimization
Conj	lib/simd/Grid_generic.h	/^  struct Conj{$/;"	s	namespace:Grid::Optimization
Conj	lib/simd/Grid_imci.h	/^  struct Conj{$/;"	s	namespace:Grid::Optimization
Conj	lib/simd/Grid_neon.h	/^  struct Conj{$/;"	s	namespace:Grid::Optimization
Conj	lib/simd/Grid_qpx.h	/^  struct Conj{$/;"	s	namespace:Grid::Optimization
Conj	lib/simd/Grid_sse4.h	/^  struct Conj{$/;"	s	namespace:Grid::Optimization
ConjLhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
ConjLhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
ConjLhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
ConjLhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
ConjRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
ConjRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
ConjRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
ConjRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
ConjSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Conj        ConjSIMD;$/;"	t	namespace:Grid
ConjSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Conj        ConjSIMD;$/;"	t	namespace:Grid
ConjSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Conj        ConjSIMD;$/;"	t	namespace:Grid
ConjSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Conj        ConjSIMD;$/;"	t	namespace:Grid
ConjSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Conj        ConjSIMD;$/;"	t	namespace:Grid
ConjSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Conj        ConjSIMD;$/;"	t	namespace:Grid
ConjSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Conj        ConjSIMD;$/;"	t	namespace:Grid
Conjugate	lib/Eigen/src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon387
ConjugateBC	lib/qcd/utils/CovariantCshift.h	/^namespace ConjugateBC { $/;"	n	namespace:Grid::QCD
ConjugateGaugeImpl	lib/qcd/action/gauge/GaugeImplementations.h	/^template <class GimplTypes> class ConjugateGaugeImpl : public GimplTypes {$/;"	c	namespace:Grid::QCD
ConjugateGimplD	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef ConjugateGaugeImpl<GimplTypesD> ConjugateGimplD; \/\/ Double$/;"	t	namespace:Grid::QCD
ConjugateGimplF	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef ConjugateGaugeImpl<GimplTypesF> ConjugateGimplF; \/\/ Float$/;"	t	namespace:Grid::QCD
ConjugateGimplR	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef ConjugateGaugeImpl<GimplTypesR> ConjugateGimplR; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
ConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  explicit ConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen
ConjugateGradient	lib/algorithms/iterative/ConjugateGradient.h	/^  ConjugateGradient(RealD tol, Integer maxit, bool err_on_no_conv = true)$/;"	f	class:Grid::ConjugateGradient
ConjugateGradient	lib/algorithms/iterative/ConjugateGradient.h	/^class ConjugateGradient : public OperatorFunction<Field> {$/;"	c	namespace:Grid
ConjugateGradientModule	lib/qcd/modules/SolverModules.h	/^class ConjugateGradientModule: public SolverModule<ConjugateGradient, Field, SolverParameters> {$/;"	c	namespace:Grid
ConjugateGradientMultiShift	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^    ConjugateGradientMultiShift(Integer maxit,MultiShiftFunction &_shifts) : $/;"	f	class:Grid::ConjugateGradientMultiShift
ConjugateGradientMultiShift	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^    class ConjugateGradientMultiShift : public OperatorMultiFunction<Field>,$/;"	c	namespace:Grid
ConjugateIwasakiGaugeActionD	lib/qcd/action/gauge/Gauge.h	/^typedef IwasakiGaugeAction<ConjugateGimplD>         ConjugateIwasakiGaugeActionD;$/;"	t	namespace:Grid::QCD
ConjugateIwasakiGaugeActionF	lib/qcd/action/gauge/Gauge.h	/^typedef IwasakiGaugeAction<ConjugateGimplF>         ConjugateIwasakiGaugeActionF;$/;"	t	namespace:Grid::QCD
ConjugateIwasakiGaugeActionR	lib/qcd/action/gauge/Gauge.h	/^typedef IwasakiGaugeAction<ConjugateGimplR>         ConjugateIwasakiGaugeActionR;$/;"	t	namespace:Grid::QCD
ConjugatePlaqPlusRectangleActionD	lib/qcd/action/gauge/Gauge.h	/^typedef PlaqPlusRectangleAction<ConjugateGimplD>    ConjugatePlaqPlusRectangleActionD;$/;"	t	namespace:Grid::QCD
ConjugatePlaqPlusRectangleActionF	lib/qcd/action/gauge/Gauge.h	/^typedef PlaqPlusRectangleAction<ConjugateGimplF>    ConjugatePlaqPlusRectangleActionF;$/;"	t	namespace:Grid::QCD
ConjugatePlaqPlusRectangleActionR	lib/qcd/action/gauge/Gauge.h	/^typedef PlaqPlusRectangleAction<ConjugateGimplR>    ConjugatePlaqPlusRectangleActionR;$/;"	t	namespace:Grid::QCD
ConjugateResidual	lib/algorithms/iterative/ConjugateResidual.h	/^    ConjugateResidual(RealD tol,Integer maxit) : Tolerance(tol), MaxIterations(maxit) { $/;"	f	class:Grid::ConjugateResidual
ConjugateResidual	lib/algorithms/iterative/ConjugateResidual.h	/^    class ConjugateResidual : public OperatorFunction<Field> {$/;"	c	namespace:Grid
ConjugateResidualModule	lib/qcd/modules/SolverModules.h	/^class ConjugateResidualModule: public SolverModule<ConjugateResidual, Field, SolverParameters> {$/;"	c	namespace:Grid
ConjugateReturnType	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<const MatrixConjugateReturnType,Mode> ConjugateReturnType;$/;"	t	class:Eigen::SelfAdjointView
ConjugateReturnType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<const MatrixConjugateReturnType,Mode> ConjugateReturnType;$/;"	t	class:Eigen::TriangularView
ConjugateReturnType	lib/Eigen/src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence
ConjugateReturnType	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type ConjugateReturnType;$/;"	t
ConjugateSymanzikGaugeActionD	lib/qcd/action/gauge/Gauge.h	/^typedef SymanzikGaugeAction<ConjugateGimplD>        ConjugateSymanzikGaugeActionD;$/;"	t	namespace:Grid::QCD
ConjugateSymanzikGaugeActionF	lib/qcd/action/gauge/Gauge.h	/^typedef SymanzikGaugeAction<ConjugateGimplF>        ConjugateSymanzikGaugeActionF;$/;"	t	namespace:Grid::QCD
ConjugateSymanzikGaugeActionR	lib/qcd/action/gauge/Gauge.h	/^typedef SymanzikGaugeAction<ConjugateGimplR>        ConjugateSymanzikGaugeActionR;$/;"	t	namespace:Grid::QCD
ConjugateWilsonGaugeActionD	lib/qcd/action/gauge/Gauge.h	/^typedef WilsonGaugeAction<ConjugateGimplD>          ConjugateWilsonGaugeActionD;$/;"	t	namespace:Grid::QCD
ConjugateWilsonGaugeActionF	lib/qcd/action/gauge/Gauge.h	/^typedef WilsonGaugeAction<ConjugateGimplF>          ConjugateWilsonGaugeActionF;$/;"	t	namespace:Grid::QCD
ConjugateWilsonGaugeActionR	lib/qcd/action/gauge/Gauge.h	/^typedef WilsonGaugeAction<ConjugateGimplR>          ConjugateWilsonGaugeActionR;$/;"	t	namespace:Grid::QCD
ConstAffinePart	lib/Eigen/src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform
ConstAffinePart	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
ConstAlignedMapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, AlignedMax> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived> ConstBlockXpr;$/;"	t
ConstCholMatrixPtr	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef CholMatrixType const * ConstCholMatrixPtr;$/;"	t	class:Eigen::SimplicialCholeskyBase
ConstCholMatrixPtr	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef CholMatrixType const * ConstCholMatrixPtr;$/;"	t	struct:Eigen::internal::simplicial_cholesky_grab_input
ConstColXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ConstColXpr;$/;"	t
ConstColsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ConstColsBlockXpr;$/;"	t
ConstColwiseReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstDiagonalDynamicIndexReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived,DynamicIndex> >::type ConstDiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase
ConstDiagonalIndexReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
ConstDiagonalReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived> >::type ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
ConstDiagonalReturnType	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef Diagonal<const SparseMatrix> ConstDiagonalReturnType;$/;"	t	class:Eigen::SparseMatrix
ConstEE	lib/qcd/action/fermion/FermionOperator.h	/^      virtual int    ConstEE(void) { return 1; }; \/\/ clover returns zero as EE depends on gauge field$/;"	f	class:Grid::QCD::FermionOperator
ConstFixedBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct ConstFixedBlockXpr { typedef Block<const Derived,Rows,Cols> Type; };$/;"	s
ConstFixedSegmentReturnType	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	s
ConstInnerVectorReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true> ConstInnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstInnerVectorsReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,Dynamic,Dynamic,true> ConstInnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstLinearPart	lib/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> ConstLinearPart;$/;"	t	class:Eigen::Transform
ConstMapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstMatrixPtr	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef MatrixType const * ConstMatrixPtr;$/;"	t	struct:Eigen::internal::simplicial_cholesky_grab_input
ConstMatrixType	lib/Eigen/src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform
ConstNColsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
ConstNRowsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
ConstNormalReturnType	lib/Eigen/src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane
ConstReverseReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase
ConstReverseReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef Reverse<const ExpressionType, Direction> ConstReverseReturnType;$/;"	t	class:Eigen::VectorwiseOp
ConstRowXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowXpr;$/;"	t
ConstRowsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowsBlockXpr;$/;"	t
ConstRowwiseReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstSegmentReturnType	lib/Eigen/src/plugins/BlockMethods.h	/^typedef const VectorBlock<const Derived> ConstSegmentReturnType;$/;"	t
ConstSelfAdjointViewReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
ConstSelfAdjointViewReturnType	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<int UpLo> struct ConstSelfAdjointViewReturnType {$/;"	s	class:Eigen::internal::generic_matrix_wrapper
ConstSelfAdjointViewReturnType	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<int UpLo> struct ConstSelfAdjointViewReturnType$/;"	s	class:Eigen::internal::generic_matrix_wrapper
ConstSelfAdjointViewReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SparseSelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::SparseMatrixBase
ConstStartMinusOne	lib/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase
ConstTranslationPart	lib/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,!(internal::traits<MatrixType>::Flags & RowMajorBit)> ConstTranslationPart;$/;"	t	class:Eigen::Transform
ConstTransposeReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase
ConstTransposeReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase
ConstTransposeReturnType	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<const typename MatrixType::ConstTransposeReturnType,TransposeMode> ConstTransposeReturnType;$/;"	t	class:Eigen::SelfAdjointView
ConstTransposeReturnType	lib/Eigen/src/Core/SolverBase.h	/^    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::SolverBase
ConstTransposeReturnType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<const typename MatrixType::ConstTransposeReturnType,TransposeMode> ConstTransposeReturnType;$/;"	t	class:Eigen::TriangularView
ConstTransposeReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstTriangularViewReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
Constant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase
ConstantBlock	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Replicate<const ConstantColumn,1,Cols>                        ConstantBlock;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
ConstantBlock	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Replicate<const ConstantColumn,Rows,1>                        ConstantBlock;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
ConstantBlock	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename helper::ConstantBlock ConstantBlock;$/;"	t	struct:Eigen::internal::product_evaluator
ConstantColumn	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Lhs::ConstColXpr                                     ConstantColumn;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
ConstantColumn	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Rhs::ConstRowXpr                                     ConstantColumn;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
ConstantReturnType	lib/Eigen/src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase
ConstantReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;$/;"	t	class:Eigen::DenseBase
ConstantReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase
ConstantReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase
Container	gcc-bug-report/broken.cc	/^  Container(int size) : data (size){};$/;"	f	class:Container
Container	gcc-bug-report/broken.cc	/^template<class obj> class Container {$/;"	c	file:
ContinuedFractionFermion5D	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    ContinuedFractionFermion5D<Impl>::ContinuedFractionFermion5D($/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
ContinuedFractionFermion5D	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^    class ContinuedFractionFermion5D : public WilsonFermion5D<Impl>$/;"	c	namespace:Grid::QCD
ConvertToPacket2l	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^static inline Packet2l ConvertToPacket2l(const Packet2d& x) {$/;"	f	namespace:Eigen::internal
CoorFromIndex	lib/util/Lexicographic.h	/^    static inline void CoorFromIndex (std::vector<int>& coor,int index,std::vector<int> &dims){$/;"	f	class:Grid::Lexicographic
CopyPlane	lib/stencil/Stencil.h	/^  void CopyPlane(int point, int dimension,int lplane,int rplane,int cbmask,int permute,int wrap)$/;"	f	class:Grid::CartesianStencil
Copy_plane	lib/cshift/Cshift_common.h	/^template<class vobj> void Copy_plane(Lattice<vobj>& lhs,const Lattice<vobj> &rhs, int dimension,int lplane,int rplane,int cbmask)$/;"	f	namespace:Grid
Copy_plane_permute	lib/cshift/Cshift_common.h	/^template<class vobj> void Copy_plane_permute(Lattice<vobj>& lhs,const Lattice<vobj> &rhs, int dimension,int lplane,int rplane,int cbmask,int permute_type)$/;"	f	namespace:Grid
CornerType	lib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
CornerType	lib/Eigen/src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox
CorrReader	extras/Hadrons/Global.hpp	/^typedef Hdf5Reader CorrReader;$/;"	t
CorrReader	extras/Hadrons/Global.hpp	/^typedef XmlReader CorrReader;$/;"	t
CorrReader	lib/Hadrons/Global.hpp	/^typedef Hdf5Reader CorrReader;$/;"	t
CorrReader	lib/Hadrons/Global.hpp	/^typedef XmlReader CorrReader;$/;"	t
CorrWriter	extras/Hadrons/Global.hpp	/^typedef Hdf5Writer CorrWriter;$/;"	t
CorrWriter	extras/Hadrons/Global.hpp	/^typedef XmlWriter CorrWriter;$/;"	t
CorrWriter	lib/Hadrons/Global.hpp	/^typedef Hdf5Writer CorrWriter;$/;"	t
CorrWriter	lib/Hadrons/Global.hpp	/^typedef XmlWriter CorrWriter;$/;"	t
CosRealFunctor	lib/simd/Grid_vector_unops.h	/^struct CosRealFunctor {$/;"	s	namespace:Grid
CosReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_cos_op<Scalar>, const Derived> CosReturnType;$/;"	t
CoshReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_cosh_op<Scalar>, const Derived> CoshReturnType;$/;"	t
Cost	lib/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon503
Cost	lib/Eigen/src/Core/Redux.h	/^    Cost = Derived::SizeAtCompileTime == Dynamic ? HugeCost$/;"	e	enum:Eigen::internal::redux_traits::__anon118
Cost	lib/Eigen/src/Core/VectorwiseOp.h	/^  template<typename Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_lpnorm
Cost	lib/Eigen/src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux
Cost	lib/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon223
Cost	lib/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon224
Cost	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon268
Cost	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon269
Cost	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon270
Cost	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = 3 * NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon482
Cost	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon478
Cost	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon479
Cost	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon480
Cost	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon481
Cost	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon477
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon403
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon407
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon408
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon409
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon412
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon404
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = 3 * NumTraits<Scalar>::AddCost +$/;"	e	enum:Eigen::internal::functor_traits::__anon410
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon406
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon414
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon415
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon416
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = scalar_div_cost<result_type,PacketAccess>::value$/;"	e	enum:Eigen::internal::functor_traits::__anon413
Cost	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon411
Cost	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^    Cost = 1,$/;"	e	enum:Eigen::internal::functor_traits::__anon485
Cost	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = 0 \/* as the constant value should be loaded in register only once for the whole expression *\/,$/;"	e	enum:Eigen::internal::functor_traits::__anon483
Cost	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon484
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon435
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon436
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon437
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon438
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon433
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon434
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon422
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon423
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon424
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon425
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon426
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon427
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon428
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon429
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon430
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon419
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon420
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon421
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon417
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon418
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon440
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon439
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon431
Cost	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon432
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = $/;"	e	enum:Eigen::internal::functor_traits::__anon476
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = ( (EIGEN_FAST_MATH && is_same<Scalar,float>::value)$/;"	e	enum:Eigen::internal::functor_traits::__anon463
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = (sizeof(Scalar) == 8 ? 28$/;"	e	enum:Eigen::internal::functor_traits::__anon455
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon456
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon457
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon458
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon459
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon460
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon461
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon462
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon464
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon465
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon441
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon442
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? 5 * NumTraits<Scalar>::MulCost : NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon445
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon444
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon469
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon470
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon471
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon472
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon473
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon474
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon475
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = functor_traits<scalar_log_op<Scalar> >::Cost \/\/ TODO measure cost of log1p$/;"	e	enum:Eigen::internal::functor_traits::__anon453
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost =$/;"	e	enum:Eigen::internal::functor_traits::__anon451
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost =$/;"	e	enum:Eigen::internal::functor_traits::__anon452
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon447
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon448
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon449
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon450
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon468
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog10 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon454
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon443
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon466
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon467
Cost	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon446
CostOpType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::evaluator
CountReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> CountReturnType;$/;"	t	class:Eigen::VectorwiseOp
CovShiftBackward	lib/qcd/action/gauge/GaugeImplementations.h	/^  CovShiftBackward(const GaugeLinkField &Link, int mu,$/;"	f	class:Grid::QCD::PeriodicGaugeImpl
CovShiftBackward	lib/qcd/action/gauge/GaugeImplementations.h	/^  static Lattice<covariant> CovShiftBackward(const GaugeLinkField &Link, int mu,$/;"	f	class:Grid::QCD::ConjugateGaugeImpl
CovShiftBackward	lib/qcd/utils/CovariantCshift.h	/^  template<class covariant,class gauge> Lattice<covariant> CovShiftBackward(const Lattice<gauge> &Link, $/;"	f	namespace:Grid::QCD::ConjugateBC
CovShiftBackward	lib/qcd/utils/CovariantCshift.h	/^  template<class covariant,class gauge> Lattice<covariant> CovShiftBackward(const Lattice<gauge> &Link, $/;"	f	namespace:Grid::QCD::PeriodicBC
CovShiftForward	lib/qcd/action/gauge/GaugeImplementations.h	/^  CovShiftForward(const GaugeLinkField &Link, int mu,$/;"	f	class:Grid::QCD::PeriodicGaugeImpl
CovShiftForward	lib/qcd/action/gauge/GaugeImplementations.h	/^  static Lattice<covariant> CovShiftForward(const GaugeLinkField &Link, int mu,$/;"	f	class:Grid::QCD::ConjugateGaugeImpl
CovShiftForward	lib/qcd/utils/CovariantCshift.h	/^  template<class covariant,class gauge> Lattice<covariant> CovShiftForward(const Lattice<gauge> &Link, $/;"	f	namespace:Grid::QCD::ConjugateBC
CovShiftForward	lib/qcd/utils/CovariantCshift.h	/^  template<class covariant,class gauge> Lattice<covariant> CovShiftForward(const Lattice<gauge> &Link, $/;"	f	namespace:Grid::QCD::PeriodicBC
CovShiftIdentityBackward	lib/qcd/action/gauge/GaugeImplementations.h	/^  CovShiftIdentityBackward(const GaugeLinkField &Link, int mu) {$/;"	f	class:Grid::QCD::ConjugateGaugeImpl
CovShiftIdentityBackward	lib/qcd/action/gauge/GaugeImplementations.h	/^  CovShiftIdentityBackward(const GaugeLinkField &Link, int mu) {$/;"	f	class:Grid::QCD::PeriodicGaugeImpl
CovShiftIdentityForward	lib/qcd/action/gauge/GaugeImplementations.h	/^  CovShiftIdentityForward(const GaugeLinkField &Link, int mu) {$/;"	f	class:Grid::QCD::ConjugateGaugeImpl
CovShiftIdentityForward	lib/qcd/action/gauge/GaugeImplementations.h	/^  CovShiftIdentityForward(const GaugeLinkField &Link, int mu) {$/;"	f	class:Grid::QCD::PeriodicGaugeImpl
CreateSubspace	lib/algorithms/CoarsenedMatrix.h	/^    virtual void CreateSubspace(GridParallelRNG  &RNG,LinearOperatorBase<FineField> &hermop,int nn=nbasis) {$/;"	f	class:Grid::Aggregation
CreateSubspaceLanczos	lib/algorithms/CoarsenedMatrix.h	/^    virtual void CreateSubspaceLanczos(GridParallelRNG  &RNG,LinearOperatorBase<FineField> &hermop,int nn=nbasis) $/;"	f	class:Grid::Aggregation
CreateSubspaceRandom	lib/algorithms/CoarsenedMatrix.h	/^    void CreateSubspaceRandom(GridParallelRNG &RNG){$/;"	f	class:Grid::Aggregation
CrossReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp
Cshift	lib/cshift/Cshift_mpi.h	/^template<class vobj> Lattice<vobj> Cshift(const Lattice<vobj> &rhs,int dimension,int shift)$/;"	f	namespace:Grid
Cshift	lib/cshift/Cshift_none.h	/^template<class vobj> Lattice<vobj> Cshift(const Lattice<vobj> &rhs,int dimension,int shift)$/;"	f	namespace:Grid
Cshift_comms	lib/cshift/Cshift_mpi.h	/^template<class vobj> void Cshift_comms(Lattice<vobj> &ret,const Lattice<vobj> &rhs,int dimension,int shift,int cbmask)$/;"	f	namespace:Grid
Cshift_comms	lib/cshift/Cshift_mpi.h	/^template<class vobj> void Cshift_comms(Lattice<vobj>& ret,const Lattice<vobj> &rhs,int dimension,int shift)$/;"	f	namespace:Grid
Cshift_comms_simd	lib/cshift/Cshift_mpi.h	/^template<class vobj> void  Cshift_comms_simd(Lattice<vobj> &ret,const Lattice<vobj> &rhs,int dimension,int shift,int cbmask)$/;"	f	namespace:Grid
Cshift_comms_simd	lib/cshift/Cshift_mpi.h	/^template<class vobj> void Cshift_comms_simd(Lattice<vobj>& ret,const Lattice<vobj> &rhs,int dimension,int shift)$/;"	f	namespace:Grid
Cshift_local	lib/cshift/Cshift_common.h	/^template<class vobj> Lattice<vobj> Cshift_local(Lattice<vobj> &ret,const Lattice<vobj> &rhs,int dimension,int shift,int cbmask)$/;"	f	namespace:Grid
Cshift_local	lib/cshift/Cshift_common.h	/^template<class vobj> void Cshift_local(Lattice<vobj>& ret,const Lattice<vobj> &rhs,int dimension,int shift)$/;"	f	namespace:Grid
CubeReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_cube_op<Scalar>, const Derived> CubeReturnType;$/;"	t
CwiseAbs2ReturnType	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived> CwiseAbs2ReturnType;$/;"	t
CwiseAbsReturnType	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived> CwiseAbsReturnType;$/;"	t
CwiseBinaryOp	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp
CwiseBinaryOp	lib/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : $/;"	c	namespace:Eigen
CwiseBinaryOpImpl	lib/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl$/;"	c	namespace:Eigen
CwiseBinaryOpImpl	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl
CwiseBinaryOpImpl	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen
CwiseInverseReturnType	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived> CwiseInverseReturnType;$/;"	t
CwiseNullaryOp	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index rows, Index cols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp
CwiseNullaryOp	lib/Eigen/src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : public internal::dense_xpr_base< CwiseNullaryOp<NullaryOp, PlainObjectType> >::type, internal::no_assignment_operator$/;"	c	namespace:Eigen
CwiseProductDenseReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> struct CwiseProductDenseReturnType {$/;"	s	class:Eigen::SparseMatrixBase
CwiseScalarEqualReturnType	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^typedef CwiseBinaryOp<internal::scalar_cmp_op<Scalar,Scalar,internal::cmp_EQ>, const Derived, const ConstantReturnType> CwiseScalarEqualReturnType;$/;"	t
CwiseSignReturnType	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sign_op<Scalar>, const Derived> CwiseSignReturnType;$/;"	t
CwiseSqrtReturnType	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived> CwiseSqrtReturnType;$/;"	t
CwiseTernaryOp	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  EIGEN_STRONG_INLINE CwiseTernaryOp(const Arg1& a1, const Arg2& a2,$/;"	f	class:Eigen::CwiseTernaryOp
CwiseTernaryOp	lib/Eigen/src/Core/CwiseTernaryOp.h	/^class CwiseTernaryOp : public CwiseTernaryOpImpl<$/;"	c	namespace:Eigen
CwiseTernaryOpImpl	lib/Eigen/src/Core/CwiseTernaryOp.h	/^class CwiseTernaryOpImpl$/;"	c	namespace:Eigen
CwiseUnaryOp	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    explicit CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp
CwiseUnaryOp	lib/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : public CwiseUnaryOpImpl<UnaryOp, XprType, typename internal::traits<XprType>::StorageKind>, internal::no_assignment_operator$/;"	c	namespace:Eigen
CwiseUnaryOpImpl	lib/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl$/;"	c	namespace:Eigen
CwiseUnaryView	lib/Eigen/src/Core/CwiseUnaryView.h	/^    explicit inline CwiseUnaryView(MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView
CwiseUnaryView	lib/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : public CwiseUnaryViewImpl<ViewOp, MatrixType, typename internal::traits<MatrixType>::StorageKind>$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	lib/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	lib/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen
DBW2GMod	lib/qcd/modules/Registration.h	/^typedef QCD::DBW2GModule<ImplementationPolicy> DBW2GMod;$/;"	t
DBW2GModule	lib/qcd/modules/ActionModules.h	/^class DBW2GModule: public ActionModule<DBW2GaugeAction<Impl>, BetaGaugeActionParameters> {$/;"	c	namespace:Grid::QCD
DBW2GaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      DBW2GaugeAction(RealD beta) : RBCGaugeAction<Gimpl>(beta,-1.4067) {};$/;"	f	class:Grid::QCD::DBW2GaugeAction
DBW2GaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^    class DBW2GaugeAction : public RBCGaugeAction<Gimpl> {$/;"	c	namespace:Grid::QCD
DEAD	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	109;"	d
DEAD_NON_PRINCIPAL	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	113;"	d
DEAD_PRINCIPAL	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	112;"	d
DEBUG_VAR	extras/Hadrons/Global.hpp	105;"	d
DEBUG_VAR	extras/qed-fvol/Global.hpp	32;"	d
DEBUG_VAR	lib/Hadrons/Global.hpp	105;"	d
DECLARE_PROJ	lib/qcd/action/fermion/WilsonCompressor.h	197;"	d
DECLARE_RELATIONAL	lib/lattice/Lattice_comparison_utils.h	/^DECLARE_RELATIONAL(==,seq);$/;"	m	namespace:Grid
DECLARE_RELATIONAL	lib/lattice/Lattice_comparison_utils.h	182;"	d
DECLARE_RELATIONAL	lib/lattice/Lattice_comparison_utils.h	225;"	d
DECL_GSISX	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	76;"	d
DECL_GSSVX	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	16;"	d
DECL_PERMUTE_N	lib/simd/Grid_generic.h	386;"	d
DECL_PERMUTE_N	lib/simd/Grid_generic.h	402;"	d
DEFAULT_MAT_EXP	lib/tensors/Tensor_exp.h	31;"	d
DEFINE_HDF5_NATIVE_TYPES	lib/serialisation/Hdf5Type.h	/^  DEFINE_HDF5_NATIVE_TYPES;$/;"	m	namespace:Grid
DEFINE_HDF5_NATIVE_TYPES	lib/serialisation/Hdf5Type.h	24;"	d
DEFINE_MEMPEAK	extras/Hadrons/Application.cc	164;"	d	file:
DEFINE_MEMPEAK	lib/Hadrons/Application.cc	164;"	d	file:
DEFINE_TEST_G	tests/core/Test_gamma.cc	120;"	d	file:
DEFINE_TEST_G	tests/core/Test_gamma.cc	99;"	d	file:
DHOP_SITE_DEPTH_HAND_INSTANTIATE	lib/qcd/action/fermion/StaggeredKernelsHand.cc	308;"	d	file:
DHOP_SITE_HAND_INSTANTIATE	lib/qcd/action/fermion/StaggeredKernelsHand.cc	302;"	d	file:
DIR0_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	178;"	d
DIR0_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	19;"	d
DIR0_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	2;"	d
DIR0_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	10;"	d
DIR0_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	186;"	d
DIR0_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	27;"	d
DIR1_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	179;"	d
DIR1_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	20;"	d
DIR1_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	3;"	d
DIR1_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	11;"	d
DIR1_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	187;"	d
DIR1_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	28;"	d
DIR2_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	180;"	d
DIR2_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	21;"	d
DIR2_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	4;"	d
DIR2_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	12;"	d
DIR2_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	188;"	d
DIR2_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	29;"	d
DIR3_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	181;"	d
DIR3_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	22;"	d
DIR3_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	5;"	d
DIR3_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	13;"	d
DIR3_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	189;"	d
DIR3_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	30;"	d
DIR4_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	182;"	d
DIR4_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	23;"	d
DIR4_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	6;"	d
DIR4_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	14;"	d
DIR4_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	190;"	d
DIR4_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	31;"	d
DIR5_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	183;"	d
DIR5_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	24;"	d
DIR5_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	7;"	d
DIR5_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	15;"	d
DIR5_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	191;"	d
DIR5_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	32;"	d
DIR6_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	184;"	d
DIR6_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	25;"	d
DIR6_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	8;"	d
DIR6_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	16;"	d
DIR6_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	192;"	d
DIR6_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	33;"	d
DIR7_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	185;"	d
DIR7_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	26;"	d
DIR7_PROJMEM	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	9;"	d
DIR7_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	17;"	d
DIR7_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	193;"	d
DIR7_RECON	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	34;"	d
DISABLE_WARNINGS_H	lib/DisableWarnings.h	31;"	d
DST_CHAN	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	65;"	d
DST_CTRL	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	66;"	d
DW	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DW(const FermionField &in, FermionField &out,int dag)$/;"	f	class:Grid::QCD::WilsonFermion5D
DWF	tests/qdpxx/Test_qdpxx_munprec.cc	/^                 DWF,           \/\/ CPS style preconditioning$/;"	e	enum:ChromaAction	file:
DWFPar	extras/Hadrons/Modules/MAction/DWF.hpp	/^class DWFPar: Serializable$/;"	c
DWFPar	lib/Hadrons/Modules/MAction/DWF.hpp	/^class DWFPar: Serializable$/;"	c
DaggerNo	lib/qcd/QCD.h	/^    static const int DaggerNo=0;$/;"	m	namespace:Grid::QCD
DaggerYes	lib/qcd/QCD.h	/^    static const int DaggerYes=1;$/;"	m	namespace:Grid::QCD
DataRowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon386
DataRowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon388
DataRowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon389
DecompositionOptions	lib/Eigen/src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
DecompositionType	lib/Eigen/src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base
DecompositionType	lib/Eigen/src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base
Decompress	lib/qcd/action/fermion/WilsonCompressor.h	/^  inline void Decompress(SiteHalfSpinor *out,$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
Decompress	lib/stencil/SimpleCompressor.h	/^  inline void Decompress(vobj *out,vobj *in, int o){ assert(0); }$/;"	f	class:Grid::SimpleCompressor
Decompress	lib/stencil/Stencil.h	/^  struct Decompress {$/;"	s	class:Grid::CartesianStencil
DecompressionStep	lib/qcd/action/fermion/WilsonCompressor.h	/^  inline bool DecompressionStep(void) { return false; }$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
DecompressionStep	lib/qcd/action/fermion/WilsonCompressor.h	/^  inline bool DecompressionStep(void) { return true; }$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
DecompressionStep	lib/stencil/SimpleCompressor.h	/^  inline bool DecompressionStep(void) { return false; }$/;"	f	class:Grid::SimpleCompressor
Decompressions	lib/stencil/Stencil.h	/^  std::vector<Decompress> Decompressions;$/;"	m	class:Grid::CartesianStencil
DecompressionsSHM	lib/stencil/Stencil.h	/^  std::vector<Decompress> DecompressionsSHM;$/;"	m	class:Grid::CartesianStencil
Default	lib/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
DefaultProduct	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
DefaultReader	lib/serialisation/Serialisation.h	/^  typedef XmlReader DefaultReader;$/;"	t	namespace:Grid
DefaultTraversal	lib/Eigen/src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::TraversalType
DefaultWriter	lib/serialisation/Serialisation.h	/^  typedef XmlWriter DefaultWriter;$/;"	t	namespace:Grid
Default_t	lib/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
Defined	lib/Eigen/src/Core/util/Meta.h	/^  enum { Defined = 0 };$/;"	e	enum:Eigen::scalar_product_traits::__anon112
Delta	lib/algorithms/approx/Zolotarev.h	/^    Delta,	      \/* maximum error, |R(x) - sgn(x)| <= Delta *\/$/;"	m	struct:Grid::Approx::__anon695
DenOp	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      FermionOperator<Impl> & DenOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
DenOp	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      FermionOperator<Impl> & DenOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
DenOp	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      FermionOperator<Impl> & DenOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
DenOp	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      FermionOperator<Impl> & DenOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
Dense	lib/Eigen/src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
Dense2Dense	lib/Eigen/src/Core/AssignEvaluator.h	/^struct Dense2Dense {};$/;"	s	namespace:Eigen::internal
Dense2Triangular	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Dense2Triangular         {};$/;"	s	namespace:Eigen::internal
DenseBase	lib/Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC DenseBase()$/;"	f	class:Eigen::DenseBase
DenseBase	lib/Eigen/src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen
DenseCoeffsBase	lib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	lib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	lib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	lib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen
DenseIndex	lib/Eigen/src/Core/util/Meta.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
DenseMatrix	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef Matrix<Scalar,Dynamic,Dynamic> DenseMatrix;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType
DenseMatrixType	lib/Eigen/src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase
DenseMatrixType	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase
DenseMatrixType	lib/Eigen/src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase
DenseMatrixType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::InverseImpl
DenseMatrixType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	class:Eigen::TriangularViewImpl
DenseMatrixType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::FullMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase
DenseMatrixType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::SparseMatrixBase
DenseShape	lib/Eigen/src/Core/util/Constants.h	/^struct DenseShape             { static std::string debugName() { return "DenseShape"; } };$/;"	s	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() {$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index cols) : m_rows(rows), m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index) : m_rows(rows) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index, Index, Index cols) : m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index,Index,Index) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    explicit DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseType	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase
DenseType	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase
DenseType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase
Depth	lib/Eigen/src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(traits<_Lhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon185
DerivCalls	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DerivCalls;$/;"	m	class:Grid::QCD::WilsonFermion5D
DerivCommTime	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DerivCommTime;$/;"	m	class:Grid::QCD::WilsonFermion5D
DerivComputeTime	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DerivComputeTime;$/;"	m	class:Grid::QCD::WilsonFermion5D
DerivDhopComputeTime	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DerivDhopComputeTime;$/;"	m	class:Grid::QCD::WilsonFermion5D
DerivInternal	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DerivInternal(StencilImpl &st, DoubledGaugeField &U, DoubledGaugeField &UUU, $/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DerivInternal	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DerivInternal(StencilImpl & st,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DerivInternal	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DerivInternal(StencilImpl &st, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::WilsonFermion
DerivInternal	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DerivInternal(StencilImpl & st,$/;"	f	class:Grid::QCD::WilsonFermion5D
DerivativeP	lib/qcd/utils/Metric.h	/^  void DerivativeP(MomentaField& der){$/;"	f	class:Grid::QCD::GeneralisedMomenta
DerivativeSolver	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  OperatorFunction<FermionField> &DerivativeSolver;$/;"	m	class:Grid::QCD::TwoFlavourPseudoFermionAction
DerivativeSolver	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      OperatorFunction<FermionField> &DerivativeSolver;$/;"	m	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
DerivativeSolver	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      OperatorFunction<FermionField> &DerivativeSolver;$/;"	m	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
DerivativeSolver	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      OperatorFunction<FermionField> &DerivativeSolver;$/;"	m	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
DerivativeU	lib/qcd/utils/Metric.h	/^  void DerivativeU(MomentaField& in, MomentaField& der){$/;"	f	class:Grid::QCD::GeneralisedMomenta
Derived	lib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Derived	lib/Eigen/src/Core/Product.h	/^    typedef Product<Lhs, Rhs, Option> Derived;$/;"	t	class:Eigen::ProductImpl
Derived	lib/Eigen/src/Core/Solve.h	/^  typedef Solve<Decomposition,RhsType> Derived;$/;"	t	class:Eigen::SolveImpl
Derived	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl
DerivedAlignment	lib/Eigen/src/Core/Ref.h	/^      DerivedAlignment = int(evaluator<Derived>::Alignment),$/;"	e	enum:Eigen::internal::traits::match::__anon150
Descriptor	lib/communicator/Communicator_mpi3_leader.cc	/^struct Descriptor {$/;"	s	namespace:Grid	file:
Descrs	lib/communicator/Communicator_mpi3_leader.cc	/^  volatile Descriptor Descrs[pool];$/;"	m	class:Grid::SlaveState	file:
Determinant	lib/tensors/Tensor_determinant.h	/^    inline iScalar<vtype> Determinant(const iMatrix<vtype,N> &arg)$/;"	f	namespace:Grid
Determinant	lib/tensors/Tensor_determinant.h	/^  inline ComplexD Determinant( const ComplexD &arg){    return arg;}$/;"	f	namespace:Grid
Determinant	lib/tensors/Tensor_determinant.h	/^  inline ComplexF Determinant( const ComplexF &arg){    return arg;}$/;"	f	namespace:Grid
Determinant	lib/tensors/Tensor_determinant.h	/^  inline RealD Determinant( const RealD &arg){    return arg;}$/;"	f	namespace:Grid
Determinant	lib/tensors/Tensor_determinant.h	/^  inline RealF Determinant( const RealF &arg){    return arg;}$/;"	f	namespace:Grid
Dhop	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::Dhop(const FermionField &in, FermionField &out, int dag) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
Dhop	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::Dhop(const FermionField &in, FermionField &out,int dag)$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
Dhop	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::Dhop(const FermionField &in, FermionField &out, int dag) {$/;"	f	class:Grid::QCD::WilsonFermion
Dhop	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::Dhop(const FermionField &in, FermionField &out,int dag)$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopCalls	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DhopCalls;$/;"	m	class:Grid::QCD::WilsonFermion5D
DhopCommTime	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DhopCommTime;$/;"	m	class:Grid::QCD::WilsonFermion5D
DhopComputeTime	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DhopComputeTime;$/;"	m	class:Grid::QCD::WilsonFermion5D
DhopComputeTime2	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DhopComputeTime2;$/;"	m	class:Grid::QCD::WilsonFermion5D
DhopDeriv	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DhopDeriv(GaugeField &mat, const FermionField &U, const FermionField &V, int dag) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DhopDeriv	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DhopDeriv(GaugeField &mat,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DhopDeriv	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopDeriv(GaugeField &mat, const FermionField &U, const FermionField &V, int dag) {$/;"	f	class:Grid::QCD::WilsonFermion
DhopDeriv	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopDeriv(GaugeField &mat,$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopDerivEO	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DhopDerivEO(GaugeField &mat, const FermionField &U, const FermionField &V, int dag) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DhopDerivEO	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DhopDerivEO(GaugeField &mat,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DhopDerivEO	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopDerivEO(GaugeField &mat, const FermionField &U, const FermionField &V, int dag) {$/;"	f	class:Grid::QCD::WilsonFermion
DhopDerivEO	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopDerivEO(GaugeField &mat,$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopDerivOE	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DhopDerivOE(GaugeField &mat, const FermionField &U, const FermionField &V, int dag) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DhopDerivOE	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DhopDerivOE(GaugeField &mat,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DhopDerivOE	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopDerivOE(GaugeField &mat, const FermionField &U, const FermionField &V, int dag) {$/;"	f	class:Grid::QCD::WilsonFermion
DhopDerivOE	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopDerivOE(GaugeField &mat,$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopDir	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DhopDir(const FermionField &in, FermionField &out, int dir, int disp) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DhopDir	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DhopDir(const FermionField &in, FermionField &out,int dir5,int disp)$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DhopDir	lib/qcd/action/fermion/StaggeredKernels.cc	/^void StaggeredKernels<Impl>::DhopDir( StencilImpl &st, DoubledGaugeField &U,  DoubledGaugeField &UUU, SiteSpinor *buf, int sF,$/;"	f	class:Grid::QCD::StaggeredKernels
DhopDir	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopDir(const FermionField &in, FermionField &out, int dir, int disp) {$/;"	f	class:Grid::QCD::WilsonFermion
DhopDir	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopDir(const FermionField &in, FermionField &out,int dir5,int disp)$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopDir	lib/qcd/action/fermion/WilsonKernels.cc	/^void WilsonKernels<Impl>::DhopDir( StencilImpl &st, DoubledGaugeField &U,SiteHalfSpinor *buf, int sF,$/;"	f	class:Grid::QCD::WilsonKernels
DhopDirDisp	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopDirDisp(const FermionField &in, FermionField &out,int dirdisp, int gamma, int dag) {$/;"	f	class:Grid::QCD::WilsonFermion
DhopEO	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DhopEO(const FermionField &in, FermionField &out, int dag) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DhopEO	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DhopEO(const FermionField &in, FermionField &out,int dag)$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DhopEO	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopEO(const FermionField &in, FermionField &out,int dag) {$/;"	f	class:Grid::QCD::WilsonFermion
DhopEO	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopEO(const FermionField &in, FermionField &out,int dag)$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopFaceTime	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DhopFaceTime;$/;"	m	class:Grid::QCD::WilsonFermion5D
DhopInternal	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DhopInternal(StencilImpl &st, LebesgueOrder &lo,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DhopInternal	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DhopInternal(StencilImpl & st, LebesgueOrder &lo,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DhopInternal	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopInternal(StencilImpl &st, LebesgueOrder &lo,$/;"	f	class:Grid::QCD::WilsonFermion
DhopInternal	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopInternal(StencilImpl & st, LebesgueOrder &lo,$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopInternalOverlappedComms	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopInternalOverlappedComms(StencilImpl & st, LebesgueOrder &lo,$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopInternalSerialComms	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopInternalSerialComms(StencilImpl & st, LebesgueOrder &lo,$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopOE	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::DhopOE(const FermionField &in, FermionField &out, int dag) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
DhopOE	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::DhopOE(const FermionField &in, FermionField &out,int dag)$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
DhopOE	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::DhopOE(const FermionField &in, FermionField &out, int dag) {$/;"	f	class:Grid::QCD::WilsonFermion
DhopOE	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::DhopOE(const FermionField &in, FermionField &out,int dag)$/;"	f	class:Grid::QCD::WilsonFermion5D
DhopSite	lib/qcd/action/fermion/StaggeredKernels.cc	/^void StaggeredKernels<Impl>::DhopSite(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U, DoubledGaugeField &UUU,$/;"	f	class:Grid::QCD::StaggeredKernels
DhopSite	lib/qcd/action/fermion/WilsonKernels.h	/^  DhopSite(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U, SiteHalfSpinor * buf,$/;"	f	class:Grid::QCD::WilsonKernels
DhopSiteAsm	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	/^template <> void StaggeredKernels<StaggeredImplD>::DhopSiteAsm(StencilImpl &st, LebesgueOrder &lo, $/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteAsm	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	/^template <> void StaggeredKernels<StaggeredImplF>::DhopSiteAsm(StencilImpl &st, LebesgueOrder &lo, $/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteAsm	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	/^template <> void StaggeredKernels<StaggeredVec5dImplD>::DhopSiteAsm(StencilImpl &st, LebesgueOrder &lo, $/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteAsm	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	/^template <> void StaggeredKernels<StaggeredVec5dImplF>::DhopSiteAsm(StencilImpl &st, LebesgueOrder &lo, $/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteAsm	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	/^void StaggeredKernels<Impl>::DhopSiteAsm(StencilImpl &st, LebesgueOrder &lo, $/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteDag	lib/qcd/action/fermion/StaggeredKernels.cc	/^void StaggeredKernels<Impl>::DhopSiteDag(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U, DoubledGaugeField &UUU,$/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteDag	lib/qcd/action/fermion/WilsonKernels.h	/^  DhopSiteDag(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U, SiteHalfSpinor * buf,$/;"	f	class:Grid::QCD::WilsonKernels
DhopSiteDag	lib/qcd/action/fermion/WilsonKernels.h	/^  DhopSiteDag(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,SiteHalfSpinor * buf,$/;"	f	class:Grid::QCD::WilsonKernels
DhopSiteDepth	lib/qcd/action/fermion/StaggeredKernels.cc	/^void StaggeredKernels<Impl>::DhopSiteDepth(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteDepthHand	lib/qcd/action/fermion/StaggeredKernelsHand.cc	/^void StaggeredKernels<Impl>::DhopSiteDepthHand(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::StaggeredKernels
DhopSiteHand	lib/qcd/action/fermion/StaggeredKernelsHand.cc	/^void StaggeredKernels<Impl>::DhopSiteHand(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,DoubledGaugeField &UUU,$/;"	f	class:Grid::QCD::StaggeredKernels
DhopTotalTime	lib/qcd/action/fermion/WilsonFermion5D.h	/^     double DhopTotalTime;$/;"	m	class:Grid::QCD::WilsonFermion5D
DiagCoeffNested	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                                                                       : SparseXprType::ColsAtCompileTime>::type DiagCoeffNested;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
DiagFlags	lib/Eigen/src/Core/ProductEvaluators.h	/^    DiagFlags = evaluator<DiagonalType>::Flags,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
DiagIndex	lib/Eigen/src/Core/Diagonal.h	/^    enum { DiagIndex = _DiagIndex };$/;"	e	enum:Eigen::Diagonal::__anon402
DiagIndex	lib/Eigen/src/Core/SolveTriangular.h	/^    DiagIndex  = IsLower ? LoopIndex : Size - LoopIndex - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon133
DiagSizeAtCompileTime	lib/Eigen/src/SVD/BDCSVD.h	/^    DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime, ColsAtCompileTime), $/;"	e	enum:Eigen::BDCSVD::__anon622
DiagSizeAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon620
DiagSizeAtCompileTime	lib/Eigen/src/SVD/SVDBase.h	/^    DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::SVDBase::__anon621
DiagVectorType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Diagonal	lib/Eigen/src/Core/Diagonal.h	/^    explicit inline Diagonal(MatrixType& matrix, Index a_index = DiagIndex) : m_matrix(matrix), m_index(a_index) {}$/;"	f	class:Eigen::Diagonal
Diagonal	lib/Eigen/src/Core/Diagonal.h	/^template<typename MatrixType, int _DiagIndex> class Diagonal$/;"	c	namespace:Eigen
Diagonal2Dense	lib/Eigen/src/Core/DiagonalMatrix.h	/^struct Diagonal2Dense {};$/;"	s	namespace:Eigen::internal
Diagonal2Sparse	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct Diagonal2Sparse {};$/;"	s	namespace:Eigen::internal
DiagonalBase	lib/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
DiagonalDynamicIndexReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived,DynamicIndex> DiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase
DiagonalIndexReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
DiagonalIntReturnType	lib/Eigen/src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen
DiagonalPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    explicit DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
DiagonalReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
DiagonalReturnType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalReturnType	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef Diagonal<SparseMatrix> DiagonalReturnType;$/;"	t	class:Eigen::SparseMatrix
DiagonalShape	lib/Eigen/src/Core/util/Constants.h	/^struct DiagonalShape          { static std::string debugName() { return "DiagonalShape"; } };$/;"	s	namespace:Eigen
DiagonalSize	lib/Eigen/src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon387
DiagonalType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalVectorType	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper
DiagonalVectorType	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase
DiagonalVectorType	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix
DiagonalVectorType	lib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalVectorType	lib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalWrapper	lib/Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalWrapper(DiagonalVectorType& a_diagonal) : m_diagonal(a_diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper
DiagonalWrapper	lib/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen
DigammaReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_digamma_op<Scalar>, const Derived> DigammaReturnType;$/;"	t
Dim	lib/Eigen/src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon600
Dim	lib/Eigen/src/Geometry/Homogeneous.h	/^    Dim  = Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::homogeneous_right_product_refactoring_helper::__anon609
Dim	lib/Eigen/src/Geometry/Homogeneous.h	/^    Dim = Rhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::homogeneous_left_product_refactoring_helper::__anon610
Dim	lib/Eigen/src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon586
Dim	lib/Eigen/src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon587
Dim	lib/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon588
Dim	lib/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon589
Dim	lib/Eigen/src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon591
Dim	lib/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon596
Dim	lib/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon597
Dim	lib/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon598
Dim	lib/Eigen/src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon593
Dim	lib/Eigen/src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon590
Dim1	lib/Eigen/src/Geometry/Transform.h	/^    Dim1 = _Dim==Dynamic ? _Dim : _Dim + 1,$/;"	e	enum:Eigen::internal::traits::__anon592
Dimension	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Dimension = Representation::Dimension;$/;"	m	class:Grid::QCD::StaggeredImpl
Dimension	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Dimension = Representation::Dimension;$/;"	m	class:Grid::QCD::StaggeredVec5dImpl
Dimension	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Dimension = Representation::Dimension;$/;"	m	class:Grid::QCD::WilsonImpl
Dimension	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  static const int Dimension = Nrepresentation;$/;"	m	class:Grid::QCD::DomainWallVec5dImpl
Dimension	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ static const int Dimension = Nrepresentation;$/;"	m	class:Grid::QCD::GparityWilsonImpl
Dimension	lib/qcd/representations/adjoint.h	/^  static const int Dimension = ncolour * ncolour - 1;$/;"	m	class:Grid::QCD::AdjointRep
Dimension	lib/qcd/representations/fundamental.h	/^  static const int Dimension = ncolour;$/;"	m	class:Grid::QCD::FundamentalRep
Dimension	lib/qcd/representations/two_index.h	/^  static const int Dimension = ncolour * (ncolour + S) \/ 2;$/;"	m	class:Grid::QCD::TwoIndexRep
Dimension	lib/qcd/utils/SUn.h	/^  static const int Dimension = ncolour;$/;"	m	class:Grid::QCD::SU
Dimension	lib/qcd/utils/SUnAdjoint.h	/^  static const int Dimension = ncolour * ncolour - 1;$/;"	m	class:Grid::QCD::SU_Adjoint
Dimension	lib/qcd/utils/SUnTwoIndex.h	/^  static const int Dimension = ncolour * (ncolour + S) \/ 2;$/;"	m	class:Grid::QCD::SU_TwoIndex
Dimensions	lib/communicator/Communicator_base.cc	/^int                      CartesianCommunicator::Dimensions(void)         { return _ndimension; };$/;"	f	class:Grid::CartesianCommunicator
DirectAccessBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
DirectAccessors	lib/Eigen/src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
DirectLinearAccessType	lib/Eigen/src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits
DirectWriteAccessors	lib/Eigen/src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
Direction	lib/Eigen/src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon608
DirectionType	lib/Eigen/src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
DiscLoopPar	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^class DiscLoopPar: Serializable$/;"	c
DiscLoopPar	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^class DiscLoopPar: Serializable$/;"	c
Div	lib/simd/Grid_avx.h	/^  struct Div {$/;"	s	namespace:Grid::Optimization
Div	lib/simd/Grid_avx512.h	/^  struct Div{$/;"	s	namespace:Grid::Optimization
Div	lib/simd/Grid_generic.h	/^  struct Div{$/;"	s	namespace:Grid::Optimization
Div	lib/simd/Grid_imci.h	/^  struct Div{$/;"	s	namespace:Grid::Optimization
Div	lib/simd/Grid_neon.h	/^  struct Div{$/;"	s	namespace:Grid::Optimization
Div	lib/simd/Grid_qpx.h	/^  struct Div{$/;"	s	namespace:Grid::Optimization
Div	lib/simd/Grid_sse4.h	/^  struct Div{$/;"	s	namespace:Grid::Optimization
DivIntFunctor	lib/simd/Grid_vector_unops.h	/^  DivIntFunctor(Integer _y) : y(_y){};$/;"	f	struct:Grid::DivIntFunctor
DivIntFunctor	lib/simd/Grid_vector_unops.h	/^struct DivIntFunctor {$/;"	s	namespace:Grid
DivSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Div         DivSIMD;$/;"	t	namespace:Grid
DivSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Div         DivSIMD;$/;"	t	namespace:Grid
DivSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Div         DivSIMD;$/;"	t	namespace:Grid
DivSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Div         DivSIMD;$/;"	t	namespace:Grid
DivSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Div         DivSIMD;$/;"	t	namespace:Grid
DivSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Div         DivSIMD;$/;"	t	namespace:Grid
DivSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Div         DivSIMD;$/;"	t	namespace:Grid
Dminus	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::Dminus(const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
DminusDag	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::DminusDag(const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
DmuAmu	lib/qcd/utils/GaugeFix.h	/^  static void DmuAmu(const std::vector<GaugeMat> &A,GaugeMat &dmuAmu) {$/;"	f	class:FourierAcceleratedGaugeFixer
DomainWallFermion	lib/qcd/action/fermion/DomainWallFermion.h	/^      DomainWallFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::DomainWallFermion
DomainWallFermion	lib/qcd/action/fermion/DomainWallFermion.h	/^    class DomainWallFermion : public CayleyFermion5D<Impl>$/;"	c	namespace:Grid::QCD
DomainWallFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<WilsonImplD> DomainWallFermionD;$/;"	t	namespace:Grid::QCD
DomainWallFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<WilsonImplDF> DomainWallFermionDF;$/;"	t	namespace:Grid::QCD
DomainWallFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<WilsonImplF> DomainWallFermionF;$/;"	t	namespace:Grid::QCD
DomainWallFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<WilsonImplFH> DomainWallFermionFH;$/;"	t	namespace:Grid::QCD
DomainWallFermionModule	lib/qcd/modules/FermionOperatorModules.h	/^class DomainWallFermionModule: public FermionOperatorModule<DomainWallFermion, FermionImpl, DomainWallFermionParameters> {$/;"	c	namespace:Grid::QCD
DomainWallFermionParameters	lib/qcd/modules/FermionOperatorModules.h	/^class DomainWallFermionParameters : Serializable {$/;"	c	namespace:Grid::QCD
DomainWallFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<WilsonImplR> DomainWallFermionR;$/;"	t	namespace:Grid::QCD
DomainWallFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<WilsonImplRL> DomainWallFermionRL;$/;"	t	namespace:Grid::QCD
DomainWallFermionVec5dD	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<DomainWallVec5dImplD> DomainWallFermionVec5dD;$/;"	t	namespace:Grid::QCD
DomainWallFermionVec5dDF	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<DomainWallVec5dImplDF> DomainWallFermionVec5dDF;$/;"	t	namespace:Grid::QCD
DomainWallFermionVec5dF	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<DomainWallVec5dImplF> DomainWallFermionVec5dF;$/;"	t	namespace:Grid::QCD
DomainWallFermionVec5dFH	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<DomainWallVec5dImplFH> DomainWallFermionVec5dFH;$/;"	t	namespace:Grid::QCD
DomainWallFermionVec5dR	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<DomainWallVec5dImplR> DomainWallFermionVec5dR;$/;"	t	namespace:Grid::QCD
DomainWallFermionVec5dRL	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<DomainWallVec5dImplRL> DomainWallFermionVec5dRL;$/;"	t	namespace:Grid::QCD
DomainWallVec5dImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  DomainWallVec5dImpl(const ImplParams &p = ImplParams()) : Params(p){};$/;"	f	class:Grid::QCD::DomainWallVec5dImpl
DomainWallVec5dImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^class DomainWallVec5dImpl :  public PeriodicGaugeImpl< GaugeImplTypes< S,Nrepresentation> > { $/;"	c	namespace:Grid::QCD
DomainWallVec5dImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexD,Nc, CoeffReal> DomainWallVec5dImplD; \/\/ Double$/;"	t	namespace:Grid::QCD
DomainWallVec5dImplDF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexD,Nc, CoeffRealHalfComms> DomainWallVec5dImplDF; \/\/ Double$/;"	t	namespace:Grid::QCD
DomainWallVec5dImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexF,Nc, CoeffReal> DomainWallVec5dImplF; \/\/ Float$/;"	t	namespace:Grid::QCD
DomainWallVec5dImplFH	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexF,Nc, CoeffRealHalfComms> DomainWallVec5dImplFH; \/\/ Float$/;"	t	namespace:Grid::QCD
DomainWallVec5dImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplex ,Nc, CoeffReal> DomainWallVec5dImplR; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
DomainWallVec5dImplRL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplex ,Nc, CoeffRealHalfComms> DomainWallVec5dImplRL; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
DomainWallVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef DomainWallFermion<DomainWallVec5dImplR>                      DomainWallVecFermionR;$/;"	t	file:
DontAlign	lib/Eigen/src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::StorageOptions
DontAlignCols	lib/Eigen/src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon161
DoublePacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct DoublePacket$/;"	s	namespace:Eigen::internal
DoublePacketType	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef DoublePacket<RealPacket> DoublePacketType;$/;"	t	class:Eigen::internal::gebp_traits
DoublePrecision	lib/tensors/Tensor_class.h	/^  typedef iMatrix<typename GridTypeMapper<vtype>::DoublePrecision, N> DoublePrecision;$/;"	t	class:Grid::iMatrix
DoublePrecision	lib/tensors/Tensor_class.h	/^  typedef iScalar<typename GridTypeMapper<vtype>::DoublePrecision> DoublePrecision;$/;"	t	class:Grid::iScalar
DoublePrecision	lib/tensors/Tensor_class.h	/^  typedef iVector<typename GridTypeMapper<vtype>::DoublePrecision, N> DoublePrecision;$/;"	t	class:Grid::iVector
DoublePrecision	lib/tensors/Tensor_traits.h	/^    typedef ComplexD DoublePrecision;$/;"	t	class:Grid::GridTypeMapper
DoublePrecision	lib/tensors/Tensor_traits.h	/^    typedef RealD DoublePrecision;$/;"	t	class:Grid::GridTypeMapper
DoublePrecision	lib/tensors/Tensor_traits.h	/^    typedef typename T::DoublePrecision DoublePrecision;$/;"	t	class:Grid::GridTypeMapper
DoublePrecision	lib/tensors/Tensor_traits.h	/^    typedef vComplexD DoublePrecision;$/;"	t	class:Grid::GridTypeMapper
DoublePrecision	lib/tensors/Tensor_traits.h	/^    typedef vRealD DoublePrecision;$/;"	t	class:Grid::GridTypeMapper
DoublePrecision	lib/tensors/Tensor_traits.h	/^    typedef void DoublePrecision;$/;"	t	class:Grid::GridTypeMapper
DoubleStore	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void DoubleStore(GridBase *GaugeGrid,$/;"	f	class:Grid::QCD::StaggeredImpl
DoubleStore	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void DoubleStore(GridBase *GaugeGrid,$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
DoubleStore	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void DoubleStore(GridBase *GaugeGrid,$/;"	f	class:Grid::QCD::WilsonImpl
DoubleStore	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  inline void DoubleStore(GridBase *GaugeGrid, DoubledGaugeField &Uds,const GaugeField &Umu) $/;"	f	class:Grid::QCD::DomainWallVec5dImpl
DoubleStore	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ inline void DoubleStore(GridBase *GaugeGrid,DoubledGaugeField &Uds,const GaugeField &Umu)$/;"	f	class:Grid::QCD::GparityWilsonImpl
DoubleStoredColourMatrix	lib/qcd/QCD.h	/^    typedef iDoubleStoredColourMatrix<Complex  > DoubleStoredColourMatrix;$/;"	t	namespace:Grid::QCD
DoubleStoredColourMatrixD	lib/qcd/QCD.h	/^    typedef iDoubleStoredColourMatrix<ComplexD > DoubleStoredColourMatrixD;$/;"	t	namespace:Grid::QCD
DoubleStoredColourMatrixF	lib/qcd/QCD.h	/^    typedef iDoubleStoredColourMatrix<ComplexF > DoubleStoredColourMatrixF;$/;"	t	namespace:Grid::QCD
DoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SiteDoubledGaugeField> DoubledGaugeField;$/;"	t	class:Grid::QCD::StaggeredImpl
DoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SiteDoubledGaugeField> DoubledGaugeField;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
DoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SiteDoubledGaugeField> DoubledGaugeField;$/;"	t	class:Grid::QCD::WilsonImpl
DoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef Lattice<SiteDoubledGaugeField>                      DoubledGaugeField;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
DoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef Lattice<SiteDoubledGaugeField> DoubledGaugeField;$/;"	t	class:Grid::QCD::GparityWilsonImpl
Dst	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluator::XprType Dst;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
DstAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    DstAlignment = DstEvaluator::Alignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon138
DstAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    DstAlignment = Kernel::AssignmentTraits::DstAlignment$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon147
DstAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    DstAlignment = Kernel::AssignmentTraits::DstAlignment$/;"	e	enum:Eigen::internal::dense_assignment_loop::__anon148
DstEvaluatorType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef DstEvaluatorTypeT DstEvaluatorType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
DstEvaluatorType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
DstEvaluatorType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
DstEvaluatorType	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::DstEvaluatorType DstEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstEvaluatorType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::DstEvaluatorType DstEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstEvaluatorType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;$/;"	t	struct:Eigen::internal::triangular_assignment_loop
DstFlags	lib/Eigen/src/Core/AssignEvaluator.h	/^    DstFlags = DstEvaluator::Flags,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon137
DstHasDirectAccess	lib/Eigen/src/Core/AssignEvaluator.h	/^    DstHasDirectAccess = DstFlags & DirectAccessBit,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon138
DstHasDirectAccess	lib/Eigen/src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
DstIndex	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename DstXprType::StorageIndex DstIndex;$/;"	t	struct:Eigen::internal::Assignment
DstIsRowMajor	lib/Eigen/src/Core/AssignEvaluator.h	/^    DstIsRowMajor = DstFlags&RowMajorBit,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
DstScalar	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Dst::Scalar DstScalar;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
DstXprType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorType::XprType DstXprType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
DstXprType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorType::XprType DstXprType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
DstXprType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorTypeT::XprType DstXprType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
DstXprType	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::DstXprType DstXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstXprType	lib/Eigen/src/Core/Swap.h	/^  typedef typename Base::DstXprType DstXprType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
DstXprType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::DstXprType DstXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstXprType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename DstEvaluatorType::XprType DstXprType;$/;"	t	struct:Eigen::internal::triangular_assignment_loop
DtoH	lib/simd/Grid_avx.h	/^    static inline __m256i DtoH (__m256d a,__m256d b,__m256d c,__m256d d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoH	lib/simd/Grid_avx512.h	/^    static inline __m512i DtoH (__m512d a,__m512d b,__m512d c,__m512d d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoH	lib/simd/Grid_generic.h	/^    static inline vech DtoH (vecd a,vecd b,vecd c,vecd d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoH	lib/simd/Grid_neon.h	/^    static inline float16x8_t DtoH (float64x2_t a,float64x2_t b,float64x2_t c,float64x2_t d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoH	lib/simd/Grid_qpx.h	/^    static inline vech DtoH (vector4double a, vector4double b, $/;"	f	struct:Grid::Optimization::PrecisionChange
DtoH	lib/simd/Grid_sse4.h	/^    static inline __m128i DtoH (__m128d a,__m128d b,__m128d c,__m128d d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoS	lib/simd/Grid_avx.h	/^    static inline __m256 DtoS (__m256d a,__m256d b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoS	lib/simd/Grid_avx512.h	/^    static inline __m512 DtoS (__m512d a,__m512d b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoS	lib/simd/Grid_generic.h	/^    static inline vecf DtoS (vecd a,vecd b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoS	lib/simd/Grid_neon.h	/^    static inline float32x4_t DtoS (float64x2_t a,float64x2_t b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoS	lib/simd/Grid_qpx.h	/^    static inline vector4float DtoS (vector4double a, vector4double b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DtoS	lib/simd/Grid_sse4.h	/^    static inline __m128 DtoS (__m128d a,__m128d b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
DumbOperator	tests/debug/Test_synthetic_lanczos.cc	/^  DumbOperator(GridBase *grid)    : scale(grid)$/;"	f	class:DumbOperator
DumbOperator	tests/debug/Test_synthetic_lanczos.cc	/^template<class Field> class DumbOperator  : public LinearOperatorBase<Field> {$/;"	c	file:
DumbOperator	tests/hmc/Test_multishift_sqrt.cc	/^  DumbOperator(GridBase *grid)$/;"	f	class:DumbOperator
DumbOperator	tests/hmc/Test_multishift_sqrt.cc	/^template<class Field> class DumbOperator  : public LinearOperatorBase<Field> {$/;"	c	file:
Dynamic	lib/Eigen/src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
DynamicIndex	lib/Eigen/src/Core/util/Constants.h	/^const int DynamicIndex = 0xffffff;$/;"	m	namespace:Eigen
EIGEN_ALIGN16	lib/Eigen/src/Core/util/Macros.h	751;"	d
EIGEN_ALIGN32	lib/Eigen/src/Core/util/Macros.h	752;"	d
EIGEN_ALIGN64	lib/Eigen/src/Core/util/Macros.h	753;"	d
EIGEN_ALIGN8	lib/Eigen/src/Core/util/Macros.h	750;"	d
EIGEN_ALIGNEDBOX_H	lib/Eigen/src/Geometry/AlignedBox.h	11;"	d
EIGEN_ALIGNED_ALLOCA	lib/Eigen/src/Core/util/Memory.h	629;"	d
EIGEN_ALIGNED_ALLOCATOR	lib/Eigen/src/StlSupport/details.h	15;"	d
EIGEN_ALIGN_MAX	lib/Eigen/src/Core/util/Macros.h	755;"	d
EIGEN_ALIGN_TO_BOUNDARY	lib/Eigen/src/Core/util/Macros.h	648;"	d
EIGEN_ALLANDANY_H	lib/Eigen/src/Core/BooleanRedux.h	11;"	d
EIGEN_ALLOCA	lib/Eigen/src/Core/util/Memory.h	547;"	d
EIGEN_ALLOCA	lib/Eigen/src/Core/util/Memory.h	549;"	d
EIGEN_ALWAYS_INLINE	lib/Eigen/src/Core/util/Macros.h	505;"	d
EIGEN_ALWAYS_INLINE	lib/Eigen/src/Core/util/Macros.h	507;"	d
EIGEN_AMBIVECTOR_H	lib/Eigen/src/SparseCore/AmbiVector.h	11;"	d
EIGEN_ANGLEAXIS_H	lib/Eigen/src/Geometry/AngleAxis.h	11;"	d
EIGEN_APPLE_DOUBLE_NEON_BUG	lib/Eigen/src/Core/arch/NEON/PacketMath.h	529;"	d
EIGEN_APPLE_DOUBLE_NEON_BUG	lib/Eigen/src/Core/arch/NEON/PacketMath.h	531;"	d
EIGEN_ARCH_ARM	lib/Eigen/src/Core/util/Macros.h	167;"	d
EIGEN_ARCH_ARM	lib/Eigen/src/Core/util/Macros.h	169;"	d
EIGEN_ARCH_ARM64	lib/Eigen/src/Core/util/Macros.h	174;"	d
EIGEN_ARCH_ARM64	lib/Eigen/src/Core/util/Macros.h	176;"	d
EIGEN_ARCH_ARM_OR_ARM64	lib/Eigen/src/Core/util/Macros.h	180;"	d
EIGEN_ARCH_ARM_OR_ARM64	lib/Eigen/src/Core/util/Macros.h	182;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	lib/Eigen/src/Core/arch/AVX/PacketMath.h	22;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	22;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	31;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	lib/Eigen/src/Core/arch/Default/Settings.h	46;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	lib/Eigen/src/Core/arch/NEON/PacketMath.h	33;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	lib/Eigen/src/Core/arch/SSE/PacketMath.h	22;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	32;"	d
EIGEN_ARCH_IA64	lib/Eigen/src/Core/util/Macros.h	201;"	d
EIGEN_ARCH_IA64	lib/Eigen/src/Core/util/Macros.h	203;"	d
EIGEN_ARCH_MIPS	lib/Eigen/src/Core/util/Macros.h	187;"	d
EIGEN_ARCH_MIPS	lib/Eigen/src/Core/util/Macros.h	189;"	d
EIGEN_ARCH_PPC	lib/Eigen/src/Core/util/Macros.h	208;"	d
EIGEN_ARCH_PPC	lib/Eigen/src/Core/util/Macros.h	210;"	d
EIGEN_ARCH_SPARC	lib/Eigen/src/Core/util/Macros.h	194;"	d
EIGEN_ARCH_SPARC	lib/Eigen/src/Core/util/Macros.h	196;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	lib/Eigen/src/Core/util/Macros.h	720;"	d
EIGEN_ARCH_i386	lib/Eigen/src/Core/util/Macros.h	154;"	d
EIGEN_ARCH_i386	lib/Eigen/src/Core/util/Macros.h	156;"	d
EIGEN_ARCH_i386_OR_x86_64	lib/Eigen/src/Core/util/Macros.h	160;"	d
EIGEN_ARCH_i386_OR_x86_64	lib/Eigen/src/Core/util/Macros.h	162;"	d
EIGEN_ARCH_x86_64	lib/Eigen/src/Core/util/Macros.h	148;"	d
EIGEN_ARCH_x86_64	lib/Eigen/src/Core/util/Macros.h	150;"	d
EIGEN_ARM_PREFETCH	lib/Eigen/src/Core/arch/NEON/PacketMath.h	57;"	d
EIGEN_ARM_PREFETCH	lib/Eigen/src/Core/arch/NEON/PacketMath.h	59;"	d
EIGEN_ARM_PREFETCH	lib/Eigen/src/Core/arch/NEON/PacketMath.h	61;"	d
EIGEN_ARM_PREFETCH	lib/Eigen/src/Core/arch/NEON/PacketMath.h	64;"	d
EIGEN_ARRAYBASE_H	lib/Eigen/src/Core/ArrayBase.h	11;"	d
EIGEN_ARRAYWRAPPER_H	lib/Eigen/src/Core/ArrayWrapper.h	11;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY	lib/Eigen/src/Core/GlobalFunctions.h	38;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_UNARY	lib/Eigen/src/Core/GlobalFunctions.h	16;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_UNARY	lib/Eigen/src/Core/GlobalFunctions.h	29;"	d
EIGEN_ARRAY_H	lib/Eigen/src/Core/Array.h	11;"	d
EIGEN_ASM_COMMENT	lib/Eigen/src/Core/util/Macros.h	620;"	d
EIGEN_ASSIGNMENT_FUNCTORS_H	lib/Eigen/src/Core/functors/AssignmentFunctors.h	11;"	d
EIGEN_ASSIGN_EVALUATOR_H	lib/Eigen/src/Core/AssignEvaluator.h	13;"	d
EIGEN_ASSIGN_H	lib/Eigen/src/Core/Assign.h	13;"	d
EIGEN_ASSIGN_VML_H	lib/Eigen/src/Core/Assign_MKL.h	35;"	d
EIGEN_BANDMATRIX_H	lib/Eigen/src/Core/BandMatrix.h	11;"	d
EIGEN_BASIC_PRECONDITIONERS_H	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	11;"	d
EIGEN_BDCSVD_H	lib/Eigen/src/SVD/BDCSVD.h	21;"	d
EIGEN_BICGSTAB_H	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	12;"	d
EIGEN_BIDIAGONALIZATION_H	lib/Eigen/src/SVD/UpperBidiagonalization.h	12;"	d
EIGEN_BINARY_FUNCTORS_H	lib/Eigen/src/Core/functors/BinaryFunctors.h	11;"	d
EIGEN_BLASUTIL_H	lib/Eigen/src/Core/util/BlasUtil.h	11;"	d
EIGEN_BLAS_GEMV_SPECIALIZATION	lib/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	88;"	d
EIGEN_BLAS_GEMV_SPECIALIZE	lib/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	52;"	d
EIGEN_BLAS_HEMM_L	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	90;"	d
EIGEN_BLAS_HEMM_R	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	206;"	d
EIGEN_BLAS_RANKUPDATE_C	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	96;"	d
EIGEN_BLAS_RANKUPDATE_R	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	75;"	d
EIGEN_BLAS_RANKUPDATE_SPECIALIZE	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	47;"	d
EIGEN_BLAS_SYMM_L	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	43;"	d
EIGEN_BLAS_SYMM_R	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	160;"	d
EIGEN_BLAS_SYMV_SPECIALIZATION	lib/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	74;"	d
EIGEN_BLAS_SYMV_SPECIALIZE	lib/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	50;"	d
EIGEN_BLAS_TRMM_L	lib/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	78;"	d
EIGEN_BLAS_TRMM_R	lib/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	189;"	d
EIGEN_BLAS_TRMM_SPECIALIZE	lib/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	53;"	d
EIGEN_BLAS_TRMV_CM	lib/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	74;"	d
EIGEN_BLAS_TRMV_RM	lib/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	156;"	d
EIGEN_BLAS_TRMV_SPECIALIZE	lib/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	50;"	d
EIGEN_BLAS_TRSM_L	lib/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	41;"	d
EIGEN_BLAS_TRSM_R	lib/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	94;"	d
EIGEN_BLOCK_H	lib/Eigen/src/Core/Block.h	12;"	d
EIGEN_BLOCK_HOUSEHOLDER_H	lib/Eigen/src/Householder/BlockHouseholder.h	12;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	lib/Eigen/src/Core/arch/AVX/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	lib/Eigen/src/Core/arch/Default/Settings.h	31;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	lib/Eigen/src/Core/arch/NEON/PacketMath.h	20;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	lib/Eigen/src/Core/arch/SSE/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	20;"	d
EIGEN_CAT	lib/Eigen/src/Core/util/Macros.h	479;"	d
EIGEN_CAT2	lib/Eigen/src/Core/util/Macros.h	478;"	d
EIGEN_CATCH	lib/Eigen/src/Core/util/Macros.h	965;"	d
EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT	lib/Eigen/src/Core/ProductEvaluators.h	222;"	d
EIGEN_CHECK_BINARY_COMPATIBILIY	lib/Eigen/src/Core/util/XprHelper.h	815;"	d
EIGEN_CHOLMODSUPPORT_H	lib/Eigen/src/CholmodSupport/CholmodSupport.h	11;"	d
EIGEN_COLAMD_H	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	48;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_H	lib/Eigen/src/QR/ColPivHouseholderQR.h	12;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_LAPACKE_H	lib/Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h	35;"	d
EIGEN_COMMA	lib/Eigen/src/Core/util/Macros.h	481;"	d
EIGEN_COMMAINITIALIZER_H	lib/Eigen/src/Core/CommaInitializer.h	12;"	d
EIGEN_COMPLETEORTHOGONALDECOMPOSITION_H	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	11;"	d
EIGEN_COMPLEX32_ALTIVEC_H	lib/Eigen/src/Core/arch/AltiVec/Complex.h	12;"	d
EIGEN_COMPLEX32_ALTIVEC_H	lib/Eigen/src/Core/arch/ZVector/Complex.h	12;"	d
EIGEN_COMPLEX_AVX_H	lib/Eigen/src/Core/arch/AVX/Complex.h	11;"	d
EIGEN_COMPLEX_CUDA_H	lib/Eigen/src/Core/arch/CUDA/Complex.h	11;"	d
EIGEN_COMPLEX_EIGEN_SOLVER_H	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	13;"	d
EIGEN_COMPLEX_NEON_H	lib/Eigen/src/Core/arch/NEON/Complex.h	12;"	d
EIGEN_COMPLEX_SCHUR_H	lib/Eigen/src/Eigenvalues/ComplexSchur.h	13;"	d
EIGEN_COMPLEX_SCHUR_LAPACKE_H	lib/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h	34;"	d
EIGEN_COMPLEX_SSE_H	lib/Eigen/src/Core/arch/SSE/Complex.h	11;"	d
EIGEN_COMPRESSED_STORAGE_H	lib/Eigen/src/SparseCore/CompressedStorage.h	11;"	d
EIGEN_COMP_ARM	lib/Eigen/src/Core/util/Macros.h	106;"	d
EIGEN_COMP_ARM	lib/Eigen/src/Core/util/Macros.h	108;"	d
EIGEN_COMP_CLANG	lib/Eigen/src/Core/util/Macros.h	33;"	d
EIGEN_COMP_CLANG	lib/Eigen/src/Core/util/Macros.h	35;"	d
EIGEN_COMP_EMSCRIPTEN	lib/Eigen/src/Core/util/Macros.h	113;"	d
EIGEN_COMP_EMSCRIPTEN	lib/Eigen/src/Core/util/Macros.h	115;"	d
EIGEN_COMP_GNUC	lib/Eigen/src/Core/util/Macros.h	26;"	d
EIGEN_COMP_GNUC	lib/Eigen/src/Core/util/Macros.h	28;"	d
EIGEN_COMP_GNUC_STRICT	lib/Eigen/src/Core/util/Macros.h	121;"	d
EIGEN_COMP_GNUC_STRICT	lib/Eigen/src/Core/util/Macros.h	123;"	d
EIGEN_COMP_IBM	lib/Eigen/src/Core/util/Macros.h	92;"	d
EIGEN_COMP_IBM	lib/Eigen/src/Core/util/Macros.h	94;"	d
EIGEN_COMP_ICC	lib/Eigen/src/Core/util/Macros.h	48;"	d
EIGEN_COMP_ICC	lib/Eigen/src/Core/util/Macros.h	50;"	d
EIGEN_COMP_LLVM	lib/Eigen/src/Core/util/Macros.h	41;"	d
EIGEN_COMP_LLVM	lib/Eigen/src/Core/util/Macros.h	43;"	d
EIGEN_COMP_MINGW	lib/Eigen/src/Core/util/Macros.h	55;"	d
EIGEN_COMP_MINGW	lib/Eigen/src/Core/util/Macros.h	57;"	d
EIGEN_COMP_MSVC	lib/Eigen/src/Core/util/Macros.h	69;"	d
EIGEN_COMP_MSVC	lib/Eigen/src/Core/util/Macros.h	71;"	d
EIGEN_COMP_MSVC_STRICT	lib/Eigen/src/Core/util/Macros.h	85;"	d
EIGEN_COMP_MSVC_STRICT	lib/Eigen/src/Core/util/Macros.h	87;"	d
EIGEN_COMP_PGI	lib/Eigen/src/Core/util/Macros.h	101;"	d
EIGEN_COMP_PGI	lib/Eigen/src/Core/util/Macros.h	99;"	d
EIGEN_COMP_SUNCC	lib/Eigen/src/Core/util/Macros.h	62;"	d
EIGEN_COMP_SUNCC	lib/Eigen/src/Core/util/Macros.h	64;"	d
EIGEN_CONDITIONESTIMATOR_H	lib/Eigen/src/Core/ConditionEstimator.h	11;"	d
EIGEN_CONJUGATE_GRADIENT_H	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	11;"	d
EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	11;"	d
EIGEN_CONSTANTS_H	lib/Eigen/src/Core/util/Constants.h	12;"	d
EIGEN_COREEVALUATORS_H	lib/Eigen/src/Core/CoreEvaluators.h	14;"	d
EIGEN_COREITERATORS_H	lib/Eigen/src/Core/CoreIterators.h	11;"	d
EIGEN_CPUID	lib/Eigen/src/Core/util/Memory.h	757;"	d
EIGEN_CPUID	lib/Eigen/src/Core/util/Memory.h	762;"	d
EIGEN_CPUID	lib/Eigen/src/Core/util/Memory.h	766;"	d
EIGEN_CPUID	lib/Eigen/src/Core/util/Memory.h	771;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/Core/ArrayBase.h	100;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/Core/ArrayBase.h	89;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/Core/DenseBase.h	570;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/Core/DenseBase.h	577;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/Core/MatrixBase.h	123;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/Core/MatrixBase.h	132;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/SparseCore/SparseMatrixBase.h	147;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	lib/Eigen/src/SparseCore/SparseMatrixBase.h	165;"	d
EIGEN_CWISE_BINARY_OP_H	lib/Eigen/src/Core/CwiseBinaryOp.h	12;"	d
EIGEN_CWISE_BINARY_RETURN_TYPE	lib/Eigen/src/Core/util/Macros.h	902;"	d
EIGEN_CWISE_NULLARY_OP_H	lib/Eigen/src/Core/CwiseNullaryOp.h	11;"	d
EIGEN_CWISE_TERNARY_OP_H	lib/Eigen/src/Core/CwiseTernaryOp.h	13;"	d
EIGEN_CWISE_UNARY_OP_H	lib/Eigen/src/Core/CwiseUnaryOp.h	12;"	d
EIGEN_CWISE_UNARY_VIEW_H	lib/Eigen/src/Core/CwiseUnaryView.h	11;"	d
EIGEN_DBG_SPARSE	lib/Eigen/src/SparseCore/SparseUtil.h	16;"	d
EIGEN_DEBUG_ALIGNED_LOAD	lib/Eigen/src/Core/GenericPacketMath.h	27;"	d
EIGEN_DEBUG_ALIGNED_STORE	lib/Eigen/src/Core/GenericPacketMath.h	35;"	d
EIGEN_DEBUG_UNALIGNED_LOAD	lib/Eigen/src/Core/GenericPacketMath.h	31;"	d
EIGEN_DEBUG_UNALIGNED_STORE	lib/Eigen/src/Core/GenericPacketMath.h	39;"	d
EIGEN_DEBUG_VAR	lib/Eigen/src/Core/util/Macros.h	475;"	d
EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	lib/Eigen/src/Core/util/Macros.h	528;"	d
EIGEN_DEFAULT_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	777;"	d
EIGEN_DEFAULT_DENSE_INDEX_TYPE	lib/Eigen/src/Core/util/Macros.h	336;"	d
EIGEN_DEFAULT_IO_FORMAT	lib/Eigen/src/Core/util/Macros.h	806;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	lib/Eigen/src/Core/util/Macros.h	330;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	lib/Eigen/src/Core/util/Macros.h	332;"	d
EIGEN_DEFAULT_SETTINGS_H	lib/Eigen/src/Core/arch/Default/Settings.h	17;"	d
EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	lib/Eigen/src/Core/util/Macros.h	529;"	d
EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION	lib/Eigen/src/StlSupport/StdDeque.h	21;"	d
EIGEN_DEFINE_STL_LIST_SPECIALIZATION	lib/Eigen/src/StlSupport/StdList.h	20;"	d
EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION	lib/Eigen/src/StlSupport/StdVector.h	21;"	d
EIGEN_DENSEBASE_H	lib/Eigen/src/Core/DenseBase.h	12;"	d
EIGEN_DENSECOEFFSBASE_H	lib/Eigen/src/Core/DenseCoeffsBase.h	11;"	d
EIGEN_DENSESTORAGEBASE_H	lib/Eigen/src/Core/PlainObjectBase.h	12;"	d
EIGEN_DENSE_PUBLIC_INTERFACE	lib/Eigen/src/Core/util/Macros.h	867;"	d
EIGEN_DEPRECATED	lib/Eigen/src/Core/util/Macros.h	594;"	d
EIGEN_DETERMINANT_H	lib/Eigen/src/LU/Determinant.h	11;"	d
EIGEN_DIAGONALMATRIX_H	lib/Eigen/src/Core/DiagonalMatrix.h	12;"	d
EIGEN_DIAGONALPRODUCT_H	lib/Eigen/src/Core/DiagonalProduct.h	12;"	d
EIGEN_DIAGONAL_H	lib/Eigen/src/Core/Diagonal.h	12;"	d
EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT	lib/Eigen/src/Core/util/Macros.h	740;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	lib/Eigen/src/Core/DenseBase.h	572;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	lib/Eigen/src/Core/DenseBase.h	579;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	lib/Eigen/src/SparseCore/SparseMatrixBase.h	151;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	lib/Eigen/src/SparseCore/SparseMatrixBase.h	155;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	lib/Eigen/src/SparseCore/SparseMatrixBase.h	168;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	lib/Eigen/src/Core/DenseBase.h	571;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	lib/Eigen/src/Core/DenseBase.h	578;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	lib/Eigen/src/SparseCore/SparseMatrixBase.h	150;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	lib/Eigen/src/SparseCore/SparseMatrixBase.h	154;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	lib/Eigen/src/SparseCore/SparseMatrixBase.h	167;"	d
EIGEN_DOC_UNARY_ADDONS	lib/Eigen/src/Core/ArrayBase.h	101;"	d
EIGEN_DOC_UNARY_ADDONS	lib/Eigen/src/Core/ArrayBase.h	90;"	d
EIGEN_DOC_UNARY_ADDONS	lib/Eigen/src/Core/MatrixBase.h	124;"	d
EIGEN_DOC_UNARY_ADDONS	lib/Eigen/src/Core/MatrixBase.h	133;"	d
EIGEN_DOC_UNARY_ADDONS	lib/Eigen/src/SparseCore/SparseMatrixBase.h	149;"	d
EIGEN_DOC_UNARY_ADDONS	lib/Eigen/src/SparseCore/SparseMatrixBase.h	153;"	d
EIGEN_DOC_UNARY_ADDONS	lib/Eigen/src/SparseCore/SparseMatrixBase.h	166;"	d
EIGEN_DONT_INLINE	lib/Eigen/src/Core/util/Macros.h	511;"	d
EIGEN_DONT_INLINE	lib/Eigen/src/Core/util/Macros.h	513;"	d
EIGEN_DONT_INLINE	lib/Eigen/src/Core/util/Macros.h	515;"	d
EIGEN_DOT_H	lib/Eigen/src/Core/Dot.h	11;"	d
EIGEN_EIGENBASE_H	lib/Eigen/src/Core/EigenBase.h	12;"	d
EIGEN_EIGENSOLVER_H	lib/Eigen/src/Eigenvalues/EigenSolver.h	12;"	d
EIGEN_EMPTY	lib/Eigen/src/Core/util/Macros.h	813;"	d
EIGEN_EMPTY_STRUCT_CTOR	lib/Eigen/src/Core/util/XprHelper.h	18;"	d
EIGEN_EMPTY_STRUCT_CTOR	lib/Eigen/src/Core/util/XprHelper.h	22;"	d
EIGEN_EULERANGLES_H	lib/Eigen/src/Geometry/EulerAngles.h	11;"	d
EIGEN_EXCEPTION_SPEC	lib/Eigen/src/Core/CommaInitializer.h	/^  EIGEN_EXCEPTION_SPEC(Eigen::eigen_assert_exception)$/;"	f	struct:Eigen::CommaInitializer
EIGEN_EXCEPTION_SPEC	lib/Eigen/src/Core/util/Macros.h	984;"	d
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(bool) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(double) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(float) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(int) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(long long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(short) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(signed char) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned char) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned int) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned long long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned short) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	40;"	d
EIGEN_EXPLICIT_CAST	lib/Eigen/src/Core/arch/CUDA/Half.h	42;"	d
EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE	lib/Eigen/src/Core/util/Macros.h	923;"	d
EIGEN_EXTRACT_8f_FROM_16f	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	662;"	d
EIGEN_EXTRACT_8f_FROM_16f	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	666;"	d
EIGEN_FAST_MATH	lib/Eigen/src/Core/util/Macros.h	472;"	d
EIGEN_FORCEALIGNEDACCESS_H	lib/Eigen/src/Core/ForceAlignedAccess.h	11;"	d
EIGEN_FORWARDDECLARATIONS_H	lib/Eigen/src/Core/util/ForwardDeclarations.h	12;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	lib/Eigen/src/Core/util/Memory.h	46;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	lib/Eigen/src/Core/util/Memory.h	48;"	d
EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H	lib/Eigen/src/QR/FullPivHouseholderQR.h	12;"	d
EIGEN_FUZZY_H	lib/Eigen/src/Core/Fuzzy.h	12;"	d
EIGEN_GCC3_OR_OLDER	lib/Eigen/src/Core/util/Macros.h	139;"	d
EIGEN_GCC3_OR_OLDER	lib/Eigen/src/Core/util/Macros.h	141;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	lib/Eigen/src/Core/util/Macros.h	705;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1096;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1133;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1200;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1242;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1301;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1336;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1392;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1429;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1471;"	d
EIGEN_GEBGP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1504;"	d
EIGEN_GEBP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	1023;"	d
EIGEN_GEBP_ONESTEP	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	970;"	d
EIGEN_GENERALIZEDEIGENSOLVER_H	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	13;"	d
EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	12;"	d
EIGEN_GENERAL_BLOCK_PANEL_H	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	11;"	d
EIGEN_GENERAL_MATRIX_MATRIX_BLAS_H	lib/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	34;"	d
EIGEN_GENERAL_MATRIX_MATRIX_H	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	11;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_BLAS_H	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	34;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	11;"	d
EIGEN_GENERAL_MATRIX_VECTOR_BLAS_H	lib/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	34;"	d
EIGEN_GENERAL_MATRIX_VECTOR_H	lib/Eigen/src/Core/products/GeneralMatrixVector.h	11;"	d
EIGEN_GENERAL_PRODUCT_H	lib/Eigen/src/Core/GeneralProduct.h	12;"	d
EIGEN_GENERIC_PACKET_MATH_H	lib/Eigen/src/Core/GenericPacketMath.h	12;"	d
EIGEN_GENERIC_PUBLIC_INTERFACE	lib/Eigen/src/Core/util/Macros.h	849;"	d
EIGEN_GEOMETRY_SSE_H	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	12;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	lib/Eigen/src/Core/util/Memory.h	36;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	lib/Eigen/src/Core/util/Memory.h	38;"	d
EIGEN_GLOBAL_FUNCTIONS_H	lib/Eigen/src/Core/GlobalFunctions.h	12;"	d
EIGEN_GNUC_AT	lib/Eigen/src/Core/util/Macros.h	130;"	d
EIGEN_GNUC_AT	lib/Eigen/src/Core/util/Macros.h	134;"	d
EIGEN_GNUC_AT_LEAST	lib/Eigen/src/Core/util/Macros.h	128;"	d
EIGEN_GNUC_AT_LEAST	lib/Eigen/src/Core/util/Macros.h	132;"	d
EIGEN_GNUC_AT_MOST	lib/Eigen/src/Core/util/Macros.h	129;"	d
EIGEN_GNUC_AT_MOST	lib/Eigen/src/Core/util/Macros.h	133;"	d
EIGEN_HALF_CUDA_H	lib/Eigen/src/Core/arch/CUDA/Half.h	37;"	d
EIGEN_HAS_BUILTIN	lib/Eigen/src/Core/util/Macros.h	341;"	d
EIGEN_HAS_BUILTIN	lib/Eigen/src/Core/util/Macros.h	343;"	d
EIGEN_HAS_C99_MATH	lib/Eigen/src/Core/util/Macros.h	384;"	d
EIGEN_HAS_C99_MATH	lib/Eigen/src/Core/util/Macros.h	386;"	d
EIGEN_HAS_CONSTEXPR	lib/Eigen/src/Core/util/Macros.h	417;"	d
EIGEN_HAS_CONSTEXPR	lib/Eigen/src/Core/util/Macros.h	421;"	d
EIGEN_HAS_CONSTEXPR	lib/Eigen/src/Core/util/Macros.h	425;"	d
EIGEN_HAS_CXX11	lib/Eigen/src/Core/util/Macros.h	360;"	d
EIGEN_HAS_CXX11	lib/Eigen/src/Core/util/Macros.h	362;"	d
EIGEN_HAS_CXX11_CONTAINERS	lib/Eigen/src/Core/util/Macros.h	447;"	d
EIGEN_HAS_CXX11_CONTAINERS	lib/Eigen/src/Core/util/Macros.h	449;"	d
EIGEN_HAS_CXX11_MATH	lib/Eigen/src/Core/util/Macros.h	435;"	d
EIGEN_HAS_CXX11_MATH	lib/Eigen/src/Core/util/Macros.h	437;"	d
EIGEN_HAS_CXX11_NOEXCEPT	lib/Eigen/src/Core/util/Macros.h	460;"	d
EIGEN_HAS_CXX11_NOEXCEPT	lib/Eigen/src/Core/util/Macros.h	462;"	d
EIGEN_HAS_RVALUE_REFERENCES	lib/Eigen/src/Core/util/Macros.h	372;"	d
EIGEN_HAS_RVALUE_REFERENCES	lib/Eigen/src/Core/util/Macros.h	374;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	26;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD	lib/Eigen/src/Core/arch/NEON/PacketMath.h	28;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	28;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	lib/Eigen/src/Core/arch/AVX/PacketMath.h	27;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	27;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	22;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	lib/Eigen/src/Core/arch/NEON/PacketMath.h	24;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	lib/Eigen/src/Core/arch/SSE/PacketMath.h	27;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	24;"	d
EIGEN_HAS_STD_RESULT_OF	lib/Eigen/src/Core/util/Macros.h	393;"	d
EIGEN_HAS_STD_RESULT_OF	lib/Eigen/src/Core/util/Macros.h	395;"	d
EIGEN_HAS_VARIADIC_TEMPLATES	lib/Eigen/src/Core/util/Macros.h	405;"	d
EIGEN_HAS_VARIADIC_TEMPLATES	lib/Eigen/src/Core/util/Macros.h	407;"	d
EIGEN_HESSENBERGDECOMPOSITION_H	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	12;"	d
EIGEN_HOMOGENEOUS_H	lib/Eigen/src/Geometry/Homogeneous.h	11;"	d
EIGEN_HOUSEHOLDER_H	lib/Eigen/src/Householder/Householder.h	12;"	d
EIGEN_HOUSEHOLDER_SEQUENCE_H	lib/Eigen/src/Householder/HouseholderSequence.h	12;"	d
EIGEN_HYPERPLANE_H	lib/Eigen/src/Geometry/Hyperplane.h	12;"	d
EIGEN_IDEAL_MAX_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	662;"	d
EIGEN_IMPLIES	lib/Eigen/src/Core/util/Macros.h	899;"	d
EIGEN_INCLUDE_TYPE_TRAITS	lib/Eigen/src/Core/util/Macros.h	980;"	d
EIGEN_INCOMPLETE_CHOlESKY_H	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	12;"	d
EIGEN_INCOMPLETE_LUT_H	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	12;"	d
EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR	lib/Eigen/src/Core/util/Macros.h	816;"	d
EIGEN_INHERIT_ASSIGNMENT_OPERATORS	lib/Eigen/src/Core/util/Macros.h	839;"	d
EIGEN_INITIALIZE_COEFFS	lib/Eigen/src/Core/PlainObjectBase.h	15;"	d
EIGEN_INITIALIZE_COEFFS	lib/Eigen/src/Core/PlainObjectBase.h	18;"	d
EIGEN_INITIALIZE_COEFFS	lib/Eigen/src/Core/PlainObjectBase.h	21;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	lib/Eigen/src/Core/PlainObjectBase.h	16;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	lib/Eigen/src/Core/PlainObjectBase.h	19;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	lib/Eigen/src/Core/PlainObjectBase.h	22;"	d
EIGEN_INSERT_8f_INTO_16f	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	676;"	d
EIGEN_INSERT_8f_INTO_16f	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	680;"	d
EIGEN_INTERNAL_CHECK_COST_VALUE	lib/Eigen/src/Core/util/StaticAssert.h	213;"	d
EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	lib/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	lib/Eigen/src/Core/DenseStorage.h	16;"	d
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	lib/Eigen/src/Core/DenseStorage.h	18;"	d
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	lib/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT__INVALID_COST_VALUE	lib/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT__INVALID_COST_VALUE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
EIGEN_INVERSE_H	lib/Eigen/src/Core/Inverse.h	11;"	d
EIGEN_INVERSE_IMPL_H	lib/Eigen/src/LU/InverseImpl.h	12;"	d
EIGEN_INVERSE_SSE_H	lib/Eigen/src/LU/arch/Inverse_SSE.h	28;"	d
EIGEN_IO_H	lib/Eigen/src/Core/IO.h	12;"	d
EIGEN_ITERATIVE_SOLVER_BASE_H	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	11;"	d
EIGEN_JACOBISVD_H	lib/Eigen/src/SVD/JacobiSVD.h	12;"	d
EIGEN_JACOBISVD_LAPACKE_H	lib/Eigen/src/SVD/JacobiSVD_LAPACKE.h	34;"	d
EIGEN_JACOBI_H	lib/Eigen/src/Jacobi/Jacobi.h	12;"	d
EIGEN_LAPACKE_EIG_SELFADJ	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h	40;"	d
EIGEN_LAPACKE_LLT	lib/Eigen/src/Cholesky/LLT_LAPACKE.h	42;"	d
EIGEN_LAPACKE_LU_PARTPIV	lib/Eigen/src/LU/PartialPivLU_LAPACKE.h	42;"	d
EIGEN_LAPACKE_QR_COLPIV	lib/Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h	41;"	d
EIGEN_LAPACKE_QR_NOPIV	lib/Eigen/src/QR/HouseholderQR_LAPACKE.h	43;"	d
EIGEN_LAPACKE_SCHUR_COMPLEX	lib/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h	40;"	d
EIGEN_LAPACKE_SCHUR_REAL	lib/Eigen/src/Eigenvalues/RealSchur_LAPACKE.h	40;"	d
EIGEN_LAPACKE_SVD	lib/Eigen/src/SVD/JacobiSVD_LAPACKE.h	40;"	d
EIGEN_LDLT_H	lib/Eigen/src/Cholesky/LDLT.h	14;"	d
EIGEN_LEAST_SQUARE_CONJUGATE_GRADIENT_H	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	11;"	d
EIGEN_LLT_H	lib/Eigen/src/Cholesky/LLT.h	11;"	d
EIGEN_LLT_LAPACKE_H	lib/Eigen/src/Cholesky/LLT_LAPACKE.h	34;"	d
EIGEN_LOGICAL_XOR	lib/Eigen/src/Core/util/Macros.h	897;"	d
EIGEN_LU_H	lib/Eigen/src/LU/FullPivLU.h	11;"	d
EIGEN_LU_STRUCTS	lib/Eigen/src/SparseLU/SparseLU_Structs.h	70;"	d
EIGEN_MACROS_H	lib/Eigen/src/Core/util/Macros.h	12;"	d
EIGEN_MAJOR_VERSION	lib/Eigen/src/Core/util/Macros.h	15;"	d
EIGEN_MAKESTRING	lib/Eigen/src/Core/util/Macros.h	485;"	d
EIGEN_MAKESTRING2	lib/Eigen/src/Core/util/Macros.h	484;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	lib/Eigen/src/Core/util/Memory.h	690;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF	lib/Eigen/src/Core/util/Memory.h	662;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE	lib/Eigen/src/Core/util/Memory.h	691;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW	lib/Eigen/src/Core/util/Memory.h	657;"	d
EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS	lib/Eigen/src/Core/Array.h	279;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	lib/Eigen/src/Core/Array.h	273;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	lib/Eigen/src/Core/Array.h	301;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	lib/Eigen/src/Core/Array.h	285;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	lib/Eigen/src/Core/Array.h	300;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE	lib/Eigen/src/Core/Array.h	303;"	d
EIGEN_MAKE_CWISE_BINARY_OP	lib/Eigen/src/Core/util/Macros.h	912;"	d
EIGEN_MAKE_CWISE_COMP_OP	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	108;"	d
EIGEN_MAKE_CWISE_COMP_OP	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	210;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	126;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	211;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	lib/Eigen/src/Core/Matrix.h	434;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	lib/Eigen/src/Core/Matrix.h	457;"	d
EIGEN_MAKE_IMAGE_HELPERS	lib/Eigen/src/misc/Image.h	67;"	d
EIGEN_MAKE_KERNEL_HELPERS	lib/Eigen/src/misc/Kernel.h	66;"	d
EIGEN_MAKE_SCALAR_BINARY_OP	lib/Eigen/src/Core/util/Macros.h	956;"	d
EIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT	lib/Eigen/src/Core/util/Macros.h	947;"	d
EIGEN_MAKE_SCALAR_BINARY_OP_ONTHERIGHT	lib/Eigen/src/Core/util/Macros.h	938;"	d
EIGEN_MAKE_TYPEDEFS	lib/Eigen/src/Core/Matrix.h	426;"	d
EIGEN_MAKE_TYPEDEFS	lib/Eigen/src/Core/Matrix.h	456;"	d
EIGEN_MAKE_TYPEDEFS	lib/Eigen/src/Geometry/AlignedBox.h	372;"	d
EIGEN_MAKE_TYPEDEFS	lib/Eigen/src/Geometry/AlignedBox.h	388;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	lib/Eigen/src/Core/Matrix.h	440;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	lib/Eigen/src/Core/Matrix.h	455;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	lib/Eigen/src/Geometry/AlignedBox.h	376;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	lib/Eigen/src/Geometry/AlignedBox.h	387;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	lib/Eigen/src/Core/DenseStorage.h	62;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	lib/Eigen/src/Core/DenseStorage.h	69;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	lib/Eigen/src/Core/DenseStorage.h	75;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	lib/Eigen/src/Core/util/Memory.h	55;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	lib/Eigen/src/Core/util/Memory.h	57;"	d
EIGEN_MAPBASE_H	lib/Eigen/src/Core/MapBase.h	12;"	d
EIGEN_MAPPED_SPARSEMATRIX_H	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	11;"	d
EIGEN_MAP_H	lib/Eigen/src/Core/Map.h	12;"	d
EIGEN_MATHFUNCTIONSIMPL_H	lib/Eigen/src/Core/MathFunctionsImpl.h	12;"	d
EIGEN_MATHFUNCTIONS_H	lib/Eigen/src/Core/MathFunctions.h	11;"	d
EIGEN_MATHFUNC_IMPL	lib/Eigen/src/Core/MathFunctions.h	68;"	d
EIGEN_MATHFUNC_RETVAL	lib/Eigen/src/Core/MathFunctions.h	69;"	d
EIGEN_MATH_FUNCTIONS_ALTIVEC_H	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	17;"	d
EIGEN_MATH_FUNCTIONS_ALTIVEC_H	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	17;"	d
EIGEN_MATH_FUNCTIONS_AVX_H	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	11;"	d
EIGEN_MATH_FUNCTIONS_CUDA_H	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	11;"	d
EIGEN_MATH_FUNCTIONS_NEON_H	lib/Eigen/src/Core/arch/NEON/MathFunctions.h	13;"	d
EIGEN_MATH_FUNCTIONS_SSE_H	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	16;"	d
EIGEN_MATRIXBASEEIGENVALUES_H	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	12;"	d
EIGEN_MATRIXBASE_H	lib/Eigen/src/Core/MatrixBase.h	12;"	d
EIGEN_MATRIXSTORAGE_H	lib/Eigen/src/Core/DenseStorage.h	13;"	d
EIGEN_MATRIX_H	lib/Eigen/src/Core/Matrix.h	12;"	d
EIGEN_MAX_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	769;"	d
EIGEN_MAX_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	771;"	d
EIGEN_MAX_CPP_VER	lib/Eigen/src/Core/util/Macros.h	356;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	689;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	691;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	726;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	735;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	736;"	d
EIGEN_MEMBER_FUNCTOR	lib/Eigen/src/Core/VectorwiseOp.h	84;"	d
EIGEN_MEMORY_H	lib/Eigen/src/Core/util/Memory.h	21;"	d
EIGEN_META_H	lib/Eigen/src/Core/util/Meta.h	12;"	d
EIGEN_MINOR_VERSION	lib/Eigen/src/Core/util/Macros.h	16;"	d
EIGEN_MIN_ALIGN_BYTES	lib/Eigen/src/Core/util/Macros.h	675;"	d
EIGEN_MISC_IMAGE_H	lib/Eigen/src/misc/Image.h	11;"	d
EIGEN_MISC_KERNEL_H	lib/Eigen/src/misc/Kernel.h	11;"	d
EIGEN_MKL_DOMAIN_ALL	lib/Eigen/src/Core/util/MKL_support.h	81;"	d
EIGEN_MKL_DOMAIN_ALL	lib/Eigen/src/Core/util/MKL_support.h	83;"	d
EIGEN_MKL_DOMAIN_BLAS	lib/Eigen/src/Core/util/MKL_support.h	87;"	d
EIGEN_MKL_DOMAIN_BLAS	lib/Eigen/src/Core/util/MKL_support.h	89;"	d
EIGEN_MKL_DOMAIN_FFT	lib/Eigen/src/Core/util/MKL_support.h	93;"	d
EIGEN_MKL_DOMAIN_FFT	lib/Eigen/src/Core/util/MKL_support.h	95;"	d
EIGEN_MKL_DOMAIN_PARDISO	lib/Eigen/src/Core/util/MKL_support.h	105;"	d
EIGEN_MKL_DOMAIN_PARDISO	lib/Eigen/src/Core/util/MKL_support.h	107;"	d
EIGEN_MKL_DOMAIN_VML	lib/Eigen/src/Core/util/MKL_support.h	101;"	d
EIGEN_MKL_DOMAIN_VML	lib/Eigen/src/Core/util/MKL_support.h	99;"	d
EIGEN_MKL_SUPPORT_H	lib/Eigen/src/Core/util/MKL_support.h	34;"	d
EIGEN_MKL_VML_DECLARE_POW_CALL	lib/Eigen/src/Core/Assign_MKL.h	140;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL	lib/Eigen/src/Core/Assign_MKL.h	82;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS	lib/Eigen/src/Core/Assign_MKL.h	114;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_CPLX	lib/Eigen/src/Core/Assign_MKL.h	110;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL	lib/Eigen/src/Core/Assign_MKL.h	106;"	d
EIGEN_MKL_VML_THRESHOLD	lib/Eigen/src/Core/util/MKL_support.h	76;"	d
EIGEN_MSVC10_WORKAROUND_BINARYOP_RETURN_TYPE	lib/Eigen/src/Core/util/Macros.h	933;"	d
EIGEN_NESTBYVALUE_H	lib/Eigen/src/Core/NestByValue.h	12;"	d
EIGEN_NOALIAS_H	lib/Eigen/src/Core/NoAlias.h	11;"	d
EIGEN_NOEXCEPT	lib/Eigen/src/Core/util/Macros.h	981;"	d
EIGEN_NOEXCEPT_IF	lib/Eigen/src/Core/Array.h	/^    Array& operator=(Array&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)$/;"	f	class:Eigen::Array
EIGEN_NOEXCEPT_IF	lib/Eigen/src/Core/Array.h	/^    Array(Array&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)$/;"	f	class:Eigen::Array
EIGEN_NOEXCEPT_IF	lib/Eigen/src/Core/Matrix.h	/^    Matrix& operator=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)$/;"	f	class:Eigen::Matrix
EIGEN_NOEXCEPT_IF	lib/Eigen/src/Core/Matrix.h	/^    Matrix(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)$/;"	f	class:Eigen::Matrix
EIGEN_NOEXCEPT_IF	lib/Eigen/src/Core/util/Macros.h	982;"	d
EIGEN_NOT_A_MACRO	lib/Eigen/src/Core/util/Macros.h	327;"	d
EIGEN_NO_DEBUG	lib/Eigen/src/Core/util/Macros.h	533;"	d
EIGEN_NO_THROW	lib/Eigen/src/Core/util/Macros.h	983;"	d
EIGEN_NULLARY_FUNCTORS_H	lib/Eigen/src/Core/functors/NullaryFunctors.h	11;"	d
EIGEN_NUMTRAITS_H	lib/Eigen/src/Core/NumTraits.h	11;"	d
EIGEN_ONLY_USED_FOR_DEBUG	lib/Eigen/src/Core/util/Macros.h	587;"	d
EIGEN_ORDERING_H	lib/Eigen/src/OrderingMethods/Ordering.h	12;"	d
EIGEN_ORTHOMETHODS_H	lib/Eigen/src/Geometry/OrthoMethods.h	12;"	d
EIGEN_OS_ANDROID	lib/Eigen/src/Core/util/Macros.h	234;"	d
EIGEN_OS_ANDROID	lib/Eigen/src/Core/util/Macros.h	236;"	d
EIGEN_OS_BSD	lib/Eigen/src/Core/util/Macros.h	248;"	d
EIGEN_OS_BSD	lib/Eigen/src/Core/util/Macros.h	250;"	d
EIGEN_OS_CYGWIN	lib/Eigen/src/Core/util/Macros.h	290;"	d
EIGEN_OS_CYGWIN	lib/Eigen/src/Core/util/Macros.h	292;"	d
EIGEN_OS_GNULINUX	lib/Eigen/src/Core/util/Macros.h	241;"	d
EIGEN_OS_GNULINUX	lib/Eigen/src/Core/util/Macros.h	243;"	d
EIGEN_OS_LINUX	lib/Eigen/src/Core/util/Macros.h	226;"	d
EIGEN_OS_LINUX	lib/Eigen/src/Core/util/Macros.h	228;"	d
EIGEN_OS_MAC	lib/Eigen/src/Core/util/Macros.h	255;"	d
EIGEN_OS_MAC	lib/Eigen/src/Core/util/Macros.h	257;"	d
EIGEN_OS_QNX	lib/Eigen/src/Core/util/Macros.h	262;"	d
EIGEN_OS_QNX	lib/Eigen/src/Core/util/Macros.h	264;"	d
EIGEN_OS_SOLARIS	lib/Eigen/src/Core/util/Macros.h	311;"	d
EIGEN_OS_SOLARIS	lib/Eigen/src/Core/util/Macros.h	313;"	d
EIGEN_OS_SUN	lib/Eigen/src/Core/util/Macros.h	304;"	d
EIGEN_OS_SUN	lib/Eigen/src/Core/util/Macros.h	306;"	d
EIGEN_OS_UNIX	lib/Eigen/src/Core/util/Macros.h	219;"	d
EIGEN_OS_UNIX	lib/Eigen/src/Core/util/Macros.h	221;"	d
EIGEN_OS_WIN	lib/Eigen/src/Core/util/Macros.h	269;"	d
EIGEN_OS_WIN	lib/Eigen/src/Core/util/Macros.h	271;"	d
EIGEN_OS_WIN64	lib/Eigen/src/Core/util/Macros.h	276;"	d
EIGEN_OS_WIN64	lib/Eigen/src/Core/util/Macros.h	278;"	d
EIGEN_OS_WINCE	lib/Eigen/src/Core/util/Macros.h	283;"	d
EIGEN_OS_WINCE	lib/Eigen/src/Core/util/Macros.h	285;"	d
EIGEN_OS_WIN_STRICT	lib/Eigen/src/Core/util/Macros.h	297;"	d
EIGEN_OS_WIN_STRICT	lib/Eigen/src/Core/util/Macros.h	299;"	d
EIGEN_PACKET_MATH_ALTIVEC_H	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_AVX512_H	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_AVX_H	lib/Eigen/src/Core/arch/AVX/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_CUDA_H	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_HALF_CUDA_H	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	11;"	d
EIGEN_PACKET_MATH_NEON_H	lib/Eigen/src/Core/arch/NEON/PacketMath.h	13;"	d
EIGEN_PACKET_MATH_SSE_H	lib/Eigen/src/Core/arch/SSE/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_ZVECTOR_H	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	11;"	d
EIGEN_PARALLELIZER_H	lib/Eigen/src/Core/products/Parallelizer.h	11;"	d
EIGEN_PARAMETRIZEDLINE_H	lib/Eigen/src/Geometry/ParametrizedLine.h	12;"	d
EIGEN_PARDISOSUPPORT_H	lib/Eigen/src/PardisoSupport/PardisoSupport.h	33;"	d
EIGEN_PARTIALLU_H	lib/Eigen/src/LU/PartialPivLU.h	12;"	d
EIGEN_PARTIALLU_LAPACK_H	lib/Eigen/src/LU/PartialPivLU_LAPACKE.h	34;"	d
EIGEN_PARTIAL_REDUX_H	lib/Eigen/src/Core/VectorwiseOp.h	12;"	d
EIGEN_PASTIXSUPPORT_H	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	11;"	d
EIGEN_PERMISSIVE_EXPR	lib/Eigen/src/Core/util/Macros.h	519;"	d
EIGEN_PERMISSIVE_EXPR	lib/Eigen/src/Core/util/Macros.h	521;"	d
EIGEN_PERMUTATIONMATRIX_H	lib/Eigen/src/Core/PermutationMatrix.h	12;"	d
EIGEN_PI	lib/Eigen/src/Core/MathFunctions.h	15;"	d
EIGEN_PLAIN_ENUM_MAX	lib/Eigen/src/Core/util/Macros.h	873;"	d
EIGEN_PLAIN_ENUM_MIN	lib/Eigen/src/Core/util/Macros.h	872;"	d
EIGEN_PPC_PREFETCH	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	127;"	d
EIGEN_PPC_PREFETCH	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	129;"	d
EIGEN_PP_EXPAND	lib/Eigen/src/Core/Assign_MKL.h	69;"	d
EIGEN_PREDICATE_SAME_MATRIX_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	169;"	d
EIGEN_PRODUCTEVALUATORS_H	lib/Eigen/src/Core/ProductEvaluators.h	14;"	d
EIGEN_PRODUCT_H	lib/Eigen/src/Core/Product.h	11;"	d
EIGEN_QR_H	lib/Eigen/src/QR/HouseholderQR.h	13;"	d
EIGEN_QR_LAPACKE_H	lib/Eigen/src/QR/HouseholderQR_LAPACKE.h	35;"	d
EIGEN_QUATERNION_H	lib/Eigen/src/Geometry/Quaternion.h	12;"	d
EIGEN_RANDOM_H	lib/Eigen/src/Core/Random.h	11;"	d
EIGEN_REALSVD2X2_H	lib/Eigen/src/misc/RealSvd2x2.h	12;"	d
EIGEN_REAL_QZ_H	lib/Eigen/src/Eigenvalues/RealQZ.h	11;"	d
EIGEN_REAL_SCHUR_H	lib/Eigen/src/Eigenvalues/RealSchur.h	12;"	d
EIGEN_REAL_SCHUR_LAPACKE_H	lib/Eigen/src/Eigenvalues/RealSchur_LAPACKE.h	34;"	d
EIGEN_REDUX_H	lib/Eigen/src/Core/Redux.h	12;"	d
EIGEN_REF_H	lib/Eigen/src/Core/Ref.h	11;"	d
EIGEN_REPLICATE_H	lib/Eigen/src/Core/Replicate.h	11;"	d
EIGEN_RESTRICT	lib/Eigen/src/Core/util/Macros.h	791;"	d
EIGEN_RESTRICT	lib/Eigen/src/Core/util/Macros.h	794;"	d
EIGEN_RETURNBYVALUE_H	lib/Eigen/src/Core/ReturnByValue.h	12;"	d
EIGEN_REVERSE_H	lib/Eigen/src/Core/Reverse.h	13;"	d
EIGEN_ROTATION2D_H	lib/Eigen/src/Geometry/Rotation2D.h	11;"	d
EIGEN_ROTATIONBASE_H	lib/Eigen/src/Geometry/RotationBase.h	11;"	d
EIGEN_SAEIGENSOLVER_LAPACKE_H	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h	34;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	lib/Eigen/src/Core/util/Macros.h	320;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	lib/Eigen/src/Core/util/Macros.h	322;"	d
EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE	lib/Eigen/src/Core/util/Macros.h	927;"	d
EIGEN_SCALAR_BINARY_SUPPORTED	lib/Eigen/src/Core/util/Macros.h	920;"	d
EIGEN_SCALING_H	lib/Eigen/src/Geometry/Scaling.h	11;"	d
EIGEN_SELECT_H	lib/Eigen/src/Core/Select.h	11;"	d
EIGEN_SELFADJOINTEIGENSOLVER_H	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	12;"	d
EIGEN_SELFADJOINTMATRIX_H	lib/Eigen/src/Core/SelfAdjointView.h	11;"	d
EIGEN_SELFADJOINTRANK2UPTADE_H	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	11;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_BLAS_H	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	34;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_H	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	11;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_BLAS_H	lib/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	34;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_H	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	11;"	d
EIGEN_SELFADJOINT_PRODUCT_H	lib/Eigen/src/Core/products/SelfadjointProduct.h	11;"	d
EIGEN_SELFCWISEBINARYOP_H	lib/Eigen/src/Core/SelfCwiseBinaryOp.h	11;"	d
EIGEN_SIMPLICIAL_CHOLESKY_H	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	11;"	d
EIGEN_SIMPLICIAL_CHOLESKY_IMPL_H	lib/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	46;"	d
EIGEN_SIZE_MAX	lib/Eigen/src/Core/util/Macros.h	894;"	d
EIGEN_SIZE_MIN_PREFER_DYNAMIC	lib/Eigen/src/Core/util/Macros.h	878;"	d
EIGEN_SIZE_MIN_PREFER_FIXED	lib/Eigen/src/Core/util/Macros.h	886;"	d
EIGEN_SOLVERBASE_H	lib/Eigen/src/Core/SolverBase.h	11;"	d
EIGEN_SOLVETRIANGULAR_H	lib/Eigen/src/Core/SolveTriangular.h	11;"	d
EIGEN_SOLVEWITHGUESS_H	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	11;"	d
EIGEN_SOLVE_H	lib/Eigen/src/Core/Solve.h	11;"	d
EIGEN_SPARSEASSIGN_H	lib/Eigen/src/SparseCore/SparseAssign.h	11;"	d
EIGEN_SPARSEDENSEPRODUCT_H	lib/Eigen/src/SparseCore/SparseDenseProduct.h	11;"	d
EIGEN_SPARSELU_GEMM_KERNEL_H	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	11;"	d
EIGEN_SPARSELU_MEMORY	lib/Eigen/src/SparseLU/SparseLU_Memory.h	32;"	d
EIGEN_SPARSELU_SUPERNODAL_MATRIX_H	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	12;"	d
EIGEN_SPARSELU_UTILS_H	lib/Eigen/src/SparseLU/SparseLU_Utils.h	12;"	d
EIGEN_SPARSEMATRIXBASE_H	lib/Eigen/src/SparseCore/SparseMatrixBase.h	11;"	d
EIGEN_SPARSEMATRIX_H	lib/Eigen/src/SparseCore/SparseMatrix.h	11;"	d
EIGEN_SPARSEPRODUCT_H	lib/Eigen/src/SparseCore/SparseProduct.h	11;"	d
EIGEN_SPARSEREDUX_H	lib/Eigen/src/SparseCore/SparseRedux.h	11;"	d
EIGEN_SPARSESOLVERBASE_H	lib/Eigen/src/SparseCore/SparseSolverBase.h	11;"	d
EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	11;"	d
EIGEN_SPARSETRANSPOSE_H	lib/Eigen/src/SparseCore/SparseTranspose.h	11;"	d
EIGEN_SPARSETRIANGULARSOLVER_H	lib/Eigen/src/SparseCore/TriangularSolver.h	11;"	d
EIGEN_SPARSEUTIL_H	lib/Eigen/src/SparseCore/SparseUtil.h	11;"	d
EIGEN_SPARSEVECTOR_H	lib/Eigen/src/SparseCore/SparseVector.h	11;"	d
EIGEN_SPARSEVIEW_H	lib/Eigen/src/SparseCore/SparseView.h	12;"	d
EIGEN_SPARSE_AMD_H	lib/Eigen/src/OrderingMethods/Amd.h	32;"	d
EIGEN_SPARSE_BLOCK_H	lib/Eigen/src/SparseCore/SparseBlock.h	11;"	d
EIGEN_SPARSE_COMPRESSED_BASE_H	lib/Eigen/src/SparseCore/SparseCompressedBase.h	11;"	d
EIGEN_SPARSE_CWISE_BINARY_OP_H	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	11;"	d
EIGEN_SPARSE_CWISE_UNARY_OP_H	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	11;"	d
EIGEN_SPARSE_DIAGONAL_PRODUCT_H	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	11;"	d
EIGEN_SPARSE_DOT_H	lib/Eigen/src/SparseCore/SparseDot.h	11;"	d
EIGEN_SPARSE_FUZZY_H	lib/Eigen/src/SparseCore/SparseFuzzy.h	11;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR	lib/Eigen/src/SparseCore/SparseUtil.h	21;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS	lib/Eigen/src/SparseCore/SparseUtil.h	39;"	d
EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	lib/Eigen/src/SparseCore/SparseUtil.h	32;"	d
EIGEN_SPARSE_LU_H	lib/Eigen/src/SparseLU/SparseLU.h	13;"	d
EIGEN_SPARSE_MAP_H	lib/Eigen/src/SparseCore/SparseMap.h	11;"	d
EIGEN_SPARSE_PERMUTATION_H	lib/Eigen/src/SparseCore/SparsePermutation.h	11;"	d
EIGEN_SPARSE_PUBLIC_INTERFACE	lib/Eigen/src/SparseCore/SparseUtil.h	43;"	d
EIGEN_SPARSE_QR_H	lib/Eigen/src/SparseQR/SparseQR.h	12;"	d
EIGEN_SPARSE_REF_H	lib/Eigen/src/SparseCore/SparseRef.h	11;"	d
EIGEN_SPARSE_SELFADJOINTVIEW_H	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	11;"	d
EIGEN_SPARSE_TRIANGULARVIEW_H	lib/Eigen/src/SparseCore/SparseTriangularView.h	12;"	d
EIGEN_STABLENORM_H	lib/Eigen/src/Core/StableNorm.h	11;"	d
EIGEN_STACK_ALLOCATION_LIMIT	lib/Eigen/src/Core/util/Macros.h	799;"	d
EIGEN_STATIC_ASSERT	lib/Eigen/src/Core/util/StaticAssert.h	117;"	d
EIGEN_STATIC_ASSERT	lib/Eigen/src/Core/util/StaticAssert.h	32;"	d
EIGEN_STATIC_ASSERT_ARRAYXPR	lib/Eigen/src/Core/util/StaticAssert.h	201;"	d
EIGEN_STATIC_ASSERT_DYNAMIC_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	147;"	d
EIGEN_STATIC_ASSERT_FIXED_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	142;"	d
EIGEN_STATIC_ASSERT_H	lib/Eigen/src/Core/util/StaticAssert.h	12;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	lib/Eigen/src/Core/MapBase.h	14;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	lib/Eigen/src/Core/MapBase.h	295;"	d
EIGEN_STATIC_ASSERT_LVALUE	lib/Eigen/src/Core/util/StaticAssert.h	197;"	d
EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	157;"	d
EIGEN_STATIC_ASSERT_NON_INTEGER	lib/Eigen/src/Core/util/StaticAssert.h	182;"	d
EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	187;"	d
EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	162;"	d
EIGEN_STATIC_ASSERT_SAME_XPR_KIND	lib/Eigen/src/Core/util/StaticAssert.h	205;"	d
EIGEN_STATIC_ASSERT_SIZE_1x1	lib/Eigen/src/Core/util/StaticAssert.h	192;"	d
EIGEN_STATIC_ASSERT_VECTOR_ONLY	lib/Eigen/src/Core/util/StaticAssert.h	137;"	d
EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	152;"	d
EIGEN_STDDEQUE_H	lib/Eigen/src/StlSupport/StdDeque.h	12;"	d
EIGEN_STDLIST_H	lib/Eigen/src/StlSupport/StdList.h	11;"	d
EIGEN_STDVECTOR_H	lib/Eigen/src/StlSupport/StdVector.h	12;"	d
EIGEN_STD_DEQUE_SPECIALIZATION_BODY	lib/Eigen/src/StlSupport/StdDeque.h	52;"	d
EIGEN_STD_LIST_SPECIALIZATION_BODY	lib/Eigen/src/StlSupport/StdList.h	52;"	d
EIGEN_STD_VECTOR_SPECIALIZATION_BODY	lib/Eigen/src/StlSupport/StdVector.h	52;"	d
EIGEN_STL_DETAILS_H	lib/Eigen/src/StlSupport/details.h	12;"	d
EIGEN_STL_FUNCTORS_H	lib/Eigen/src/Core/functors/StlFunctors.h	11;"	d
EIGEN_STRIDE_H	lib/Eigen/src/Core/Stride.h	11;"	d
EIGEN_STRONG_INLINE	lib/Eigen/src/Core/util/Macros.h	491;"	d
EIGEN_STRONG_INLINE	lib/Eigen/src/Core/util/Macros.h	493;"	d
EIGEN_SUITESPARSEQRSUPPORT_H	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	12;"	d
EIGEN_SUPERLUSUPPORT_H	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	11;"	d
EIGEN_SUPERLU_HAS_ILU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	70;"	d
EIGEN_SUPERLU_HAS_ILU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	820;"	d
EIGEN_SVDBASE_H	lib/Eigen/src/SVD/SVDBase.h	17;"	d
EIGEN_SWAP_H	lib/Eigen/src/Core/Swap.h	11;"	d
EIGEN_TERNARY_FUNCTORS_H	lib/Eigen/src/Core/functors/TernaryFunctors.h	11;"	d
EIGEN_THROW	lib/Eigen/src/Core/util/Macros.h	963;"	d
EIGEN_THROW_X	lib/Eigen/src/Core/util/Macros.h	962;"	d
EIGEN_TMP_NOOPT_ATTRIB	lib/Eigen/src/Core/MathFunctions.h	794;"	d
EIGEN_TMP_NOOPT_ATTRIB	lib/Eigen/src/Core/MathFunctions.h	798;"	d
EIGEN_TMP_NOOPT_ATTRIB	lib/Eigen/src/Core/MathFunctions.h	808;"	d
EIGEN_TRANSFORM_H	lib/Eigen/src/Geometry/Transform.h	13;"	d
EIGEN_TRANSLATION_H	lib/Eigen/src/Geometry/Translation.h	11;"	d
EIGEN_TRANSPOSE_H	lib/Eigen/src/Core/Transpose.h	12;"	d
EIGEN_TRANSPOSITIONS_H	lib/Eigen/src/Core/Transpositions.h	11;"	d
EIGEN_TRIANGULARMATRIXVECTOR_H	lib/Eigen/src/Core/products/TriangularMatrixVector.h	11;"	d
EIGEN_TRIANGULARMATRIX_H	lib/Eigen/src/Core/TriangularMatrix.h	12;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_BLAS_H	lib/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	34;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_H	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	11;"	d
EIGEN_TRIANGULAR_MATRIX_VECTOR_BLAS_H	lib/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	34;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_BLAS_H	lib/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	34;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_H	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	11;"	d
EIGEN_TRIANGULAR_SOLVER_VECTOR_H	lib/Eigen/src/Core/products/TriangularSolverVector.h	11;"	d
EIGEN_TRIDIAGONALIZATION_H	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	12;"	d
EIGEN_TRY	lib/Eigen/src/Core/util/Macros.h	964;"	d
EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH	lib/Eigen/src/Core/arch/Default/Settings.h	38;"	d
EIGEN_TYPE_CASTING_AVX_H	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	11;"	d
EIGEN_TYPE_CASTING_CUDA_H	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	11;"	d
EIGEN_TYPE_CASTING_SSE_H	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	11;"	d
EIGEN_UMEYAMA_H	lib/Eigen/src/Geometry/Umeyama.h	11;"	d
EIGEN_UMFPACKSUPPORT_H	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	11;"	d
EIGEN_UNALIGNED_VECTORIZE	lib/Eigen/src/Core/util/Macros.h	784;"	d
EIGEN_UNARY_FUNCTORS_H	lib/Eigen/src/Core/functors/UnaryFunctors.h	11;"	d
EIGEN_UNROLLING_LIMIT	lib/Eigen/src/Core/arch/Default/Settings.h	24;"	d
EIGEN_UNUSED	lib/Eigen/src/Core/util/Macros.h	605;"	d
EIGEN_UNUSED_VARIABLE	lib/Eigen/src/Core/util/Macros.h	616;"	d
EIGEN_USE_BLAS	lib/Eigen/src/Core/util/MKL_support.h	38;"	d
EIGEN_USE_LAPACKE	lib/Eigen/src/Core/util/MKL_support.h	41;"	d
EIGEN_USE_LAPACKE	lib/Eigen/src/Core/util/MKL_support.h	49;"	d
EIGEN_USE_LAPACKE	lib/Eigen/src/Core/util/MKL_support.h	67;"	d
EIGEN_USE_LAPACKE	lib/Eigen/src/Core/util/MKL_support.h	70;"	d
EIGEN_USE_LAPACKE_STRICT	lib/Eigen/src/Core/util/MKL_support.h	69;"	d
EIGEN_USE_MKL	lib/Eigen/src/Core/util/MKL_support.h	53;"	d
EIGEN_USE_MKL	lib/Eigen/src/Core/util/MKL_support.h	60;"	d
EIGEN_USE_MKL	lib/Eigen/src/Core/util/MKL_support.h	62;"	d
EIGEN_USE_MKL_ALL	lib/Eigen/src/Core/util/MKL_support.h	66;"	d
EIGEN_USE_MKL_VML	lib/Eigen/src/Core/util/MKL_support.h	44;"	d
EIGEN_USE_MKL_VML	lib/Eigen/src/Core/util/MKL_support.h	68;"	d
EIGEN_USE_STD_FPCLASSIFY	lib/Eigen/src/Core/MathFunctions.h	708;"	d
EIGEN_USE_STD_FPCLASSIFY	lib/Eigen/src/Core/MathFunctions.h	710;"	d
EIGEN_USING_ARRAY_TYPEDEFS	lib/Eigen/src/Core/Array.h	316;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE	lib/Eigen/src/Core/Array.h	310;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE	lib/Eigen/src/Core/Array.h	305;"	d
EIGEN_VECTORBLOCK_H	lib/Eigen/src/Core/VectorBlock.h	12;"	d
EIGEN_VERSION_AT_LEAST	lib/Eigen/src/Core/util/Macros.h	18;"	d
EIGEN_VISITOR_H	lib/Eigen/src/Core/Visitor.h	11;"	d
EIGEN_VMLMODE_EXPAND_LA	lib/Eigen/src/Core/Assign_MKL.h	71;"	d
EIGEN_VMLMODE_EXPAND_LA	lib/Eigen/src/Core/Assign_MKL.h	73;"	d
EIGEN_VMLMODE_EXPAND__	lib/Eigen/src/Core/Assign_MKL.h	76;"	d
EIGEN_VMLMODE_PREFIX	lib/Eigen/src/Core/Assign_MKL.h	80;"	d
EIGEN_VMLMODE_PREFIX_LA	lib/Eigen/src/Core/Assign_MKL.h	78;"	d
EIGEN_VMLMODE_PREFIX__	lib/Eigen/src/Core/Assign_MKL.h	79;"	d
EIGEN_WARNINGS_DISABLED	lib/Eigen/src/Core/util/DisableStupidWarnings.h	2;"	d
EIGEN_WARNINGS_DISABLED	lib/Eigen/src/Core/util/ReenableStupidWarnings.h	2;"	d
EIGEN_WORKAROUND_MSVC_STL_SUPPORT	lib/Eigen/src/StlSupport/details.h	54;"	d
EIGEN_WORLD_VERSION	lib/Eigen/src/Core/util/Macros.h	14;"	d
EIGEN_XPRHELPER_H	lib/Eigen/src/Core/util/XprHelper.h	12;"	d
EIGEN_ZVECTOR_PREFETCH	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	129;"	d
EIGEN_ZVECTOR_PREFETCH	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	131;"	d
END_HADRONS_NAMESPACE	extras/Hadrons/Global.hpp	43;"	d
END_HADRONS_NAMESPACE	lib/Hadrons/Global.hpp	43;"	d
END_MODULE_NAMESPACE	extras/Hadrons/Global.hpp	48;"	d
END_MODULE_NAMESPACE	lib/Hadrons/Global.hpp	48;"	d
END_QEDFVOL_NAMESPACE	extras/qed-fvol/Global.hpp	11;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	110;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	137;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	160;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	183;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	215;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	236;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	257;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	286;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	307;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	328;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	369;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	377;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	398;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	419;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	444;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	465;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	486;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	516;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	537;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	558;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	585;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	606;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	627;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	63;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	86;"	d
EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	48;"	d
E_diag	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	/^    E_diag = 1,$/;"	e	enum:__anon4
E_diag	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	/^    E_diag = 1,$/;"	e	enum:__anon687
Edge	extras/Hadrons/Graph.hpp	/^    typedef std::pair<T, T> Edge;$/;"	t	class:Graph
Edge	lib/Hadrons/Graph.hpp	/^    typedef std::pair<T, T> Edge;$/;"	t	class:Graph
EigVecMask	lib/Eigen/src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
Eigen	lib/Eigen/src/Cholesky/LDLT.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Cholesky/LLT.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Cholesky/LLT_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Array.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/ArrayBase.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/ArrayWrapper.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Assign.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/AssignEvaluator.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Assign_MKL.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/BandMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Block.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/BooleanRedux.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/CommaInitializer.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/ConditionEstimator.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/CoreEvaluators.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/CoreIterators.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/CwiseBinaryOp.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/CwiseNullaryOp.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/CwiseTernaryOp.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/CwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/CwiseUnaryView.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/DenseBase.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/DenseCoeffsBase.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/DenseStorage.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Diagonal.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/DiagonalMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/DiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Dot.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/EigenBase.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/ForceAlignedAccess.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Fuzzy.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/GeneralProduct.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/GenericPacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/GlobalFunctions.h	/^namespace Eigen$/;"	n
Eigen	lib/Eigen/src/Core/IO.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Inverse.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Map.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/MapBase.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/MathFunctionsImpl.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Matrix.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/MatrixBase.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/NestByValue.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/NoAlias.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/NumTraits.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/PermutationMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/PlainObjectBase.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Product.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/ProductEvaluators.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Random.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Redux.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Ref.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Replicate.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/ReturnByValue.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Reverse.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Select.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/SelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Solve.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/SolveTriangular.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/SolverBase.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/StableNorm.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Stride.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Swap.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Transpose.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/Transpositions.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/TriangularMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/VectorwiseOp.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/Visitor.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/arch/AVX/Complex.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/CUDA/Half.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/NEON/Complex.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/NEON/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/SSE/Complex.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/functors/StlFunctors.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/functors/TernaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/Parallelizer.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/BlasUtil.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/Constants.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/MKL_support.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/Macros.h	/^    namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/Macros.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/Memory.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/Meta.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/StaticAssert.h	/^    namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Core/util/XprHelper.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/RealQZ.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Eigenvalues/RealSchur.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/RealSchur_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/EulerAngles.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Homogeneous.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/OrthoMethods.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/Umeyama.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Householder/BlockHouseholder.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Householder/Householder.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/Householder/HouseholderSequence.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^namespace Eigen {  $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/Jacobi/Jacobi.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/LU/Determinant.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/LU/FullPivLU.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/LU/InverseImpl.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/LU/PartialPivLU.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/LU/PartialPivLU_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/MetisSupport/MetisSupport.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/OrderingMethods/Amd.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/OrderingMethods/Ordering.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/QR/HouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/QR/HouseholderQR_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SVD/BDCSVD.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SVD/JacobiSVD.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SVD/JacobiSVD_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SVD/SVDBase.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/AmbiVector.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/CompressedStorage.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseAssign.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseBlock.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseColEtree.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseDot.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseFuzzy.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseMap.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparsePermutation.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseRedux.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseRef.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseTranspose.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseUtil.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseVector.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/SparseView.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseCore/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_Utils.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_column_bmod.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_pivotL.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_pruneL.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseLU/SparseLU_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SparseQR/SparseQR.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/StlSupport/details.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace Eigen {$/;"	n
Eigen	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/misc/Image.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/misc/Kernel.h	/^namespace Eigen { $/;"	n
Eigen	lib/Eigen/src/misc/RealSvd2x2.h	/^namespace Eigen {$/;"	n
EigenBase	lib/Eigen/src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
EigenBase2EigenBase	lib/Eigen/src/Core/AssignEvaluator.h	/^struct EigenBase2EigenBase {};$/;"	s	namespace:Eigen::internal
EigenSolver	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver
EigenSolver	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    explicit EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver
EigenSolver	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    explicit EigenSolver(const EigenBase<InputType>& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver
EigenSolver	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	lib/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase
EigenvalueType	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvalueType	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver
EigenvalueType	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef CwiseBinaryOp<internal::scalar_quotient_op<ComplexScalar,Scalar>,ComplexVectorType,VectorType> EigenvalueType;$/;"	t	class:Eigen::GeneralizedEigenSolver
EigenvalueType	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealQZ
EigenvalueType	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur
EigenvaluesOnly	lib/Eigen/src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
EigenvaluesReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase
EigenvaluesReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase
EigenvaluesReturnType	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView
EigenvectorType	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvectorsType	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver
EigenvectorsType	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::GeneralizedEigenSolver
EigenvectorsType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Matrix<Scalar,Size,Size,ColMajor,MaxColsAtCompileTime,MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
EigenvectorsType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::EigenvectorsType EigenvectorsType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Elapsed	lib/perfmon/Timer.h	/^  GridTime Elapsed(void) {$/;"	f	class:Grid::GridStopWatch
Element	lib/serialisation/BaseIO.h	/^    typedef typename element<V>::type Element;$/;"	t	class:Grid::Flatten
Element	lib/serialisation/BaseIO.h	/^    typedef typename element<V>::type Element;$/;"	t	class:Grid::Reconstruct
ElseMatrixNested	lib/Eigen/src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits
EmComp	extras/Hadrons/Modules/MGauge/StochEm.hpp	/^    typedef PhotonR::GaugeLinkField EmComp;$/;"	t	class:TStochEm
EmComp	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    typedef PhotonR::GaugeLinkField EmComp;$/;"	t	class:TChargedProp
EmComp	extras/qed-fvol/qed-fvol.cc	/^typedef PhotonR::GaugeLinkField         EmComp;$/;"	t	file:
EmComp	lib/Hadrons/Modules/MGauge/StochEm.hpp	/^    typedef PhotonR::GaugeLinkField EmComp;$/;"	t	class:TStochEm
EmComp	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    typedef PhotonR::GaugeLinkField EmComp;$/;"	t	class:TChargedProp
EmField	extras/Hadrons/Modules/MGauge/StochEm.hpp	/^    typedef PhotonR::GaugeField     EmField;$/;"	t	class:TStochEm
EmField	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    typedef PhotonR::GaugeField     EmField;$/;"	t	class:TChargedProp
EmField	extras/qed-fvol/qed-fvol.cc	/^typedef PhotonR::GaugeField             EmField;$/;"	t	file:
EmField	lib/Hadrons/Modules/MGauge/StochEm.hpp	/^    typedef PhotonR::GaugeField     EmField;$/;"	t	class:TStochEm
EmField	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    typedef PhotonR::GaugeField     EmField;$/;"	t	class:TChargedProp
EmptyRep	lib/qcd/representations/fundamental.h	/^    explicit EmptyRep(GridBase* grid) {} \/\/do nothing$/;"	f	class:Grid::QCD::EmptyRep
EmptyRep	lib/qcd/representations/fundamental.h	/^  class EmptyRep {$/;"	c	namespace:Grid::QCD
EnableCoeff	lib/Eigen/src/Core/Product.h	/^      EnableCoeff = IsOneByOne || Option==LazyProduct$/;"	e	enum:Eigen::ProductImpl::__anon127
EnableVml	lib/Eigen/src/Core/Assign_MKL.h	/^      EnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon154
Eng	tests/testu01/Test_smallcrush.cc	/^  static RngEngine Eng;$/;"	m	struct:TestRNG	file:
Eng	tests/testu01/Test_smallcrush.cc	/^RngEngine        TestRNG::Eng;$/;"	m	class:TestRNG	file:
EngineMT	tests/testu01/Test_smallcrush.cc	/^std::vector<std::mt19937>       EngineMT;$/;"	v
EngineRanlux	tests/testu01/Test_smallcrush.cc	/^std::vector<std::ranlux48>      EngineRanlux;$/;"	v
EngineSitmo	tests/testu01/Test_smallcrush.cc	/^std::vector<sitmo::prng_engine> EngineSitmo;$/;"	v
Entries	lib/allocator/AlignedAllocator.cc	/^PointerCache::PointerCacheEntry PointerCache::Entries[PointerCache::Ncache];$/;"	m	class:Grid::PointerCache	file:
Entries	lib/allocator/AlignedAllocator.h	/^    static PointerCacheEntry Entries[Ncache];$/;"	m	class:Grid::PointerCache
Environment	extras/Hadrons/Environment.cc	/^Environment::Environment(void)$/;"	f	class:Environment
Environment	extras/Hadrons/Environment.hpp	/^class Environment$/;"	c
Environment	lib/Hadrons/Environment.cc	/^Environment::Environment(void)$/;"	f	class:Environment
Environment	lib/Hadrons/Environment.hpp	/^class Environment$/;"	c
ErfReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_erf_op<Scalar>, const Derived> ErfReturnType;$/;"	t
ErfcReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_erfc_op<Scalar>, const Derived> ErfcReturnType;$/;"	t
ErrorOnNoConverge	lib/algorithms/iterative/BlockConjugateGradient.h	/^  bool ErrorOnNoConverge;  \/\/ throw an assert when the CG fails to converge.$/;"	m	class:Grid::BlockConjugateGradient
ErrorOnNoConverge	lib/algorithms/iterative/ConjugateGradient.h	/^  bool ErrorOnNoConverge;  \/\/ throw an assert when the CG fails to converge.$/;"	m	class:Grid::ConjugateGradient
EssentialVectorType	lib/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::EssentialVectorType EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence
EssentialVectorType	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EssentialVectorType	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EvalBeforeAssigningBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4; \/\/ FIXME deprecated$/;"	m	namespace:Eigen
EvalBeforeNestingBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
EvalIterator	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename evaluator<ArgType>::InnerIterator EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename evaluator<ArgType>::InnerIterator        EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename evaluator<ArgType>::InnerIterator        EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef typename evaluator<ArgType>::InnerIterator EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	lib/Eigen/src/SparseCore/SparseView.h	/^    typedef typename evaluator<ArgType>::InnerIterator EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase
EvalToRowMajor	lib/Eigen/src/Core/ProductEvaluators.h	/^    EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
EvalToTemp	lib/Eigen/src/Core/CoreEvaluators.h	/^  explicit EvalToTemp(const ArgType& arg)$/;"	f	class:Eigen::internal::EvalToTemp
EvalToTemp	lib/Eigen/src/Core/CoreEvaluators.h	/^class EvalToTemp$/;"	c	namespace:Eigen::internal
EvaluatorFlags	lib/Eigen/src/Core/Matrix.h	/^    EvaluatorFlags = LinearAccessBit | DirectAccessBit | packet_access_bit | row_major_bit,$/;"	e	enum:Eigen::internal::traits::__anon172
EvaluatorType	lib/Eigen/src/Core/CoreIterators.h	/^  typedef evaluator<XprType> EvaluatorType;$/;"	t	class:Eigen::internal::inner_iterator_selector
EvaluatorType	lib/Eigen/src/Core/CoreIterators.h	/^  typedef internal::evaluator<XprType> EvaluatorType;$/;"	t	class:Eigen::InnerIterator
Even	lib/cartesian/Cartesian_red_black.h	/^  static const int Even   =CbRed;$/;"	m	namespace:Grid
Event	lib/communicator/Communicator_mpi3_leader.cc	/^int Slave::Event (void) {$/;"	f	class:Grid::Slave
EventLoop	lib/communicator/Communicator_mpi3_leader.cc	/^  void EventLoop (void) {$/;"	f	class:Grid::Slave
Exchange	lib/qcd/action/fermion/WilsonCompressor.h	/^  inline void Exchange(SiteHalfSpinor *mp,$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
Exchange	lib/simd/Grid_avx.h	/^  struct Exchange{$/;"	s	namespace:Grid::Optimization
Exchange	lib/simd/Grid_avx512.h	/^  struct Exchange{$/;"	s	namespace:Grid::Optimization
Exchange	lib/simd/Grid_generic.h	/^  struct Exchange{$/;"	s	namespace:Grid::Optimization
Exchange	lib/simd/Grid_neon.h	/^  struct Exchange{$/;"	s	namespace:Grid::Optimization
Exchange	lib/simd/Grid_qpx.h	/^  struct Exchange{$/;"	s	namespace:Grid::Optimization
Exchange	lib/simd/Grid_sse4.h	/^  struct Exchange{$/;"	s	namespace:Grid::Optimization
Exchange	lib/stencil/SimpleCompressor.h	/^  inline void Exchange(vobj *mp,vobj *vp0,vobj *vp1,Integer type,Integer o){$/;"	f	class:Grid::SimpleCompressor
Exchange0	lib/simd/Grid_avx.h	/^    static inline void Exchange0(__m256 &out1,__m256 &out2,__m256 in1,__m256 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_avx.h	/^    static inline void Exchange0(__m256d &out1,__m256d &out2,__m256d in1,__m256d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_avx512.h	/^    static inline void Exchange0(__m512 &out1,__m512 &out2,__m512 in1,__m512 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_avx512.h	/^    static inline void Exchange0(__m512d &out1,__m512d &out2,__m512d in1,__m512d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_generic.h	/^    static inline void Exchange0(vec<T> &out1,vec<T> &out2,vec<T> &in1,vec<T> &in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_neon.h	/^    static inline void Exchange0(float32x4_t &out1,float32x4_t &out2,float32x4_t in1,float32x4_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_neon.h	/^    static inline void Exchange0(float64x2_t &out1,float64x2_t &out2,float64x2_t in1,float64x2_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_qpx.h	/^    static inline void Exchange0(vector4double &out1, vector4double &out2,$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_sse4.h	/^    static inline void Exchange0(__m128 &out1,__m128 &out2,__m128 in1,__m128 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange0	lib/simd/Grid_sse4.h	/^    static inline void Exchange0(__m128d &out1,__m128d &out2,__m128d in1,__m128d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_avx.h	/^    static inline void Exchange1(__m256 &out1,__m256 &out2,__m256 in1,__m256 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_avx.h	/^    static inline void Exchange1(__m256d &out1,__m256d &out2,__m256d in1,__m256d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_avx512.h	/^    static inline void Exchange1(__m512 &out1,__m512 &out2,__m512 in1,__m512 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_avx512.h	/^    static inline void Exchange1(__m512d &out1,__m512d &out2,__m512d in1,__m512d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_generic.h	/^    static inline void Exchange1(vec<T> &out1,vec<T> &out2,vec<T> &in1,vec<T> &in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_neon.h	/^    static inline void Exchange1(float32x4_t &out1,float32x4_t &out2,float32x4_t in1,float32x4_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_neon.h	/^    static inline void Exchange1(float64x2_t &out1,float64x2_t &out2,float64x2_t in1,float64x2_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_qpx.h	/^    static inline void Exchange1(vector4double &out1, vector4double &out2,$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_sse4.h	/^    static inline void Exchange1(__m128 &out1,__m128 &out2,__m128 in1,__m128 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange1	lib/simd/Grid_sse4.h	/^    static inline void Exchange1(__m128d &out1,__m128d &out2,__m128d in1,__m128d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_avx.h	/^    static inline void Exchange2(__m256 &out1,__m256 &out2,__m256 in1,__m256 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_avx.h	/^    static inline void Exchange2(__m256d &out1,__m256d &out2,__m256d in1,__m256d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_avx512.h	/^    static inline void Exchange2(__m512 &out1,__m512 &out2,__m512 in1,__m512 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_avx512.h	/^    static inline void Exchange2(__m512d &out1,__m512d &out2,__m512d in1,__m512d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_generic.h	/^    static inline void Exchange2(vec<T> &out1,vec<T> &out2,vec<T> &in1,vec<T> &in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_neon.h	/^    static inline void Exchange2(float32x4_t &out1,float32x4_t &out2,float32x4_t in1,float32x4_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_neon.h	/^    static inline void Exchange2(float64x2_t &out1,float64x2_t &out2,float64x2_t in1,float64x2_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_qpx.h	/^    static inline void Exchange2(vector4double &out1, vector4double &out2,$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_sse4.h	/^    static inline void Exchange2(__m128 &out1,__m128 &out2,__m128 in1,__m128 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange2	lib/simd/Grid_sse4.h	/^    static inline void Exchange2(__m128d &out1,__m128d &out2,__m128d in1,__m128d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_avx.h	/^    static inline void Exchange3(__m256 &out1,__m256 &out2,__m256 in1,__m256 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_avx.h	/^    static inline void Exchange3(__m256d &out1,__m256d &out2,__m256d in1,__m256d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_avx512.h	/^    static inline void Exchange3(__m512 &out1,__m512 &out2,__m512 in1,__m512 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_avx512.h	/^    static inline void Exchange3(__m512d &out1,__m512d &out2,__m512d in1,__m512d in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_generic.h	/^    static inline void Exchange3(vec<T> &out1,vec<T> &out2,vec<T> &in1,vec<T> &in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_neon.h	/^    static inline void Exchange3(float32x4_t &out1,float32x4_t &out2,float32x4_t in1,float32x4_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_neon.h	/^    static inline void Exchange3(float64x2_t &out1,float64x2_t &out2,float64x2_t in1,float64x2_t in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_qpx.h	/^    static inline void Exchange3(vector4double &out1, vector4double &out2,$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_sse4.h	/^    static inline void Exchange3(__m128 &out1,__m128 &out2,__m128 in1,__m128 in2){$/;"	f	struct:Grid::Optimization::Exchange
Exchange3	lib/simd/Grid_sse4.h	/^    static inline void Exchange3(__m128d &out1,__m128d &out2,__m128d in1,__m128d in2){$/;"	f	struct:Grid::Optimization::Exchange
ExchangeN	lib/simd/Grid_generic.h	/^    static inline void ExchangeN(vec<T> &out1,vec<T> &out2,vec<T> &in1,vec<T> &in2){$/;"	f	struct:Grid::Optimization::Exchange
ExchangeTester	tests/Test_simd.cc	/^void ExchangeTester(const functor &func)$/;"	f
ExpFunctor	lib/simd/Grid_vector_unops.h	/^struct ExpFunctor {$/;"	s	namespace:Grid
ExpReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_exp_op<Scalar>, const Derived> ExpReturnType;$/;"	t
ExpandMem	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  enum { ExpandMem = true };$/;"	e	enum:Eigen::internal::column_dfs_traits::__anon657
ExpandMem	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  enum { ExpandMem = false };$/;"	e	enum:Eigen::internal::panel_dfs_traits::__anon661
ExpiAlphaDmuAmu	lib/qcd/utils/GaugeFix.h	/^  static void ExpiAlphaDmuAmu(const std::vector<GaugeMat> &A,GaugeMat &g,Real & alpha, GaugeMat &dmuAmu) {$/;"	f	class:FourierAcceleratedGaugeFixer
Exponentiate	lib/tensors/Tensor_exp.h	/^    inline iMatrix<vtype,3> Exponentiate(const iMatrix<vtype,3> &arg, RealD alpha  , Integer Nexp = DEFAULT_MAT_EXP )$/;"	f	namespace:Grid
Exponentiate	lib/tensors/Tensor_exp.h	/^    inline iMatrix<vtype,N> Exponentiate(const iMatrix<vtype,N> &arg, RealD alpha  , Integer Nexp = DEFAULT_MAT_EXP )$/;"	f	namespace:Grid
Exponentiate	lib/tensors/Tensor_exp.h	/^  template<class vtype> inline iScalar<vtype> Exponentiate(const iScalar<vtype>&r, RealD alpha ,  Integer Nexp = DEFAULT_MAT_EXP)$/;"	f	namespace:Grid
Exponentiate	lib/tensors/Tensor_exp.h	/^template<class vtype, int N> inline iVector<vtype, N> Exponentiate(const iVector<vtype,N>&r, RealD alpha ,  Integer Nexp = DEFAULT_MAT_EXP)$/;"	f	namespace:Grid
ExportFermion	tests/qdpxx/Test_qdpxx_munprec.cc	/^  static void ExportFermion(Grid::QCD::LatticeFermion & gr,$/;"	f	class:Chroma::ChromaWrapper
ExportFermion	tests/qdpxx/Test_qdpxx_stag.cc	/^  static void ExportFermion(FermionField & gr,$/;"	f	class:Chroma::ChromaWrapper
ExportGauge	tests/qdpxx/Test_qdpxx_stag.cc	/^  static void ExportGauge(GaugeField & gr,$/;"	f	class:Chroma::ChromaWrapper
ExpressionTraits	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef traits<ExpressionType> ExpressionTraits;$/;"	t	struct:Eigen::internal::evaluator_base
ExpressionType	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionTypeNested	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::ref_selector<ExpressionType>::non_const_type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp
ExpressionTypeNestedCleaned	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp
ExtendedType	lib/Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp
ExtractSlice	lib/lattice/Lattice_transfer.h	/^void ExtractSlice(Lattice<vobj> &lowDim,const Lattice<vobj> & higherDim,int slice, int orthog)$/;"	f	namespace:Grid
ExtractSliceLocal	lib/lattice/Lattice_transfer.h	/^void ExtractSliceLocal(Lattice<vobj> &lowDim, Lattice<vobj> & higherDim,int slice_lo,int slice_hi, int orthog)$/;"	f	namespace:Grid
ExtractType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
F	lib/algorithms/approx/Zolotarev.cc	/^static INTERNAL_PRECISION U, F, K;	\/* THREAD LOCAL *\/$/;"	m	namespace:Grid::Approx	file:
FERMIONOPERATOR_MODULES_H	lib/qcd/modules/FermionOperatorModules.h	30;"	d
FERM_TYPE_ALIASES	extras/Hadrons/Global.hpp	64;"	d
FERM_TYPE_ALIASES	lib/Hadrons/Global.hpp	64;"	d
FEenableexcept	tests/debug/Test_synthetic_lanczos.cc	/^FEenableexcept (unsigned int excepts)$/;"	f	file:
FFT	lib/algorithms/FFT.h	/^    FFT ( GridCartesian * grid ) :$/;"	f	class:Grid::FFT
FFT	lib/algorithms/FFT.h	/^  class FFT {$/;"	c	namespace:Grid
FFTW	lib/algorithms/FFT.h	/^  template<> struct FFTW<ComplexD> {$/;"	s	namespace:Grid
FFTW	lib/algorithms/FFT.h	/^  template<> struct FFTW<ComplexF> {$/;"	s	namespace:Grid
FFTW	lib/algorithms/FFT.h	/^  template<class scalar> struct FFTW { };$/;"	s	namespace:Grid
FFTW_BACKWARD	lib/algorithms/FFT.h	104;"	d
FFTW_FORWARD	lib/algorithms/FFT.h	103;"	d
FFTW_plan	lib/algorithms/FFT.h	/^    typedef fftw_plan    FFTW_plan;$/;"	t	struct:Grid::FFTW
FFTW_plan	lib/algorithms/FFT.h	/^    typedef fftwf_plan    FFTW_plan;$/;"	t	struct:Grid::FFTW
FFTW_scalar	lib/algorithms/FFT.h	/^    typedef fftw_complex FFTW_scalar;$/;"	t	struct:Grid::FFTW
FFTW_scalar	lib/algorithms/FFT.h	/^    typedef fftwf_complex FFTW_scalar;$/;"	t	struct:Grid::FFTW
FFT_all_dim	lib/algorithms/FFT.h	/^    void FFT_all_dim(Lattice<vobj> &result,const Lattice<vobj> &source,int sign){$/;"	f	class:Grid::FFT
FFT_dim	lib/algorithms/FFT.h	/^    void FFT_dim(Lattice<vobj> &result,const Lattice<vobj> &source,int dim, int sign){$/;"	f	class:Grid::FFT
FFT_dim_mask	lib/algorithms/FFT.h	/^    void FFT_dim_mask(Lattice<vobj> &result,const Lattice<vobj> &source,std::vector<int> mask,int sign){$/;"	f	class:Grid::FFT
FGS_TYPE_ALIASES	extras/Hadrons/Global.hpp	86;"	d
FGS_TYPE_ALIASES	lib/Hadrons/Global.hpp	86;"	d
FG_update_P	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  void FG_update_P(Field& U, int level, double fg_dt, double ep) {$/;"	f	class:Grid::QCD::ForceGradient
FIMPL	extras/Hadrons/Global.hpp	55;"	d
FIMPL	lib/Hadrons/Global.hpp	55;"	d
FLGT	lib/qcd/LatticeTheories.h	/^    typedef FermionicLatticeGaugeTheory FLGT;$/;"	t	struct:Grid::LatticeTheories::QCD
FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	lib/Eigen/src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
FLOAT_WRAP_1	lib/simd/Grid_qpx.h	220;"	d
FLOAT_WRAP_2	lib/simd/Grid_qpx.h	206;"	d
FLOAT_WRAP_3	lib/simd/Grid_qpx.h	191;"	d
FLOAT_WRAP_EXCHANGE	lib/simd/Grid_qpx.h	415;"	d
FOPtr	lib/qcd/modules/FermionOperatorModules.h	/^  std::unique_ptr< FOType<FermionImpl> > FOPtr;$/;"	m	class:Grid::FermionOperatorModule
FORCE_COMMS	lib/communicator/Communicator_mpi3.cc	74;"	d	file:
FOUR	lib/algorithms/approx/Zolotarev.cc	49;"	d	file:
FP32	lib/Eigen/src/Core/arch/CUDA/Half.h	/^union FP32 {$/;"	u	namespace:Eigen::half_impl
FP32	lib/simd/Grid_sse4.h	/^  union FP32 {$/;"	u	namespace:Grid::Optimization
FREEMOMPROP	extras/Hadrons/Modules/MScalar/Scalar.hpp	4;"	d
FREEMOMPROP	lib/Hadrons/Modules/MScalar/Scalar.hpp	4;"	d
FUNDAMENTAL_H	lib/qcd/representations/fundamental.h	7;"	d
Factor	lib/Eigen/src/Core/CoreEvaluators.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::unary_evaluator::__anon240
FactorType	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> FactorType;$/;"	t	class:Eigen::IncompleteCholesky
FactorType	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor,StorageIndex> FactorType;$/;"	t	class:Eigen::IncompleteLUT
Factory	extras/Hadrons/Factory.hpp	/^class Factory$/;"	c
Factory	lib/Hadrons/Factory.hpp	/^class Factory$/;"	c
Factory	lib/qcd/modules/Factory.h	/^class Factory$/;"	c	namespace:Grid
Factory_hpp_	lib/qcd/modules/Factory.h	27;"	d
FermBase	lib/qcd/modules/FermionOperatorModules.h	/^  typedef FermionOperatorModule<DomainWallFermion, FermionImpl, DomainWallFermionParameters> FermBase;$/;"	t	class:Grid::QCD::DomainWallFermionModule
FermBase	lib/qcd/modules/FermionOperatorModules.h	/^  typedef FermionOperatorModule<MobiusFermion, FermionImpl, MobiusFermionParameters> FermBase;$/;"	t	class:Grid::QCD::MobiusFermionModule
FermBase	lib/qcd/modules/FermionOperatorModules.h	/^  typedef FermionOperatorModule<WilsonFermion, FermionImpl, WilsonFermionParameters> FermBase;$/;"	t	class:Grid::QCD::WilsonFermionModule
FermOp	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  FermionOperator<Impl> &FermOp;  \/\/ the basic operator$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
FermOp	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      FermionOperator<Impl> & FermOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
FermOp	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  FermionOperator<Impl> &FermOp;  \/\/ the basic operator$/;"	m	class:Grid::QCD::TwoFlavourPseudoFermionAction
FermOp	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      FermionOperator<Impl> &FermOp;  \/\/ the basic operator$/;"	m	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
FermOp4dVecTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	52;"	d
FermOp5dVecTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	75;"	d
FermOpStaggeredTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	44;"	d
FermOpStaggeredVec5dTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	48;"	d
FermOpTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	85;"	d
FermToProp	lib/qcd/QCD.h	/^    void FermToProp(Prop &p, const Ferm &f, const int s, const int c)$/;"	f	namespace:Grid::QCD
FermionField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SiteSpinor>            FermionField;$/;"	t	class:Grid::QCD::StaggeredImpl
FermionField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SiteSpinor>            FermionField;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
FermionField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SiteSpinor>            FermionField;$/;"	t	class:Grid::QCD::WilsonImpl
FermionField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef Lattice<SiteSpinor>          FermionField;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
FermionField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef Lattice<SiteSpinor> FermionField;$/;"	t	class:Grid::QCD::GparityWilsonImpl
FermionField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Field                FermionField;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
FermionField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Field              FermionField;$/;"	t	class:Grid::ScalarImplTypes
FermionField	tests/core/Test_gparity.cc	/^typedef typename GparityDomainWallFermionR::FermionField FermionField;$/;"	t	file:
FermionField	tests/qdpxx/Test_qdpxx_stag.cc	/^typedef Grid::QCD::StaggeredImplR::FermionField FermionField;$/;"	t	file:
FermionField	tests/solver/Test_dwf_lanczos.cc	/^typedef typename GparityDomainWallFermionR::FermionField FermionField;$/;"	t	file:
FermionField	tests/solver/Test_wilson_lanczos.cc	/^typedef typename WilsonFermionR::FermionField FermionField;$/;"	t	file:
FermionGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  GridBase *FermionGrid(void) { return _grid; }$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
FermionGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      GridBase *FermionGrid(void)            { return _FiveDimGrid;}$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
FermionGrid	lib/qcd/action/fermion/WilsonFermion.h	/^  GridBase *FermionGrid(void) { return _grid; }$/;"	f	class:Grid::QCD::WilsonFermion
FermionGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^      GridBase *FermionGrid(void)            { return _FiveDimGrid;}$/;"	f	class:Grid::QCD::WilsonFermion5D
FermionImplementationPolicy	tests/hmc/Test_hmc_Factories.cc	/^typedef QCD::WilsonImplR      FermionImplementationPolicy;$/;"	t	namespace:Grid	file:
FermionOp	tests/solver/Test_wilson_lanczos.cc	/^typedef WilsonFermionR FermionOp;$/;"	t	file:
FermionOperator	lib/qcd/action/fermion/FermionOperator.h	/^      FermionOperator(const ImplParams &p= ImplParams()) : Impl(p) {};$/;"	f	class:Grid::QCD::FermionOperator
FermionOperator	lib/qcd/action/fermion/FermionOperator.h	/^    class FermionOperator : public CheckerBoardedSparseMatrixBase<typename Impl::FermionField>, public Impl$/;"	c	namespace:Grid::QCD
FermionOperatorModule	lib/qcd/modules/FermionOperatorModules.h	/^  FermionOperatorModule(FOPar Par) : Parametrized<FOPar>(Par) {}$/;"	f	class:Grid::FermionOperatorModule
FermionOperatorModule	lib/qcd/modules/FermionOperatorModules.h	/^  FermionOperatorModule(Reader<ReaderClass>& Reader) : Parametrized<FOPar>(Reader){};$/;"	f	class:Grid::FermionOperatorModule
FermionOperatorModule	lib/qcd/modules/FermionOperatorModules.h	/^class FermionOperatorModule$/;"	c	namespace:Grid
FermionOperatorModuleBase	lib/qcd/modules/FermionOperatorModules.h	/^class FermionOperatorModuleBase : public HMCModuleBase<Product>{$/;"	c	namespace:Grid
FermionParameters	tests/hmc/Test_hmc_EOMobiusRatio.cc	/^  struct FermionParameters: Serializable {$/;"	s	namespace:Grid	file:
FermionParameters	tests/hmc/Test_hmc_EOMobiusRatioManyFlavour.cc	/^  struct FermionParameters: Serializable {$/;"	s	namespace:Grid	file:
FermionRedBlackGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  GridBase *FermionRedBlackGrid(void) { return _cbgrid; }$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
FermionRedBlackGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      GridBase *FermionRedBlackGrid(void)    { return _FiveDimRedBlackGrid;}$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
FermionRedBlackGrid	lib/qcd/action/fermion/WilsonFermion.h	/^  GridBase *FermionRedBlackGrid(void) { return _cbgrid; }$/;"	f	class:Grid::QCD::WilsonFermion
FermionRedBlackGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^      GridBase *FermionRedBlackGrid(void)    { return _FiveDimRedBlackGrid;}$/;"	f	class:Grid::QCD::WilsonFermion5D
FermionicLatticeGaugeTheory	lib/qcd/LatticeTheories.h	/^struct FermionicLatticeGaugeTheory$/;"	s	namespace:Grid::LatticeTheories
Field	lib/qcd/action/gauge/GaugeImplTypes.h	/^  typedef Lattice<SiteField>   Field;$/;"	t	class:Grid::QCD::GaugeImplTypes
Field	lib/qcd/action/gauge/Photon.h	/^    typedef Lattice<SiteField> Field;$/;"	t	class:Grid::QCD::QedGimpl
Field	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Lattice<SiteField>   Field;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
Field	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Lattice<SiteField> Field;$/;"	t	class:Grid::ScalarImplTypes
Field	lib/qcd/hmc/HMC.h	/^  typedef typename IntegratorType::Field Field;$/;"	t	class:Grid::QCD::HybridMonteCarlo
Field	lib/qcd/hmc/integrators/Integrator.h	/^  typedef typename FieldImplementation::Field Field;$/;"	t	class:Grid::QCD::Integrator
Field	lib/qcd/observables/plaquette.h	/^  typedef typename Impl::Field Field;$/;"	t	class:Grid::QCD::PlaquetteLogger
Field	lib/qcd/observables/topological_charge.h	/^    typedef typename Impl::Field Field;$/;"	t	class:Grid::QCD::TopologicalCharge
Field	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^  typedef typename Impl::Field Field;$/;"	t	class:MagMeas	file:
FieldMetaData	lib/parallelIO/MetaData.h	/^      FieldMetaData(void) { $/;"	f	class:Grid::FieldMetaData
FieldMetaData	lib/parallelIO/MetaData.h	/^    class FieldMetaData : Serializable {$/;"	c	namespace:Grid
FieldSquareNorm	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline RealD FieldSquareNorm(Field& U){$/;"	f	class:Grid::QCD::GaugeImplTypes
FieldSquareNorm	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline RealD FieldSquareNorm(Field& U) {$/;"	f	class:Grid::ScalarAdjMatrixImplTypes
FieldSquareNorm	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline RealD FieldSquareNorm(Field& U) {$/;"	f	class:Grid::ScalarImplTypes
FieldStrength	lib/qcd/utils/WilsonLoops.h	/^  static void FieldStrength(GaugeMat &FS, const GaugeLorentz &Umu, int mu, int nu){$/;"	f	class:Grid::QCD::WilsonLoops
File	lib/parallelIO/IldgIO.h	/^   FILE       *File;$/;"	m	class:Grid::QCD::GridLimeReader
File	lib/parallelIO/IldgIO.h	/^   FILE       *File;$/;"	m	class:Grid::QCD::GridLimeWriter
FineField	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice<Fobj >        FineField;$/;"	t	class:Grid::Aggregation
FineField	lib/algorithms/CoarsenedMatrix.h	/^    typedef Lattice<Fobj >        FineField;$/;"	t	class:Grid::CoarsenedMatrix
FineField	tests/solver/Test_dwf_hdcr.cc	/^  typedef typename Aggregation<Fobj,CComplex,nbasis>::FineField    FineField;$/;"	t	class:MultiGridPreconditioner	file:
FineGrid	lib/algorithms/CoarsenedMatrix.h	/^    GridBase *FineGrid;$/;"	m	class:Grid::Aggregation
FineOperator	tests/solver/Test_dwf_hdcr.cc	/^  typedef LinearOperatorBase<FineField>                            FineOperator;$/;"	t	class:MultiGridPreconditioner	file:
FixedBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct FixedBlockXpr { typedef Block<Derived,Rows,Cols> Type; };$/;"	s
FixedSegmentReturnType	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	s
Flags	lib/Eigen/src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon168
Flags	lib/Eigen/src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon169
Flags	lib/Eigen/src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
Flags	lib/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon388
Flags	lib/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon389
Flags	lib/Eigen/src/Core/Block.h	/^    Flags = (traits<XprType>::Flags & (DirectAccessBit | (InnerPanel?CompressedAccessBit:0))) | FlagsLvalueBit | FlagsRowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon213
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (Flags0 & ~RowMajorBit) | (Arg1Flags & RowMajorBit),$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (evaluator<ArgType>::Flags & (HereditaryBits | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon233
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (evaluator<ArgTypeNestedCleaned>::Flags & (HereditaryBits|LinearAccessMask) & ~RowMajorBit) | (traits<XprType>::Flags & RowMajorBit),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon241
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (evaluator<PlainObjectTypeCleaned>::Flags$/;"	e	enum:Eigen::internal::evaluator::__anon229
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (traits<XprType>::Flags&RowMajorBit) | (evaluator<ArgType>::Flags&(HereditaryBits&(~RowMajorBit))) | LinearAccessBit,$/;"	e	enum:Eigen::internal::evaluator::__anon243
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (unsigned int)(evaluator<ArgType>::Flags & (HereditaryBits | DirectAccessBit) & ~RowMajorBit) | LinearAccessBit,$/;"	e	enum:Eigen::internal::evaluator::__anon246
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = (unsigned int)evaluator<ThenMatrixType>::Flags & evaluator<ElseMatrixType>::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::evaluator::__anon239
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsRowMajorBit,$/;"	e	enum:Eigen::internal::evaluator::__anon237
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<ArgType>::Flags ^ RowMajorBit,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon228
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<ArgType>::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon230
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<ArgType>::Flags,$/;"	e	enum:Eigen::internal::evaluator_wrapper_base::__anon244
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Flags,$/;"	e	enum:Eigen::internal::evaluator::__anon236
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = int( evaluator<PlainObjectType>::Flags) & (LinearAccessMask&PacketAccessMask),$/;"	e	enum:Eigen::internal::evaluator::__anon235
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = int(Flags0) & (HereditaryBits | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
Flags	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags = traits<Derived>::EvaluatorFlags,$/;"	e	enum:Eigen::internal::evaluator::__anon227
Flags	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    Flags = cwise_promote_storage_order<typename traits<Lhs>::StorageKind,typename traits<Rhs>::StorageKind,_LhsNested::Flags & RowMajorBit,_RhsNested::Flags & RowMajorBit>::value$/;"	e	enum:Eigen::internal::traits::__anon505
Flags	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    Flags = traits<PlainObjectType>::Flags & RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon163
Flags	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  enum { Flags = _Arg1Nested::Flags & RowMajorBit };$/;"	e	enum:Eigen::internal::traits::__anon220
Flags	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & RowMajorBit $/;"	e	enum:Eigen::internal::traits::__anon155
Flags	lib/Eigen/src/Core/CwiseUnaryView.h	/^    Flags = traits<_MatrixTypeNested>::Flags & (RowMajorBit | FlagsLvalueBit | DirectAccessBit), \/\/ FIXME DirectAccessBit should not be handled by expressions$/;"	e	enum:Eigen::internal::traits::__anon394
Flags	lib/Eigen/src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon129
Flags	lib/Eigen/src/Core/Diagonal.h	/^    Flags = (unsigned int)_MatrixTypeNested::Flags & (RowMajorBit | MaskLvalueBit | DirectAccessBit) & ~RowMajorBit, \/\/ FIXME DirectAccessBit should not be handled by expressions$/;"	e	enum:Eigen::internal::traits::__anon401
Flags	lib/Eigen/src/Core/DiagonalMatrix.h	/^      Flags = NoPreferredStorageOrderBit$/;"	e	enum:Eigen::DiagonalBase::__anon398
Flags	lib/Eigen/src/Core/DiagonalMatrix.h	/^    Flags =  (traits<DiagonalVectorType>::Flags & LvalueBit) | NoPreferredStorageOrderBit$/;"	e	enum:Eigen::internal::traits::__anon400
Flags	lib/Eigen/src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit | NoPreferredStorageOrderBit$/;"	e	enum:Eigen::internal::traits::__anon399
Flags	lib/Eigen/src/Core/Inverse.h	/^    Flags = BaseTraits::Flags & RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon248
Flags	lib/Eigen/src/Core/Inverse.h	/^  enum { Flags = Base::Flags | EvalBeforeNestingBit };$/;"	e	enum:Eigen::internal::unary_evaluator::__anon249
Flags	lib/Eigen/src/Core/Map.h	/^    Flags = is_lvalue<PlainObjectType>::value ? int(Flags0) : (int(Flags0) & ~LvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon134
Flags	lib/Eigen/src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon172
Flags	lib/Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon500
Flags	lib/Eigen/src/Core/PermutationMatrix.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon501
Flags	lib/Eigen/src/Core/Product.h	/^    Flags = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon126
Flags	lib/Eigen/src/Core/ProductEvaluators.h	/^    Flags = ((HereditaryBits|_LinearAccessMask) & (unsigned int)(MatrixFlags)) | (_Vectorizable ? PacketAccessBit : 0),$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
Flags	lib/Eigen/src/Core/ProductEvaluators.h	/^    Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
Flags	lib/Eigen/src/Core/ProductEvaluators.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon174
Flags	lib/Eigen/src/Core/ProductEvaluators.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon178
Flags	lib/Eigen/src/Core/Redux.h	/^    Flags = evaluator<XprType>::Flags & ~DirectAccessBit,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
Flags	lib/Eigen/src/Core/Ref.h	/^    Flags = traits<Map<_PlainObjectType, _Options, _StrideType> >::Flags | NestByRefBit,$/;"	e	enum:Eigen::internal::traits::__anon149
Flags	lib/Eigen/src/Core/Replicate.h	/^    Flags = IsRowMajor ? RowMajorBit : 0$/;"	e	enum:Eigen::internal::traits::__anon225
Flags	lib/Eigen/src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon390
Flags	lib/Eigen/src/Core/Reverse.h	/^    Flags = _MatrixTypeNested::Flags & (RowMajorBit | LvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon165
Flags	lib/Eigen/src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon128
Flags	lib/Eigen/src/Core/SelfAdjointView.h	/^      Flags = internal::traits<SelfAdjointView>::Flags,$/;"	e	enum:Eigen::SelfAdjointView::__anon218
Flags	lib/Eigen/src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits|FlagsLvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon217
Flags	lib/Eigen/src/Core/Solve.h	/^    Flags = BaseTraits::Flags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon256
Flags	lib/Eigen/src/Core/Solve.h	/^  enum { Flags = Base::Flags | EvalBeforeNestingBit };$/;"	e	enum:Eigen::internal::evaluator::__anon257
Flags	lib/Eigen/src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon391
Flags	lib/Eigen/src/Core/TriangularMatrix.h	/^      Flags = internal::traits<TriangularView>::Flags,$/;"	e	enum:Eigen::TriangularView::__anon21
Flags	lib/Eigen/src/Core/TriangularMatrix.h	/^      Flags = internal::traits<TriangularViewType>::Flags$/;"	e	enum:Eigen::TriangularViewImpl::__anon22
Flags	lib/Eigen/src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits | FlagsLvalueBit) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit)))$/;"	e	enum:Eigen::internal::traits::__anon20
Flags	lib/Eigen/src/Core/VectorwiseOp.h	/^    Flags = RowsAtCompileTime == 1 ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon156
Flags	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon578
Flags	lib/Eigen/src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon607
Flags	lib/Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon604
Flags	lib/Eigen/src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon601
Flags	lib/Eigen/src/Geometry/Quaternion.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon602
Flags	lib/Eigen/src/Geometry/Transform.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon592
Flags	lib/Eigen/src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon651
Flags	lib/Eigen/src/LU/FullPivLU.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon677
Flags	lib/Eigen/src/LU/PartialPivLU.h	/^    Flags = BaseTraits::Flags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon673
Flags	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon643
Flags	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon641
Flags	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon645
Flags	lib/Eigen/src/SparseCore/SparseBlock.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon553
Flags	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    Flags = Derived::Flags$/;"	e	enum:Eigen::internal::evaluator::__anon538
Flags	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(Lhs::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::binary_evaluator::__anon525
Flags	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(LhsArg::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon530
Flags	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(Rhs::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::binary_evaluator::__anon523
Flags	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(RhsArg::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon528
Flags	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = XprType::Flags$/;"	e	enum:Eigen::internal::binary_evaluator::__anon521
Flags	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = XprType::Flags$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon526
Flags	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon517
Flags	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon518
Flags	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Flags = NeedToTranspose ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::sparse_dense_outer_product_evaluator::__anon547
Flags	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Lhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon546
Flags	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Rhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon545
Flags	lib/Eigen/src/SparseCore/SparseMap.h	/^    Flags = TraitsBase::Flags & (~ (NestByRefBit | LvalueBit))$/;"	e	enum:Eigen::internal::traits::__anon568
Flags	lib/Eigen/src/SparseCore/SparseMap.h	/^    Flags = TraitsBase::Flags & (~NestByRefBit)$/;"	e	enum:Eigen::internal::traits::__anon567
Flags	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon515
Flags	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon514
Flags	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit | CompressedAccessBit,$/;"	e	enum:Eigen::internal::traits::__anon513
Flags	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
Flags	lib/Eigen/src/SparseCore/SparsePermutation.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon557
Flags	lib/Eigen/src/SparseCore/SparsePermutation.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon558
Flags	lib/Eigen/src/SparseCore/SparseRef.h	/^    Flags = (traits<SparseMatrix<MatScalar,MatOptions,MatIndex> >::Flags | CompressedAccessBit | NestByRefBit) & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon534
Flags	lib/Eigen/src/SparseCore/SparseRef.h	/^    Flags = (traits<SparseVector<MatScalar,MatOptions,MatIndex> >::Flags | CompressedAccessBit | NestByRefBit) & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon537
Flags	lib/Eigen/src/SparseCore/SparseRef.h	/^    Flags = traits<PlainObjectType>::Flags | CompressedAccessBit | NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon532
Flags	lib/Eigen/src/SparseCore/SparseRef.h	/^    Flags = traits<PlainObjectType>::Flags | CompressedAccessBit | NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon535
Flags	lib/Eigen/src/SparseCore/SparseTranspose.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon562
Flags	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon561
Flags	lib/Eigen/src/SparseCore/SparseVector.h	/^    Flags = SparseVectorType::Flags$/;"	e	enum:Eigen::internal::evaluator::__anon543
Flags	lib/Eigen/src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit) | CompressedAccessBit,$/;"	e	enum:Eigen::internal::traits::__anon539
Flags	lib/Eigen/src/SparseCore/SparseView.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon564
Flags	lib/Eigen/src/SparseCore/SparseView.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon566
Flags	lib/Eigen/src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon563
Flags0	lib/Eigen/src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon168
Flags0	lib/Eigen/src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon169
Flags0	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = (int(Arg1Flags) | int(Arg2Flags) | int(Arg3Flags)) & ($/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
Flags0	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
Flags0	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = evaluator<ArgType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::evaluator::__anon237
Flags0	lib/Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = evaluator<ArgType>::Flags,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
Flags0	lib/Eigen/src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon134
Flags0	lib/Eigen/src/Core/Transpose.h	/^    Flags0 = traits<MatrixTypeNestedPlain>::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon391
Flags1	lib/Eigen/src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon391
FlagsLinearAccessBit	lib/Eigen/src/Core/CoreEvaluators.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (evaluator<ArgType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,    $/;"	e	enum:Eigen::internal::evaluator::__anon237
FlagsLvalueBit	lib/Eigen/src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon213
FlagsLvalueBit	lib/Eigen/src/Core/CwiseUnaryView.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon394
FlagsLvalueBit	lib/Eigen/src/Core/SelfAdjointView.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon217
FlagsLvalueBit	lib/Eigen/src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon391
FlagsLvalueBit	lib/Eigen/src/Core/TriangularMatrix.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon20
FlagsRowMajorBit	lib/Eigen/src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon213
FlagsRowMajorBit	lib/Eigen/src/Core/CoreEvaluators.h	/^    FlagsRowMajorBit = XprType::Flags&RowMajorBit,$/;"	e	enum:Eigen::internal::evaluator::__anon237
Flatten	lib/serialisation/BaseIO.h	/^  Flatten<V>::Flatten(const V &vector)$/;"	f	class:Grid::Flatten
Flatten	lib/serialisation/BaseIO.h	/^  class Flatten$/;"	c	namespace:Grid
FloorReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_floor_op<Scalar>, const Derived> FloorReturnType;$/;"	t
Flops	lib/algorithms/FFT.h	/^    double Flops(void) {return flops;}$/;"	f	class:Grid::FFT
ForceAlignedAccess	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC explicit inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess
ForceAlignedAccess	lib/Eigen/src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen
ForceAlignment	lib/Eigen/src/Core/GeneralProduct.h	/^    ForceAlignment  = internal::packet_traits<Scalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gemv_static_vector_if::__anon212
ForceDiagonal	lib/algorithms/CoarsenedMatrix.h	/^    void ForceDiagonal(void) {$/;"	f	class:Grid::CoarsenedMatrix
ForceGradient	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  ForceGradient(GridBase* grid, IntegratorParameters Par,$/;"	f	class:Grid::QCD::ForceGradient
ForceGradient	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^class ForceGradient : public Integrator<FieldImplementation, SmearingPolicy,$/;"	c	namespace:Grid::QCD
ForceHermitian	lib/algorithms/CoarsenedMatrix.h	/^    void ForceHermitian(void) {$/;"	f	class:Grid::CoarsenedMatrix
FourierAccelSteepestDescentStep	lib/qcd/utils/GaugeFix.h	/^  static Real FourierAccelSteepestDescentStep(std::vector<GaugeMat> &U,Real & alpha, GaugeMat & dmuAmu) {$/;"	f	class:FourierAcceleratedGaugeFixer
FourierAcceleratedGaugeFixer	lib/qcd/utils/GaugeFix.h	/^class FourierAcceleratedGaugeFixer  : public Gimpl {$/;"	c
FreePropPar	extras/Hadrons/Modules/MScalar/FreeProp.hpp	/^class FreePropPar: Serializable$/;"	c
FreePropPar	lib/Hadrons/Modules/MScalar/FreeProp.hpp	/^class FreePropPar: Serializable$/;"	c
FreePropagator	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void  FreePropagator(const FermionField &in,FermionField &out,RealD mass) { $/;"	f	class:Grid::QCD::FermionOperator
FreePropagator	lib/qcd/action/gauge/Photon.h	/^  void Photon<Gimpl>::FreePropagator (const GaugeField &in,GaugeField &out)$/;"	f	class:Grid::QCD::Photon
FreePropagator	lib/qcd/action/scalar/ScalarImpl.h	/^    static void FreePropagator(const Field &in, Field &out, RealD m)$/;"	f	class:Grid::ScalarImplTypes
FreePropagator	lib/qcd/action/scalar/ScalarImpl.h	/^    static void FreePropagator(const Field &in, Field &out,$/;"	f	class:Grid::ScalarImplTypes
FromTwoVectors	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion
FullDimensions	lib/cartesian/Cartesian_base.h	/^    inline const std::vector<int> &FullDimensions(void)         { return _fdimensions;};$/;"	f	class:Grid::GridBase
FullMatrixType	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject FullMatrixType;$/;"	t	struct:Eigen::internal::traits
FullMatrixType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject FullMatrixType;$/;"	t	struct:Eigen::internal::traits
FullPivHouseholderQR	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    explicit FullPivHouseholderQR(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    explicit FullPivHouseholderQR(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
FullPivHouseholderQRMatrixQReturnType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
FullPivHouseholderQRMatrixQReturnType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal
FullPivHouseholderQRPreconditioner	lib/Eigen/src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
FullPivLU	lib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU
FullPivLU	lib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivLU
FullPivLU	lib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU
FullPivLU	lib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivLU
FullPivLU	lib/Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
FullPrecision	lib/Eigen/src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon162
Func	extras/Hadrons/Factory.hpp	/^    typedef std::function<std::unique_ptr<T>(const std::string)> Func;$/;"	t	class:Factory
Func	lib/Hadrons/Factory.hpp	/^    typedef std::function<std::unique_ptr<T>(const std::string)> Func;$/;"	t	class:Factory
Func	lib/qcd/modules/Factory.h	/^    typedef std::function< std::unique_ptr<T> (const CreatorInput&) > Func;$/;"	t	class:Grid::Factory
Functor	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_all<BinaryOp>::type Functor;$/;"	t	class:Eigen::CwiseBinaryOp
Functor	lib/Eigen/src/Core/Swap.h	/^  typedef swap_assign_op<Scalar> Functor;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
FunctorType	lib/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon101
FunctorType	lib/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon102
FunctorType	lib/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon103
FundamentalLieAlgebraMatrix	lib/qcd/representations/adjoint.h	/^  void FundamentalLieAlgebraMatrix($/;"	f	class:Grid::QCD::AdjointRep
FundamentalLieAlgebraMatrix	lib/qcd/representations/two_index.h	/^  void FundamentalLieAlgebraMatrix($/;"	f	class:Grid::QCD::TwoIndexRep
FundamentalLieAlgebraMatrix	lib/qcd/utils/SUn.h	/^  static void FundamentalLieAlgebraMatrix(const LatticeAlgebraVector &h,$/;"	f	class:Grid::QCD::SU
FundamentalMatrices	lib/qcd/utils/SUn.h	/^typedef SU<Nc> FundamentalMatrices;$/;"	t	namespace:Grid::QCD
FundamentalRep	lib/qcd/representations/fundamental.h	/^  explicit FundamentalRep(GridBase* grid) {} \/\/do nothing$/;"	f	class:Grid::QCD::FundamentalRep
FundamentalRep	lib/qcd/representations/fundamental.h	/^class FundamentalRep {$/;"	c	namespace:Grid::QCD
FundamentalRepresentation	lib/qcd/representations/fundamental.h	/^typedef	 FundamentalRep<Nc> FundamentalRepresentation;$/;"	t	namespace:Grid::QCD
G5R5	lib/qcd/utils/LinalgUtils.h	/^void G5R5(Lattice<vobj> &z,const Lattice<vobj> &x)$/;"	f	namespace:Grid::QCD
G5_HERMITIAN_LINOP	lib/qcd/action/fermion/g5HermitianLinop.h	29;"	d
GAUGE_CONFIG_	lib/qcd/smearing/GaugeConfiguration.h	7;"	d
GAUGE_TYPE_ALIASES	extras/Hadrons/Global.hpp	72;"	d
GAUGE_TYPE_ALIASES	lib/Hadrons/Global.hpp	72;"	d
GCC_VERSION	lib/json/json.hpp	66;"	d
GCRnStep	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    RealD GCRnStep(LinearOperatorBase<Field> &Linop,const Field &src, Field &psi,RealD rsq){$/;"	f	class:Grid::PrecGeneralisedConjugateResidual
GEMM_SPECIALIZATION	lib/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	49;"	d
GENERIC_DHOPDIR_LEG	lib/qcd/action/fermion/WilsonKernels.cc	89;"	d	file:
GENERIC_STENCIL_LEG	lib/qcd/action/fermion/WilsonKernels.cc	46;"	d	file:
GENERIC_STENCIL_LEG_EXT	lib/qcd/action/fermion/WilsonKernels.cc	80;"	d	file:
GENERIC_STENCIL_LEG_INT	lib/qcd/action/fermion/WilsonKernels.cc	62;"	d	file:
GEN_SIMD_WIDTH	lib/simd/Grid_neon.h	42;"	d
GEN_SIMD_WIDTH	lib/simd/Grid_qpx.h	31;"	d
GFSrcName_	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::string                freeMomPropName_, GFSrcName_;$/;"	m	class:TChargedProp
GFSrcName_	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::string                freeMomPropName_, GFSrcName_;$/;"	m	class:TChargedProp
GFSrc_	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    ScalarField                *freeMomProp_, *GFSrc_;$/;"	m	class:TChargedProp
GFSrc_	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    ScalarField                *freeMomProp_, *GFSrc_;$/;"	m	class:TChargedProp
GRID_ALGORITHMS_H	lib/algorithms/Algorithms.h	30;"	d
GRID_ALGORITHMS_ITERATIVE_GENERIC_PCG	lib/algorithms/iterative/AdefGeneric.h	29;"	d
GRID_ALGORITHM_COARSENED_MATRIX_H	lib/algorithms/CoarsenedMatrix.h	32;"	d
GRID_ALGORITHM_LINEAR_OP_H	lib/algorithms/LinearOperator.h	30;"	d
GRID_ALGORITHM_SPARSE_MATRIX_H	lib/algorithms/SparseMatrix.h	29;"	d
GRID_ALIGNED_ALLOCATOR_H	lib/allocator/AlignedAllocator.h	30;"	d
GRID_ASM_AV512_H	lib/simd/Intel512avx.h	29;"	d
GRID_ASM_AV512_H	lib/simd/Intel512imci.h	29;"	d
GRID_ASM_BGQ_QPX_H	lib/simd/BGQQPX.h	29;"	d
GRID_ASM_BGQ_QPX_H	lib/simd/IBM_qpx.h	29;"	d
GRID_ASM_INTEL_512_QCD_H	lib/simd/Intel512wilson.h	29;"	d
GRID_ASM_INTEL_COMMON_512_H	lib/simd/Intel512common.h	29;"	d
GRID_BASE_H	lib/GridCore.h	39;"	d
GRID_BINARY_IO_H	lib/parallelIO/BinaryIO.h	30;"	d
GRID_BINOP	lib/lattice/Lattice_ET.h	294;"	d
GRID_BINOP	lib/lattice/Lattice_ET.h	430;"	d
GRID_BINOP_LEFT	lib/lattice/Lattice_ET.h	310;"	d
GRID_BINOP_RIGHT	lib/lattice/Lattice_ET.h	324;"	d
GRID_BLOCK_CONJUGATE_GRADIENT_H	lib/algorithms/iterative/BlockConjugateGradient.h	31;"	d
GRID_CARTESIAN_BASE_H	lib/cartesian/Cartesian_base.h	31;"	d
GRID_CARTESIAN_FULL_H	lib/cartesian/Cartesian_full.h	29;"	d
GRID_CARTESIAN_H	lib/cartesian/Cartesian.h	29;"	d
GRID_CARTESIAN_RED_BLACK_H	lib/cartesian/Cartesian_red_black.h	30;"	d
GRID_CHEBYSHEV_H	lib/algorithms/approx/Chebyshev.h	30;"	d
GRID_COMMUNICATOR_BASE_H	lib/communicator/Communicator_base.h	30;"	d
GRID_COMMUNICATOR_H	lib/communicator/Communicator.h	29;"	d
GRID_COMPARISON_H	lib/lattice/Lattice_comparison_utils.h	30;"	d
GRID_CONJUGATE_GRADIENT_H	lib/algorithms/iterative/ConjugateGradient.h	32;"	d
GRID_CONJUGATE_GRADIENT_MIXED_PREC_H	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	29;"	d
GRID_CONJUGATE_MULTI_SHIFT_GRADIENT_H	lib/algorithms/iterative/ConjugateGradientMultiShift.h	30;"	d
GRID_CONJUGATE_RESIDUAL_H	lib/algorithms/iterative/ConjugateResidual.h	30;"	d
GRID_DEF_BINOP	lib/lattice/Lattice_ET.h	341;"	d
GRID_DEF_BINOP	lib/lattice/Lattice_ET.h	434;"	d
GRID_DEF_TRINOP	lib/lattice/Lattice_ET.h	345;"	d
GRID_DEF_TRINOP	lib/lattice/Lattice_ET.h	435;"	d
GRID_DEF_UNOP	lib/lattice/Lattice_ET.h	298;"	d
GRID_DEF_UNOP	lib/lattice/Lattice_ET.h	433;"	d
GRID_ENUM_TYPE	lib/serialisation/MacroMagic.h	144;"	d
GRID_EXTRACT_H	lib/tensors/Tensor_extract_merge.h	33;"	d
GRID_FORMAT	lib/parallelIO/IldgIOtypes.h	41;"	d
GRID_GAUGE_IMPL_TYPES_H	lib/qcd/action/gauge/GaugeImplTypes.h	30;"	d
GRID_GENERIC_HMC_RUNNER	lib/qcd/hmc/GenericHMCrunner.h	31;"	d
GRID_H	lib/Grid.h	39;"	d
GRID_HMC_MODULES	lib/qcd/hmc/HMCModules.h	31;"	d
GRID_ILDGTYPES_IO_H	lib/parallelIO/IldgIOtypes.h	28;"	d
GRID_ILDG_IO_H	lib/parallelIO/IldgIO.h	28;"	d
GRID_INIT_H	lib/util/Init.h	30;"	d
GRID_IO_FIELD	lib/parallelIO/IldgIOtypes.h	/^  const int GRID_IO_FIELD      = 0; \/\/ hardcode lift from QIO compat$/;"	m	namespace:Grid
GRID_IO_GLOBAL	lib/parallelIO/IldgIOtypes.h	/^  const int GRID_IO_GLOBAL     = 1; \/\/ hardcode lift from QIO compat$/;"	m	namespace:Grid
GRID_IO_MULTIFILE	lib/parallelIO/IldgIOtypes.h	/^  const int GRID_IO_MULTIFILE  = 1; \/\/ hardcode lift from QIO compat$/;"	m	namespace:Grid
GRID_IO_SINGLEFILE	lib/parallelIO/IldgIOtypes.h	/^  const int GRID_IO_SINGLEFILE = 0; \/\/ hardcode lift from QIO compat$/;"	m	namespace:Grid
GRID_IRL_H	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	31;"	d
GRID_LATTICE_ARITH_H	lib/lattice/Lattice_arith.h	29;"	d
GRID_LATTICE_BASE_H	lib/lattice/Lattice_base.h	32;"	d
GRID_LATTICE_COMPARISON_H	lib/lattice/Lattice_comparison.h	30;"	d
GRID_LATTICE_CONFORMABLE_H	lib/lattice/Lattice_conformable.h	29;"	d
GRID_LATTICE_COORDINATE_H	lib/lattice/Lattice_coordinate.h	29;"	d
GRID_LATTICE_ET_H	lib/lattice/Lattice_ET.h	32;"	d
GRID_LATTICE_EXPRESSION_TEMPLATES	lib/lattice/Lattice_base.h	329;"	d
GRID_LATTICE_H	lib/lattice/Lattice.h	29;"	d
GRID_LATTICE_LOCALREDUCTION_H	lib/lattice/Lattice_local.h	29;"	d
GRID_LATTICE_OVERLOAD_H	lib/lattice/Lattice_overload.h	29;"	d
GRID_LATTICE_PEEK_H	lib/lattice/Lattice_peekpoke.h	31;"	d
GRID_LATTICE_REALITY_H	lib/lattice/Lattice_reality.h	31;"	d
GRID_LATTICE_REDUCTION_H	lib/lattice/Lattice_reduction.h	23;"	d
GRID_LATTICE_RNG_H	lib/lattice/Lattice_rng.h	30;"	d
GRID_LATTICE_TRACE_H	lib/lattice/Lattice_trace.h	29;"	d
GRID_LATTICE_TRANSFER_H	lib/lattice/Lattice_transfer.h	29;"	d
GRID_LATTICE_TRANSPOSE_H	lib/lattice/Lattice_transpose.h	30;"	d
GRID_LATTICE_UNARY_H	lib/lattice/Lattice_unary.h	32;"	d
GRID_LATTICE_WHERE_H	lib/lattice/Lattice_where.h	31;"	d
GRID_LEBESGUE_H	lib/stencil/Lebesgue.h	30;"	d
GRID_LEXICOGRAPHIC_H	lib/util/Lexicographic.h	2;"	d
GRID_LOG_H	lib/log/Log.h	34;"	d
GRID_LT_H	lib/qcd/LatticeTheories.h	34;"	d
GRID_MACRO_BOOL	lib/serialisation/MacroMagic.h	83;"	d
GRID_MACRO_CAT	lib/serialisation/MacroMagic.h	78;"	d
GRID_MACRO_COMP_MEMBER	lib/serialisation/MacroMagic.h	112;"	d
GRID_MACRO_DEFER1	lib/serialisation/MacroMagic.h	70;"	d
GRID_MACRO_DEFER2	lib/serialisation/MacroMagic.h	71;"	d
GRID_MACRO_DEFER3	lib/serialisation/MacroMagic.h	72;"	d
GRID_MACRO_DEFER4	lib/serialisation/MacroMagic.h	73;"	d
GRID_MACRO_EMPTY	lib/serialisation/MacroMagic.h	55;"	d
GRID_MACRO_ENUMCASE	lib/serialisation/MacroMagic.h	146;"	d
GRID_MACRO_ENUMCASEIO	lib/serialisation/MacroMagic.h	148;"	d
GRID_MACRO_ENUMTEST	lib/serialisation/MacroMagic.h	147;"	d
GRID_MACRO_ENUMVAL	lib/serialisation/MacroMagic.h	145;"	d
GRID_MACRO_EVAL	lib/serialisation/MacroMagic.h	57;"	d
GRID_MACRO_EVAL1	lib/serialisation/MacroMagic.h	68;"	d
GRID_MACRO_EVAL1024	lib/serialisation/MacroMagic.h	58;"	d
GRID_MACRO_EVAL128	lib/serialisation/MacroMagic.h	61;"	d
GRID_MACRO_EVAL16	lib/serialisation/MacroMagic.h	64;"	d
GRID_MACRO_EVAL2	lib/serialisation/MacroMagic.h	67;"	d
GRID_MACRO_EVAL256	lib/serialisation/MacroMagic.h	60;"	d
GRID_MACRO_EVAL32	lib/serialisation/MacroMagic.h	63;"	d
GRID_MACRO_EVAL4	lib/serialisation/MacroMagic.h	66;"	d
GRID_MACRO_EVAL512	lib/serialisation/MacroMagic.h	59;"	d
GRID_MACRO_EVAL64	lib/serialisation/MacroMagic.h	62;"	d
GRID_MACRO_EVAL8	lib/serialisation/MacroMagic.h	65;"	d
GRID_MACRO_FIRST	lib/serialisation/MacroMagic.h	52;"	d
GRID_MACRO_HAS_ARGS	lib/serialisation/MacroMagic.h	94;"	d
GRID_MACRO_IF_ELSE	lib/serialisation/MacroMagic.h	85;"	d
GRID_MACRO_IS_PROBE	lib/serialisation/MacroMagic.h	75;"	d
GRID_MACRO_MAGIC_H	lib/serialisation/MacroMagic.h	2;"	d
GRID_MACRO_MAP	lib/serialisation/MacroMagic.h	97;"	d
GRID_MACRO_MEMBER	lib/serialisation/MacroMagic.h	111;"	d
GRID_MACRO_NOT	lib/serialisation/MacroMagic.h	80;"	d
GRID_MACRO_OS_WRITE_MEMBER	lib/serialisation/MacroMagic.h	113;"	d
GRID_MACRO_PROBE	lib/serialisation/MacroMagic.h	76;"	d
GRID_MACRO_READ_MEMBER	lib/serialisation/MacroMagic.h	114;"	d
GRID_MACRO_SECOND	lib/serialisation/MacroMagic.h	53;"	d
GRID_MACRO_WRITE_MEMBER	lib/serialisation/MacroMagic.h	115;"	d
GRID_MATH_ARITH_ADD_H	lib/tensors/Tensor_arith_add.h	30;"	d
GRID_MATH_ARITH_H	lib/tensors/Tensor_arith.h	29;"	d
GRID_MATH_ARITH_MAC_H	lib/tensors/Tensor_arith_mac.h	29;"	d
GRID_MATH_ARITH_MUL_H	lib/tensors/Tensor_arith_mul.h	29;"	d
GRID_MATH_ARITH_SCALAR_H	lib/tensors/Tensor_arith_scalar.h	30;"	d
GRID_MATH_ARITH_SUB_H	lib/tensors/Tensor_arith_sub.h	30;"	d
GRID_MATH_DET_H	lib/tensors/Tensor_determinant.h	29;"	d
GRID_MATH_EXP_H	lib/tensors/Tensor_exp.h	29;"	d
GRID_MATH_H	lib/tensors/Tensors.h	31;"	d
GRID_MATH_INNER_H	lib/tensors/Tensor_inner.h	30;"	d
GRID_MATH_OUTER_H	lib/tensors/Tensor_outer.h	29;"	d
GRID_MATH_REALITY_H	lib/tensors/Tensor_reality.h	30;"	d
GRID_MATH_TA_H	lib/tensors/Tensor_Ta.h	30;"	d
GRID_MATH_TENSORS_H	lib/tensors/Tensor_class.h	25;"	d
GRID_MATH_TRACE_H	lib/tensors/Tensor_trace.h	30;"	d
GRID_MATH_TRAITS_H	lib/tensors/Tensor_traits.h	23;"	d
GRID_MATH_TRANSPOSE_H	lib/tensors/Tensor_transpose.h	29;"	d
GRID_NERSC_IO_H	lib/parallelIO/NerscIO.h	31;"	d
GRID_NORMAL_EQUATIONS_H	lib/algorithms/iterative/NormalEquations.h	29;"	d
GRID_OMP	lib/threads/Threads.h	33;"	d
GRID_PERFCOUNT_H	lib/perfmon/PerfCount.h	31;"	d
GRID_PRECONDITIONER_H	lib/algorithms/Preconditioner.h	29;"	d
GRID_PREC_CONJUGATE_RESIDUAL_H	lib/algorithms/iterative/PrecConjugateResidual.h	29;"	d
GRID_PREC_GCR_H	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	30;"	d
GRID_QCD_ACTION_H	lib/qcd/action/Action.h	34;"	d
GRID_QCD_ACTION_PARAMS_H	lib/qcd/action/ActionParams.h	33;"	d
GRID_QCD_BASE_H	lib/qcd/QCD.h	33;"	d
GRID_QCD_CAYLEY_FERMION_H	lib/qcd/action/fermion/CayleyFermion5D.h	30;"	d
GRID_QCD_CONTINUED_FRACTION_H	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	30;"	d
GRID_QCD_CORE_H	lib/GridQCDcore.h	31;"	d
GRID_QCD_DHOP_H	lib/qcd/action/fermion/WilsonKernels.h	32;"	d
GRID_QCD_DIRAC_H	lib/qcd/spin/Dirac.h	33;"	d
GRID_QCD_DOMAIN_WALL_FERMION_H	lib/qcd/action/fermion/DomainWallFermion.h	30;"	d
GRID_QCD_FERMION_CORE_H	lib/qcd/action/fermion/FermionCore.h	29;"	d
GRID_QCD_FERMION_H	lib/qcd/action/fermion/Fermion.h	29;"	d
GRID_QCD_FERMION_OPERATOR_H	lib/qcd/action/fermion/FermionOperator.h	31;"	d
GRID_QCD_FERMION_OPERATOR_IMPL_H	lib/qcd/action/fermion/FermionOperatorImpl.h	33;"	d
GRID_QCD_GAMMA_H	lib/qcd/spin/Gamma.h	2;"	d
GRID_QCD_GAUGE_H	lib/qcd/action/gauge/Gauge.h	30;"	d
GRID_QCD_GAUGE_IMPLEMENTATIONS_H	lib/qcd/action/gauge/GaugeImplementations.h	30;"	d
GRID_QCD_IMPROVED_STAGGERED_FERMION_5D_H	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	31;"	d
GRID_QCD_IMPR_STAG_FERMION_H	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	30;"	d
GRID_QCD_LINALG_UTILS_H	lib/qcd/utils/LinalgUtils.h	31;"	d
GRID_QCD_MOBIUS_FERMION_H	lib/qcd/action/fermion/MobiusFermion.h	30;"	d
GRID_QCD_MOBIUS_ZOLOTAREV_FERMION_H	lib/qcd/action/fermion/MobiusZolotarevFermion.h	30;"	d
GRID_QCD_PARTIAL_FRACTION_H	lib/qcd/action/fermion/PartialFractionFermion5D.h	30;"	d
GRID_QCD_SCALAR_H	lib/qcd/action/scalar/Scalar.h	30;"	d
GRID_QCD_SCALED_SHAMIR_FERMION_H	lib/qcd/action/fermion/ScaledShamirFermion.h	30;"	d
GRID_QCD_SHAMIR_ZOLOTAREV_FERMION_H	lib/qcd/action/fermion/ShamirZolotarevFermion.h	30;"	d
GRID_QCD_SMEARING_H	lib/qcd/smearing/Smearing.h	2;"	d
GRID_QCD_SPACE_TIME_GRID_H	lib/qcd/utils/SpaceTimeGrid.h	29;"	d
GRID_QCD_STAGGERED_KERNELS_H	lib/qcd/action/fermion/StaggeredKernels.h	30;"	d
GRID_QCD_TWOSPIN_H	lib/qcd/spin/TwoSpinor.h	30;"	d
GRID_QCD_WILSON_COMPRESSOR_H	lib/qcd/action/fermion/WilsonCompressor.h	31;"	d
GRID_QCD_WILSON_FERMION_5D_H	lib/qcd/action/fermion/WilsonFermion5D.h	32;"	d
GRID_QCD_WILSON_FERMION_H	lib/qcd/action/fermion/WilsonFermion.h	32;"	d
GRID_QCD_WILSON_TM_FERMION_H	lib/qcd/action/fermion/WilsonTMFermion.h	29;"	d
GRID_QCD_ZMOBIUS_FERMION_H	lib/qcd/action/fermion/ZMobiusFermion.h	30;"	d
GRID_SCHUR_RED_BLACK_H	lib/algorithms/iterative/SchurRedBlack.h	29;"	d
GRID_SERIALISATION_ABSTRACT_READER_H	lib/serialisation/BaseIO.h	31;"	d
GRID_SERIALISATION_BINARY_READER_H	lib/serialisation/BinaryIO.h	30;"	d
GRID_SERIALISATION_HDF5_H	lib/serialisation/Hdf5IO.h	2;"	d
GRID_SERIALISATION_HDF5_TYPE_H	lib/serialisation/Hdf5Type.h	2;"	d
GRID_SERIALISATION_JSON_IO_H	lib/serialisation/JSON_IO.h	29;"	d
GRID_SERIALISATION_READER_H	lib/serialisation/Serialisation.h	30;"	d
GRID_SERIALISATION_TEXT_READER_H	lib/serialisation/TextIO.h	30;"	d
GRID_SERIALISATION_XML_READER_H	lib/serialisation/XmlIO.h	31;"	d
GRID_SERIALIZABLE_CLASS_MEMBERS	lib/serialisation/MacroMagic.h	117;"	d
GRID_SERIALIZABLE_ENUM	lib/serialisation/MacroMagic.h	150;"	d
GRID_SIMD_H	lib/simd/Simd.h	32;"	d
GRID_STD_H	lib/GridStd.h	2;"	d
GRID_STENCIL_H	lib/stencil/Stencil.h	29;"	d
GRID_TENSOR_INDEX_H	lib/tensors/Tensor_index.h	29;"	d
GRID_TENSOR_LOGICAL_H	lib/tensors/Tensor_logical.h	29;"	d
GRID_TENSOR_UNARY_H	lib/tensors/Tensor_unary.h	31;"	d
GRID_TEXT_INDENT	lib/serialisation/TextIO.cc	35;"	d	file:
GRID_THREADS_H	lib/threads/Threads.h	30;"	d
GRID_TIME_H	lib/perfmon/Timer.h	30;"	d
GRID_TRINOP	lib/lattice/Lattice_ET.h	295;"	d
GRID_TRINOP	lib/lattice/Lattice_ET.h	431;"	d
GRID_UNOP	lib/lattice/Lattice_ET.h	293;"	d
GRID_UNOP	lib/lattice/Lattice_ET.h	429;"	d
GRID_UTIL_H	lib/util/Util.h	2;"	d
GRID_VECTOR_TYPES	lib/simd/Grid_vector_types.h	39;"	d
GRID_VECTOR_UNOPS	lib/simd/Grid_vector_unops.h	33;"	d
Gamma	lib/qcd/spin/Gamma.h	/^    Gamma(Algebra initg): g(initg) {}  $/;"	f	class:Grid::QCD::Gamma
Gamma	lib/qcd/spin/Gamma.h	/^class Gamma {$/;"	c	namespace:Grid::QCD
Gamma3ptPar	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^class Gamma3ptPar: Serializable$/;"	c
Gamma3ptPar	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^class Gamma3ptPar: Serializable$/;"	c
Gamma5HermitianLinearOperator	lib/qcd/action/fermion/g5HermitianLinop.h	/^    Gamma5HermitianLinearOperator(Matrix &Mat): _Mat(Mat), g5(Gamma::Algebra::Gamma5) {};$/;"	f	class:Grid::QCD::Gamma5HermitianLinearOperator
Gamma5HermitianLinearOperator	lib/qcd/action/fermion/g5HermitianLinop.h	/^class Gamma5HermitianLinearOperator : public LinearOperatorBase<Field> {$/;"	c	namespace:Grid::QCD
Gamma5R5HermitianLinearOperator	lib/qcd/action/fermion/g5HermitianLinop.h	/^  Gamma5R5HermitianLinearOperator(Matrix &Mat): _Mat(Mat){};$/;"	f	class:Grid::QCD::Gamma5R5HermitianLinearOperator
Gamma5R5HermitianLinearOperator	lib/qcd/action/fermion/g5HermitianLinop.h	/^class Gamma5R5HermitianLinearOperator : public LinearOperatorBase<Field> {$/;"	c	namespace:Grid::QCD
GammaL	lib/qcd/spin/Dirac.h	/^  GammaL(const Algebra initg): gamma(initg) {}$/;"	f	class:Grid::QCD::GammaL
GammaL	lib/qcd/spin/Dirac.h	/^  GammaL(const Gamma   initg): gamma(initg) {}$/;"	f	class:Grid::QCD::GammaL
GammaL	lib/qcd/spin/Dirac.h	/^class GammaL$/;"	c	namespace:Grid::QCD
GammaPair	extras/Hadrons/Modules/MContraction/Meson.hpp	/^typedef std::pair<Gamma::Algebra, Gamma::Algebra> GammaPair;$/;"	t
GammaPair	lib/Hadrons/Modules/MContraction/Meson.hpp	/^typedef std::pair<Gamma::Algebra, Gamma::Algebra> GammaPair;$/;"	t
Gather	lib/stencil/Stencil.h	/^  int Gather(const Lattice<vobj> &rhs,int dimension,int shift,int cbmask,compressor & compress,int &face_idx)$/;"	f	class:Grid::CartesianStencil
GatherSimd	lib/stencil/Stencil.h	/^  int  GatherSimd(const Lattice<vobj> &rhs,int dimension,int shift,int cbmask,compressor &compress,int & face_idx)$/;"	f	class:Grid::CartesianStencil
Gather_plane_exchange_table	lib/stencil/Stencil.h	/^void Gather_plane_exchange_table(std::vector<std::pair<int,int> >& table,const Lattice<vobj> &rhs,$/;"	f	namespace:Grid
Gather_plane_extract	lib/cshift/Cshift_common.h	/^Gather_plane_extract(const Lattice<vobj> &rhs,std::vector<typename vobj::scalar_object *> pointers,int dimension,int plane,int cbmask)$/;"	f	namespace:Grid
Gather_plane_simple	lib/cshift/Cshift_common.h	/^Gather_plane_simple (const Lattice<vobj> &rhs,commVector<vobj> &buffer,int dimension,int plane,int cbmask, int off=0)$/;"	f	namespace:Grid
Gather_plane_simple_table	lib/stencil/Stencil.h	/^void Gather_plane_simple_table (std::vector<std::pair<int,int> >& table,const Lattice<vobj> &rhs,cobj *buffer,compressor &compress, int off,int so)$/;"	f	namespace:Grid
Gather_plane_table_compute	lib/stencil/Stencil.cc	/^void Gather_plane_table_compute (GridBase *grid,int dimension,int plane,int cbmask,$/;"	f	namespace:Grid
Gauge3x2munger	lib/parallelIO/MetaData.h	/^    struct Gauge3x2munger{$/;"	s	namespace:Grid::QCD
Gauge3x2unmunger	lib/parallelIO/MetaData.h	/^    struct Gauge3x2unmunger{$/;"	s	namespace:Grid::QCD
GaugeField	tests/qdpxx/Test_qdpxx_stag.cc	/^typedef Grid::QCD::LatticeGaugeField GaugeField;$/;"	t	file:
GaugeGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  GridBase *GaugeGrid(void) { return _grid; }$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
GaugeGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      GridBase *GaugeGrid(void)              { return _FourDimGrid ;}$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
GaugeGrid	lib/qcd/action/fermion/WilsonFermion.h	/^  GridBase *GaugeGrid(void) { return _grid; }$/;"	f	class:Grid::QCD::WilsonFermion
GaugeGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^      GridBase *GaugeGrid(void)              { return _FourDimGrid ;}$/;"	f	class:Grid::QCD::WilsonFermion5D
GaugeImplTypes	lib/qcd/action/gauge/GaugeImplTypes.h	/^template <class S, int Nrepresentation = Nc, int Nexp = 12 > class GaugeImplTypes {$/;"	c	namespace:Grid::QCD
GaugeLinkToLieAlgebraField	lib/qcd/utils/GaugeFix.h	/^  static void GaugeLinkToLieAlgebraField(const std::vector<GaugeMat> &U,std::vector<GaugeMat> &A) {$/;"	f	class:FourierAcceleratedGaugeFixer
GaugeLorentz	extras/qed-fvol/WilsonLoops.h	/^  typedef typename Gimpl::GaugeField GaugeLorentz;$/;"	t	class:NewWilsonLoops
GaugeLorentz	lib/qcd/utils/GaugeFix.h	/^  typedef typename Gimpl::GaugeField GaugeLorentz;$/;"	t	class:FourierAcceleratedGaugeFixer
GaugeLorentz	lib/qcd/utils/WilsonLoops.h	/^  typedef typename Gimpl::GaugeField GaugeLorentz;$/;"	t	class:Grid::QCD::WilsonLoops
GaugeMat	extras/qed-fvol/WilsonLoops.h	/^  typedef typename Gimpl::GaugeLinkField GaugeMat;$/;"	t	class:NewWilsonLoops
GaugeMat	lib/qcd/utils/GaugeFix.h	/^  typedef typename Gimpl::GaugeLinkField GaugeMat;$/;"	t	class:FourierAcceleratedGaugeFixer
GaugeMat	lib/qcd/utils/WilsonLoops.h	/^  typedef typename Gimpl::GaugeLinkField GaugeMat;$/;"	t	class:Grid::QCD::WilsonLoops
GaugePropPar	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^class GaugePropPar: Serializable$/;"	c
GaugePropPar	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^class GaugePropPar: Serializable$/;"	c
GaugeRedBlackGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  GridBase *GaugeRedBlackGrid(void) { return _cbgrid; }$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
GaugeRedBlackGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      GridBase *GaugeRedBlackGrid(void)      { return _FourDimRedBlackGrid ;}$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
GaugeRedBlackGrid	lib/qcd/action/fermion/WilsonFermion.h	/^  GridBase *GaugeRedBlackGrid(void) { return _cbgrid; }$/;"	f	class:Grid::QCD::WilsonFermion
GaugeRedBlackGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^      GridBase *GaugeRedBlackGrid(void)      { return _FourDimRedBlackGrid ;}$/;"	f	class:Grid::QCD::WilsonFermion5D
GaugeSimpleMunger	lib/parallelIO/MetaData.h	/^    struct GaugeSimpleMunger{$/;"	s	namespace:Grid::QCD
GaugeSimpleUnmunger	lib/parallelIO/MetaData.h	/^    struct GaugeSimpleUnmunger {$/;"	s	namespace:Grid::QCD
GaugeStatistics	lib/parallelIO/MetaData.h	/^ inline void GaugeStatistics(Lattice<vLorentzColourMatrixD> & data,FieldMetaData &header)$/;"	f	namespace:Grid::QCD
GaugeStatistics	lib/parallelIO/MetaData.h	/^ inline void GaugeStatistics(Lattice<vLorentzColourMatrixF> & data,FieldMetaData &header)$/;"	f	namespace:Grid::QCD
GaugeTransform	lib/qcd/utils/SUn.h	/^    static void GaugeTransform( std::vector<GaugeMat> &U, GaugeMat &g){$/;"	f	class:Grid::QCD::SU
GaugeTransform	lib/qcd/utils/SUn.h	/^  static void GaugeTransform( GaugeField &Umu, GaugeMat &g){$/;"	f	class:Grid::QCD::SU
GaussianFundamentalLieAlgebraMatrix	lib/qcd/utils/SUn.h	/^  static void GaussianFundamentalLieAlgebraMatrix(GridParallelRNG &pRNG,$/;"	f	class:Grid::QCD::SU
GemmParallelInfo	lib/Eigen/src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), lhs_start(0), lhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo
GemmParallelInfo	lib/Eigen/src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
GemmProduct	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
GemvProduct	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
GenEigMask	lib/Eigen/src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
Gene	extras/Hadrons/GeneticScheduler.hpp	/^    typedef std::vector<T>                   Gene;$/;"	t	class:GeneticScheduler
Gene	lib/Hadrons/GeneticScheduler.hpp	/^    typedef std::vector<T>                   Gene;$/;"	t	class:GeneticScheduler
GenePair	extras/Hadrons/GeneticScheduler.hpp	/^    typedef std::pair<Gene *, Gene *>        GenePair;$/;"	t	class:GeneticScheduler
GenePair	lib/Hadrons/GeneticScheduler.hpp	/^    typedef std::pair<Gene *, Gene *>        GenePair;$/;"	t	class:GeneticScheduler
GeneralisedMomenta	lib/qcd/utils/Metric.h	/^  GeneralisedMomenta(GridBase* grid, Metric<MomentaField>& M): M(M), Mom(grid), AuxMom(grid), AuxField(grid){}$/;"	f	class:Grid::QCD::GeneralisedMomenta
GeneralisedMomenta	lib/qcd/utils/Metric.h	/^class GeneralisedMomenta{$/;"	c	namespace:Grid::QCD
GeneralizedEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver()$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    explicit GeneralizedEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^template<typename _MatrixType> class GeneralizedEigenSolver$/;"	c	namespace:Eigen
GeneralizedSelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    explicit GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen
Generic	lib/Eigen/src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
GenericDhopSite	lib/qcd/action/fermion/WilsonKernels.cc	/^void WilsonKernels<Impl>::GenericDhopSite(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::WilsonKernels
GenericDhopSiteDag	lib/qcd/action/fermion/WilsonKernels.cc	/^void WilsonKernels<Impl>::GenericDhopSiteDag(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::WilsonKernels
GenericDhopSiteDagExt	lib/qcd/action/fermion/WilsonKernels.cc	/^void WilsonKernels<Impl>::GenericDhopSiteDagExt(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::WilsonKernels
GenericDhopSiteDagInt	lib/qcd/action/fermion/WilsonKernels.cc	/^void WilsonKernels<Impl>::GenericDhopSiteDagInt(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::WilsonKernels
GenericDhopSiteExt	lib/qcd/action/fermion/WilsonKernels.cc	/^void WilsonKernels<Impl>::GenericDhopSiteExt(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::WilsonKernels
GenericDhopSiteInt	lib/qcd/action/fermion/WilsonKernels.cc	/^void WilsonKernels<Impl>::GenericDhopSiteInt(StencilImpl &st, LebesgueOrder &lo, DoubledGaugeField &U,$/;"	f	class:Grid::QCD::WilsonKernels
GenericNumTraits	lib/Eigen/src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
GeneticPar	extras/Hadrons/Application.hpp	/^        GeneticPar(void):$/;"	f	class:Application::GeneticPar
GeneticPar	extras/Hadrons/Application.hpp	/^    class GeneticPar: Serializable$/;"	c	class:Application
GeneticPar	lib/Hadrons/Application.hpp	/^        GeneticPar(void):$/;"	f	class:Application::GeneticPar
GeneticPar	lib/Hadrons/Application.hpp	/^    class GeneticPar: Serializable$/;"	c	class:Application
GeneticScheduler	extras/Hadrons/GeneticScheduler.hpp	/^GeneticScheduler<T>::GeneticScheduler(Graph<T> &graph, const ObjFunc &func,$/;"	f	class:GeneticScheduler
GeneticScheduler	extras/Hadrons/GeneticScheduler.hpp	/^class GeneticScheduler$/;"	c
GeneticScheduler	lib/Hadrons/GeneticScheduler.hpp	/^GeneticScheduler<T>::GeneticScheduler(Graph<T> &graph, const ObjFunc &func,$/;"	f	class:GeneticScheduler
GeneticScheduler	lib/Hadrons/GeneticScheduler.hpp	/^class GeneticScheduler$/;"	c
Geometry	lib/algorithms/CoarsenedMatrix.h	/^  Geometry(int _d)  {$/;"	f	class:Grid::Geometry
Geometry	lib/algorithms/CoarsenedMatrix.h	/^  class Geometry {$/;"	c	namespace:Grid
GetAction	lib/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
GetActionSet	lib/qcd/hmc/HMCResourceManager.h	/^  void GetActionSet(ActionSet<typename ImplementationPolicy::Field, RepresentationPolicy>& Aset){$/;"	f	class:Grid::QCD::HMCResourceManager
GetCartesian	lib/qcd/hmc/HMCResourceManager.h	/^  GridCartesian* GetCartesian(std::string s = "") {$/;"	f	class:Grid::QCD::HMCResourceManager
GetCheckPointer	lib/qcd/hmc/HMCResourceManager.h	/^  BaseHmcCheckpointer<ImplementationPolicy>* GetCheckPointer() {$/;"	f	class:Grid::QCD::HMCResourceManager
GetCores	lib/threads/Threads.h	/^  static int GetCores(void)   { return _cores; };$/;"	f	class:Grid::GridThread
GetEngine	lib/lattice/Lattice_rng.h	/^    void GetEngine(RngEngine &Eng, int gen){$/;"	f	class:Grid::GridRNGbase
GetEntry	lib/stencil/Stencil.h	/^  inline StencilEntry * GetEntry(int &ptype,int point,int osite) { $/;"	f	class:Grid::CartesianStencil
GetHyperThreads	lib/threads/Threads.h	/^  static int GetHyperThreads(void) { assert(_threads%_cores ==0); return _threads\/_cores; };$/;"	f	class:Grid::GridThread
GetInfo	lib/stencil/Stencil.h	/^  inline uint64_t GetInfo(int &ptype,int &local,int &perm,int point,int ent,uint64_t base) {$/;"	f	class:Grid::CartesianStencil
GetLinOp	tests/qdpxx/Test_qdpxx_munprec.cc	/^  static Handle< LinearOperatorArray<T4> >  GetLinOp (U &u, ChromaAction parms)$/;"	f	class:Chroma::ChromaWrapper
GetLinOp	tests/qdpxx/Test_qdpxx_stag.cc	/^  static Handle< Chroma::EvenOddLinearOperator<T4,U,U> >  GetLinOp (U &u,U &u_fat,U &u_triple)$/;"	f	class:Chroma::ChromaWrapper
GetNodeLocal	lib/stencil/Stencil.h	/^  inline int GetNodeLocal(int osite,int point) { $/;"	f	class:Grid::CartesianStencil
GetObservables	lib/qcd/hmc/HMCResourceManager.h	/^  std::vector<HmcObservable<typename ImplementationPolicy::Field>* > GetObservables(){$/;"	f	class:Grid::QCD::HMCResourceManager
GetPFInfo	lib/stencil/Stencil.h	/^  inline uint64_t GetPFInfo(int ent,uint64_t base) {$/;"	f	class:Grid::CartesianStencil
GetParallelRNG	lib/qcd/hmc/HMCResourceManager.h	/^  GridParallelRNG& GetParallelRNG() {$/;"	f	class:Grid::QCD::HMCResourceManager
GetPlaquette	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^  static Chroma::Handle< Chroma::LinearGaugeAction > GetPlaquette ( U &u )$/;"	f	class:Chroma::ChromaWrapper
GetRBCAction	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^  static Chroma::Handle< Chroma::LinearGaugeAction > GetRBCAction ( U &u )$/;"	f	class:Chroma::ChromaWrapper
GetRBCartesian	lib/qcd/hmc/HMCResourceManager.h	/^  GridRedBlackCartesian* GetRBCartesian(std::string s = "") {$/;"	f	class:Grid::QCD::HMCResourceManager
GetRectangle	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^  static Chroma::Handle< Chroma::LinearGaugeAction > GetRectangle ( U &u )$/;"	f	class:Chroma::ChromaWrapper
GetSerialRNG	lib/qcd/hmc/HMCResourceManager.h	/^  GridSerialRNG& GetSerialRNG() { return RNGs.get_sRNG(); }$/;"	f	class:Grid::QCD::HMCResourceManager
GetSolver	tests/qdpxx/Test_qdpxx_munprec.cc	/^  static Chroma::Handle< Chroma::SystemSolver<QDP::LatticeFermion> > GetSolver(QDP::multi1d<QDP::LatticeColorMatrix> &u, ChromaAction parms)$/;"	f	class:Chroma::ChromaWrapper
GetState	lib/lattice/Lattice_rng.h	/^    void GetState(std::vector<RngStateType> & saved,RngEngine &eng) {$/;"	f	class:Grid::GridRNGbase
GetState	lib/lattice/Lattice_rng.h	/^    void GetState(std::vector<RngStateType> & saved,int gen) {$/;"	f	class:Grid::GridRNGbase
GetThreads	lib/threads/Threads.h	/^  static int GetThreads(void) { return _threads; };$/;"	f	class:Grid::GridThread
GetU01	tests/testu01/Test_smallcrush.cc	/^  static uint32_t GetU01(void) { $/;"	f	struct:TestRNG
GetU01MT	tests/testu01/Test_smallcrush.cc	/^uint32_t GetU01MT(void) {$/;"	f
GetU01Ranlux	tests/testu01/Test_smallcrush.cc	/^uint32_t GetU01Ranlux(void) {$/;"	f
GetU01Sitmo	tests/testu01/Test_smallcrush.cc	/^uint32_t GetU01Sitmo(void) {$/;"	f
GetWork	lib/communicator/Communicator_mpi3_leader.cc	/^  static void GetWork(int nwork, int me, int & mywork, int & myoff,int units){$/;"	f	class:Grid::MPIoffloadEngine
GetWork	lib/threads/Threads.h	/^  static void GetWork(int nwork, int me, int & mywork, int & myoff){$/;"	f	class:Grid::GridThread
GetWork	lib/threads/Threads.h	/^  static void GetWork(int nwork, int me, int & mywork, int & myoff,int units){$/;"	f	class:Grid::GridThread
GetWorkBarrier	lib/threads/Threads.h	/^  static void GetWorkBarrier(int nwork, int &me, int & mywork, int & myoff){$/;"	f	class:Grid::GridThread
Gimpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef PeriodicGaugeImpl<GaugeImplTypes<S, Dimension > > Gimpl;$/;"	t	class:Grid::QCD::StaggeredImpl
Gimpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef PeriodicGaugeImpl<GaugeImplTypes<S, Dimension > > Gimpl;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
Gimpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef PeriodicGaugeImpl<GaugeImplTypes<S, Dimension > > Gimpl;$/;"	t	class:Grid::QCD::WilsonImpl
Gimpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef PeriodicGaugeImpl<GaugeImplTypes<S, Nrepresentation> > Gimpl;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
Gimpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef ConjugateGaugeImpl< GaugeImplTypes<S,Nrepresentation> > Gimpl;$/;"	t	class:Grid::QCD::GparityWilsonImpl
GimplAdjointTypesD	lib/qcd/action/gauge/GaugeImplTypes.h	/^typedef GaugeImplTypes<vComplexD, SU<Nc>::AdjointDimension> GimplAdjointTypesD;$/;"	t	namespace:Grid::QCD
GimplAdjointTypesF	lib/qcd/action/gauge/GaugeImplTypes.h	/^typedef GaugeImplTypes<vComplexF, SU<Nc>::AdjointDimension> GimplAdjointTypesF;$/;"	t	namespace:Grid::QCD
GimplAdjointTypesR	lib/qcd/action/gauge/GaugeImplTypes.h	/^typedef GaugeImplTypes<vComplex, SU<Nc>::AdjointDimension> GimplAdjointTypesR;$/;"	t	namespace:Grid::QCD
GimplTypesD	lib/qcd/action/gauge/GaugeImplTypes.h	/^typedef GaugeImplTypes<vComplexD, Nc> GimplTypesD;$/;"	t	namespace:Grid::QCD
GimplTypesF	lib/qcd/action/gauge/GaugeImplTypes.h	/^typedef GaugeImplTypes<vComplexF, Nc> GimplTypesF;$/;"	t	namespace:Grid::QCD
GimplTypesR	lib/qcd/action/gauge/GaugeImplTypes.h	/^typedef GaugeImplTypes<vComplex, Nc> GimplTypesR;$/;"	t	namespace:Grid::QCD
GlobalCoorToGlobalIndex	lib/cartesian/Cartesian_base.h	/^    void GlobalCoorToGlobalIndex(const std::vector<int> & gcoor,int & gidx){$/;"	f	class:Grid::GridBase
GlobalCoorToProcessorCoorLocalCoor	lib/cartesian/Cartesian_base.h	/^    void GlobalCoorToProcessorCoorLocalCoor(std::vector<int> &pcoor,std::vector<int> &lcoor,const std::vector<int> &gcoor)$/;"	f	class:Grid::GridBase
GlobalCoorToRankIndex	lib/cartesian/Cartesian_base.h	/^    void GlobalCoorToRankIndex(int &rank, int &o_idx, int &i_idx ,const std::vector<int> &gcoor)$/;"	f	class:Grid::GridBase
GlobalDimensions	lib/cartesian/Cartesian_base.h	/^    inline const std::vector<int> &GlobalDimensions(void)       { return _gdimensions;};$/;"	f	class:Grid::GridBase
GlobalIndexToGlobalCoor	lib/cartesian/Cartesian_base.h	/^    void GlobalIndexToGlobalCoor(int gidx,std::vector<int> &gcoor){$/;"	f	class:Grid::GridBase
GlobalLU_t	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef LU_GlobalLU_t<IndexVector, ScalarVector> GlobalLU_t; $/;"	t	class:Eigen::internal::SparseLUImpl
GlobalPar	extras/Hadrons/Application.hpp	/^    class GlobalPar: Serializable$/;"	c	class:Application
GlobalPar	lib/Hadrons/Application.hpp	/^    class GlobalPar: Serializable$/;"	c	class:Application
GlobalSum	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::GlobalSum(ComplexD &c)$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::GlobalSum(ComplexF &c)$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_base.h	/^  template<class obj> void GlobalSum(obj &o){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalSum(double &d)$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalSum(float &f){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalSum(uint32_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalSum(uint64_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalSum(double &d)$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalSum(float &f){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalSum(uint32_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalSum(uint64_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::GlobalSum(double &d)$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::GlobalSum(float &f){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::GlobalSum(uint32_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::GlobalSum(uint64_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalSum(double &){}$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalSum(float &){}$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalSum(uint32_t &){}$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalSum(uint64_t &){}$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::GlobalSum(double &d)$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::GlobalSum(float &f){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::GlobalSum(uint32_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSum	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::GlobalSum(uint64_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::GlobalSumVector(ComplexD *c,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::GlobalSumVector(ComplexF *c,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalSumVector(double *d,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalSumVector(float *f,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalSumVector(double *d,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalSumVector(float *f,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::GlobalSumVector(double *d,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::GlobalSumVector(float *f,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalSumVector(double *,int N){}$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalSumVector(float *,int N){}$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::GlobalSumVector(double *d,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalSumVector	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::GlobalSumVector(float *f,int N)$/;"	f	class:Grid::CartesianCommunicator
GlobalU01	lib/lattice/Lattice_rng.h	/^    uint32_t GlobalU01(int gsite){$/;"	f	class:Grid::GridParallelRNG
GlobalXOR	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalXOR(uint32_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalXOR	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::GlobalXOR(uint64_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalXOR	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalXOR(uint32_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalXOR	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::GlobalXOR(uint64_t &u){$/;"	f	class:Grid::CartesianCommunicator
GlobalXOR	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalXOR(uint32_t &){}$/;"	f	class:Grid::CartesianCommunicator
GlobalXOR	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::GlobalXOR(uint64_t &){}$/;"	f	class:Grid::CartesianCommunicator
Gmu	benchmarks/Benchmark_dwf.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	benchmarks/Benchmark_dwf_sweep.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	benchmarks/Benchmark_wilson.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	benchmarks/Benchmark_wilson_sweep.cc	/^Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/Test_cayley_even_odd_vec.cc	/^    Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/Test_dwf_mixedcg_prec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/Test_dwf_mixedcg_prec_halfcomms.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_cf_coarsen_support.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_checker.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_contfrac_even_odd.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_dwf_even_odd.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_dwf_rb5d.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_mobius_even_odd.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_wilson_even_odd.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_wilson_twisted_mass_even_odd.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/core/Test_zmobius_even_odd.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/debug/Test_cayley_cg.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/debug/Test_cayley_coarsen_support.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/debug/Test_cayley_even_odd.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_cf_cr_unprec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_contfrac_cg.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_dwf_cg_prec.cc	/^Gamma::Algebra Gmu[] = {Gamma::Algebra::GammaX, Gamma::Algebra::GammaY, Gamma::Algebra::GammaZ,$/;"	v
Gmu	tests/solver/Test_dwf_cg_schur.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_dwf_cg_unprec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_dwf_cr_unprec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_dwf_fpgcr.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_staggered_block_cg_unprec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_staggered_cg_unprec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_wilson_cg_prec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_wilson_cg_schur.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_wilson_cg_unprec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_wilson_cr_unprec.cc	/^  Gamma::Algebra Gmu [] = {$/;"	v
Gmu	tests/solver/Test_zmobius_cg_prec.cc	/^Gamma::Algebra Gmu[] = {Gamma::Algebra::GammaX, Gamma::Algebra::GammaY, Gamma::Algebra::GammaZ,$/;"	v
GparityDomainWallFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<GparityWilsonImplD> GparityDomainWallFermionD;$/;"	t	namespace:Grid::QCD
GparityDomainWallFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<GparityWilsonImplDF> GparityDomainWallFermionDF;$/;"	t	namespace:Grid::QCD
GparityDomainWallFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<GparityWilsonImplF> GparityDomainWallFermionF;$/;"	t	namespace:Grid::QCD
GparityDomainWallFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<GparityWilsonImplFH> GparityDomainWallFermionFH;$/;"	t	namespace:Grid::QCD
GparityDomainWallFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<GparityWilsonImplR> GparityDomainWallFermionR;$/;"	t	namespace:Grid::QCD
GparityDomainWallFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef DomainWallFermion<GparityWilsonImplRL> GparityDomainWallFermionRL;$/;"	t	namespace:Grid::QCD
GparityFermOpTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	89;"	d
GparityMobiusFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<GparityWilsonImplD> GparityMobiusFermionD;$/;"	t	namespace:Grid::QCD
GparityMobiusFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<GparityWilsonImplDF> GparityMobiusFermionDF;$/;"	t	namespace:Grid::QCD
GparityMobiusFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<GparityWilsonImplF> GparityMobiusFermionF;$/;"	t	namespace:Grid::QCD
GparityMobiusFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<GparityWilsonImplFH> GparityMobiusFermionFH;$/;"	t	namespace:Grid::QCD
GparityMobiusFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<GparityWilsonImplR> GparityMobiusFermionR;$/;"	t	namespace:Grid::QCD
GparityMobiusFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<GparityWilsonImplRL> GparityMobiusFermionRL;$/;"	t	namespace:Grid::QCD
GparityWilsonFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<GparityWilsonImplD>     GparityWilsonFermionD;$/;"	t	namespace:Grid::QCD
GparityWilsonFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<GparityWilsonImplDF>     GparityWilsonFermionDF;$/;"	t	namespace:Grid::QCD
GparityWilsonFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<GparityWilsonImplF>     GparityWilsonFermionF;$/;"	t	namespace:Grid::QCD
GparityWilsonFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<GparityWilsonImplFH>     GparityWilsonFermionFH;$/;"	t	namespace:Grid::QCD
GparityWilsonFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<GparityWilsonImplR>     GparityWilsonFermionR;$/;"	t	namespace:Grid::QCD
GparityWilsonFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<GparityWilsonImplRL>     GparityWilsonFermionRL;$/;"	t	namespace:Grid::QCD
GparityWilsonImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ GparityWilsonImpl(const ImplParams &p = ImplParams()) : Params(p){};$/;"	f	class:Grid::QCD::GparityWilsonImpl
GparityWilsonImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^class GparityWilsonImpl : public ConjugateGaugeImpl<GaugeImplTypes<S, Nrepresentation> > {$/;"	c	namespace:Grid::QCD
GparityWilsonImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef GparityWilsonImpl<vComplexD, Nc,CoeffReal> GparityWilsonImplD;  \/\/ Double$/;"	t	namespace:Grid::QCD
GparityWilsonImplDF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef GparityWilsonImpl<vComplexD, Nc,CoeffRealHalfComms> GparityWilsonImplDF;  \/\/ Double$/;"	t	namespace:Grid::QCD
GparityWilsonImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef GparityWilsonImpl<vComplexF, Nc,CoeffReal> GparityWilsonImplF;  \/\/ Float$/;"	t	namespace:Grid::QCD
GparityWilsonImplFH	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef GparityWilsonImpl<vComplexF, Nc,CoeffRealHalfComms> GparityWilsonImplFH;  \/\/ Float$/;"	t	namespace:Grid::QCD
GparityWilsonImplParams	lib/qcd/action/ActionParams.h	/^    GparityWilsonImplParams() : twists(Nd, 0), overlapCommsCompute(false){};$/;"	f	struct:Grid::QCD::GparityWilsonImplParams
GparityWilsonImplParams	lib/qcd/action/ActionParams.h	/^  struct GparityWilsonImplParams {$/;"	s	namespace:Grid::QCD
GparityWilsonImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef GparityWilsonImpl<vComplex , Nc,CoeffReal> GparityWilsonImplR;  \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
GparityWilsonImplRL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef GparityWilsonImpl<vComplex , Nc,CoeffRealHalfComms> GparityWilsonImplRL;  \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
GparityWilsonTMFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<GparityWilsonImplD> GparityWilsonTMFermionD;$/;"	t	namespace:Grid::QCD
GparityWilsonTMFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<GparityWilsonImplDF> GparityWilsonTMFermionDF;$/;"	t	namespace:Grid::QCD
GparityWilsonTMFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<GparityWilsonImplF> GparityWilsonTMFermionF;$/;"	t	namespace:Grid::QCD
GparityWilsonTMFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<GparityWilsonImplFH> GparityWilsonTMFermionFH;$/;"	t	namespace:Grid::QCD
GparityWilsonTMFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<GparityWilsonImplR> GparityWilsonTMFermionR;$/;"	t	namespace:Grid::QCD
GparityWilsonTMFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<GparityWilsonImplRL> GparityWilsonTMFermionRL;$/;"	t	namespace:Grid::QCD
Graph	extras/Hadrons/Graph.hpp	/^Graph<T>::Graph(void)$/;"	f	class:Graph
Graph	extras/Hadrons/Graph.hpp	/^class Graph$/;"	c
Graph	lib/Hadrons/Graph.hpp	/^Graph<T>::Graph(void)$/;"	f	class:Graph
Graph	lib/Hadrons/Graph.hpp	/^class Graph$/;"	c
Grid	lib/algorithms/CoarsenedMatrix.h	/^    GridBase * Grid(void)         { return _grid; };   \/\/ this is all the linalg routines need to know$/;"	f	class:Grid::CoarsenedMatrix
Grid	lib/algorithms/CoarsenedMatrix.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/FFT.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/LinearOperator.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/Preconditioner.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/SparseMatrix.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/approx/Chebyshev.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/approx/MultiShiftFunction.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/algorithms/approx/MultiShiftFunction.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/approx/Zolotarev.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/algorithms/approx/Zolotarev.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/BlockConjugateGradient.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/ConjugateGradient.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/ConjugateResidual.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/NormalEquations.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/PrecConjugateResidual.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^namespace Grid {$/;"	n
Grid	lib/algorithms/iterative/SchurRedBlack.h	/^namespace Grid {$/;"	n
Grid	lib/allocator/AlignedAllocator.cc	/^namespace Grid$/;"	n	file:
Grid	lib/allocator/AlignedAllocator.h	/^namespace Grid {$/;"	n
Grid	lib/cartesian/Cartesian_base.h	/^namespace Grid{$/;"	n
Grid	lib/cartesian/Cartesian_full.h	/^namespace Grid{$/;"	n
Grid	lib/cartesian/Cartesian_red_black.h	/^namespace Grid {$/;"	n
Grid	lib/communicator/Communicator_base.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/communicator/Communicator_base.h	/^namespace Grid {$/;"	n
Grid	lib/communicator/Communicator_mpi.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/communicator/Communicator_mpi3.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/communicator/Communicator_mpi3_leader.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/communicator/Communicator_none.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/communicator/Communicator_shmem.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/cshift/Cshift_common.h	/^namespace Grid {$/;"	n
Grid	lib/cshift/Cshift_mpi.h	/^namespace Grid { $/;"	n
Grid	lib/cshift/Cshift_none.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_ET.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_arith.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_base.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_comparison.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_comparison_utils.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_conformable.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_coordinate.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_local.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_overload.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_peekpoke.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_reality.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_reduction.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_rng.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_trace.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_transfer.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_transpose.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_unary.h	/^namespace Grid {$/;"	n
Grid	lib/lattice/Lattice_where.h	/^namespace Grid {$/;"	n
Grid	lib/log/Log.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/log/Log.h	/^namespace Grid {$/;"	n
Grid	lib/parallelIO/BinaryIO.h	/^namespace Grid { $/;"	n
Grid	lib/parallelIO/IldgIO.h	/^namespace Grid {$/;"	n
Grid	lib/parallelIO/IldgIOtypes.h	/^namespace Grid {$/;"	n
Grid	lib/parallelIO/MetaData.h	/^namespace Grid {$/;"	n
Grid	lib/parallelIO/NerscIO.h	/^namespace Grid {$/;"	n
Grid	lib/perfmon/PerfCount.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/perfmon/PerfCount.h	/^namespace Grid {$/;"	n
Grid	lib/perfmon/Stat.cc	/^namespace Grid { $/;"	n	file:
Grid	lib/perfmon/Stat.h	/^namespace Grid { $/;"	n
Grid	lib/perfmon/Timer.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/LatticeTheories.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/QCD.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/ActionBase.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/ActionParams.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/ActionSet.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/CayleyFermion5D.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/CayleyFermion5D.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/CayleyFermion5Dcache.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/CayleyFermion5Ddense.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/CayleyFermion5Dssp.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/DomainWallFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/Fermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/FermionOperator.h	/^      GridBase * Grid(void)   { return FermionGrid(); };   \/\/ this is all the linalg routines need to know$/;"	f	class:Grid::QCD::FermionOperator
Grid	lib/qcd/action/fermion/FermionOperator.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/FermionOperatorImpl.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/MobiusFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/MobiusZolotarevFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/OverlapWilsonCayleyTanhFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/OverlapWilsonCayleyZolotarevFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/OverlapWilsonContfracTanhFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/OverlapWilsonContfracZolotarevFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/OverlapWilsonPartialFractionTanhFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/OverlapWilsonPartialFractionZolotarevFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/ScaledShamirFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/ShamirZolotarevFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/StaggeredKernels.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/StaggeredKernels.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/StaggeredKernelsHand.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/WilsonCompressor.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/WilsonFermion.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/WilsonFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/WilsonFermion5D.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/WilsonFermion5D.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/WilsonKernels.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/WilsonKernels.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/WilsonTMFermion.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/action/fermion/WilsonTMFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/ZMobiusFermion.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/fermion/g5HermitianLinop.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/gauge/Gauge.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/gauge/GaugeImplTypes.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/gauge/GaugeImplementations.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/gauge/Photon.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/gauge/WilsonGaugeAction.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/pseudofermion/TwoFlavour.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/action/scalar/Scalar.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/scalar/ScalarAction.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/scalar/ScalarImpl.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/action/scalar/ScalarInteractionAction.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/GenericHMCrunner.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/HMC.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/HMCModules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/HMCResourceManager.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/HMCRunnerModule.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/HMC_GridModules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/integrators/Integrator.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/modules/ActionModules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/modules/Factory.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/modules/FermionOperatorModules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/modules/Modules.cc	/^namespace Grid{$/;"	n	file:
Grid	lib/qcd/modules/Modules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/modules/ObservableModules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/modules/SolverModules.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/observables/hmc_observable.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/observables/plaquette.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/observables/topological_charge.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/representations/adjoint.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/representations/fundamental.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/representations/hmc_types.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/representations/two_index.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/smearing/APEsmearing.h	/^  namespace Grid {$/;"	n
Grid	lib/qcd/smearing/GaugeConfiguration.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/smearing/StoutSmearing.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/smearing/WilsonFlow.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/spin/Dirac.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/spin/Gamma.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/qcd/spin/Gamma.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/spin/TwoSpinor.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/utils/CovariantCshift.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/utils/CovariantLaplacian.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/utils/LinalgUtils.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/utils/Metric.h	/^namespace Grid{$/;"	n
Grid	lib/qcd/utils/SUn.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/utils/SUnAdjoint.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/utils/SUnTwoIndex.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/utils/ScalarObjs.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/utils/SpaceTimeGrid.cc	/^namespace Grid { $/;"	n	file:
Grid	lib/qcd/utils/SpaceTimeGrid.h	/^namespace Grid {$/;"	n
Grid	lib/qcd/utils/WilsonLoops.h	/^namespace Grid {$/;"	n
Grid	lib/serialisation/BaseIO.h	/^namespace Grid {$/;"	n
Grid	lib/serialisation/BinaryIO.h	/^namespace Grid {$/;"	n
Grid	lib/serialisation/Hdf5IO.h	/^namespace Grid$/;"	n
Grid	lib/serialisation/Hdf5Type.h	/^namespace Grid$/;"	n
Grid	lib/serialisation/JSON_IO.cc	/^namespace Grid$/;"	n	file:
Grid	lib/serialisation/JSON_IO.h	/^namespace Grid$/;"	n
Grid	lib/serialisation/Serialisation.h	/^namespace Grid {$/;"	n
Grid	lib/serialisation/TextIO.h	/^namespace Grid$/;"	n
Grid	lib/serialisation/XmlIO.h	/^namespace Grid$/;"	n
Grid	lib/simd/Grid_avx.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Grid_avx512.h	/^namespace Grid{$/;"	n
Grid	lib/simd/Grid_generic.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Grid_generic_types.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Grid_imci.h	/^namespace Grid{$/;"	n
Grid	lib/simd/Grid_neon.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Grid_qpx.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Grid_sse4.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Grid_vector_types.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Grid_vector_unops.h	/^namespace Grid {$/;"	n
Grid	lib/simd/Simd.h	/^namespace Grid {$/;"	n
Grid	lib/simd/l1p.h	/^namespace Grid {$/;"	n
Grid	lib/stencil/Lebesgue.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/stencil/Lebesgue.h	/^namespace Grid {$/;"	n
Grid	lib/stencil/SimpleCompressor.h	/^namespace Grid {$/;"	n
Grid	lib/stencil/Stencil.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/stencil/Stencil.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_Ta.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_arith_add.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_arith_mac.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_arith_mul.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_arith_scalar.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_arith_sub.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_class.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_determinant.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_exp.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_extract_merge.h	/^namespace Grid{$/;"	n
Grid	lib/tensors/Tensor_index.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_inner.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_logical.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_outer.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_reality.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_trace.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_traits.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_transpose.h	/^namespace Grid {$/;"	n
Grid	lib/tensors/Tensor_unary.h	/^namespace Grid {$/;"	n
Grid	lib/threads/Threads.h	/^namespace Grid {$/;"	n
Grid	lib/util/Init.cc	/^namespace Grid {$/;"	n	file:
Grid	lib/util/Init.h	/^namespace Grid {$/;"	n
Grid	lib/util/Lexicographic.h	/^namespace Grid{$/;"	n
Grid	tests/hmc/Test_hmc_DBW2_Implicit.cc	/^namespace Grid{$/;"	n	file:
Grid	tests/hmc/Test_hmc_EOMobiusRatio.cc	/^namespace Grid{$/;"	n	file:
Grid	tests/hmc/Test_hmc_EOMobiusRatioManyFlavour.cc	/^namespace Grid{$/;"	n	file:
Grid	tests/hmc/Test_hmc_Factories.cc	/^namespace Grid{$/;"	n	file:
Grid	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^namespace Grid {$/;"	n	file:
Grid	tests/hmc/Test_hmc_WilsonGauge_Implicit.cc	/^namespace Grid{$/;"	n	file:
Grid	tests/smearing/Test_WilsonFlow.cc	/^namespace Grid{$/;"	n	file:
GridBase	lib/cartesian/Cartesian_base.h	/^    GridBase(const std::vector<int> & processor_grid) : CartesianCommunicator(processor_grid) {};$/;"	f	class:Grid::GridBase
GridBase	lib/cartesian/Cartesian_base.h	/^  class GridBase : public CartesianCommunicator , public GridThread {$/;"	c	namespace:Grid
GridBinOpClass	lib/lattice/Lattice_ET.h	253;"	d
GridCartesian	lib/cartesian/Cartesian_full.h	/^    GridCartesian(const std::vector<int> &dimensions,$/;"	f	class:Grid::GridCartesian
GridCartesian	lib/cartesian/Cartesian_full.h	/^class GridCartesian: public GridBase {$/;"	c	namespace:Grid
GridClock	lib/perfmon/Timer.h	/^typedef  std::chrono::system_clock          GridClock;$/;"	t	namespace:Grid
GridCmdOptionCSL	lib/util/Init.cc	/^void GridCmdOptionCSL(std::string str,std::vector<std::string> & vec)$/;"	f	namespace:Grid
GridCmdOptionExists	lib/util/Init.cc	/^bool GridCmdOptionExists(char** begin, char** end, const std::string& option)$/;"	f	namespace:Grid
GridCmdOptionInt	lib/util/Init.cc	/^void GridCmdOptionInt(std::string &str,int & val)$/;"	f	namespace:Grid
GridCmdOptionIntVector	lib/util/Init.cc	/^void GridCmdOptionIntVector(std::string &str,std::vector<int> & vec)$/;"	f	namespace:Grid
GridCmdOptionPayload	lib/util/Init.cc	/^std::string GridCmdOptionPayload(char ** begin, char ** end, const std::string & option)$/;"	f	namespace:Grid
GridCmdVectorIntToString	lib/util/Init.cc	/^std::string GridCmdVectorIntToString(const std::vector<int> & vec){$/;"	f	namespace:Grid
GridDefaultFourDimModule	lib/qcd/hmc/HMC_GridModules.h	/^typedef GridFourDimModule<vComplex> GridDefaultFourDimModule;$/;"	t	namespace:Grid
GridDefaultLatt	lib/util/Init.cc	/^const std::vector<int> &GridDefaultLatt(void)     {return Grid_default_latt;};$/;"	f	namespace:Grid
GridDefaultMpi	lib/util/Init.cc	/^const std::vector<int> &GridDefaultMpi(void)      {return Grid_default_mpi;};$/;"	f	namespace:Grid
GridDefaultSimd	lib/util/Init.cc	/^const std::vector<int> GridDefaultSimd(int dims,int nsimd)$/;"	f	namespace:Grid
GridFourDimModule	lib/qcd/hmc/HMC_GridModules.h	/^  GridFourDimModule() {$/;"	f	class:Grid::GridFourDimModule
GridFourDimModule	lib/qcd/hmc/HMC_GridModules.h	/^  GridFourDimModule(GridModuleParameters Params) {$/;"	f	class:Grid::GridFourDimModule
GridFourDimModule	lib/qcd/hmc/HMC_GridModules.h	/^class GridFourDimModule : public GridModule {$/;"	c	namespace:Grid
GridFromExpression	lib/lattice/Lattice_ET.h	/^inline void GridFromExpression($/;"	f	namespace:Grid
GridFromExpression	lib/lattice/Lattice_ET.h	/^inline void GridFromExpression(GridBase *&grid, const T1 &lat)  \/\/ Lattice leaf$/;"	f	namespace:Grid
GridFromExpression	lib/lattice/Lattice_ET.h	/^inline void GridFromExpression(GridBase *&grid,$/;"	f	namespace:Grid
GridLimeReader	lib/parallelIO/IldgIO.h	/^class GridLimeReader : public BinaryIO {$/;"	c	namespace:Grid::QCD
GridLimeWriter	lib/parallelIO/IldgIO.h	/^class GridLimeWriter : public BinaryIO {$/;"	c	namespace:Grid::QCD
GridLogConfigure	lib/log/Log.cc	/^void GridLogConfigure(std::vector<std::string> &logstreams) {$/;"	f	namespace:Grid
GridLogLayout	lib/util/Init.cc	/^void GridLogLayout() {$/;"	f	namespace:Grid
GridLogTimestamp	lib/log/Log.cc	/^void GridLogTimestamp(int on){$/;"	f	namespace:Grid
GridLogger	lib/log/Log.h	/^  GridLogger(int on, std::string nm, Colours&col_class, std::string col_key = "NORMAL"):$/;"	f	class:Grid::GridLogger
GridLogger	lib/log/Log.h	/^class GridLogger: public Logger {$/;"	c	namespace:Grid
GridMetaData	lib/parallelIO/MetaData.h	/^    inline void GridMetaData(GridBase *grid,FieldMetaData &header)$/;"	f	namespace:Grid::QCD
GridModule	lib/qcd/hmc/HMC_GridModules.h	/^class GridModule {$/;"	c	namespace:Grid
GridModuleParameters	lib/qcd/hmc/HMC_GridModules.h	/^  GridModuleParameters(Reader<ReaderClass>& Reader, std::string n = "LatticeGrid"):name(n) {$/;"	f	class:Grid::GridModuleParameters
GridModuleParameters	lib/qcd/hmc/HMC_GridModules.h	/^class GridModuleParameters: Serializable{   $/;"	c	namespace:Grid
GridParallelRNG	lib/lattice/Lattice_rng.h	/^    GridParallelRNG(GridBase *grid) : GridRNGbase() {$/;"	f	class:Grid::GridParallelRNG
GridParallelRNG	lib/lattice/Lattice_rng.h	/^  class GridParallelRNG : public GridRNGbase {$/;"	c	namespace:Grid
GridParseLayout	lib/util/Init.cc	/^void GridParseLayout(char **argv,int argc,$/;"	f	namespace:Grid
GridPt	extras/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<GridCartesian>         GridPt;$/;"	t	class:Environment
GridPt	lib/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<GridCartesian>         GridPt;$/;"	t	class:Environment
GridRNGbase	lib/lattice/Lattice_rng.h	/^  class GridRNGbase {$/;"	c	namespace:Grid
GridRbPt	extras/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<GridRedBlackCartesian> GridRbPt;$/;"	t	class:Environment
GridRbPt	lib/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<GridRedBlackCartesian> GridRbPt;$/;"	t	class:Environment
GridRedBlackCartesian	lib/cartesian/Cartesian_red_black.h	/^    GridRedBlackCartesian(const GridBase *base) : GridRedBlackCartesian(base->_fdimensions,base->_simd_layout,base->_processors)  {};$/;"	f	class:Grid::GridRedBlackCartesian
GridRedBlackCartesian	lib/cartesian/Cartesian_red_black.h	/^    GridRedBlackCartesian(const std::vector<int> &dimensions,$/;"	f	class:Grid::GridRedBlackCartesian
GridRedBlackCartesian	lib/cartesian/Cartesian_red_black.h	/^class GridRedBlackCartesian : public GridBase$/;"	c	namespace:Grid
GridRefs	lib/qcd/modules/FermionOperatorModules.h	/^  std::vector< QCD::GridModule* >    GridRefs;$/;"	m	class:Grid::FermionOperatorModule
GridSerialRNG	lib/lattice/Lattice_rng.h	/^    GridSerialRNG() : GridRNGbase() {$/;"	f	class:Grid::GridSerialRNG
GridSerialRNG	lib/lattice/Lattice_rng.h	/^  class GridSerialRNG : public GridRNGbase {$/;"	c	namespace:Grid
GridStopWatch	lib/perfmon/Timer.h	/^  GridStopWatch () { $/;"	f	class:Grid::GridStopWatch
GridStopWatch	lib/perfmon/Timer.h	/^class GridStopWatch {$/;"	c	namespace:Grid
GridTensorBase	lib/tensors/Tensor_class.h	/^class GridTensorBase {};$/;"	c	namespace:Grid
GridThread	lib/threads/Threads.h	/^class GridThread {$/;"	c	namespace:Grid
GridTime	lib/perfmon/Timer.h	/^typedef  std::chrono::milliseconds          GridTime;$/;"	t	namespace:Grid
GridTimePoint	lib/perfmon/Timer.h	/^typedef  std::chrono::time_point<GridClock> GridTimePoint;$/;"	t	namespace:Grid
GridTrinOpClass	lib/lattice/Lattice_ET.h	274;"	d
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template <class T> class GridTypeMapper {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<ComplexD> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<ComplexF> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<Integer> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<RealD> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<RealF> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<vComplexD> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<vComplexF> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<vComplexH> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<vInteger> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<vRealD> {$/;"	c	namespace:Grid
GridTypeMapper	lib/tensors/Tensor_traits.h	/^  template<> class GridTypeMapper<vRealF> {$/;"	c	namespace:Grid
GridUnopClass	lib/lattice/Lattice_ET.h	220;"	d
GridUsecs	lib/perfmon/Timer.h	/^typedef  std::chrono::microseconds          GridUsecs;$/;"	t	namespace:Grid
Grid_backtrace_buffer	lib/util/Init.cc	/^void * Grid_backtrace_buffer[_NBACKTRACE];$/;"	m	namespace:Grid	file:
Grid_debug_handler_init	lib/util/Init.cc	/^void Grid_debug_handler_init(void)$/;"	f	namespace:Grid
Grid_default_latt	lib/util/Init.cc	/^static std::vector<int> Grid_default_latt;$/;"	m	namespace:Grid	file:
Grid_default_mpi	lib/util/Init.cc	/^static std::vector<int> Grid_default_mpi;$/;"	m	namespace:Grid	file:
Grid_finalize	lib/util/Init.cc	/^void Grid_finalize(void)$/;"	f	namespace:Grid
Grid_half	lib/simd/Grid_sse4.h	/^    Grid_half(){}$/;"	f	struct:Grid::Optimization::Grid_half
Grid_half	lib/simd/Grid_sse4.h	/^    Grid_half(uint16_t raw) : x(raw) {}$/;"	f	struct:Grid::Optimization::Grid_half
Grid_half	lib/simd/Grid_sse4.h	/^  struct Grid_half {$/;"	s	namespace:Grid::Optimization
Grid_init	lib/util/Init.cc	/^void Grid_init(int *argc,char ***argv)$/;"	f	namespace:Grid
Grid_is_initialised	lib/util/Init.cc	/^static int Grid_is_initialised = 0;$/;"	m	namespace:Grid	file:
Grid_mm_cvtph_ps	lib/simd/Grid_sse4.h	/^  static inline __m128 Grid_mm_cvtph_ps(__m128i h,int discard) {$/;"	f	namespace:Grid::Optimization
Grid_mm_cvtph_ps	lib/simd/Grid_sse4.h	426;"	d
Grid_mm_cvtps_ph	lib/simd/Grid_sse4.h	/^  static inline __m128i Grid_mm_cvtps_ph(__m128 f,int discard) {$/;"	f	namespace:Grid::Optimization
Grid_mm_cvtps_ph	lib/simd/Grid_sse4.h	425;"	d
Grid_ntohll	lib/parallelIO/BinaryIO.h	/^inline uint64_t Grid_ntohll(uint64_t A) { $/;"	f	namespace:Grid
Grid_ntohll	lib/parallelIO/BinaryIO.h	/^inline uint64_t Grid_ntohll(uint64_t A) { return A; }$/;"	f	namespace:Grid
Grid_quiesce_nodes	lib/log/Log.cc	/^void Grid_quiesce_nodes(void) {$/;"	f	namespace:Grid
Grid_sa_signal_handler	lib/util/Init.cc	/^void Grid_sa_signal_handler(int sig,siginfo_t *si,void * ptr)$/;"	f	namespace:Grid
Grid_semaphore	lib/communicator/Communicator_mpi3_leader.cc	/^typedef sem_t *Grid_semaphore;$/;"	t	file:
Grid_simd	lib/simd/Grid_vector_types.h	/^  Grid_simd(const Grid_simd &&rhs) : v(rhs.v){};$/;"	f	class:Grid::Grid_simd
Grid_simd	lib/simd/Grid_vector_types.h	/^  Grid_simd(const Grid_simd &rhs) : v(rhs.v){};  \/\/ compiles in movaps$/;"	f	class:Grid::Grid_simd
Grid_simd	lib/simd/Grid_vector_types.h	/^  Grid_simd(const Real a) { vsplat(*this, Scalar_type(a)); };$/;"	f	class:Grid::Grid_simd
Grid_simd	lib/simd/Grid_vector_types.h	/^  Grid_simd(const typename std::enable_if<is_complex<S>::value, S>::type a) {$/;"	f	class:Grid::Grid_simd
Grid_simd	lib/simd/Grid_vector_types.h	/^class Grid_simd {$/;"	c	namespace:Grid
Grid_unquiesce_nodes	lib/log/Log.cc	/^void Grid_unquiesce_nodes(void) {$/;"	f	namespace:Grid
Grids	lib/qcd/hmc/HMCResourceManager.h	/^  std::unordered_map<std::string, GridModule> Grids;$/;"	m	class:Grid::QCD::HMCResourceManager
Group	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef QCD::SU<N> Group;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
GroupCoor	lib/communicator/Communicator_base.h	/^  std::vector<int> GroupCoor;$/;"	m	class:Grid::CartesianCommunicator
GroupDims	lib/communicator/Communicator_base.h	/^  std::vector<int>  GroupDims;$/;"	m	class:Grid::CartesianCommunicator
GroupRank	lib/communicator/Communicator_base.h	/^  static int GroupRank;$/;"	m	class:Grid::CartesianCommunicator
GroupRank	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::GroupRank;$/;"	m	class:Grid::CartesianCommunicator	file:
GroupRanks	lib/communicator/Communicator_base.h	/^  static std::vector<int> GroupRanks; $/;"	m	class:Grid::CartesianCommunicator
GroupRanks	lib/communicator/Communicator_mpi3.cc	/^std::vector<int> CartesianCommunicator::GroupRanks;  $/;"	m	class:Grid::CartesianCommunicator	file:
GroupSize	lib/communicator/Communicator_base.h	/^  static int GroupSize;$/;"	m	class:Grid::CartesianCommunicator
GroupSize	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::GroupSize;$/;"	m	class:Grid::CartesianCommunicator	file:
H5NS	lib/serialisation/Hdf5IO.h	11;"	d
H5NS	lib/serialisation/Hdf5Type.h	9;"	d
HADRON_ERROR	extras/Hadrons/Global.hpp	100;"	d
HADRON_ERROR	lib/Hadrons/Global.hpp	100;"	d
HALF	lib/algorithms/approx/Zolotarev.cc	50;"	d	file:
HAND_DECLARATIONS	lib/qcd/action/fermion/WilsonKernelsHand.cc	391;"	d	file:
HAND_RESULT	lib/qcd/action/fermion/WilsonKernelsHand.cc	356;"	d	file:
HAND_RESULT_EXT	lib/qcd/action/fermion/WilsonKernelsHand.cc	373;"	d	file:
HAND_SPECIALISE_EMPTY	lib/qcd/action/fermion/WilsonKernelsHand.cc	599;"	d	file:
HAND_STENCIL_LEG	lib/qcd/action/fermion/WilsonKernelsHand.cc	310;"	d	file:
HAND_STENCIL_LEG_EXT	lib/qcd/action/fermion/WilsonKernelsHand.cc	346;"	d	file:
HAND_STENCIL_LEG_INT	lib/qcd/action/fermion/WilsonKernelsHand.cc	327;"	d	file:
HASH	lib/simd/IBM_qpx.h	100;"	d
HASHit	lib/simd/IBM_qpx.h	99;"	d
HAVE_HDF5	tests/IO/Test_serialisation.cc	155;"	d	file:
HCoeffsType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR
HCoeffsType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
HCoeffsType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR
HCoeffsType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
HCoeffsType	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR
HDF5_DEF_DATASET_THRES	lib/serialisation/Hdf5IO.h	16;"	d
HDF5_GRID_GUARD	lib/serialisation/Hdf5IO.h	20;"	d
HDF5_NATIVE_TYPE	lib/serialisation/Hdf5Type.h	12;"	d
HDF5_NATIVE_TYPE	lib/serialisation/Hdf5Type.h	75;"	d
HDim	lib/Eigen/src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon591
HDim	lib/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon596
HDim	lib/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon597
HDim	lib/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon598
HDim	lib/Eigen/src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon593
HEADER_PUGICONFIG_HPP	lib/pugixml/pugiconfig.hpp	15;"	d
HEADER_PUGIXML_HPP	lib/pugixml/pugixml.h	23;"	d
HMCBaseMod	lib/qcd/hmc/HMCRunnerModule.h	/^  typedef HMCModule< QCD::GenericHMCRunnerTemplate<ImplementationPolicy, RepresentationPolicy, QCD::ForceGradient>, ReaderClass   > HMCBaseMod;$/;"	t	class:Grid::HMCForceGradient
HMCBaseMod	lib/qcd/hmc/HMCRunnerModule.h	/^  typedef HMCModule< QCD::GenericHMCRunnerTemplate<ImplementationPolicy, RepresentationPolicy, QCD::LeapFrog>, ReaderClass  > HMCBaseMod;$/;"	t	class:Grid::HMCLeapFrog
HMCBaseMod	lib/qcd/hmc/HMCRunnerModule.h	/^  typedef HMCModule< QCD::GenericHMCRunnerTemplate<ImplementationPolicy, RepresentationPolicy, QCD::MinimumNorm2>, ReaderClass  > HMCBaseMod;$/;"	t	class:Grid::HMCMinimumNorm2
HMCForceGradient	lib/qcd/hmc/HMCRunnerModule.h	/^class HMCForceGradient: public HMCModule< QCD::GenericHMCRunnerTemplate<ImplementationPolicy, RepresentationPolicy, QCD::ForceGradient>, ReaderClass  >{$/;"	c	namespace:Grid
HMCLeapFrog	lib/qcd/hmc/HMCRunnerModule.h	/^class HMCLeapFrog: public HMCModule< QCD::GenericHMCRunnerTemplate<ImplementationPolicy, RepresentationPolicy, QCD::LeapFrog>, ReaderClass >{$/;"	c	namespace:Grid
HMCMinimumNorm2	lib/qcd/hmc/HMCRunnerModule.h	/^class HMCMinimumNorm2: public HMCModule< QCD::GenericHMCRunnerTemplate<ImplementationPolicy, RepresentationPolicy, QCD::MinimumNorm2>, ReaderClass  >{$/;"	c	namespace:Grid
HMCModule	lib/qcd/hmc/HMCRunnerModule.h	/^  HMCModule(QCD::HMCparameters Par) : Parametrized<QCD::HMCparameters>(Par) {}$/;"	f	class:Grid::HMCModule
HMCModule	lib/qcd/hmc/HMCRunnerModule.h	/^  HMCModule(Reader<ReaderCl>& R) : Parametrized<QCD::HMCparameters>(R, "HMC"){};$/;"	f	class:Grid::HMCModule
HMCModule	lib/qcd/hmc/HMCRunnerModule.h	/^class HMCModule$/;"	c	namespace:Grid
HMCModuleBase	lib/qcd/modules/Modules.h	/^class HMCModuleBase {$/;"	c	namespace:Grid
HMCModuleFactory	lib/qcd/modules/Registration.h	/^typedef HMCRunnerModuleFactory<hmc_string, Serialiser > HMCModuleFactory;$/;"	t
HMCPtr	lib/qcd/hmc/HMCRunnerModule.h	/^  std::unique_ptr<HMCType> HMCPtr;$/;"	m	class:Grid::HMCModule
HMCResourceManager	lib/qcd/hmc/HMCResourceManager.h	/^  HMCResourceManager() : have_RNG(false), have_CheckPointer(false) {}$/;"	f	class:Grid::QCD::HMCResourceManager
HMCResourceManager	lib/qcd/hmc/HMCResourceManager.h	/^class HMCResourceManager {$/;"	c	namespace:Grid::QCD
HMCRunnerBase	lib/qcd/hmc/GenericHMCrunner.h	/^class HMCRunnerBase {$/;"	c	namespace:Grid::QCD
HMCRunnerModuleFactory	lib/qcd/hmc/HMCRunnerModule.h	/^class HMCRunnerModuleFactory$/;"	c	namespace:Grid
HMCWrapperTemplate	lib/qcd/hmc/GenericHMCrunner.h	/^  HMCWrapperTemplate(HMCparameters Par){$/;"	f	class:Grid::QCD::HMCWrapperTemplate
HMCWrapperTemplate	lib/qcd/hmc/GenericHMCrunner.h	/^class HMCWrapperTemplate: public HMCRunnerBase<ReaderClass> {$/;"	c	namespace:Grid::QCD
HMC_AGGREGATE_INCLUDED	lib/qcd/hmc/HMC_aggregate.h	32;"	d
HMC_ActionModuleFactory	lib/qcd/modules/ActionModules.h	/^class HMC_ActionModuleFactory$/;"	c	namespace:Grid
HMC_CPModuleFactory	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^class HMC_CPModuleFactory$/;"	c	namespace:Grid
HMC_FermionOperatorModuleFactory	lib/qcd/modules/FermionOperatorModules.h	/^class HMC_FermionOperatorModuleFactory$/;"	c	namespace:Grid
HMC_GRID_MODULES	lib/qcd/hmc/HMC_GridModules.h	31;"	d
HMC_INCLUDED	lib/qcd/hmc/HMC.h	40;"	d
HMC_MODULES_H	lib/qcd/modules/Modules.h	30;"	d
HMC_OBSERVABLE_H	lib/qcd/observables/hmc_observable.h	31;"	d
HMC_OBSERVABLE_MODULES_H	lib/qcd/modules/ObservableModules.h	30;"	d
HMC_ObservablesModuleFactory	lib/qcd/modules/ObservableModules.h	/^class HMC_ObservablesModuleFactory$/;"	c	namespace:Grid
HMC_PLAQUETTE_H	lib/qcd/observables/plaquette.h	31;"	d
HMC_RESOURCE_MANAGER_H	lib/qcd/hmc/HMCResourceManager.h	31;"	d
HMC_RUNNER_MODULE	lib/qcd/hmc/HMCRunnerModule.h	31;"	d
HMC_SolverModuleFactory	lib/qcd/modules/SolverModules.h	/^class HMC_SolverModuleFactory$/;"	c	namespace:Grid
HMC_TOP_CHARGE_H	lib/qcd/observables/topological_charge.h	31;"	d
HMC_TYPES_H	lib/qcd/representations/hmc_types.h	2;"	d
HMCparameters	lib/qcd/hmc/HMC.h	/^  HMCparameters() {$/;"	f	struct:Grid::QCD::HMCparameters
HMCparameters	lib/qcd/hmc/HMC.h	/^  HMCparameters(Reader<ReaderClass> & TheReader){$/;"	f	struct:Grid::QCD::HMCparameters
HMCparameters	lib/qcd/hmc/HMC.h	/^struct HMCparameters: Serializable {$/;"	s	namespace:Grid::QCD
HNormalizedReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(ConstStartMinusOne,Scalar,quotient) HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase
HNormalizedReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Block	lib/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Factors	lib/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Size	lib/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon160
HNormalized_SizeMinusOne	lib/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon160
HVERSION	lib/algorithms/approx/Zolotarev.h	8;"	d
HadronsLogger	extras/Hadrons/Global.hpp	/^    HadronsLogger(int on, std::string nm): Logger("Hadrons", on, nm,$/;"	f	class:HadronsLogger
HadronsLogger	extras/Hadrons/Global.hpp	/^class HadronsLogger: public Logger$/;"	c
HadronsLogger	lib/Hadrons/Global.hpp	/^    HadronsLogger(int on, std::string nm): Logger("Hadrons", on, nm,$/;"	f	class:HadronsLogger
HadronsLogger	lib/Hadrons/Global.hpp	/^class HadronsLogger: public Logger$/;"	c
Hadrons_Application_hpp_	extras/Hadrons/Application.hpp	31;"	d
Hadrons_Application_hpp_	lib/Hadrons/Application.hpp	31;"	d
Hadrons_Environment_hpp_	extras/Hadrons/Environment.hpp	31;"	d
Hadrons_Environment_hpp_	lib/Hadrons/Environment.hpp	31;"	d
Hadrons_Factory_hpp_	extras/Hadrons/Factory.hpp	31;"	d
Hadrons_Factory_hpp_	lib/Hadrons/Factory.hpp	31;"	d
Hadrons_GeneticScheduler_hpp_	extras/Hadrons/GeneticScheduler.hpp	31;"	d
Hadrons_GeneticScheduler_hpp_	lib/Hadrons/GeneticScheduler.hpp	31;"	d
Hadrons_Global_hpp_	extras/Hadrons/Global.hpp	31;"	d
Hadrons_Global_hpp_	lib/Hadrons/Global.hpp	31;"	d
Hadrons_Graph_hpp_	extras/Hadrons/Graph.hpp	31;"	d
Hadrons_Graph_hpp_	lib/Hadrons/Graph.hpp	31;"	d
Hadrons_MAction_DWF_hpp_	extras/Hadrons/Modules/MAction/DWF.hpp	31;"	d
Hadrons_MAction_DWF_hpp_	lib/Hadrons/Modules/MAction/DWF.hpp	31;"	d
Hadrons_MAction_Wilson_hpp_	extras/Hadrons/Modules/MAction/Wilson.hpp	31;"	d
Hadrons_MAction_Wilson_hpp_	lib/Hadrons/Modules/MAction/Wilson.hpp	31;"	d
Hadrons_MContraction_Baryon_hpp_	extras/Hadrons/Modules/MContraction/Baryon.hpp	31;"	d
Hadrons_MContraction_Baryon_hpp_	lib/Hadrons/Modules/MContraction/Baryon.hpp	31;"	d
Hadrons_MContraction_DiscLoop_hpp_	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	30;"	d
Hadrons_MContraction_DiscLoop_hpp_	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	30;"	d
Hadrons_MContraction_Gamma3pt_hpp_	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	30;"	d
Hadrons_MContraction_Gamma3pt_hpp_	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	30;"	d
Hadrons_MContraction_Meson_hpp_	extras/Hadrons/Modules/MContraction/Meson.hpp	33;"	d
Hadrons_MContraction_Meson_hpp_	lib/Hadrons/Modules/MContraction/Meson.hpp	33;"	d
Hadrons_MContraction_WeakHamiltonianEye_hpp_	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	30;"	d
Hadrons_MContraction_WeakHamiltonianEye_hpp_	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	30;"	d
Hadrons_MContraction_WeakHamiltonianNonEye_hpp_	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	30;"	d
Hadrons_MContraction_WeakHamiltonianNonEye_hpp_	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	30;"	d
Hadrons_MContraction_WeakHamiltonian_hpp_	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	30;"	d
Hadrons_MContraction_WeakHamiltonian_hpp_	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	30;"	d
Hadrons_MContraction_WeakNeutral4ptDisc_hpp_	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	30;"	d
Hadrons_MContraction_WeakNeutral4ptDisc_hpp_	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	30;"	d
Hadrons_MFermion_GaugeProp_hpp_	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	2;"	d
Hadrons_MFermion_GaugeProp_hpp_	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	2;"	d
Hadrons_MGauge_Load_hpp_	extras/Hadrons/Modules/MGauge/Load.hpp	31;"	d
Hadrons_MGauge_Load_hpp_	lib/Hadrons/Modules/MGauge/Load.hpp	31;"	d
Hadrons_MGauge_Random_hpp_	extras/Hadrons/Modules/MGauge/Random.hpp	31;"	d
Hadrons_MGauge_Random_hpp_	lib/Hadrons/Modules/MGauge/Random.hpp	31;"	d
Hadrons_MGauge_StochEm_hpp_	extras/Hadrons/Modules/MGauge/StochEm.hpp	29;"	d
Hadrons_MGauge_StochEm_hpp_	lib/Hadrons/Modules/MGauge/StochEm.hpp	29;"	d
Hadrons_MGauge_Unit_hpp_	extras/Hadrons/Modules/MGauge/Unit.hpp	31;"	d
Hadrons_MGauge_Unit_hpp_	lib/Hadrons/Modules/MGauge/Unit.hpp	31;"	d
Hadrons_MLoop_NoiseLoop_hpp_	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	30;"	d
Hadrons_MLoop_NoiseLoop_hpp_	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	30;"	d
Hadrons_MScalar_ChargedProp_hpp_	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	2;"	d
Hadrons_MScalar_ChargedProp_hpp_	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	2;"	d
Hadrons_MScalar_FreeProp_hpp_	extras/Hadrons/Modules/MScalar/FreeProp.hpp	2;"	d
Hadrons_MScalar_FreeProp_hpp_	lib/Hadrons/Modules/MScalar/FreeProp.hpp	2;"	d
Hadrons_MSink_Point_hpp_	extras/Hadrons/Modules/MSink/Point.hpp	2;"	d
Hadrons_MSink_Point_hpp_	lib/Hadrons/Modules/MSink/Point.hpp	2;"	d
Hadrons_MSolver_RBPrecCG_hpp_	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	31;"	d
Hadrons_MSolver_RBPrecCG_hpp_	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	31;"	d
Hadrons_MSource_Point_hpp_	extras/Hadrons/Modules/MSource/Point.hpp	31;"	d
Hadrons_MSource_Point_hpp_	lib/Hadrons/Modules/MSource/Point.hpp	31;"	d
Hadrons_MSource_SeqGamma_hpp_	extras/Hadrons/Modules/MSource/SeqGamma.hpp	32;"	d
Hadrons_MSource_SeqGamma_hpp_	lib/Hadrons/Modules/MSource/SeqGamma.hpp	32;"	d
Hadrons_MSource_WallSource_hpp_	extras/Hadrons/Modules/MSource/Wall.hpp	30;"	d
Hadrons_MSource_WallSource_hpp_	lib/Hadrons/Modules/MSource/Wall.hpp	30;"	d
Hadrons_MSource_Z2_hpp_	extras/Hadrons/Modules/MSource/Z2.hpp	31;"	d
Hadrons_MSource_Z2_hpp_	lib/Hadrons/Modules/MSource/Z2.hpp	31;"	d
Hadrons_ModuleFactory_hpp_	extras/Hadrons/ModuleFactory.hpp	31;"	d
Hadrons_ModuleFactory_hpp_	lib/Hadrons/ModuleFactory.hpp	31;"	d
Hadrons_Module_hpp_	extras/Hadrons/Module.hpp	31;"	d
Hadrons_Module_hpp_	lib/Hadrons/Module.hpp	31;"	d
Hadrons_Scalar_hpp_	extras/Hadrons/Modules/MScalar/Scalar.hpp	2;"	d
Hadrons_Scalar_hpp_	lib/Hadrons/Modules/MScalar/Scalar.hpp	2;"	d
HalfLength	lib/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon120
HalfLength	lib/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon122
HalfPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::half HalfPacket;$/;"	t	class:Eigen::internal::BlasLinearMapper
HalfPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::half HalfPacket;$/;"	t	class:Eigen::internal::blas_data_mapper
HalfSpinColourVector	lib/qcd/QCD.h	/^    typedef iHalfSpinColourVector<Complex > HalfSpinColourVector;$/;"	t	namespace:Grid::QCD
HalfSpinColourVectorD	lib/qcd/QCD.h	/^    typedef iHalfSpinColourVector<ComplexD> HalfSpinColourVectorD;$/;"	t	namespace:Grid::QCD
HalfSpinColourVectorF	lib/qcd/QCD.h	/^    typedef iHalfSpinColourVector<ComplexF> HalfSpinColourVectorF;$/;"	t	namespace:Grid::QCD
HalfSpinVector	lib/qcd/QCD.h	/^    typedef iHalfSpinVector<Complex >       HalfSpinVector;$/;"	t	namespace:Grid::QCD
HalfSpinVectorD	lib/qcd/QCD.h	/^    typedef iHalfSpinVector<ComplexD>       HalfSpinVectorD;$/;"	t	namespace:Grid::QCD
HalfSpinVectorF	lib/qcd/QCD.h	/^    typedef iHalfSpinVector<ComplexF>       HalfSpinVectorF;$/;"	t	namespace:Grid::QCD
HaloExchange	lib/stencil/Stencil.h	/^  template<class compressor> void HaloExchange(const Lattice<vobj> &source,compressor &compress) $/;"	f	class:Grid::CartesianStencil
HaloExchangeOpt	lib/qcd/action/fermion/WilsonCompressor.h	/^  void HaloExchangeOpt(const Lattice<vobj> &source,compressor &compress) $/;"	f	class:Grid::QCD::WilsonStencil
HaloExchangeOptGather	lib/qcd/action/fermion/WilsonCompressor.h	/^  void HaloExchangeOptGather(const Lattice<vobj> &source,compressor &compress) $/;"	f	class:Grid::QCD::WilsonStencil
HaloGather	lib/stencil/Stencil.h	/^  void HaloGather(const Lattice<vobj> &source,compressor &compress)$/;"	f	class:Grid::CartesianStencil
HaloGatherDir	lib/stencil/Stencil.h	/^  template<class compressor> int HaloGatherDir(const Lattice<vobj> &source,compressor &compress,int point,int & face_idx)$/;"	f	class:Grid::CartesianStencil
HaloGatherOpt	lib/qcd/action/fermion/WilsonCompressor.h	/^  void HaloGatherOpt(const Lattice<vobj> &source,compressor &compress)$/;"	f	class:Grid::QCD::WilsonStencil
HandDhopSite	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^WilsonKernels<Impl>::HandDhopSite(StencilImpl &st,LebesgueOrder &lo,DoubledGaugeField &U,SiteHalfSpinor  *buf,$/;"	f	class:Grid::QCD::WilsonKernels
HandDhopSiteDag	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^void WilsonKernels<Impl>::HandDhopSiteDag(StencilImpl &st,LebesgueOrder &lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
HandDhopSiteDagExt	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^void WilsonKernels<Impl>::HandDhopSiteDagExt(StencilImpl &st,LebesgueOrder &lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
HandDhopSiteDagInt	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^void WilsonKernels<Impl>::HandDhopSiteDagInt(StencilImpl &st,LebesgueOrder &lo,DoubledGaugeField &U,SiteHalfSpinor *buf,$/;"	f	class:Grid::QCD::WilsonKernels
HandDhopSiteExt	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^WilsonKernels<Impl>::HandDhopSiteExt(StencilImpl &st,LebesgueOrder &lo,DoubledGaugeField &U,SiteHalfSpinor  *buf,$/;"	f	class:Grid::QCD::WilsonKernels
HandDhopSiteInt	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^WilsonKernels<Impl>::HandDhopSiteInt(StencilImpl &st,LebesgueOrder &lo,DoubledGaugeField &U,SiteHalfSpinor  *buf,$/;"	f	class:Grid::QCD::WilsonKernels
HandOptDslash	lib/qcd/action/fermion/WilsonFermion.cc	/^int WilsonFermionStatic::HandOptDslash;$/;"	m	class:Grid::QCD::WilsonFermionStatic	file:
HandOptDslash	lib/qcd/action/fermion/WilsonFermion.h	/^  static int HandOptDslash;  \/\/ these are a temporary hack$/;"	m	class:Grid::QCD::WilsonFermionStatic
HandShake	lib/communicator/Communicator_shmem.cc	/^} HandShake;$/;"	t	namespace:Grid	typeref:struct:Grid::HandShake_t	file:
HandShake_t	lib/communicator/Communicator_shmem.cc	/^typedef struct HandShake_t { $/;"	s	namespace:Grid	file:
HasACos	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasASin	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasATan	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasATan   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasAbs	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasAbs	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasAbs	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasAbs	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasAbs	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasAbs	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasAbs	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasAbs	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasAbs	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasAbs	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasAbs	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasAbs	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasAbs	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasAbs	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasAbs	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasAbs	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasAbs2	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasAbs2	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasAbs2	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasAbs2	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasAbs2	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasAbs2	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasAbs2	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasAbs2	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasAbs2	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasAbs2	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasAbs2	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasAbs2	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasAdd	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasAdd	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasAdd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasAdd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasAdd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasAdd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasAdd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasAdd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
HasAdd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasAdd	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasAdd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasAdd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasAdd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasAdd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasAdd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasAdd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasAdd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
HasAdd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasAdd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasArg	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasArg    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasBetaInc	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasBetaInc = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasBetaInc	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBetaInc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasBetaInc	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBetaInc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasBlend	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasBlend  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasBlend	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasBlend = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasBlend	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasBlend = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasBlend	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasBlend  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasBlend	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasBlend	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon321
HasBlend	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasBlend	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBlend = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasBlend	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBlend = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasBlend	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasBlend	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasBlend	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasBlend	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon335
HasBlend	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasBlend  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasBlend	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon309
HasBlend	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasBlend	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasCeil	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasCeil   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasCeil	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasCeil	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasCeil	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasCeil	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasCeil	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasCeil	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasCeil	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasCeil	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasConj	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasConj	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasCos	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasCos	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasCos	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasCos	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasCos	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasCos	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
HasCos	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
HasCos	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasCos	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasCos	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasCosh	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasCosh   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasDiGamma	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasDiGamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasDiGamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasDiGamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasDirectAccess	lib/Eigen/src/Core/Ref.h	/^      HasDirectAccess = internal::has_direct_access<Derived>::ret,$/;"	e	enum:Eigen::internal::traits::match::__anon150
HasDiv	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasDiv	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasDiv	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasDiv	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasDiv	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasDiv	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasDiv = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon352
HasDiv	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasDiv = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon353
HasDiv	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasDiv	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasDiv	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasDiv  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
HasDiv	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasDiv	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasDiv	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasDiv	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasDiv	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasDiv	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasDiv	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasDiv	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
HasDiv	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
HasDiv	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasDiv	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasDiv	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasDiv	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasDiv	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasDiv	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasDiv	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
HasDiv	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasDiv	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasErf	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasErf = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasErf	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErf = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasErf	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErf = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasErfc	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasErfc = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasErfc	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErfc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasErfc	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErfc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasExp	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasExp	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasExp	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasExp	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasExp = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
HasExp	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasExp	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasExp	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasExp	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasExp	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasExp    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasExp	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
HasExp	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
HasExp	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasExp	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasExp	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasExp	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasFloor	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasFloor  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasFloor	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasFloor	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasFloor	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasFloor	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasFloor	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasFloor	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasFloor	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasFloor	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasHalfPacket	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasHalfPacket = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon507
HasHalfPacket	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasHalfPacket	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasHalfPacket	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasHalfPacket	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasHalfPacket	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasHalfPacket	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
HasHalfPacket	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon353
HasHalfPacket	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasHalfPacket	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasHalfPacket	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
HasHalfPacket	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasHalfPacket	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasHalfPacket	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasHalfPacket	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasHalfPacket	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasHalfPacket	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasHalfPacket	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasHalfPacket	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasHalfPacket=0 \/\/ Packet2i intrinsics not implemented yet$/;"	e	enum:Eigen::internal::packet_traits::__anon282
HasHalfPacket	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasHalfPacket=0, \/\/ Packet2f intrinsics not implemented yet$/;"	e	enum:Eigen::internal::packet_traits::__anon281
HasHalfPacket	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasHalfPacket=0,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
HasHalfPacket	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasHalfPacket	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasHalfPacket	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasHalfPacket	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasHalfPacket	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasHalfPacket	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasHalfPacket	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
HasHalfPacket	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasHalfPacket	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasIGamma	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasIGamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasIGamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasIGamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasIGammac	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasIGammac = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasIGammac	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGammac = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasIGammac	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGammac = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasLGamma	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasLGamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasLGamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasLGamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasLog	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasLog	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasLog	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasLog = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
HasLog	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasLog	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasLog	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasLog	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasLog	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasLog    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasLog	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
HasLog	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
HasLog	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasLog	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasLog	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasLog10	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasLog10  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasLog1p	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasLog1p  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasLog1p	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasLog1p  = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasMax	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasMax	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasMax	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasMax	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasMax	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasMax	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasMax	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasMax	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasMax	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasMax	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasMax	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasMax	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasMax	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasMax	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasMax	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasMax	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasMin	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasMin	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasMin	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasMin	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasMin	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasMin	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasMin	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasMin	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasMin	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasMin	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasMin	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasMin	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasMin	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasMin	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasMin	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasMin	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasMul	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasMul	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasMul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasMul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasMul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasMul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasMul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasMul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
HasMul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasMul	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasMul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasMul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasMul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasMul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasMul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasMul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasMul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
HasMul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasMul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasNegate	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasNegate	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasNegate	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasNegate	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasNegate	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasNegate	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasNegate	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasNegate	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasNegate	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasNegate	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasNegate	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasNegate	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasNegate	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasNegate	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasNegate	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasNegate	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasNoInnerStride	lib/Eigen/src/Core/CoreEvaluators.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::evaluator::__anon235
HasNoOuterStride	lib/Eigen/src/Core/CoreEvaluators.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::evaluator::__anon235
HasNoStride	lib/Eigen/src/Core/CoreEvaluators.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::evaluator::__anon235
HasPolygamma	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasPolygamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasPolygamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasPolygamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasPolygamma	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasPolygamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasPow	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasRound	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasRound  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasRound	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasRound	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasRound	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasRound	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasRound	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasRound	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasRound	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasRound	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasRsqrt	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasRsqrt  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasRsqrt	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasRsqrt	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasRsqrt	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
HasRsqrt	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasRsqrt = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon353
HasRsqrt	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasRsqrt	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasRsqrt	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasRsqrt	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasRsqrt	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasRsqrt  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasRsqrt	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasRsqrt	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasRsqrt	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasRsqrt	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasSameStorageOrderAsArgType	lib/Eigen/src/Core/CoreEvaluators.h	/^    HasSameStorageOrderAsArgType = (IsRowMajor == ArgTypeIsRowMajor),$/;"	e	enum:Eigen::internal::evaluator::__anon237
HasSameStorageOrderAsXprType	lib/Eigen/src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon213
HasSetLinear	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasSetLinear	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasSetLinear	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasSetLinear	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasSetLinear	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasSetLinear	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasSetLinear	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasSetLinear	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasSetLinear	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasSetLinear	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasSetLinear	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasSetLinear	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasSign	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSign   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasSin	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasSin	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasSin	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasSin	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasSin	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasSin	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
HasSin	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
HasSin	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasSin	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasSin	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasSinh	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSinh   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasSqrt	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasSqrt	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasSqrt	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
HasSqrt	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
HasSqrt	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon353
HasSqrt	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasSqrt	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasSqrt	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasSqrt	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
HasSqrt	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasSqrt   = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
HasSqrt	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon281
HasSqrt	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon285
HasSqrt	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasSqrt	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
HasSqrt	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasSqrt	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasSub	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon508
HasSub	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasSub	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
HasSub	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
HasSub	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
HasSub	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
HasSub	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
HasSub	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
HasSub	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
HasSub	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
HasSub	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
HasSub	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
HasSub	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
HasSub	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
HasSub	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
HasSub	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
HasSub	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
HasSub	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
HasTan	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasTanh	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasTanh   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasTanh	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasTanh  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
HasTanh	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasTanh  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
HasUnitDiag	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon365
HasUnitDiag	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon366
HasUnitDiag	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::TriangularViewImpl::__anon559
HasUnitDiag	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^         HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::internal::unary_evaluator::__anon560
HasUsableDirectAccess	lib/Eigen/src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon25
HasZeroDiag	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon365
HasZeroDiag	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon366
HasZeta	lib/Eigen/src/Core/GenericPacketMath.h	/^    HasZeta = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon506
HasZeta	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasZeta = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasZeta	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasZeta = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
Hdf5Reader	lib/serialisation/Hdf5IO.cc	/^Hdf5Reader::Hdf5Reader(const std::string &fileName)$/;"	f	class:Hdf5Reader
Hdf5Reader	lib/serialisation/Hdf5IO.h	/^  class Hdf5Reader: public Reader<Hdf5Reader>$/;"	c	namespace:Grid
Hdf5Type	lib/serialisation/Hdf5Type.h	/^  class Hdf5Type<std::complex<R>>$/;"	c	namespace:Grid
Hdf5Type	lib/serialisation/Hdf5Type.h	/^  template <typename T> class Hdf5Type$/;"	c	namespace:Grid
Hdf5Writer	lib/serialisation/Hdf5IO.cc	/^Hdf5Writer::Hdf5Writer(const std::string &fileName)$/;"	f	class:Hdf5Writer
Hdf5Writer	lib/serialisation/Hdf5IO.h	/^  class Hdf5Writer: public Writer<Hdf5Writer>$/;"	c	namespace:Grid
HereditaryBits	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
HermOp	lib/algorithms/LinearOperator.h	/^      void HermOp(const Field &in, Field &out){$/;"	f	class:Grid::HermitianLinearOperator
HermOp	lib/algorithms/LinearOperator.h	/^      void HermOp(const Field &in, Field &out){$/;"	f	class:Grid::MdagMLinearOperator
HermOp	lib/algorithms/LinearOperator.h	/^      void HermOp(const Field &in, Field &out){$/;"	f	class:Grid::SchurOperatorBase
HermOp	lib/algorithms/LinearOperator.h	/^      void HermOp(const Field &in, Field &out){$/;"	f	class:Grid::ShiftedMdagMLinearOperator
HermOp	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void HermOp(const Field &in, Field &out){$/;"	f	class:Grid::QCD::Gamma5HermitianLinearOperator
HermOp	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void HermOp(const Field &in, Field &out){$/;"	f	class:Grid::QCD::Gamma5R5HermitianLinearOperator
HermOp	tests/debug/Test_synthetic_lanczos.cc	/^  void HermOp(const Field &in, Field &out){$/;"	f	class:DumbOperator
HermOp	tests/hmc/Test_multishift_sqrt.cc	/^  void HermOp(const Field &in, Field &out){$/;"	f	class:DumbOperator
HermOpAndNorm	lib/algorithms/LinearOperator.h	/^      void HermOpAndNorm(const Field &in, Field &out,RealD &n1,RealD &n2){$/;"	f	class:Grid::HermitianLinearOperator
HermOpAndNorm	lib/algorithms/LinearOperator.h	/^      void HermOpAndNorm(const Field &in, Field &out,RealD &n1,RealD &n2){$/;"	f	class:Grid::MdagMLinearOperator
HermOpAndNorm	lib/algorithms/LinearOperator.h	/^      void HermOpAndNorm(const Field &in, Field &out,RealD &n1,RealD &n2){$/;"	f	class:Grid::SchurOperatorBase
HermOpAndNorm	lib/algorithms/LinearOperator.h	/^      void HermOpAndNorm(const Field &in, Field &out,RealD &n1,RealD &n2){$/;"	f	class:Grid::ShiftedMdagMLinearOperator
HermOpAndNorm	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void HermOpAndNorm(const Field &in, Field &out,RealD &n1,RealD &n2){$/;"	f	class:Grid::QCD::Gamma5HermitianLinearOperator
HermOpAndNorm	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void HermOpAndNorm(const Field &in, Field &out,RealD &n1,RealD &n2){$/;"	f	class:Grid::QCD::Gamma5R5HermitianLinearOperator
HermOpAndNorm	tests/debug/Test_synthetic_lanczos.cc	/^  void HermOpAndNorm(const Field &in, Field &out,double &n1,double &n2){$/;"	f	class:DumbOperator
HermOpAndNorm	tests/hmc/Test_multishift_sqrt.cc	/^  void HermOpAndNorm(const Field &in, Field &out,double &n1,double &n2){$/;"	f	class:DumbOperator
HermOpOperatorFunction	lib/algorithms/approx/Chebyshev.h	/^  class HermOpOperatorFunction : public OperatorFunction<Field> {$/;"	c	namespace:Grid
HermitianLinearOperator	lib/algorithms/LinearOperator.h	/^    HermitianLinearOperator(Matrix &Mat): _Mat(Mat){};$/;"	f	class:Grid::HermitianLinearOperator
HermitianLinearOperator	lib/algorithms/LinearOperator.h	/^    class HermitianLinearOperator : public LinearOperatorBase<Field> {$/;"	c	namespace:Grid
HessenbergDecomposition	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    explicit HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    explicit HessenbergDecomposition(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
HessenbergDecompositionMatrixHReturnType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
HessenbergDecompositionMatrixHReturnType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal
HigherPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef T HigherPrecVector ;$/;"	t	struct:Grid::QCD::SamePrecisionMapper
HigherPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vComplexD HigherPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
HigherPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vComplexF HigherPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
HigherPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vRealD HigherPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
HigherPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vRealF HigherPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
HmCayleyTanh	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HmCayleyTanh, \/\/ Scaled shamir 13$/;"	e	enum:ChromaAction	file:
HmCayleyZolo	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HmCayleyZolo, \/\/ Scaled shamir 13$/;"	e	enum:ChromaAction	file:
HmcObservable	lib/qcd/observables/hmc_observable.h	/^class HmcObservable {$/;"	c	namespace:Grid
Holder	extras/Hadrons/Environment.hpp	/^Holder<T>::Holder(T *pt)$/;"	f	class:Holder
Holder	extras/Hadrons/Environment.hpp	/^class Holder: public Object$/;"	c
Holder	lib/Hadrons/Environment.hpp	/^Holder<T>::Holder(T *pt)$/;"	f	class:Holder
Holder	lib/Hadrons/Environment.hpp	/^class Holder: public Object$/;"	c
Homogeneous	lib/Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC explicit inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous
Homogeneous	lib/Eigen/src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen
HomogeneousDimension	lib/Eigen/src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon612
HomogeneousReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase
HomogeneousReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef Homogeneous<ExpressionType,Direction> HomogeneousReturnType;$/;"	t	class:Eigen::VectorwiseOp
HomogeneousReturnTypeDirection	lib/Eigen/src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1&&RowsAtCompileTime==1 ? ((internal::traits<Derived>::Flags&RowMajorBit)==RowMajorBit ? Horizontal : Vertical)$/;"	e	enum:Eigen::MatrixBase::__anon151
HomogeneousShape	lib/Eigen/src/Core/util/Constants.h	/^struct HomogeneousShape       { static std::string debugName() { return "HomogeneousShape"; } };$/;"	s	namespace:Eigen
Horizontal	lib/Eigen/src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
HorizontalComm	lib/communicator/Communicator_mpi3_leader.cc	/^  static MPI_Comm HorizontalComm;$/;"	m	class:Grid::MPIoffloadEngine	file:
HorizontalComm	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Comm MPIoffloadEngine::HorizontalComm;$/;"	m	class:Grid::MPIoffloadEngine	file:
HorizontalRank	lib/communicator/Communicator_mpi3_leader.cc	/^  static int HorizontalRank;$/;"	m	class:Grid::MPIoffloadEngine	file:
HorizontalRank	lib/communicator/Communicator_mpi3_leader.cc	/^int      MPIoffloadEngine::HorizontalRank;$/;"	m	class:Grid::MPIoffloadEngine	file:
HorizontalSize	lib/communicator/Communicator_mpi3_leader.cc	/^  static int HorizontalSize;$/;"	m	class:Grid::MPIoffloadEngine	file:
HorizontalSize	lib/communicator/Communicator_mpi3_leader.cc	/^int      MPIoffloadEngine::HorizontalSize;$/;"	m	class:Grid::MPIoffloadEngine	file:
HotConfiguration	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline void HotConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::QCD::GaugeImplTypes
HotConfiguration	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void HotConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::ScalarAdjMatrixImplTypes
HotConfiguration	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void HotConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::ScalarImplTypes
HotConfiguration	lib/qcd/utils/SUn.h	/^  static void HotConfiguration(GridParallelRNG &pRNG, GaugeField &out) {$/;"	f	class:Grid::QCD::SU
HouseholderQR	lib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	lib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	lib/Eigen/src/QR/HouseholderQR.h	/^    explicit HouseholderQR(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	lib/Eigen/src/QR/HouseholderQR.h	/^    explicit HouseholderQR(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	lib/Eigen/src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
HouseholderQRPreconditioner	lib/Eigen/src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
HouseholderSequence	lib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	lib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	lib/Eigen/src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen
HouseholderSequenceShape	lib/Eigen/src/Householder/HouseholderSequence.h	/^struct HouseholderSequenceShape {};$/;"	s	namespace:Eigen::internal
HouseholderSequenceType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition
HouseholderSequenceType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization
HouseholderSequenceType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
HouseholderSequenceType	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR
HouseholderSequenceType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      HouseholderSequenceType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
HouseholderSequenceType	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR
HouseholderUSequenceType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
HouseholderVSequenceType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
HtCayleyTanh	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HtCayleyTanh, \/\/ Plain old DWF.$/;"	e	enum:ChromaAction	file:
HtCayleyZolo	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HtCayleyZolo, \/\/ $/;"	e	enum:ChromaAction	file:
HtContFracTanh	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HtContFracTanh,$/;"	e	enum:ChromaAction	file:
HtContFracZolo	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HtContFracZolo$/;"	e	enum:ChromaAction	file:
HtoD	lib/simd/Grid_avx.h	/^    static inline void HtoD (__m256i h,__m256d &a,__m256d &b,__m256d &c,__m256d &d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoD	lib/simd/Grid_avx512.h	/^    static inline void HtoD (__m512i h,__m512d &a,__m512d &b,__m512d &c,__m512d &d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoD	lib/simd/Grid_generic.h	/^    static inline void HtoD (vech h,vecd &a,vecd &b,vecd &c,vecd &d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoD	lib/simd/Grid_neon.h	/^    static inline void HtoD (float16x8_t h,float64x2_t &a,float64x2_t &b,float64x2_t &c,float64x2_t &d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoD	lib/simd/Grid_qpx.h	/^    static inline void HtoD (vech h, vector4double &a, vector4double &b, $/;"	f	struct:Grid::Optimization::PrecisionChange
HtoD	lib/simd/Grid_sse4.h	/^    static inline void HtoD (__m128i h,__m128d &a,__m128d &b,__m128d &c,__m128d &d) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoS	lib/simd/Grid_avx.h	/^    static inline void  HtoS (__m256i h,__m256 &sa,__m256 &sb) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoS	lib/simd/Grid_avx512.h	/^    static inline void  HtoS (__m512i h,__m512 &sa,__m512 &sb) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoS	lib/simd/Grid_generic.h	/^    static inline void  HtoS (vech h,vecf &sa,vecf &sb) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoS	lib/simd/Grid_neon.h	/^    static inline void  HtoS (float16x8_t h,float32x4_t &sa,float32x4_t &sb) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoS	lib/simd/Grid_qpx.h	/^    static inline void  HtoS (vech h, vector4float &sa, vector4float &sb) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HtoS	lib/simd/Grid_sse4.h	/^    static inline void  HtoS (__m128i h,__m128 &sa,__m128 &sb) {$/;"	f	struct:Grid::Optimization::PrecisionChange
HugeCost	lib/Eigen/src/Core/util/Constants.h	/^const int HugeCost = 10000;$/;"	m	namespace:Eigen
HwCayleyTanh	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HwCayleyTanh, \/\/ Scaled shamir$/;"	e	enum:ChromaAction	file:
HwCayleyZolo	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HwCayleyZolo, \/\/ Chiu Optimal$/;"	e	enum:ChromaAction	file:
HwContFracTanh	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HwContFracTanh, \/\/ $/;"	e	enum:ChromaAction	file:
HwContFracZolo	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HwContFracZolo, \/\/ Edwards, Kennedy et al prefer this$/;"	e	enum:ChromaAction	file:
HwPartFracTanh	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HwPartFracTanh, \/\/ $/;"	e	enum:ChromaAction	file:
HwPartFracZolo	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 HwPartFracZolo, \/\/ KEK's approach$/;"	e	enum:ChromaAction	file:
HybridMonteCarlo	lib/qcd/hmc/HMC.h	/^  HybridMonteCarlo(HMCparameters _Pams, IntegratorType &_Int,$/;"	f	class:Grid::QCD::HybridMonteCarlo
HybridMonteCarlo	lib/qcd/hmc/HMC.h	/^class HybridMonteCarlo {$/;"	c	namespace:Grid::QCD
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane(const VectorType& n, const Scalar& d)$/;"	f	class:Eigen::Hyperplane
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
HypotNormReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_hypotNorm,RealScalar>::Type HypotNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
ILDGCPModule	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^class ILDGCPModule: public CheckPointerModule< ImplementationPolicy> {$/;"	c	namespace:Grid::QCD
ILDGHmcCheckpointer	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^  ILDGHmcCheckpointer(const CheckpointerParameters &Params_) { initialize(Params_); }$/;"	f	class:Grid::QCD::ILDGHmcCheckpointer
ILDGHmcCheckpointer	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^class ILDGHmcCheckpointer : public BaseHmcCheckpointer<Implementation> {$/;"	c	namespace:Grid::QCD
ILDG_BINARY_DATA	lib/parallelIO/IldgIOtypes.h	43;"	d
ILDG_CHECKPOINTER	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	30;"	d
ILDG_DATA_LFN	lib/parallelIO/IldgIOtypes.h	44;"	d
ILDG_FORMAT	lib/parallelIO/IldgIOtypes.h	42;"	d
IMM	lib/simd/BGQQPX.h	111;"	d
IMM	lib/simd/IBM_qpx.h	75;"	d
IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY	lib/Eigen/src/Core/util/StaticAssert.h	/^        IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
INCLUDED_ALG_REMEZ_H	lib/algorithms/approx/Remez.h	16;"	d
INCLUDED_BIGFLOAT_H	lib/algorithms/approx/bigfloat.h	11;"	d
INHERIT_FIELD_TYPES	lib/qcd/action/gauge/GaugeImplTypes.h	48;"	d
INHERIT_FIMPL_TYPES	lib/qcd/action/fermion/FermionOperatorImpl.h	143;"	d
INHERIT_GIMPL_TYPES	lib/qcd/action/gauge/GaugeImplTypes.h	39;"	d
INHERIT_IMPL_TYPES	lib/qcd/action/fermion/FermionOperatorImpl.h	155;"	d
INSTANTIATE_ASM	lib/qcd/action/fermion/WilsonKernelsAsm.cc	87;"	d	file:
INSTANTIATE_DPERP	lib/qcd/action/fermion/CayleyFermion5D.h	189;"	d
INSTANTIATE_THEM	lib/qcd/action/fermion/WilsonKernelsHand.cc	656;"	d	file:
INSTRUCTIONS	lib/perfmon/PerfCount.h	/^    INSTRUCTIONS=3,$/;"	e	enum:Grid::PerformanceCounter::PerformanceCounterType
INTEGRATOR_ALG_INCLUDED	lib/qcd/hmc/integrators/Integrator_algorithm.h	40;"	d
INTEGRATOR_INCLUDED	lib/qcd/hmc/integrators/Integrator.h	33;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	109;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	136;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	159;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	182;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	214;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	235;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	256;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	285;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	306;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	327;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	368;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	376;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	397;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	418;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	443;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	464;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	485;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	515;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	536;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	557;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	584;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	605;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	626;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	62;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	85;"	d
INTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	47;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	108;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	135;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	158;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	181;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	213;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	234;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	255;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	284;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	305;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	326;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	367;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	375;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	396;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	417;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	442;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	463;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	484;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	514;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	535;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	556;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	583;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	604;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	61;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	625;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	84;"	d
INTERIOR_AND_EXTERIOR	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	46;"	d
INTERNAL_PRECISION	lib/algorithms/approx/Zolotarev.cc	26;"	d	file:
INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	lib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
INVALID_MATRIX_PRODUCT	lib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	lib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
INVALID_MATRIX_TEMPLATE_PARAMETERS	lib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	lib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	lib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
IOFormat	lib/Eigen/src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat
IOFormat	lib/Eigen/src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
IOobject	lib/parallelIO/BinaryIO.h	/^  static inline void IOobject(word w,$/;"	f	class:Grid::BinaryIO
IRLdiagonalisation	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  enum IRLdiagonalisation { $/;"	g	namespace:Grid
IRLdiagonaliseWithDSTEGR	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^    IRLdiagonaliseWithDSTEGR,$/;"	e	enum:Grid::IRLdiagonalisation
IRLdiagonaliseWithEigen	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^    IRLdiagonaliseWithEigen$/;"	e	enum:Grid::IRLdiagonalisation
IRLdiagonaliseWithQR	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^    IRLdiagonaliseWithQR,$/;"	e	enum:Grid::IRLdiagonalisation
Identity	lib/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase
Identity	lib/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase
Identity	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC static inline const AngleAxis Identity() { return AngleAxis(Scalar(0), Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis
Identity	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(Scalar(1), Scalar(0), Scalar(0), Scalar(0)); }$/;"	f	class:Eigen::QuaternionBase
Identity	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D
Identity	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static const Transform Identity()$/;"	f	class:Eigen::Transform
Identity	lib/Eigen/src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation
IdentityPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    explicit IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
IdentityReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,PlainObject> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase
IldgReader	lib/parallelIO/IldgIO.h	/^class IldgReader : public GridLimeReader {$/;"	c	namespace:Grid::QCD
IldgWriter	lib/parallelIO/IldgIO.h	/^class IldgWriter : public ScidacWriter {$/;"	c	namespace:Grid::QCD
ImagFunctor	lib/simd/Grid_vector_unops.h	/^struct ImagFunctor {$/;"	s	namespace:Grid
ImagReturnType	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;$/;"	t
Impl	lib/Eigen/src/Core/Block.h	/^    typedef BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind> Impl;$/;"	t	class:Eigen::Block
Impl	lib/Eigen/src/Core/Block.h	/^    typedef internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel> Impl;$/;"	t	class:Eigen::BlockImpl
ImplParams	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef StaggeredImplParams ImplParams;$/;"	t	class:Grid::QCD::StaggeredImpl
ImplParams	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef StaggeredImplParams ImplParams;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
ImplParams	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef WilsonImplParams ImplParams;$/;"	t	class:Grid::QCD::WilsonImpl
ImplParams	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef WilsonImplParams ImplParams;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
ImplParams	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef GparityWilsonImplParams ImplParams;$/;"	t	class:Grid::QCD::GparityWilsonImpl
ImplPolicy	lib/qcd/hmc/GenericHMCrunner.h	/^  typedef Implementation ImplPolicy;  \/\/ visible from outside$/;"	t	class:Grid::QCD::HMCWrapperTemplate
ImplementationPolicy	tests/hmc/Test_hmc_Factories.cc	/^typedef QCD::PeriodicGimplR   ImplementationPolicy;$/;"	t	namespace:Grid	file:
ImplicitLeapFrog	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  ImplicitLeapFrog(GridBase* grid, IntegratorParameters Par,$/;"	f	class:Grid::QCD::ImplicitLeapFrog
ImplicitLeapFrog	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^class ImplicitLeapFrog : public Integrator<FieldImplementation, SmearingPolicy,$/;"	c	namespace:Grid::QCD
ImplicitMinimumNorm2	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  ImplicitMinimumNorm2(GridBase* grid, IntegratorParameters Par,$/;"	f	class:Grid::QCD::ImplicitMinimumNorm2
ImplicitMinimumNorm2	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^class ImplicitMinimumNorm2 : public Integrator<FieldImplementation, SmearingPolicy,$/;"	c	namespace:Grid::QCD
ImplicitlyRestartedLanczos	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^ ImplicitlyRestartedLanczos(LinearOperatorBase<Field> &Linop, \/\/ op$/;"	f	class:Grid::ImplicitlyRestartedLanczos
ImplicitlyRestartedLanczos	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^class ImplicitlyRestartedLanczos {$/;"	c	namespace:Grid
ImportFermion	tests/qdpxx/Test_qdpxx_munprec.cc	/^  static void ImportFermion(Grid::QCD::LatticeFermion & gr,$/;"	f	class:Chroma::ChromaWrapper
ImportFermion	tests/qdpxx/Test_qdpxx_stag.cc	/^  static void ImportFermion(FermionField & gr,$/;"	f	class:Chroma::ChromaWrapper
ImportGauge	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::ImportGauge(const GaugeField &_Uthin) $/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
ImportGauge	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::ImportGauge(const GaugeField &_Uthin,const GaugeField &_Ufat) $/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
ImportGauge	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::ImportGauge(const GaugeField &_Uthin) $/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
ImportGauge	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::ImportGauge(const GaugeField &_Uthin,const GaugeField &_Ufat)$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
ImportGauge	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::ImportGauge(const GaugeField &_Umu) {$/;"	f	class:Grid::QCD::WilsonFermion
ImportGauge	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::ImportGauge(const GaugeField &_Umu)$/;"	f	class:Grid::QCD::WilsonFermion5D
ImportGauge	lib/qcd/utils/CovariantLaplacian.h	/^  void ImportGauge(const GaugeField& _U) {$/;"	f	class:Grid::QCD::LaplacianAdjointField
ImportGauge	lib/qcd/utils/CovariantLaplacian.h	/^  void ImportGauge(const GaugeField& _U) {$/;"	f	class:Grid::QCD::LaplacianAlgebraField
ImportGauge	lib/qcd/utils/Metric.h	/^  virtual void ImportGauge(const Field&){};$/;"	f	class:Grid::QCD::TrivialMetric
ImportGauge	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^  static void ImportGauge(Grid::QCD::LatticeGaugeField & gr,$/;"	f	class:Chroma::ChromaWrapper
ImportGauge	tests/qdpxx/Test_qdpxx_munprec.cc	/^  static void ImportGauge(Grid::QCD::LatticeGaugeField & gr,$/;"	f	class:Chroma::ChromaWrapper
ImportGauge	tests/qdpxx/Test_qdpxx_stag.cc	/^  static void ImportGauge(GaugeField & gr,$/;"	f	class:Chroma::ChromaWrapper
ImportGaugeSimple	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::ImportGaugeSimple(const GaugeField &_Utriple,const GaugeField &_Ufat) $/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
ImprovedStaggeredFermion	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^ImprovedStaggeredFermion<Impl>::ImprovedStaggeredFermion(GaugeField &_Uthin, GaugeField &_Ufat, GridCartesian &Fgrid,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
ImprovedStaggeredFermion	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^ImprovedStaggeredFermion<Impl>::ImprovedStaggeredFermion(GaugeField &_Uthin,GaugeField &_Utriple, GaugeField &_Ufat, GridCartesian &Fgrid,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
ImprovedStaggeredFermion	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^ImprovedStaggeredFermion<Impl>::ImprovedStaggeredFermion(GridCartesian &Fgrid, GridRedBlackCartesian &Hgrid, $/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
ImprovedStaggeredFermion	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^class ImprovedStaggeredFermion : public StaggeredKernels<Impl>, public ImprovedStaggeredFermionStatic {$/;"	c	namespace:Grid::QCD
ImprovedStaggeredFermion5D	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^ImprovedStaggeredFermion5D<Impl>::ImprovedStaggeredFermion5D(GaugeField &_Uthin,GaugeField &_Ufat,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
ImprovedStaggeredFermion5D	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    class ImprovedStaggeredFermion5D :  public StaggeredKernels<Impl>, public ImprovedStaggeredFermion5DStatic $/;"	c	namespace:Grid::QCD
ImprovedStaggeredFermion5DD	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion5D<StaggeredImplD> ImprovedStaggeredFermion5DD;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermion5DF	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion5D<StaggeredImplF> ImprovedStaggeredFermion5DF;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermion5DR	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion5D<StaggeredImplR> ImprovedStaggeredFermion5DR;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermion5DStatic	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    class ImprovedStaggeredFermion5DStatic { $/;"	c	namespace:Grid::QCD
ImprovedStaggeredFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion<StaggeredImplD> ImprovedStaggeredFermionD;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermionD	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^typedef ImprovedStaggeredFermion<StaggeredImplD> ImprovedStaggeredFermionD;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion<StaggeredImplF> ImprovedStaggeredFermionF;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermionF	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^typedef ImprovedStaggeredFermion<StaggeredImplF> ImprovedStaggeredFermionF;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion<StaggeredImplR> ImprovedStaggeredFermionR;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermionStatic	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^class ImprovedStaggeredFermionStatic {$/;"	c	namespace:Grid::QCD
ImprovedStaggeredFermionVec5dD	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion5D<StaggeredVec5dImplD> ImprovedStaggeredFermionVec5dD;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermionVec5dF	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion5D<StaggeredVec5dImplF> ImprovedStaggeredFermionVec5dF;$/;"	t	namespace:Grid::QCD
ImprovedStaggeredFermionVec5dR	lib/qcd/action/fermion/Fermion.h	/^typedef ImprovedStaggeredFermion5D<StaggeredVec5dImplR> ImprovedStaggeredFermionVec5dR;$/;"	t	namespace:Grid::QCD
InOutCoorToLocalCoor	lib/cartesian/Cartesian_base.h	/^    inline void InOutCoorToLocalCoor (std::vector<int> &ocoor, std::vector<int> &icoor, std::vector<int> &lcoor) {$/;"	f	class:Grid::GridBase
IncompleteCholesky	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    IncompleteCholesky() : m_initialShift(1e-3),m_factorizationIsOk(false) {}$/;"	f	class:Eigen::IncompleteCholesky
IncompleteCholesky	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    IncompleteCholesky(const MatrixType& matrix) : m_initialShift(1e-3),m_factorizationIsOk(false)$/;"	f	class:Eigen::IncompleteCholesky
IncompleteCholesky	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^class IncompleteCholesky : public SparseSolverBase<IncompleteCholesky<Scalar,_UpLo,_OrderingType> >$/;"	c	namespace:Eigen
IncompleteLUT	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    explicit IncompleteLUT(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : public SparseSolverBase<IncompleteLUT<_Scalar, _StorageIndex> >$/;"	c	namespace:Eigen
Indefinite	lib/Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Index	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::LDLT
Index	lib/Eigen/src/Cholesky/LLT.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::LLT
Index	lib/Eigen/src/Core/EigenBase.h	/^  typedef Eigen::Index Index;$/;"	t	struct:Eigen::EigenBase
Index	lib/Eigen/src/Core/Stride.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Stride
Index	lib/Eigen/src/Core/Transpositions.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::TranspositionsBase
Index	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::VectorwiseOp
Index	lib/Eigen/src/Core/util/Meta.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE Index;$/;"	t	namespace:Eigen
Index	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::ComplexEigenSolver
Index	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::ComplexSchur
Index	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::EigenSolver
Index	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::GeneralizedEigenSolver
Index	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::HessenbergDecomposition
Index	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::RealQZ
Index	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::RealSchur
Index	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::SelfAdjointEigenSolver
Index	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Tridiagonalization
Index	lib/Eigen/src/Geometry/AlignedBox.h	/^  typedef Eigen::Index                              Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::AlignedBox
Index	lib/Eigen/src/Geometry/Hyperplane.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Hyperplane
Index	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::ParametrizedLine
Index	lib/Eigen/src/Geometry/Transform.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Transform
Index	lib/Eigen/src/SVD/SVDBase.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::SVDBase
Index	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::internal::UpperBidiagonalization
Index	lib/qcd/action/ActionSet.h	/^struct Index<T, std::tuple<T, Types...>> {$/;"	s	namespace:Grid::QCD
Index	lib/qcd/action/ActionSet.h	/^struct Index<T, std::tuple<U, Types...>> {$/;"	s	namespace:Grid::QCD
IndexBased	lib/Eigen/src/Core/util/Constants.h	/^struct IndexBased {};$/;"	s	namespace:Eigen::internal
IndexFromCoor	lib/util/Lexicographic.h	/^    static inline void IndexFromCoor (std::vector<int>& coor,int &index,std::vector<int> &dims){$/;"	f	class:Grid::Lexicographic
IndexInteger	lib/stencil/Lebesgue.h	/^    typedef int32_t IndexInteger;$/;"	t	class:Grid::LebesgueOrder
IndexPointer	lib/Eigen/src/SparseCore/SparseMap.h	/^                         StorageIndex *, const StorageIndex *>::type IndexPointer;$/;"	t	class:Eigen::SparseMapBase
IndexType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef long long int IndexType;$/;"	t	struct:Eigen::internal::pardiso_run_selector
IndexVector	lib/Eigen/src/MetisSupport/MetisSupport.h	/^  typedef Matrix<StorageIndex,Dynamic,1> IndexVector; $/;"	t	class:Eigen::MetisOrdering
IndexVector	lib/Eigen/src/OrderingMethods/Ordering.h	/^    typedef Matrix<StorageIndex, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::COLAMDOrdering
IndexVector	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename Base::IndexVector IndexVector;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
IndexVector	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef typename Base::IndexVector IndexVector;$/;"	t	class:Eigen::SparseCompressedBase
IndexVector	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::IndexVector IndexVector;$/;"	t	class:Eigen::SparseMatrix
IndexVector	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector;$/;"	t	class:Eigen::SparseMatrixBase
IndexVector	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector;$/;"	t	class:Eigen::SparseLU
IndexVector	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::SparseLUImpl
IndexVector	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
IndexVector	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef Matrix<StorageIndex, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::SparseQR
IndicesRef	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef Ref<ArrayXi> IndicesRef;$/;"	t	class:Eigen::BDCSVD
IndicesType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase
IndicesType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix
IndicesType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper
IndicesType	lib/Eigen/src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<_StorageIndex, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	lib/Eigen/src/Core/PermutationMatrix.h	/^  typedef Matrix<_StorageIndex, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	lib/Eigen/src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions
IndicesType	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase
IndicesType	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper
IndicesType	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose
IndicesType	lib/Eigen/src/Core/Transpositions.h	/^  typedef Map<const Matrix<_StorageIndex,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	lib/Eigen/src/Core/Transpositions.h	/^  typedef Matrix<_StorageIndex, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
Infinity	lib/Eigen/src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
Init	lib/algorithms/approx/Chebyshev.h	/^    void Init(RealD _lo,RealD _hi,int _order)$/;"	f	class:Grid::Chebyshev
Init	lib/algorithms/approx/Chebyshev.h	/^    void Init(RealD _lo,RealD _hi,int _order, RealD (* func)(RealD))$/;"	f	class:Grid::Chebyshev
Init	lib/algorithms/approx/MultiShiftFunction.h	/^  void Init(AlgRemez & remez,double tol,bool inverse) $/;"	f	class:Grid::MultiShiftFunction
Init	lib/cartesian/Cartesian_red_black.h	/^    void Init(const std::vector<int> &dimensions,$/;"	f	class:Grid::GridRedBlackCartesian
Init	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::Init(int *argc, char ***argv) {$/;"	f	class:Grid::CartesianCommunicator
Init	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::Init(int *argc, char ***argv) {$/;"	f	class:Grid::CartesianCommunicator
Init	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::Init(int *argc, char ***argv) $/;"	f	class:Grid::CartesianCommunicator
Init	lib/communicator/Communicator_mpi3_leader.cc	/^void Slave::Init(SlaveState * _state,MPI_Comm _squadron,int _universe_rank,int _vertical_rank)$/;"	f	class:Grid::Slave
Init	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::Init(int *argc, char *** arv)$/;"	f	class:Grid::CartesianCommunicator
Init	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::Init(int *argc, char ***argv) {$/;"	f	class:Grid::CartesianCommunicator
Init	tests/testu01/Test_smallcrush.cc	/^  static void Init(GridParallelRNG *_pRNG,GridSerialRNG *_sRNG,GridBase *grid) {$/;"	f	struct:TestRNG
InnerIterator	lib/Eigen/src/Core/CoreIterators.h	/^  InnerIterator(const XprType &xpr, const Index &outerId)$/;"	f	class:Eigen::InnerIterator
InnerIterator	lib/Eigen/src/Core/CoreIterators.h	/^class InnerIterator$/;"	c	namespace:Eigen
InnerIterator	lib/Eigen/src/Core/DenseBase.h	/^    typedef Eigen::InnerIterator<Derived> InnerIterator;$/;"	t	class:Eigen::DenseBase
InnerIterator	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::conditional<OuterVector,OuterVectorInnerIterator,InnerVectorInnerIterator>::type InnerIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator()$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator(const InnerIterator& other)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator(const SparseCompressedBase& mat, Index outer)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit InnerIterator(const SparseCompressedBase& mat)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit InnerIterator(const internal::CompressedStorage<Scalar,StorageIndex>& data)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  typedef typename Derived::InnerIterator InnerIterator;$/;"	t	struct:Eigen::internal::evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^class SparseCompressedBase<Derived>::InnerIterator$/;"	c	class:Eigen::SparseCompressedBase
InnerIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const binary_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const sparse_conjunction_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  class InnerIterator$/;"	c	struct:Eigen::internal::binary_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  class InnerIterator$/;"	c	struct:Eigen::internal::sparse_conjunction_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& unaryOp, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>::InnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>::InnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    InnerIterator(const sparse_dense_outer_product_evaluator &xprEval, Index outer)$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  class InnerIterator : public LhsIterator$/;"	c	struct:Eigen::internal::sparse_dense_outer_product_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    InnerIterator(const sparse_diagonal_product_evaluator &xprEval, Index outer)$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  class InnerIterator : public SparseXprInnerIterator$/;"	c	struct:Eigen::internal::sparse_diagonal_product_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  class InnerIterator$/;"	c	struct:Eigen::internal::sparse_diagonal_product_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::InnerIterator InnerIterator;$/;"	t	class:Eigen::SparseMatrix
InnerIterator	lib/Eigen/src/SparseCore/SparseTranspose.h	/^      EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& unaryOp, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    class InnerIterator : public EvalIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& xprEval, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  class InnerIterator : public EvalIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseVector.h	/^    typedef typename Base::InnerIterator InnerIterator;$/;"	t	class:Eigen::SparseVector
InnerIterator	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef typename SparseVectorType::InnerIterator InnerIterator;$/;"	t	struct:Eigen::internal::evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& sve, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	lib/Eigen/src/SparseCore/SparseView.h	/^    class InnerIterator : public EvalIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	lib/Eigen/src/SparseCore/SparseView.h	/^    class InnerIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^     InnerIterator(const MappedSuperNodalMatrix& mat, Index outer)$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
InnerIterator	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix<Scalar,StorageIndex>::InnerIterator$/;"	c	class:Eigen::internal::MappedSuperNodalMatrix
InnerMaxSize	lib/Eigen/src/Core/AssignEvaluator.h	/^    InnerMaxSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon139
InnerMaxSize	lib/Eigen/src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
InnerMaxSize	lib/Eigen/src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon115
InnerPacketSize	lib/Eigen/src/Core/AssignEvaluator.h	/^    InnerPacketSize = unpacket_traits<InnerPacketType>::size$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon140
InnerPacketType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename find_best_packet<DstScalar,InnerSize>::type InnerPacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
InnerProduct	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
InnerRandomAccessPattern	lib/Eigen/src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
InnerRequiredAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    InnerRequiredAlignment = unpacket_traits<InnerPacketType>::alignment$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon141
InnerSize	lib/Eigen/src/Core/AssignEvaluator.h	/^    InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon139
InnerSize	lib/Eigen/src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
InnerSize	lib/Eigen/src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon213
InnerSize	lib/Eigen/src/Core/CoreEvaluators.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::evaluator::__anon237
InnerSize	lib/Eigen/src/Core/Product.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsTraits::ColsAtCompileTime, RhsTraits::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon126
InnerSize	lib/Eigen/src/Core/ProductEvaluators.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsNestedCleaned::ColsAtCompileTime, RhsNestedCleaned::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::product_evaluator::__anon176
InnerSizeAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon129
InnerSizeAtCompileTime	lib/Eigen/src/Core/Redux.h	/^    InnerSizeAtCompileTime = XprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
InnerSizeAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
InnerStride	lib/Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride
InnerStride	lib/Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC InnerStride(Index v) : Base(0, v) {} \/\/ FIXME making this explicit could break valid code$/;"	f	class:Eigen::InnerStride
InnerStride	lib/Eigen/src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen
InnerStrideAtCompileTime	lib/Eigen/src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon213
InnerStrideAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsArgType$/;"	e	enum:Eigen::internal::evaluator::__anon237
InnerStrideAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::evaluator::__anon235
InnerStrideAtCompileTime	lib/Eigen/src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon394
InnerStrideAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon129
InnerStrideAtCompileTime	lib/Eigen/src/Core/Diagonal.h	/^    InnerStrideAtCompileTime = MatrixTypeOuterStride == Dynamic ? Dynamic : MatrixTypeOuterStride+1,$/;"	e	enum:Eigen::internal::traits::__anon401
InnerStrideAtCompileTime	lib/Eigen/src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon134
InnerStrideAtCompileTime	lib/Eigen/src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon172
InnerStrideAtCompileTime	lib/Eigen/src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon164
InnerStrideAtCompileTime	lib/Eigen/src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon391
InnerStrideMatch	lib/Eigen/src/Core/Ref.h	/^      InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic)$/;"	e	enum:Eigen::internal::traits::match::__anon150
InnerTolerance	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    RealD   InnerTolerance; \/\/Initial tolerance for inner CG. Defaults to Tolerance but can be changed$/;"	m	class:Grid::MixedPrecisionConjugateGradient
InnerUnrolling	lib/Eigen/src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::UnrollingType
InnerVectorInnerIterator	lib/Eigen/src/SparseCore/SparseBlock.h	/^  EIGEN_STRONG_INLINE InnerVectorInnerIterator(const unary_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
InnerVectorInnerIterator	lib/Eigen/src/SparseCore/SparseBlock.h	/^class unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::InnerVectorInnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
InnerVectorReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true>       InnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase
InnerVectorizedTraversal	lib/Eigen/src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
InnerVectorsReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,Dynamic,Dynamic,true> InnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase
InputScalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::evaluator
InputScalar	lib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits
Insert	lib/allocator/AlignedAllocator.cc	/^PointerCache::PointerInfo PointerCache::Insert(void *ptr, size_t bytes)$/;"	f	class:Grid::PointerCache
InsertForce4D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void InsertForce4D(GaugeField &mat, FermionField &Btilde, FermionField &A,int mu){$/;"	f	class:Grid::QCD::StaggeredImpl
InsertForce4D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void InsertForce4D(GaugeField &mat, FermionField &Btilde, FermionField &A,int mu){$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
InsertForce4D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void InsertForce4D(GaugeField &mat, FermionField &Btilde, FermionField &A,int mu){$/;"	f	class:Grid::QCD::WilsonImpl
InsertForce4D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  inline void InsertForce4D(GaugeField &mat, FermionField &Btilde,FermionField &A, int mu) $/;"	f	class:Grid::QCD::DomainWallVec5dImpl
InsertForce4D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ inline void InsertForce4D(GaugeField &mat, FermionField &Btilde, FermionField &A, int mu) {$/;"	f	class:Grid::QCD::GparityWilsonImpl
InsertForce5D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void InsertForce5D(GaugeField &mat, FermionField &Btilde, FermionField &Atilde,int mu){$/;"	f	class:Grid::QCD::StaggeredImpl
InsertForce5D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void InsertForce5D(GaugeField &mat, FermionField &Btilde, FermionField &Atilde,int mu){$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
InsertForce5D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void InsertForce5D(GaugeField &mat, FermionField &Btilde, FermionField &Atilde,int mu){$/;"	f	class:Grid::QCD::WilsonImpl
InsertForce5D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  inline void InsertForce5D(GaugeField &mat, FermionField &Btilde, FermionField &Atilde, int mu) {$/;"	f	class:Grid::QCD::DomainWallVec5dImpl
InsertForce5D	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ inline void InsertForce5D(GaugeField &mat, FermionField &Btilde, FermionField &Atilde, int mu) {$/;"	f	class:Grid::QCD::GparityWilsonImpl
InsertSlice	lib/lattice/Lattice_transfer.h	/^void InsertSlice(const Lattice<vobj> &lowDim,Lattice<vobj> & higherDim,int slice, int orthog)$/;"	f	namespace:Grid
InsertSliceLocal	lib/lattice/Lattice_transfer.h	/^void InsertSliceLocal(const Lattice<vobj> &lowDim, Lattice<vobj> & higherDim,int slice_lo,int slice_hi, int orthog)$/;"	f	namespace:Grid
Instantiatable	lib/qcd/action/fermion/DomainWallFermion.h	/^      virtual void   Instantiatable(void) {};$/;"	f	class:Grid::QCD::DomainWallFermion
Instantiatable	lib/qcd/action/fermion/MobiusFermion.h	/^      virtual void   Instantiatable(void) {};$/;"	f	class:Grid::QCD::MobiusFermion
Instantiatable	lib/qcd/action/fermion/MobiusZolotarevFermion.h	/^      virtual void   Instantiatable(void) {};$/;"	f	class:Grid::QCD::MobiusZolotarevFermion
Instantiatable	lib/qcd/action/fermion/OverlapWilsonContfracTanhFermion.h	/^      virtual void   Instantiatable(void){};$/;"	f	class:Grid::QCD::OverlapWilsonContFracTanhFermion
Instantiatable	lib/qcd/action/fermion/OverlapWilsonContfracZolotarevFermion.h	/^      virtual void   Instantiatable(void){};$/;"	f	class:Grid::QCD::OverlapWilsonContFracZolotarevFermion
Instantiatable	lib/qcd/action/fermion/OverlapWilsonPartialFractionTanhFermion.h	/^      virtual void   Instantiatable(void){};$/;"	f	class:Grid::QCD::OverlapWilsonPartialFractionTanhFermion
Instantiatable	lib/qcd/action/fermion/OverlapWilsonPartialFractionZolotarevFermion.h	/^      virtual void   Instantiatable(void){};$/;"	f	class:Grid::QCD::OverlapWilsonPartialFractionZolotarevFermion
Instantiatable	lib/qcd/action/fermion/WilsonTMFermion.h	/^      virtual void   Instantiatable(void) {};$/;"	f	class:Grid::QCD::WilsonTMFermion
Instantiatable	lib/qcd/action/fermion/ZMobiusFermion.h	/^      virtual void   Instantiatable(void) {};$/;"	f	class:Grid::QCD::ZMobiusFermion
IntColVectorType	lib/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, StorageIndex>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU
IntColVectorType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<StorageIndex, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl
IntColVectorType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase
IntColVectorType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;   $/;"	t	class:Eigen::SuperLU
IntColVectorType	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU
IntDiagSizeVectorType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^                   EIGEN_SIZE_MIN_PREFER_FIXED(MaxColsAtCompileTime,MaxRowsAtCompileTime)> IntDiagSizeVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
IntDiagSizeVectorType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename FullPivHouseholderQR<MatrixType>::IntDiagSizeVectorType IntDiagSizeVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
IntPtr	lib/Eigen/src/Core/util/Meta.h	/^typedef std::intptr_t  IntPtr;$/;"	t	namespace:Eigen::internal
IntReductionTester	tests/Test_simd.cc	/^void IntReductionTester(const functor &func)$/;"	f
IntRowVectorType	lib/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, StorageIndex>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU
IntRowVectorType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<StorageIndex, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl
IntRowVectorType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
IntRowVectorType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      IntRowVectorType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
IntRowVectorType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase
IntRowVectorType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU
IntRowVectorType	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU
IntTester	tests/Test_simd.cc	/^void IntTester(const functor &func)$/;"	f
Integer	lib/simd/Simd.h	/^  typedef uint32_t Integer;$/;"	t	namespace:Grid
Integrator	lib/qcd/hmc/integrators/Integrator.h	/^  Integrator(GridBase* grid, IntegratorParameters Par,$/;"	f	class:Grid::QCD::Integrator
Integrator	lib/qcd/hmc/integrators/Integrator.h	/^class Integrator {$/;"	c	namespace:Grid::QCD
IntegratorParameters	lib/qcd/hmc/integrators/Integrator.h	/^  IntegratorParameters(ReaderClass & Reader){$/;"	f	class:Grid::QCD::IntegratorParameters
IntegratorParameters	lib/qcd/hmc/integrators/Integrator.h	/^  IntegratorParameters(int MDsteps_ = 10, RealD trajL_ = 1.0)$/;"	f	class:Grid::QCD::IntegratorParameters
IntegratorParameters	lib/qcd/hmc/integrators/Integrator.h	/^class IntegratorParameters: Serializable {$/;"	c	namespace:Grid::QCD
InvalidInput	lib/Eigen/src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
InvalidTraversal	lib/Eigen/src/Core/util/Constants.h	/^  InvalidTraversal,$/;"	e	enum:Eigen::TraversalType
Inverse	lib/Eigen/src/Core/Inverse.h	/^  explicit EIGEN_DEVICE_FUNC Inverse(const XprType &xpr)$/;"	f	class:Eigen::Inverse
Inverse	lib/Eigen/src/Core/Inverse.h	/^class Inverse : public InverseImpl<XprType,typename internal::traits<XprType>::StorageKind>$/;"	c	namespace:Eigen
InverseApproximation	tests/debug/Test_cheby.cc	/^RealD InverseApproximation(RealD x){$/;"	f
InverseApproximation	tests/hmc/Test_multishift_sqrt.cc	/^RealD InverseApproximation(RealD x){$/;"	f
InverseApproximation	tests/solver/Test_dwf_hdcr.cc	/^RealD InverseApproximation(RealD x){$/;"	f
InverseImpl	lib/Eigen/src/Core/Inverse.h	/^class InverseImpl$/;"	c	namespace:Eigen
InverseImpl	lib/Eigen/src/Core/PermutationMatrix.h	/^    InverseImpl() {}$/;"	f	class:Eigen::InverseImpl
InverseImpl	lib/Eigen/src/Core/PermutationMatrix.h	/^class InverseImpl<PermutationType, PermutationStorage>$/;"	c	namespace:Eigen
InverseNo	lib/qcd/QCD.h	/^    static const int InverseNo=0;$/;"	m	namespace:Grid::QCD
InverseReturnType	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper<const CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const DiagonalVectorType> > InverseReturnType;$/;"	t	class:Eigen::DiagonalBase
InverseReturnType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef Inverse<Derived> InverseReturnType;$/;"	t	class:Eigen::PermutationBase
InverseReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived> InverseReturnType;$/;"	t
InverseType	lib/Eigen/src/Core/Inverse.h	/^  typedef Inverse<ArgType> InverseType;$/;"	t	struct:Eigen::internal::unary_evaluator
InverseType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef Inverse<PermutationType> InverseType;$/;"	t	class:Eigen::InverseImpl
InverseYes	lib/qcd/QCD.h	/^    static const int InverseYes=1;$/;"	m	namespace:Grid::QCD
IsBoss	lib/communicator/Communicator_base.cc	/^int                      CartesianCommunicator::IsBoss(void)            { return _processor==0; };$/;"	f	class:Grid::CartesianCommunicator
IsColMajor	lib/Eigen/src/Core/CoreEvaluators.h	/^    IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
IsColMajor	lib/Eigen/src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon166
IsColVector	lib/Eigen/src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon499
IsColVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon539
IsColVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon541
IsComplex	lib/Eigen/src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon136
IsComplex	lib/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon25
IsComplex	lib/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon26
IsDense	lib/Eigen/src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::AmbiVectorMode
IsDynamicSize	lib/Eigen/src/Core/CoreEvaluators.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::evaluator::__anon235
IsFiniteReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_isfinite_op<Scalar>, const Derived> IsFiniteReturnType;$/;"	t
IsInfReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_isinf_op<Scalar>, const Derived> IsInfReturnType;$/;"	t
IsInteger	lib/Eigen/src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon136
IsLower	lib/Eigen/src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon133
IsLower	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon380
IsLower	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon381
IsLower	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon365
IsLower	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon366
IsLower	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon382
IsLower	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon383
IsNaNReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_isnan_op<Scalar>, const Derived> IsNaNReturnType;$/;"	t
IsOneByOne	lib/Eigen/src/Core/Product.h	/^      IsOneByOne = (RowsAtCompileTime == 1 || RowsAtCompileTime == Dynamic) && $/;"	e	enum:Eigen::ProductImpl::__anon127
IsPlainObjectBase	lib/Eigen/src/Core/DenseBase.h	/^    enum { IsPlainObjectBase = 0 };$/;"	e	enum:Eigen::DenseBase::__anon130
IsPlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    enum { IsPlainObjectBase = 1 };$/;"	e	enum:Eigen::PlainObjectBase::__anon397
IsProjective	lib/Eigen/src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon591
IsRepeatable	lib/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon503
IsRepeatable	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^         PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon483
IsRepeatable	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^    IsRepeatable = true$/;"	e	enum:Eigen::internal::functor_traits::__anon485
IsRepeatable	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon484
IsRowMajor	lib/Eigen/src/Core/Block.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon213
IsRowMajor	lib/Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::evaluator::__anon237
IsRowMajor	lib/Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = PlainObjectType::IsRowMajor,$/;"	e	enum:Eigen::internal::evaluator::__anon227
IsRowMajor	lib/Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = XprType::IsRowMajor,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
IsRowMajor	lib/Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = XprType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::mapbase_evaluator::__anon234
IsRowMajor	lib/Eigen/src/Core/CoreIterators.h	/^  enum { IsRowMajor = (XprType::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::inner_iterator_selector::__anon182
IsRowMajor	lib/Eigen/src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon129
IsRowMajor	lib/Eigen/src/Core/Redux.h	/^    IsRowMajor = XprType::IsRowMajor,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
IsRowMajor	lib/Eigen/src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon225
IsRowMajor	lib/Eigen/src/SparseCore/SparseBlock.h	/^      IsRowMajor = XprType::IsRowMajor,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon553
IsRowMajor	lib/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon548
IsRowMajor	lib/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon552
IsRowMajor	lib/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::internal::sparse_matrix_block_impl::__anon550
IsRowMajor	lib/Eigen/src/SparseCore/SparseBlock.h	/^  enum { IsRowMajor = unary_evaluator::IsRowMajor };$/;"	e	enum:Eigen::internal::unary_evaluator::InnerVectorInnerIterator::__anon554
IsRowMajor	lib/Eigen/src/SparseCore/SparseBlock.h	/^  enum { IsRowMajor = unary_evaluator::IsRowMajor };$/;"	e	enum:Eigen::internal::unary_evaluator::OuterVectorInnerIterator::__anon555
IsRowMajor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::binary_evaluator::InnerIterator::__anon524
IsRowMajor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(LhsArg::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::InnerIterator::__anon529
IsRowMajor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::binary_evaluator::InnerIterator::__anon522
IsRowMajor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(RhsArg::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::InnerIterator::__anon527
IsRowMajor	lib/Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::Map::__anon571
IsRowMajor	lib/Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::Map::__anon572
IsRowMajor	lib/Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::SparseMapBase::__anon569
IsRowMajor	lib/Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::SparseMapBase::__anon570
IsRowMajor	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
IsRowMajor	lib/Eigen/src/SparseCore/SparseView.h	/^    enum { IsRowMajor = (XprType::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::unary_evaluator::__anon565
IsSigned	lib/Eigen/src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon136
IsSparse	lib/Eigen/src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::AmbiVectorMode
IsTransposed	lib/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon27
IsTransposed	lib/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon25
IsVectorAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    IsVectorAtCompileTime = PlainObjectType::IsVectorAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon227
IsVectorAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon129
IsVectorAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon398
IsVectorAtCompileTime	lib/Eigen/src/Core/SolverBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::SolverBase::__anon247
IsVectorAtCompileTime	lib/Eigen/src/Core/TriangularMatrix.h	/^      IsVectorAtCompileTime = false$/;"	e	enum:Eigen::TriangularView::__anon21
IsVectorAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
Isometry	lib/Eigen/src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
Isometry2d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Isometry2f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Isometry3d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Isometry3f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
IsometryTransformType	lib/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation
IterateI	lib/stencil/Lebesgue.cc	/^void LebesgueOrder::IterateI(int ND,$/;"	f	class:Grid::LebesgueOrder
IterateO	lib/stencil/Lebesgue.cc	/^void LebesgueOrder::IterateO(int ND,int dim,$/;"	f	class:Grid::LebesgueOrder
IterationsToComplete	lib/algorithms/iterative/BlockConjugateGradient.h	/^  Integer IterationsToComplete; \/\/Number of iterations the CG took to finish. Filled in upon completion$/;"	m	class:Grid::BlockConjugateGradient
IterationsToComplete	lib/algorithms/iterative/ConjugateGradient.h	/^  Integer IterationsToComplete; \/\/Number of iterations the CG took to finish. Filled in upon completion$/;"	m	class:Grid::ConjugateGradient
IterativeSolverBase	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  explicit IterativeSolverBase(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
Iterator	lib/Eigen/src/SparseCore/AmbiVector.h	/^    explicit Iterator(const AmbiVector& vec, const RealScalar& epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator
Iterator	lib/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_StorageIndex>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
IteratorBased	lib/Eigen/src/Core/util/Constants.h	/^struct IteratorBased {};$/;"	s	namespace:Eigen::internal
IteratorType	lib/Eigen/src/Core/CoreIterators.h	/^  typedef internal::inner_iterator_selector<XprType, typename internal::evaluator_traits<XprType>::Kind> IteratorType;$/;"	t	class:Eigen::InnerIterator
IwasakiGMod	lib/qcd/modules/Registration.h	/^typedef QCD::IwasakiGModule<ImplementationPolicy> IwasakiGMod;$/;"	t
IwasakiGModule	lib/qcd/modules/ActionModules.h	/^class IwasakiGModule: public ActionModule<IwasakiGaugeAction<Impl>, BetaGaugeActionParameters> {$/;"	c	namespace:Grid::QCD
IwasakiGaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      IwasakiGaugeAction(RealD beta) : RBCGaugeAction<Gimpl>(beta,-0.331) {};$/;"	f	class:Grid::QCD::IwasakiGaugeAction
IwasakiGaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^    class IwasakiGaugeAction : public RBCGaugeAction<Gimpl> {$/;"	c	namespace:Grid::QCD
IwasakiGaugeActionD	lib/qcd/action/gauge/Gauge.h	/^typedef IwasakiGaugeAction<PeriodicGimplD>         IwasakiGaugeActionD;$/;"	t	namespace:Grid::QCD
IwasakiGaugeActionF	lib/qcd/action/gauge/Gauge.h	/^typedef IwasakiGaugeAction<PeriodicGimplF>         IwasakiGaugeActionF;$/;"	t	namespace:Grid::QCD
IwasakiGaugeActionR	lib/qcd/action/gauge/Gauge.h	/^typedef IwasakiGaugeAction<PeriodicGimplR>         IwasakiGaugeActionR;$/;"	t	namespace:Grid::QCD
JMAX	lib/algorithms/approx/Remez.h	27;"	d
JRs	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef JacobiRotation<Scalar> JRs;$/;"	t	class:Eigen::RealQZ
JSONReader	lib/serialisation/JSON_IO.cc	/^JSONReader::JSONReader(const string &fileName)$/;"	f	class:JSONReader
JSONReader	lib/serialisation/JSON_IO.h	/^  class JSONReader: public Reader<JSONReader>$/;"	c	namespace:Grid
JSONWriter	lib/serialisation/JSON_IO.cc	/^JSONWriter::JSONWriter(const string &fileName)$/;"	f	class:JSONWriter
JSONWriter	lib/serialisation/JSON_IO.h	/^  class JSONWriter: public Writer<JSONWriter>$/;"	c	namespace:Grid
JSON_DEPRECATED	lib/json/json.hpp	86;"	d
JSON_DEPRECATED	lib/json/json.hpp	88;"	d
JSON_DEPRECATED	lib/json/json.hpp	90;"	d
JacksonSmooth	lib/algorithms/approx/Chebyshev.h	/^    void JacksonSmooth(void){$/;"	f	class:Grid::Chebyshev
JacobiRotation	lib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	lib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	lib/Eigen/src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
JacobiSVD	lib/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	lib/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	lib/Eigen/src/SVD/JacobiSVD.h	/^    explicit JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	lib/Eigen/src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
JointAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    JointAlignment = EIGEN_PLAIN_ENUM_MIN(DstAlignment,SrcAlignment)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon138
K	lib/algorithms/approx/Zolotarev.cc	/^static INTERNAL_PRECISION U, F, K;	\/* THREAD LOCAL *\/$/;"	m	namespace:Grid::Approx	file:
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	134;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	212;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	283;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	374;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	441;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	513;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	582;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	60;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	105;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	116;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	130;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	140;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	53;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	62;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	76;"	d
KERNEL_DAG	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	85;"	d
KERNEL_INSTANTIATE	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	907;"	d	file:
KILL_NON_PRINCIPAL_COL	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	124;"	d
KILL_PRINCIPAL_COL	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	123;"	d
KILL_ROW	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	122;"	d
KMADD	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	107;"	d
KMADD	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	274;"	d
KNLevsetup	lib/perfmon/Stat.cc	/^void PmuStat::KNLevsetup(const char *ename, int &fd, int event, int umask)$/;"	f	class:Grid::PmuStat
KNLreadctr	lib/perfmon/Stat.cc	/^uint64_t PmuStat::KNLreadctr(int fd)$/;"	f	class:Grid::PmuStat
KNLreadctrs	lib/perfmon/Stat.cc	/^void PmuStat::KNLreadctrs(ctrs &c)$/;"	f	class:Grid::PmuStat
KNLsetup	lib/perfmon/Stat.cc	/^ void PmuStat::KNLsetup(void){$/;"	f	class:Grid::PmuStat
KappaSimilarityTransform	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    KappaSimilarityTransform (Matrix &zmob) {$/;"	f	class:Grid::KappaSimilarityTransform
KappaSimilarityTransform	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    class KappaSimilarityTransform {$/;"	c	namespace:Grid
Kernels	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  typedef StaggeredKernels<Impl> Kernels;$/;"	t	class:Grid::QCD::ImprovedStaggeredFermion
Kernels	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      typedef StaggeredKernels<Impl> Kernels;$/;"	t	class:Grid::QCD::ImprovedStaggeredFermion5D
Kernels	lib/qcd/action/fermion/WilsonFermion.h	/^  typedef WilsonKernels<Impl> Kernels;$/;"	t	class:Grid::QCD::WilsonFermion
Kernels	lib/qcd/action/fermion/WilsonFermion5D.h	/^     typedef WilsonKernels<Impl> Kernels;$/;"	t	class:Grid::QCD::WilsonFermion5D
Kind	lib/Eigen/src/Core/AssignEvaluator.h	/^template<> struct AssignmentKind<DenseShape,DenseShape> { typedef Dense2Dense Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Core/AssignEvaluator.h	/^template<typename,typename> struct AssignmentKind { typedef EigenBase2EigenBase Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Core/BandMatrix.h	/^template<> struct AssignmentKind<DenseShape,BandShape> { typedef EigenBase2EigenBase Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef IndexBased Kind;$/;"	t	struct:Eigen::internal::storage_kind_to_evaluator_kind
Kind	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename storage_kind_to_evaluator_kind<typename traits<T>::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits_base
Kind	lib/Eigen/src/Core/DiagonalMatrix.h	/^template<> struct AssignmentKind<DenseShape,DiagonalShape> { typedef Diagonal2Dense Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Core/PermutationMatrix.h	/^template<> struct AssignmentKind<DenseShape,PermutationShape> { typedef EigenBase2EigenBase Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	lib/Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<DenseShape,TriangularShape>      { typedef Triangular2Dense      Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,DenseShape>      { typedef Dense2Triangular      Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,TriangularShape> { typedef Triangular2Triangular Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename storage_kind_to_evaluator_kind<typename ArgType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	lib/Eigen/src/Geometry/Homogeneous.h	/^template<> struct AssignmentKind<DenseShape,HomogeneousShape> { typedef Dense2Dense Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseCore/SparseAssign.h	/^  typedef IteratorBased Kind;$/;"	t	struct:Eigen::internal::storage_kind_to_evaluator_kind
Kind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseShape>           { typedef Sparse2Dense  Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseTriangularShape> { typedef Sparse2Dense  Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseShape>           { typedef Sparse2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseTriangularShape> { typedef Sparse2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape,DiagonalShape> { typedef Diagonal2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseSelfAdjointShape,SparseShape> { typedef Sparse2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseShape,SparseSelfAdjointShape> { typedef SparseSelfAdjoint2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
L1D_READ_ACCESS	lib/perfmon/PerfCount.h	/^    L1D_READ_ACCESS=4,$/;"	e	enum:Grid::PerformanceCounter::PerformanceCounterType
L1P_CFG_PF_USR	lib/simd/l1p.h	7;"	d
L1P_CFG_PF_USR	lib/simd/l1p.h	8;"	d
LAPACKE_free	lib/Eigen/src/misc/lapacke.h	115;"	d
LAPACKE_malloc	lib/Eigen/src/misc/lapacke.h	112;"	d
LAPACK_C2INT	lib/Eigen/src/misc/lapacke.h	118;"	d
LAPACK_COL_MAJOR	lib/Eigen/src/misc/lapacke.h	122;"	d
LAPACK_C_SELECT1	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_C_SELECT1) ( const lapack_complex_float* );$/;"	t
LAPACK_C_SELECT2	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_C_SELECT2)$/;"	t
LAPACK_D_SELECT2	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_D_SELECT2) ( const double*, const double* );$/;"	t
LAPACK_D_SELECT3	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_D_SELECT3)$/;"	t
LAPACK_GLOBAL	lib/Eigen/src/misc/lapacke_mangling.h	10;"	d
LAPACK_GLOBAL	lib/Eigen/src/misc/lapacke_mangling.h	12;"	d
LAPACK_GLOBAL	lib/Eigen/src/misc/lapacke_mangling.h	6;"	d
LAPACK_GLOBAL	lib/Eigen/src/misc/lapacke_mangling.h	8;"	d
LAPACK_H	lib/Eigen/src/misc/lapack.h	2;"	d
LAPACK_HEADER_INCLUDED	lib/Eigen/src/misc/lapacke_mangling.h	2;"	d
LAPACK_ROW_MAJOR	lib/Eigen/src/misc/lapacke.h	121;"	d
LAPACK_S_SELECT2	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_S_SELECT2) ( const float*, const float* );$/;"	t
LAPACK_S_SELECT3	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_S_SELECT3)$/;"	t
LAPACK_TRANSPOSE_MEMORY_ERROR	lib/Eigen/src/misc/lapacke.h	125;"	d
LAPACK_WORK_MEMORY_ERROR	lib/Eigen/src/misc/lapacke.h	124;"	d
LAPACK_Z2INT	lib/Eigen/src/misc/lapacke.h	119;"	d
LAPACK_Z_SELECT1	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_Z_SELECT1) ( const lapack_complex_double* );$/;"	t
LAPACK_Z_SELECT2	lib/Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_Z_SELECT2)$/;"	t
LAPACK_cbbcsd	lib/Eigen/src/misc/lapacke.h	11569;"	d
LAPACK_cbdsqr	lib/Eigen/src/misc/lapacke.h	11108;"	d
LAPACK_cgbbrd	lib/Eigen/src/misc/lapacke.h	11096;"	d
LAPACK_cgbcon	lib/Eigen/src/misc/lapacke.h	10722;"	d
LAPACK_cgbequ	lib/Eigen/src/misc/lapacke.h	10888;"	d
LAPACK_cgbequb	lib/Eigen/src/misc/lapacke.h	10893;"	d
LAPACK_cgbrfs	lib/Eigen/src/misc/lapacke.h	10778;"	d
LAPACK_cgbrfsx	lib/Eigen/src/misc/lapacke.h	10783;"	d
LAPACK_cgbsv	lib/Eigen/src/misc/lapacke.h	10932;"	d
LAPACK_cgbsvx	lib/Eigen/src/misc/lapacke.h	10936;"	d
LAPACK_cgbsvxx	lib/Eigen/src/misc/lapacke.h	10941;"	d
LAPACK_cgbtrf	lib/Eigen/src/misc/lapacke.h	10618;"	d
LAPACK_cgbtrs	lib/Eigen/src/misc/lapacke.h	10666;"	d
LAPACK_cgebak	lib/Eigen/src/misc/lapacke.h	11204;"	d
LAPACK_cgebal	lib/Eigen/src/misc/lapacke.h	11200;"	d
LAPACK_cgebrd	lib/Eigen/src/misc/lapacke.h	11092;"	d
LAPACK_cgecon	lib/Eigen/src/misc/lapacke.h	10718;"	d
LAPACK_cgeequ	lib/Eigen/src/misc/lapacke.h	10880;"	d
LAPACK_cgeequb	lib/Eigen/src/misc/lapacke.h	10885;"	d
LAPACK_cgees	lib/Eigen/src/misc/lapacke.h	11352;"	d
LAPACK_cgeesx	lib/Eigen/src/misc/lapacke.h	11356;"	d
LAPACK_cgeev	lib/Eigen/src/misc/lapacke.h	11360;"	d
LAPACK_cgeevx	lib/Eigen/src/misc/lapacke.h	11364;"	d
LAPACK_cgehrd	lib/Eigen/src/misc/lapacke.h	11188;"	d
LAPACK_cgelq2	lib/Eigen/src/misc/lapacke.h	11510;"	d
LAPACK_cgelqf	lib/Eigen/src/misc/lapacke.h	11040;"	d
LAPACK_cgels	lib/Eigen/src/misc/lapacke.h	11280;"	d
LAPACK_cgelsd	lib/Eigen/src/misc/lapacke.h	11292;"	d
LAPACK_cgelss	lib/Eigen/src/misc/lapacke.h	11288;"	d
LAPACK_cgelsy	lib/Eigen/src/misc/lapacke.h	11284;"	d
LAPACK_cgemqrt	lib/Eigen/src/misc/lapacke.h	11612;"	d
LAPACK_cgeqlf	lib/Eigen/src/misc/lapacke.h	11052;"	d
LAPACK_cgeqp3	lib/Eigen/src/misc/lapacke.h	11028;"	d
LAPACK_cgeqpf	lib/Eigen/src/misc/lapacke.h	11024;"	d
LAPACK_cgeqr2	lib/Eigen/src/misc/lapacke.h	11478;"	d
LAPACK_cgeqrf	lib/Eigen/src/misc/lapacke.h	11020;"	d
LAPACK_cgeqrfp	lib/Eigen/src/misc/lapacke.h	11468;"	d
LAPACK_cgeqrt	lib/Eigen/src/misc/lapacke.h	11616;"	d
LAPACK_cgeqrt2	lib/Eigen/src/misc/lapacke.h	11620;"	d
LAPACK_cgeqrt3	lib/Eigen/src/misc/lapacke.h	11624;"	d
LAPACK_cgerfs	lib/Eigen/src/misc/lapacke.h	10770;"	d
LAPACK_cgerfsx	lib/Eigen/src/misc/lapacke.h	10775;"	d
LAPACK_cgerqf	lib/Eigen/src/misc/lapacke.h	11064;"	d
LAPACK_cgesdd	lib/Eigen/src/misc/lapacke.h	11372;"	d
LAPACK_cgesv	lib/Eigen/src/misc/lapacke.h	10918;"	d
LAPACK_cgesvd	lib/Eigen/src/misc/lapacke.h	11368;"	d
LAPACK_cgesvx	lib/Eigen/src/misc/lapacke.h	10924;"	d
LAPACK_cgesvxx	lib/Eigen/src/misc/lapacke.h	10929;"	d
LAPACK_cgetf2	lib/Eigen/src/misc/lapacke.h	11486;"	d
LAPACK_cgetrf	lib/Eigen/src/misc/lapacke.h	10614;"	d
LAPACK_cgetri	lib/Eigen/src/misc/lapacke.h	10840;"	d
LAPACK_cgetrs	lib/Eigen/src/misc/lapacke.h	10662;"	d
LAPACK_cggbak	lib/Eigen/src/misc/lapacke.h	11244;"	d
LAPACK_cggbal	lib/Eigen/src/misc/lapacke.h	11240;"	d
LAPACK_cgges	lib/Eigen/src/misc/lapacke.h	11420;"	d
LAPACK_cggesx	lib/Eigen/src/misc/lapacke.h	11424;"	d
LAPACK_cggev	lib/Eigen/src/misc/lapacke.h	11428;"	d
LAPACK_cggevx	lib/Eigen/src/misc/lapacke.h	11432;"	d
LAPACK_cggglm	lib/Eigen/src/misc/lapacke.h	11300;"	d
LAPACK_cgghrd	lib/Eigen/src/misc/lapacke.h	11236;"	d
LAPACK_cgglse	lib/Eigen/src/misc/lapacke.h	11296;"	d
LAPACK_cggqrf	lib/Eigen/src/misc/lapacke.h	11084;"	d
LAPACK_cggrqf	lib/Eigen/src/misc/lapacke.h	11088;"	d
LAPACK_cggsvd	lib/Eigen/src/misc/lapacke.h	11380;"	d
LAPACK_cggsvp	lib/Eigen/src/misc/lapacke.h	11272;"	d
LAPACK_cgtcon	lib/Eigen/src/misc/lapacke.h	10726;"	d
LAPACK_cgtrfs	lib/Eigen/src/misc/lapacke.h	10786;"	d
LAPACK_cgtsv	lib/Eigen/src/misc/lapacke.h	10944;"	d
LAPACK_cgtsvx	lib/Eigen/src/misc/lapacke.h	10948;"	d
LAPACK_cgttrf	lib/Eigen/src/misc/lapacke.h	10622;"	d
LAPACK_cgttrs	lib/Eigen/src/misc/lapacke.h	10670;"	d
LAPACK_chbev	lib/Eigen/src/misc/lapacke.h	11332;"	d
LAPACK_chbevd	lib/Eigen/src/misc/lapacke.h	11336;"	d
LAPACK_chbevx	lib/Eigen/src/misc/lapacke.h	11340;"	d
LAPACK_chbgst	lib/Eigen/src/misc/lapacke.h	11180;"	d
LAPACK_chbgv	lib/Eigen/src/misc/lapacke.h	11408;"	d
LAPACK_chbgvd	lib/Eigen/src/misc/lapacke.h	11412;"	d
LAPACK_chbgvx	lib/Eigen/src/misc/lapacke.h	11416;"	d
LAPACK_chbtrd	lib/Eigen/src/misc/lapacke.h	11138;"	d
LAPACK_checon	lib/Eigen/src/misc/lapacke.h	10748;"	d
LAPACK_cheequb	lib/Eigen/src/misc/lapacke.h	10915;"	d
LAPACK_cheev	lib/Eigen/src/misc/lapacke.h	11304;"	d
LAPACK_cheevd	lib/Eigen/src/misc/lapacke.h	11308;"	d
LAPACK_cheevr	lib/Eigen/src/misc/lapacke.h	11316;"	d
LAPACK_cheevx	lib/Eigen/src/misc/lapacke.h	11312;"	d
LAPACK_chegst	lib/Eigen/src/misc/lapacke.h	11172;"	d
LAPACK_chegv	lib/Eigen/src/misc/lapacke.h	11384;"	d
LAPACK_chegvd	lib/Eigen/src/misc/lapacke.h	11388;"	d
LAPACK_chegvx	lib/Eigen/src/misc/lapacke.h	11392;"	d
LAPACK_cherfs	lib/Eigen/src/misc/lapacke.h	10816;"	d
LAPACK_cherfsx	lib/Eigen/src/misc/lapacke.h	10819;"	d
LAPACK_chesv	lib/Eigen/src/misc/lapacke.h	11000;"	d
LAPACK_chesvx	lib/Eigen/src/misc/lapacke.h	11002;"	d
LAPACK_chesvxx	lib/Eigen/src/misc/lapacke.h	11005;"	d
LAPACK_cheswapr	lib/Eigen/src/misc/lapacke.h	11570;"	d
LAPACK_chetrd	lib/Eigen/src/misc/lapacke.h	11118;"	d
LAPACK_chetrf	lib/Eigen/src/misc/lapacke.h	10652;"	d
LAPACK_chetri	lib/Eigen/src/misc/lapacke.h	10858;"	d
LAPACK_chetri2	lib/Eigen/src/misc/lapacke.h	11571;"	d
LAPACK_chetri2x	lib/Eigen/src/misc/lapacke.h	11572;"	d
LAPACK_chetrs	lib/Eigen/src/misc/lapacke.h	10696;"	d
LAPACK_chetrs2	lib/Eigen/src/misc/lapacke.h	11573;"	d
LAPACK_chfrk	lib/Eigen/src/misc/lapacke.h	11437;"	d
LAPACK_chgeqz	lib/Eigen/src/misc/lapacke.h	11248;"	d
LAPACK_chpcon	lib/Eigen/src/misc/lapacke.h	10754;"	d
LAPACK_chpev	lib/Eigen/src/misc/lapacke.h	11320;"	d
LAPACK_chpevd	lib/Eigen/src/misc/lapacke.h	11324;"	d
LAPACK_chpevx	lib/Eigen/src/misc/lapacke.h	11328;"	d
LAPACK_chpgst	lib/Eigen/src/misc/lapacke.h	11176;"	d
LAPACK_chpgv	lib/Eigen/src/misc/lapacke.h	11396;"	d
LAPACK_chpgvd	lib/Eigen/src/misc/lapacke.h	11400;"	d
LAPACK_chpgvx	lib/Eigen/src/misc/lapacke.h	11404;"	d
LAPACK_chprfs	lib/Eigen/src/misc/lapacke.h	10824;"	d
LAPACK_chpsv	lib/Eigen/src/misc/lapacke.h	11014;"	d
LAPACK_chpsvx	lib/Eigen/src/misc/lapacke.h	11016;"	d
LAPACK_chptrd	lib/Eigen/src/misc/lapacke.h	11130;"	d
LAPACK_chptrf	lib/Eigen/src/misc/lapacke.h	10658;"	d
LAPACK_chptri	lib/Eigen/src/misc/lapacke.h	10864;"	d
LAPACK_chptrs	lib/Eigen/src/misc/lapacke.h	10702;"	d
LAPACK_chsein	lib/Eigen/src/misc/lapacke.h	11212;"	d
LAPACK_chseqr	lib/Eigen/src/misc/lapacke.h	11208;"	d
LAPACK_clacgv	lib/Eigen/src/misc/lapacke.h	11470;"	d
LAPACK_clacpy	lib/Eigen/src/misc/lapacke.h	11482;"	d
LAPACK_clag2z	lib/Eigen/src/misc/lapacke.h	11534;"	d
LAPACK_clagge	lib/Eigen/src/misc/lapacke.h	11542;"	d
LAPACK_claghe	lib/Eigen/src/misc/lapacke.h	11554;"	d
LAPACK_clagsy	lib/Eigen/src/misc/lapacke.h	11552;"	d
LAPACK_clange	lib/Eigen/src/misc/lapacke.h	11494;"	d
LAPACK_clanhe	lib/Eigen/src/misc/lapacke.h	11496;"	d
LAPACK_clansy	lib/Eigen/src/misc/lapacke.h	11500;"	d
LAPACK_clantr	lib/Eigen/src/misc/lapacke.h	11504;"	d
LAPACK_clapmr	lib/Eigen/src/misc/lapacke.h	11558;"	d
LAPACK_clarfb	lib/Eigen/src/misc/lapacke.h	11514;"	d
LAPACK_clarfg	lib/Eigen/src/misc/lapacke.h	11518;"	d
LAPACK_clarft	lib/Eigen/src/misc/lapacke.h	11522;"	d
LAPACK_clarfx	lib/Eigen/src/misc/lapacke.h	11526;"	d
LAPACK_clarnv	lib/Eigen/src/misc/lapacke.h	11474;"	d
LAPACK_claset	lib/Eigen/src/misc/lapacke.h	11546;"	d
LAPACK_claswp	lib/Eigen/src/misc/lapacke.h	11490;"	d
LAPACK_clatms	lib/Eigen/src/misc/lapacke.h	11530;"	d
LAPACK_clauum	lib/Eigen/src/misc/lapacke.h	11538;"	d
LAPACK_cpbcon	lib/Eigen/src/misc/lapacke.h	10738;"	d
LAPACK_cpbequ	lib/Eigen/src/misc/lapacke.h	10908;"	d
LAPACK_cpbrfs	lib/Eigen/src/misc/lapacke.h	10802;"	d
LAPACK_cpbstf	lib/Eigen/src/misc/lapacke.h	11184;"	d
LAPACK_cpbsv	lib/Eigen/src/misc/lapacke.h	10974;"	d
LAPACK_cpbsvx	lib/Eigen/src/misc/lapacke.h	10978;"	d
LAPACK_cpbtrf	lib/Eigen/src/misc/lapacke.h	10642;"	d
LAPACK_cpbtrs	lib/Eigen/src/misc/lapacke.h	10686;"	d
LAPACK_cpftrf	lib/Eigen/src/misc/lapacke.h	10635;"	d
LAPACK_cpftri	lib/Eigen/src/misc/lapacke.h	10849;"	d
LAPACK_cpftrs	lib/Eigen/src/misc/lapacke.h	10679;"	d
LAPACK_cpocon	lib/Eigen/src/misc/lapacke.h	10730;"	d
LAPACK_cpoequ	lib/Eigen/src/misc/lapacke.h	10896;"	d
LAPACK_cpoequb	lib/Eigen/src/misc/lapacke.h	10901;"	d
LAPACK_cporfs	lib/Eigen/src/misc/lapacke.h	10790;"	d
LAPACK_cporfsx	lib/Eigen/src/misc/lapacke.h	10795;"	d
LAPACK_cposv	lib/Eigen/src/misc/lapacke.h	10952;"	d
LAPACK_cposvx	lib/Eigen/src/misc/lapacke.h	10958;"	d
LAPACK_cposvxx	lib/Eigen/src/misc/lapacke.h	10963;"	d
LAPACK_cpotrf	lib/Eigen/src/misc/lapacke.h	10626;"	d
LAPACK_cpotri	lib/Eigen/src/misc/lapacke.h	10844;"	d
LAPACK_cpotrs	lib/Eigen/src/misc/lapacke.h	10674;"	d
LAPACK_cppcon	lib/Eigen/src/misc/lapacke.h	10734;"	d
LAPACK_cppequ	lib/Eigen/src/misc/lapacke.h	10904;"	d
LAPACK_cpprfs	lib/Eigen/src/misc/lapacke.h	10798;"	d
LAPACK_cppsv	lib/Eigen/src/misc/lapacke.h	10966;"	d
LAPACK_cppsvx	lib/Eigen/src/misc/lapacke.h	10970;"	d
LAPACK_cpptrf	lib/Eigen/src/misc/lapacke.h	10638;"	d
LAPACK_cpptri	lib/Eigen/src/misc/lapacke.h	10852;"	d
LAPACK_cpptrs	lib/Eigen/src/misc/lapacke.h	10682;"	d
LAPACK_cpstrf	lib/Eigen/src/misc/lapacke.h	10631;"	d
LAPACK_cptcon	lib/Eigen/src/misc/lapacke.h	10742;"	d
LAPACK_cpteqr	lib/Eigen/src/misc/lapacke.h	11160;"	d
LAPACK_cptrfs	lib/Eigen/src/misc/lapacke.h	10806;"	d
LAPACK_cptsv	lib/Eigen/src/misc/lapacke.h	10982;"	d
LAPACK_cptsvx	lib/Eigen/src/misc/lapacke.h	10986;"	d
LAPACK_cpttrf	lib/Eigen/src/misc/lapacke.h	10646;"	d
LAPACK_cpttrs	lib/Eigen/src/misc/lapacke.h	10690;"	d
LAPACK_cspcon	lib/Eigen/src/misc/lapacke.h	10752;"	d
LAPACK_csprfs	lib/Eigen/src/misc/lapacke.h	10822;"	d
LAPACK_cspsv	lib/Eigen/src/misc/lapacke.h	11008;"	d
LAPACK_cspsvx	lib/Eigen/src/misc/lapacke.h	11012;"	d
LAPACK_csptrf	lib/Eigen/src/misc/lapacke.h	10656;"	d
LAPACK_csptri	lib/Eigen/src/misc/lapacke.h	10862;"	d
LAPACK_csptrs	lib/Eigen/src/misc/lapacke.h	10700;"	d
LAPACK_cstedc	lib/Eigen/src/misc/lapacke.h	11152;"	d
LAPACK_cstegr	lib/Eigen/src/misc/lapacke.h	11156;"	d
LAPACK_cstein	lib/Eigen/src/misc/lapacke.h	11166;"	d
LAPACK_cstemr	lib/Eigen/src/misc/lapacke.h	11148;"	d
LAPACK_csteqr	lib/Eigen/src/misc/lapacke.h	11144;"	d
LAPACK_csycon	lib/Eigen/src/misc/lapacke.h	10746;"	d
LAPACK_csyconv	lib/Eigen/src/misc/lapacke.h	11574;"	d
LAPACK_csyequb	lib/Eigen/src/misc/lapacke.h	10913;"	d
LAPACK_csyr	lib/Eigen/src/misc/lapacke.h	11642;"	d
LAPACK_csyrfs	lib/Eigen/src/misc/lapacke.h	10810;"	d
LAPACK_csyrfsx	lib/Eigen/src/misc/lapacke.h	10815;"	d
LAPACK_csysv	lib/Eigen/src/misc/lapacke.h	10990;"	d
LAPACK_csysvx	lib/Eigen/src/misc/lapacke.h	10994;"	d
LAPACK_csysvxx	lib/Eigen/src/misc/lapacke.h	10999;"	d
LAPACK_csyswapr	lib/Eigen/src/misc/lapacke.h	11575;"	d
LAPACK_csytrf	lib/Eigen/src/misc/lapacke.h	10650;"	d
LAPACK_csytri	lib/Eigen/src/misc/lapacke.h	10856;"	d
LAPACK_csytri2	lib/Eigen/src/misc/lapacke.h	11576;"	d
LAPACK_csytri2x	lib/Eigen/src/misc/lapacke.h	11577;"	d
LAPACK_csytrs	lib/Eigen/src/misc/lapacke.h	10694;"	d
LAPACK_csytrs2	lib/Eigen/src/misc/lapacke.h	11578;"	d
LAPACK_ctbcon	lib/Eigen/src/misc/lapacke.h	10766;"	d
LAPACK_ctbrfs	lib/Eigen/src/misc/lapacke.h	10836;"	d
LAPACK_ctbtrs	lib/Eigen/src/misc/lapacke.h	10714;"	d
LAPACK_ctfsm	lib/Eigen/src/misc/lapacke.h	11441;"	d
LAPACK_ctftri	lib/Eigen/src/misc/lapacke.h	10873;"	d
LAPACK_ctfttp	lib/Eigen/src/misc/lapacke.h	11445;"	d
LAPACK_ctfttr	lib/Eigen/src/misc/lapacke.h	11449;"	d
LAPACK_ctgevc	lib/Eigen/src/misc/lapacke.h	11252;"	d
LAPACK_ctgexc	lib/Eigen/src/misc/lapacke.h	11256;"	d
LAPACK_ctgsen	lib/Eigen/src/misc/lapacke.h	11260;"	d
LAPACK_ctgsja	lib/Eigen/src/misc/lapacke.h	11276;"	d
LAPACK_ctgsna	lib/Eigen/src/misc/lapacke.h	11268;"	d
LAPACK_ctgsyl	lib/Eigen/src/misc/lapacke.h	11264;"	d
LAPACK_ctpcon	lib/Eigen/src/misc/lapacke.h	10762;"	d
LAPACK_ctpmqrt	lib/Eigen/src/misc/lapacke.h	11628;"	d
LAPACK_ctpqrt	lib/Eigen/src/misc/lapacke.h	11631;"	d
LAPACK_ctpqrt2	lib/Eigen/src/misc/lapacke.h	11635;"	d
LAPACK_ctprfb	lib/Eigen/src/misc/lapacke.h	11639;"	d
LAPACK_ctprfs	lib/Eigen/src/misc/lapacke.h	10832;"	d
LAPACK_ctptri	lib/Eigen/src/misc/lapacke.h	10876;"	d
LAPACK_ctptrs	lib/Eigen/src/misc/lapacke.h	10710;"	d
LAPACK_ctpttf	lib/Eigen/src/misc/lapacke.h	11453;"	d
LAPACK_ctpttr	lib/Eigen/src/misc/lapacke.h	11457;"	d
LAPACK_ctrcon	lib/Eigen/src/misc/lapacke.h	10758;"	d
LAPACK_ctrevc	lib/Eigen/src/misc/lapacke.h	11216;"	d
LAPACK_ctrexc	lib/Eigen/src/misc/lapacke.h	11224;"	d
LAPACK_ctrrfs	lib/Eigen/src/misc/lapacke.h	10828;"	d
LAPACK_ctrsen	lib/Eigen/src/misc/lapacke.h	11228;"	d
LAPACK_ctrsna	lib/Eigen/src/misc/lapacke.h	11220;"	d
LAPACK_ctrsyl	lib/Eigen/src/misc/lapacke.h	11232;"	d
LAPACK_ctrtri	lib/Eigen/src/misc/lapacke.h	10868;"	d
LAPACK_ctrtrs	lib/Eigen/src/misc/lapacke.h	10706;"	d
LAPACK_ctrttf	lib/Eigen/src/misc/lapacke.h	11461;"	d
LAPACK_ctrttp	lib/Eigen/src/misc/lapacke.h	11465;"	d
LAPACK_ctzrzf	lib/Eigen/src/misc/lapacke.h	11076;"	d
LAPACK_cunbdb	lib/Eigen/src/misc/lapacke.h	11579;"	d
LAPACK_cuncsd	lib/Eigen/src/misc/lapacke.h	11580;"	d
LAPACK_cungbr	lib/Eigen/src/misc/lapacke.h	11102;"	d
LAPACK_cunghr	lib/Eigen/src/misc/lapacke.h	11194;"	d
LAPACK_cunglq	lib/Eigen/src/misc/lapacke.h	11046;"	d
LAPACK_cungql	lib/Eigen/src/misc/lapacke.h	11056;"	d
LAPACK_cungqr	lib/Eigen/src/misc/lapacke.h	11034;"	d
LAPACK_cungrq	lib/Eigen/src/misc/lapacke.h	11068;"	d
LAPACK_cungtr	lib/Eigen/src/misc/lapacke.h	11120;"	d
LAPACK_cunmbr	lib/Eigen/src/misc/lapacke.h	11104;"	d
LAPACK_cunmhr	lib/Eigen/src/misc/lapacke.h	11196;"	d
LAPACK_cunmlq	lib/Eigen/src/misc/lapacke.h	11048;"	d
LAPACK_cunmql	lib/Eigen/src/misc/lapacke.h	11060;"	d
LAPACK_cunmqr	lib/Eigen/src/misc/lapacke.h	11036;"	d
LAPACK_cunmrq	lib/Eigen/src/misc/lapacke.h	11072;"	d
LAPACK_cunmrz	lib/Eigen/src/misc/lapacke.h	11080;"	d
LAPACK_cunmtr	lib/Eigen/src/misc/lapacke.h	11122;"	d
LAPACK_cupgtr	lib/Eigen/src/misc/lapacke.h	11132;"	d
LAPACK_cupmtr	lib/Eigen/src/misc/lapacke.h	11134;"	d
LAPACK_dbbcsd	lib/Eigen/src/misc/lapacke.h	11581;"	d
LAPACK_dbdsdc	lib/Eigen/src/misc/lapacke.h	11111;"	d
LAPACK_dbdsqr	lib/Eigen/src/misc/lapacke.h	11107;"	d
LAPACK_ddisna	lib/Eigen/src/misc/lapacke.h	11169;"	d
LAPACK_dgbbrd	lib/Eigen/src/misc/lapacke.h	11095;"	d
LAPACK_dgbcon	lib/Eigen/src/misc/lapacke.h	10721;"	d
LAPACK_dgbequ	lib/Eigen/src/misc/lapacke.h	10887;"	d
LAPACK_dgbequb	lib/Eigen/src/misc/lapacke.h	10890;"	d
LAPACK_dgbrfs	lib/Eigen/src/misc/lapacke.h	10777;"	d
LAPACK_dgbrfsx	lib/Eigen/src/misc/lapacke.h	10780;"	d
LAPACK_dgbsv	lib/Eigen/src/misc/lapacke.h	10931;"	d
LAPACK_dgbsvx	lib/Eigen/src/misc/lapacke.h	10935;"	d
LAPACK_dgbsvxx	lib/Eigen/src/misc/lapacke.h	10938;"	d
LAPACK_dgbtrf	lib/Eigen/src/misc/lapacke.h	10617;"	d
LAPACK_dgbtrs	lib/Eigen/src/misc/lapacke.h	10665;"	d
LAPACK_dgebak	lib/Eigen/src/misc/lapacke.h	11203;"	d
LAPACK_dgebal	lib/Eigen/src/misc/lapacke.h	11199;"	d
LAPACK_dgebrd	lib/Eigen/src/misc/lapacke.h	11091;"	d
LAPACK_dgecon	lib/Eigen/src/misc/lapacke.h	10717;"	d
LAPACK_dgeequ	lib/Eigen/src/misc/lapacke.h	10879;"	d
LAPACK_dgeequb	lib/Eigen/src/misc/lapacke.h	10882;"	d
LAPACK_dgees	lib/Eigen/src/misc/lapacke.h	11351;"	d
LAPACK_dgeesx	lib/Eigen/src/misc/lapacke.h	11355;"	d
LAPACK_dgeev	lib/Eigen/src/misc/lapacke.h	11359;"	d
LAPACK_dgeevx	lib/Eigen/src/misc/lapacke.h	11363;"	d
LAPACK_dgehrd	lib/Eigen/src/misc/lapacke.h	11187;"	d
LAPACK_dgejsv	lib/Eigen/src/misc/lapacke.h	11374;"	d
LAPACK_dgelq2	lib/Eigen/src/misc/lapacke.h	11509;"	d
LAPACK_dgelqf	lib/Eigen/src/misc/lapacke.h	11039;"	d
LAPACK_dgels	lib/Eigen/src/misc/lapacke.h	11279;"	d
LAPACK_dgelsd	lib/Eigen/src/misc/lapacke.h	11291;"	d
LAPACK_dgelss	lib/Eigen/src/misc/lapacke.h	11287;"	d
LAPACK_dgelsy	lib/Eigen/src/misc/lapacke.h	11283;"	d
LAPACK_dgemqrt	lib/Eigen/src/misc/lapacke.h	11611;"	d
LAPACK_dgeqlf	lib/Eigen/src/misc/lapacke.h	11051;"	d
LAPACK_dgeqp3	lib/Eigen/src/misc/lapacke.h	11027;"	d
LAPACK_dgeqpf	lib/Eigen/src/misc/lapacke.h	11023;"	d
LAPACK_dgeqr2	lib/Eigen/src/misc/lapacke.h	11477;"	d
LAPACK_dgeqrf	lib/Eigen/src/misc/lapacke.h	11019;"	d
LAPACK_dgeqrfp	lib/Eigen/src/misc/lapacke.h	11467;"	d
LAPACK_dgeqrt	lib/Eigen/src/misc/lapacke.h	11615;"	d
LAPACK_dgeqrt2	lib/Eigen/src/misc/lapacke.h	11619;"	d
LAPACK_dgeqrt3	lib/Eigen/src/misc/lapacke.h	11623;"	d
LAPACK_dgerfs	lib/Eigen/src/misc/lapacke.h	10769;"	d
LAPACK_dgerfsx	lib/Eigen/src/misc/lapacke.h	10772;"	d
LAPACK_dgerqf	lib/Eigen/src/misc/lapacke.h	11063;"	d
LAPACK_dgesdd	lib/Eigen/src/misc/lapacke.h	11371;"	d
LAPACK_dgesv	lib/Eigen/src/misc/lapacke.h	10917;"	d
LAPACK_dgesvd	lib/Eigen/src/misc/lapacke.h	11367;"	d
LAPACK_dgesvj	lib/Eigen/src/misc/lapacke.h	11376;"	d
LAPACK_dgesvx	lib/Eigen/src/misc/lapacke.h	10923;"	d
LAPACK_dgesvxx	lib/Eigen/src/misc/lapacke.h	10926;"	d
LAPACK_dgetf2	lib/Eigen/src/misc/lapacke.h	11485;"	d
LAPACK_dgetrf	lib/Eigen/src/misc/lapacke.h	10613;"	d
LAPACK_dgetri	lib/Eigen/src/misc/lapacke.h	10839;"	d
LAPACK_dgetrs	lib/Eigen/src/misc/lapacke.h	10661;"	d
LAPACK_dggbak	lib/Eigen/src/misc/lapacke.h	11243;"	d
LAPACK_dggbal	lib/Eigen/src/misc/lapacke.h	11239;"	d
LAPACK_dgges	lib/Eigen/src/misc/lapacke.h	11419;"	d
LAPACK_dggesx	lib/Eigen/src/misc/lapacke.h	11423;"	d
LAPACK_dggev	lib/Eigen/src/misc/lapacke.h	11427;"	d
LAPACK_dggevx	lib/Eigen/src/misc/lapacke.h	11431;"	d
LAPACK_dggglm	lib/Eigen/src/misc/lapacke.h	11299;"	d
LAPACK_dgghrd	lib/Eigen/src/misc/lapacke.h	11235;"	d
LAPACK_dgglse	lib/Eigen/src/misc/lapacke.h	11295;"	d
LAPACK_dggqrf	lib/Eigen/src/misc/lapacke.h	11083;"	d
LAPACK_dggrqf	lib/Eigen/src/misc/lapacke.h	11087;"	d
LAPACK_dggsvd	lib/Eigen/src/misc/lapacke.h	11379;"	d
LAPACK_dggsvp	lib/Eigen/src/misc/lapacke.h	11271;"	d
LAPACK_dgtcon	lib/Eigen/src/misc/lapacke.h	10725;"	d
LAPACK_dgtrfs	lib/Eigen/src/misc/lapacke.h	10785;"	d
LAPACK_dgtsv	lib/Eigen/src/misc/lapacke.h	10943;"	d
LAPACK_dgtsvx	lib/Eigen/src/misc/lapacke.h	10947;"	d
LAPACK_dgttrf	lib/Eigen/src/misc/lapacke.h	10621;"	d
LAPACK_dgttrs	lib/Eigen/src/misc/lapacke.h	10669;"	d
LAPACK_dhgeqz	lib/Eigen/src/misc/lapacke.h	11247;"	d
LAPACK_dhsein	lib/Eigen/src/misc/lapacke.h	11211;"	d
LAPACK_dhseqr	lib/Eigen/src/misc/lapacke.h	11207;"	d
LAPACK_dlacpy	lib/Eigen/src/misc/lapacke.h	11481;"	d
LAPACK_dlag2s	lib/Eigen/src/misc/lapacke.h	11533;"	d
LAPACK_dlagge	lib/Eigen/src/misc/lapacke.h	11541;"	d
LAPACK_dlagsy	lib/Eigen/src/misc/lapacke.h	11551;"	d
LAPACK_dlamch	lib/Eigen/src/misc/lapacke.h	11507;"	d
LAPACK_dlange	lib/Eigen/src/misc/lapacke.h	11493;"	d
LAPACK_dlansy	lib/Eigen/src/misc/lapacke.h	11499;"	d
LAPACK_dlantr	lib/Eigen/src/misc/lapacke.h	11503;"	d
LAPACK_dlapmr	lib/Eigen/src/misc/lapacke.h	11557;"	d
LAPACK_dlapy2	lib/Eigen/src/misc/lapacke.h	11561;"	d
LAPACK_dlapy3	lib/Eigen/src/misc/lapacke.h	11563;"	d
LAPACK_dlarfb	lib/Eigen/src/misc/lapacke.h	11513;"	d
LAPACK_dlarfg	lib/Eigen/src/misc/lapacke.h	11517;"	d
LAPACK_dlarft	lib/Eigen/src/misc/lapacke.h	11521;"	d
LAPACK_dlarfx	lib/Eigen/src/misc/lapacke.h	11525;"	d
LAPACK_dlarnv	lib/Eigen/src/misc/lapacke.h	11473;"	d
LAPACK_dlartgp	lib/Eigen/src/misc/lapacke.h	11565;"	d
LAPACK_dlartgs	lib/Eigen/src/misc/lapacke.h	11567;"	d
LAPACK_dlaset	lib/Eigen/src/misc/lapacke.h	11545;"	d
LAPACK_dlasrt	lib/Eigen/src/misc/lapacke.h	11549;"	d
LAPACK_dlaswp	lib/Eigen/src/misc/lapacke.h	11489;"	d
LAPACK_dlatms	lib/Eigen/src/misc/lapacke.h	11529;"	d
LAPACK_dlauum	lib/Eigen/src/misc/lapacke.h	11537;"	d
LAPACK_dopgtr	lib/Eigen/src/misc/lapacke.h	11127;"	d
LAPACK_dopmtr	lib/Eigen/src/misc/lapacke.h	11129;"	d
LAPACK_dorbdb	lib/Eigen/src/misc/lapacke.h	11582;"	d
LAPACK_dorcsd	lib/Eigen/src/misc/lapacke.h	11583;"	d
LAPACK_dorgbr	lib/Eigen/src/misc/lapacke.h	11099;"	d
LAPACK_dorghr	lib/Eigen/src/misc/lapacke.h	11191;"	d
LAPACK_dorglq	lib/Eigen/src/misc/lapacke.h	11043;"	d
LAPACK_dorgql	lib/Eigen/src/misc/lapacke.h	11055;"	d
LAPACK_dorgqr	lib/Eigen/src/misc/lapacke.h	11031;"	d
LAPACK_dorgrq	lib/Eigen/src/misc/lapacke.h	11067;"	d
LAPACK_dorgtr	lib/Eigen/src/misc/lapacke.h	11115;"	d
LAPACK_dormbr	lib/Eigen/src/misc/lapacke.h	11101;"	d
LAPACK_dormhr	lib/Eigen/src/misc/lapacke.h	11193;"	d
LAPACK_dormlq	lib/Eigen/src/misc/lapacke.h	11045;"	d
LAPACK_dormql	lib/Eigen/src/misc/lapacke.h	11059;"	d
LAPACK_dormqr	lib/Eigen/src/misc/lapacke.h	11033;"	d
LAPACK_dormrq	lib/Eigen/src/misc/lapacke.h	11071;"	d
LAPACK_dormrz	lib/Eigen/src/misc/lapacke.h	11079;"	d
LAPACK_dormtr	lib/Eigen/src/misc/lapacke.h	11117;"	d
LAPACK_dpbcon	lib/Eigen/src/misc/lapacke.h	10737;"	d
LAPACK_dpbequ	lib/Eigen/src/misc/lapacke.h	10907;"	d
LAPACK_dpbrfs	lib/Eigen/src/misc/lapacke.h	10801;"	d
LAPACK_dpbstf	lib/Eigen/src/misc/lapacke.h	11183;"	d
LAPACK_dpbsv	lib/Eigen/src/misc/lapacke.h	10973;"	d
LAPACK_dpbsvx	lib/Eigen/src/misc/lapacke.h	10977;"	d
LAPACK_dpbtrf	lib/Eigen/src/misc/lapacke.h	10641;"	d
LAPACK_dpbtrs	lib/Eigen/src/misc/lapacke.h	10685;"	d
LAPACK_dpftrf	lib/Eigen/src/misc/lapacke.h	10632;"	d
LAPACK_dpftri	lib/Eigen/src/misc/lapacke.h	10846;"	d
LAPACK_dpftrs	lib/Eigen/src/misc/lapacke.h	10676;"	d
LAPACK_dpocon	lib/Eigen/src/misc/lapacke.h	10729;"	d
LAPACK_dpoequ	lib/Eigen/src/misc/lapacke.h	10895;"	d
LAPACK_dpoequb	lib/Eigen/src/misc/lapacke.h	10898;"	d
LAPACK_dporfs	lib/Eigen/src/misc/lapacke.h	10789;"	d
LAPACK_dporfsx	lib/Eigen/src/misc/lapacke.h	10792;"	d
LAPACK_dposv	lib/Eigen/src/misc/lapacke.h	10951;"	d
LAPACK_dposvx	lib/Eigen/src/misc/lapacke.h	10957;"	d
LAPACK_dposvxx	lib/Eigen/src/misc/lapacke.h	10960;"	d
LAPACK_dpotrf	lib/Eigen/src/misc/lapacke.h	10625;"	d
LAPACK_dpotri	lib/Eigen/src/misc/lapacke.h	10843;"	d
LAPACK_dpotrs	lib/Eigen/src/misc/lapacke.h	10673;"	d
LAPACK_dppcon	lib/Eigen/src/misc/lapacke.h	10733;"	d
LAPACK_dppequ	lib/Eigen/src/misc/lapacke.h	10903;"	d
LAPACK_dpprfs	lib/Eigen/src/misc/lapacke.h	10797;"	d
LAPACK_dppsv	lib/Eigen/src/misc/lapacke.h	10965;"	d
LAPACK_dppsvx	lib/Eigen/src/misc/lapacke.h	10969;"	d
LAPACK_dpptrf	lib/Eigen/src/misc/lapacke.h	10637;"	d
LAPACK_dpptri	lib/Eigen/src/misc/lapacke.h	10851;"	d
LAPACK_dpptrs	lib/Eigen/src/misc/lapacke.h	10681;"	d
LAPACK_dpstrf	lib/Eigen/src/misc/lapacke.h	10628;"	d
LAPACK_dptcon	lib/Eigen/src/misc/lapacke.h	10741;"	d
LAPACK_dpteqr	lib/Eigen/src/misc/lapacke.h	11159;"	d
LAPACK_dptrfs	lib/Eigen/src/misc/lapacke.h	10805;"	d
LAPACK_dptsv	lib/Eigen/src/misc/lapacke.h	10981;"	d
LAPACK_dptsvx	lib/Eigen/src/misc/lapacke.h	10985;"	d
LAPACK_dpttrf	lib/Eigen/src/misc/lapacke.h	10645;"	d
LAPACK_dpttrs	lib/Eigen/src/misc/lapacke.h	10689;"	d
LAPACK_dsbev	lib/Eigen/src/misc/lapacke.h	11331;"	d
LAPACK_dsbevd	lib/Eigen/src/misc/lapacke.h	11335;"	d
LAPACK_dsbevx	lib/Eigen/src/misc/lapacke.h	11339;"	d
LAPACK_dsbgst	lib/Eigen/src/misc/lapacke.h	11179;"	d
LAPACK_dsbgv	lib/Eigen/src/misc/lapacke.h	11407;"	d
LAPACK_dsbgvd	lib/Eigen/src/misc/lapacke.h	11411;"	d
LAPACK_dsbgvx	lib/Eigen/src/misc/lapacke.h	11415;"	d
LAPACK_dsbtrd	lib/Eigen/src/misc/lapacke.h	11137;"	d
LAPACK_dsfrk	lib/Eigen/src/misc/lapacke.h	11434;"	d
LAPACK_dsgesv	lib/Eigen/src/misc/lapacke.h	10920;"	d
LAPACK_dspcon	lib/Eigen/src/misc/lapacke.h	10751;"	d
LAPACK_dspev	lib/Eigen/src/misc/lapacke.h	11319;"	d
LAPACK_dspevd	lib/Eigen/src/misc/lapacke.h	11323;"	d
LAPACK_dspevx	lib/Eigen/src/misc/lapacke.h	11327;"	d
LAPACK_dspgst	lib/Eigen/src/misc/lapacke.h	11175;"	d
LAPACK_dspgv	lib/Eigen/src/misc/lapacke.h	11395;"	d
LAPACK_dspgvd	lib/Eigen/src/misc/lapacke.h	11399;"	d
LAPACK_dspgvx	lib/Eigen/src/misc/lapacke.h	11403;"	d
LAPACK_dsposv	lib/Eigen/src/misc/lapacke.h	10954;"	d
LAPACK_dsprfs	lib/Eigen/src/misc/lapacke.h	10821;"	d
LAPACK_dspsv	lib/Eigen/src/misc/lapacke.h	11007;"	d
LAPACK_dspsvx	lib/Eigen/src/misc/lapacke.h	11011;"	d
LAPACK_dsptrd	lib/Eigen/src/misc/lapacke.h	11125;"	d
LAPACK_dsptrf	lib/Eigen/src/misc/lapacke.h	10655;"	d
LAPACK_dsptri	lib/Eigen/src/misc/lapacke.h	10861;"	d
LAPACK_dsptrs	lib/Eigen/src/misc/lapacke.h	10699;"	d
LAPACK_dstebz	lib/Eigen/src/misc/lapacke.h	11163;"	d
LAPACK_dstedc	lib/Eigen/src/misc/lapacke.h	11151;"	d
LAPACK_dstegr	lib/Eigen/src/misc/lapacke.h	11155;"	d
LAPACK_dstein	lib/Eigen/src/misc/lapacke.h	11165;"	d
LAPACK_dstemr	lib/Eigen/src/misc/lapacke.h	11147;"	d
LAPACK_dsteqr	lib/Eigen/src/misc/lapacke.h	11143;"	d
LAPACK_dsterf	lib/Eigen/src/misc/lapacke.h	11141;"	d
LAPACK_dstev	lib/Eigen/src/misc/lapacke.h	11343;"	d
LAPACK_dstevd	lib/Eigen/src/misc/lapacke.h	11345;"	d
LAPACK_dstevr	lib/Eigen/src/misc/lapacke.h	11349;"	d
LAPACK_dstevx	lib/Eigen/src/misc/lapacke.h	11347;"	d
LAPACK_dsycon	lib/Eigen/src/misc/lapacke.h	10745;"	d
LAPACK_dsyconv	lib/Eigen/src/misc/lapacke.h	11584;"	d
LAPACK_dsyequb	lib/Eigen/src/misc/lapacke.h	10910;"	d
LAPACK_dsyev	lib/Eigen/src/misc/lapacke.h	11303;"	d
LAPACK_dsyevd	lib/Eigen/src/misc/lapacke.h	11307;"	d
LAPACK_dsyevr	lib/Eigen/src/misc/lapacke.h	11315;"	d
LAPACK_dsyevx	lib/Eigen/src/misc/lapacke.h	11311;"	d
LAPACK_dsygst	lib/Eigen/src/misc/lapacke.h	11171;"	d
LAPACK_dsygv	lib/Eigen/src/misc/lapacke.h	11383;"	d
LAPACK_dsygvd	lib/Eigen/src/misc/lapacke.h	11387;"	d
LAPACK_dsygvx	lib/Eigen/src/misc/lapacke.h	11391;"	d
LAPACK_dsyrfs	lib/Eigen/src/misc/lapacke.h	10809;"	d
LAPACK_dsyrfsx	lib/Eigen/src/misc/lapacke.h	10812;"	d
LAPACK_dsysv	lib/Eigen/src/misc/lapacke.h	10989;"	d
LAPACK_dsysvx	lib/Eigen/src/misc/lapacke.h	10993;"	d
LAPACK_dsysvxx	lib/Eigen/src/misc/lapacke.h	10996;"	d
LAPACK_dsyswapr	lib/Eigen/src/misc/lapacke.h	11585;"	d
LAPACK_dsytrd	lib/Eigen/src/misc/lapacke.h	11113;"	d
LAPACK_dsytrf	lib/Eigen/src/misc/lapacke.h	10649;"	d
LAPACK_dsytri	lib/Eigen/src/misc/lapacke.h	10855;"	d
LAPACK_dsytri2	lib/Eigen/src/misc/lapacke.h	11586;"	d
LAPACK_dsytri2x	lib/Eigen/src/misc/lapacke.h	11587;"	d
LAPACK_dsytrs	lib/Eigen/src/misc/lapacke.h	10693;"	d
LAPACK_dsytrs2	lib/Eigen/src/misc/lapacke.h	11588;"	d
LAPACK_dtbcon	lib/Eigen/src/misc/lapacke.h	10765;"	d
LAPACK_dtbrfs	lib/Eigen/src/misc/lapacke.h	10835;"	d
LAPACK_dtbtrs	lib/Eigen/src/misc/lapacke.h	10713;"	d
LAPACK_dtfsm	lib/Eigen/src/misc/lapacke.h	11438;"	d
LAPACK_dtftri	lib/Eigen/src/misc/lapacke.h	10870;"	d
LAPACK_dtfttp	lib/Eigen/src/misc/lapacke.h	11442;"	d
LAPACK_dtfttr	lib/Eigen/src/misc/lapacke.h	11446;"	d
LAPACK_dtgevc	lib/Eigen/src/misc/lapacke.h	11251;"	d
LAPACK_dtgexc	lib/Eigen/src/misc/lapacke.h	11255;"	d
LAPACK_dtgsen	lib/Eigen/src/misc/lapacke.h	11259;"	d
LAPACK_dtgsja	lib/Eigen/src/misc/lapacke.h	11275;"	d
LAPACK_dtgsna	lib/Eigen/src/misc/lapacke.h	11267;"	d
LAPACK_dtgsyl	lib/Eigen/src/misc/lapacke.h	11263;"	d
LAPACK_dtpcon	lib/Eigen/src/misc/lapacke.h	10761;"	d
LAPACK_dtpmqrt	lib/Eigen/src/misc/lapacke.h	11627;"	d
LAPACK_dtpqrt	lib/Eigen/src/misc/lapacke.h	11630;"	d
LAPACK_dtpqrt2	lib/Eigen/src/misc/lapacke.h	11634;"	d
LAPACK_dtprfb	lib/Eigen/src/misc/lapacke.h	11638;"	d
LAPACK_dtprfs	lib/Eigen/src/misc/lapacke.h	10831;"	d
LAPACK_dtptri	lib/Eigen/src/misc/lapacke.h	10875;"	d
LAPACK_dtptrs	lib/Eigen/src/misc/lapacke.h	10709;"	d
LAPACK_dtpttf	lib/Eigen/src/misc/lapacke.h	11450;"	d
LAPACK_dtpttr	lib/Eigen/src/misc/lapacke.h	11454;"	d
LAPACK_dtrcon	lib/Eigen/src/misc/lapacke.h	10757;"	d
LAPACK_dtrevc	lib/Eigen/src/misc/lapacke.h	11215;"	d
LAPACK_dtrexc	lib/Eigen/src/misc/lapacke.h	11223;"	d
LAPACK_dtrrfs	lib/Eigen/src/misc/lapacke.h	10827;"	d
LAPACK_dtrsen	lib/Eigen/src/misc/lapacke.h	11227;"	d
LAPACK_dtrsna	lib/Eigen/src/misc/lapacke.h	11219;"	d
LAPACK_dtrsyl	lib/Eigen/src/misc/lapacke.h	11231;"	d
LAPACK_dtrtri	lib/Eigen/src/misc/lapacke.h	10867;"	d
LAPACK_dtrtrs	lib/Eigen/src/misc/lapacke.h	10705;"	d
LAPACK_dtrttf	lib/Eigen/src/misc/lapacke.h	11458;"	d
LAPACK_dtrttp	lib/Eigen/src/misc/lapacke.h	11462;"	d
LAPACK_dtzrzf	lib/Eigen/src/misc/lapacke.h	11075;"	d
LAPACK_lsame	lib/Eigen/src/misc/lapacke.h	147;"	d
LAPACK_sbbcsd	lib/Eigen/src/misc/lapacke.h	11589;"	d
LAPACK_sbdsdc	lib/Eigen/src/misc/lapacke.h	11110;"	d
LAPACK_sbdsqr	lib/Eigen/src/misc/lapacke.h	11106;"	d
LAPACK_sdisna	lib/Eigen/src/misc/lapacke.h	11168;"	d
LAPACK_sgbbrd	lib/Eigen/src/misc/lapacke.h	11094;"	d
LAPACK_sgbcon	lib/Eigen/src/misc/lapacke.h	10720;"	d
LAPACK_sgbequ	lib/Eigen/src/misc/lapacke.h	10886;"	d
LAPACK_sgbequb	lib/Eigen/src/misc/lapacke.h	10891;"	d
LAPACK_sgbrfs	lib/Eigen/src/misc/lapacke.h	10776;"	d
LAPACK_sgbrfsx	lib/Eigen/src/misc/lapacke.h	10781;"	d
LAPACK_sgbsv	lib/Eigen/src/misc/lapacke.h	10930;"	d
LAPACK_sgbsvx	lib/Eigen/src/misc/lapacke.h	10934;"	d
LAPACK_sgbsvxx	lib/Eigen/src/misc/lapacke.h	10939;"	d
LAPACK_sgbtrf	lib/Eigen/src/misc/lapacke.h	10616;"	d
LAPACK_sgbtrs	lib/Eigen/src/misc/lapacke.h	10664;"	d
LAPACK_sgebak	lib/Eigen/src/misc/lapacke.h	11202;"	d
LAPACK_sgebal	lib/Eigen/src/misc/lapacke.h	11198;"	d
LAPACK_sgebrd	lib/Eigen/src/misc/lapacke.h	11090;"	d
LAPACK_sgecon	lib/Eigen/src/misc/lapacke.h	10716;"	d
LAPACK_sgeequ	lib/Eigen/src/misc/lapacke.h	10878;"	d
LAPACK_sgeequb	lib/Eigen/src/misc/lapacke.h	10883;"	d
LAPACK_sgees	lib/Eigen/src/misc/lapacke.h	11350;"	d
LAPACK_sgeesx	lib/Eigen/src/misc/lapacke.h	11354;"	d
LAPACK_sgeev	lib/Eigen/src/misc/lapacke.h	11358;"	d
LAPACK_sgeevx	lib/Eigen/src/misc/lapacke.h	11362;"	d
LAPACK_sgehrd	lib/Eigen/src/misc/lapacke.h	11186;"	d
LAPACK_sgejsv	lib/Eigen/src/misc/lapacke.h	11375;"	d
LAPACK_sgelq2	lib/Eigen/src/misc/lapacke.h	11508;"	d
LAPACK_sgelqf	lib/Eigen/src/misc/lapacke.h	11038;"	d
LAPACK_sgels	lib/Eigen/src/misc/lapacke.h	11278;"	d
LAPACK_sgelsd	lib/Eigen/src/misc/lapacke.h	11290;"	d
LAPACK_sgelss	lib/Eigen/src/misc/lapacke.h	11286;"	d
LAPACK_sgelsy	lib/Eigen/src/misc/lapacke.h	11282;"	d
LAPACK_sgemqrt	lib/Eigen/src/misc/lapacke.h	11610;"	d
LAPACK_sgeqlf	lib/Eigen/src/misc/lapacke.h	11050;"	d
LAPACK_sgeqp3	lib/Eigen/src/misc/lapacke.h	11026;"	d
LAPACK_sgeqpf	lib/Eigen/src/misc/lapacke.h	11022;"	d
LAPACK_sgeqr2	lib/Eigen/src/misc/lapacke.h	11476;"	d
LAPACK_sgeqrf	lib/Eigen/src/misc/lapacke.h	11018;"	d
LAPACK_sgeqrfp	lib/Eigen/src/misc/lapacke.h	11466;"	d
LAPACK_sgeqrt	lib/Eigen/src/misc/lapacke.h	11614;"	d
LAPACK_sgeqrt2	lib/Eigen/src/misc/lapacke.h	11618;"	d
LAPACK_sgeqrt3	lib/Eigen/src/misc/lapacke.h	11622;"	d
LAPACK_sgerfs	lib/Eigen/src/misc/lapacke.h	10768;"	d
LAPACK_sgerfsx	lib/Eigen/src/misc/lapacke.h	10773;"	d
LAPACK_sgerqf	lib/Eigen/src/misc/lapacke.h	11062;"	d
LAPACK_sgesdd	lib/Eigen/src/misc/lapacke.h	11370;"	d
LAPACK_sgesv	lib/Eigen/src/misc/lapacke.h	10916;"	d
LAPACK_sgesvd	lib/Eigen/src/misc/lapacke.h	11366;"	d
LAPACK_sgesvj	lib/Eigen/src/misc/lapacke.h	11377;"	d
LAPACK_sgesvx	lib/Eigen/src/misc/lapacke.h	10922;"	d
LAPACK_sgesvxx	lib/Eigen/src/misc/lapacke.h	10927;"	d
LAPACK_sgetf2	lib/Eigen/src/misc/lapacke.h	11484;"	d
LAPACK_sgetrf	lib/Eigen/src/misc/lapacke.h	10612;"	d
LAPACK_sgetri	lib/Eigen/src/misc/lapacke.h	10838;"	d
LAPACK_sgetrs	lib/Eigen/src/misc/lapacke.h	10660;"	d
LAPACK_sggbak	lib/Eigen/src/misc/lapacke.h	11242;"	d
LAPACK_sggbal	lib/Eigen/src/misc/lapacke.h	11238;"	d
LAPACK_sgges	lib/Eigen/src/misc/lapacke.h	11418;"	d
LAPACK_sggesx	lib/Eigen/src/misc/lapacke.h	11422;"	d
LAPACK_sggev	lib/Eigen/src/misc/lapacke.h	11426;"	d
LAPACK_sggevx	lib/Eigen/src/misc/lapacke.h	11430;"	d
LAPACK_sggglm	lib/Eigen/src/misc/lapacke.h	11298;"	d
LAPACK_sgghrd	lib/Eigen/src/misc/lapacke.h	11234;"	d
LAPACK_sgglse	lib/Eigen/src/misc/lapacke.h	11294;"	d
LAPACK_sggqrf	lib/Eigen/src/misc/lapacke.h	11082;"	d
LAPACK_sggrqf	lib/Eigen/src/misc/lapacke.h	11086;"	d
LAPACK_sggsvd	lib/Eigen/src/misc/lapacke.h	11378;"	d
LAPACK_sggsvp	lib/Eigen/src/misc/lapacke.h	11270;"	d
LAPACK_sgtcon	lib/Eigen/src/misc/lapacke.h	10724;"	d
LAPACK_sgtrfs	lib/Eigen/src/misc/lapacke.h	10784;"	d
LAPACK_sgtsv	lib/Eigen/src/misc/lapacke.h	10942;"	d
LAPACK_sgtsvx	lib/Eigen/src/misc/lapacke.h	10946;"	d
LAPACK_sgttrf	lib/Eigen/src/misc/lapacke.h	10620;"	d
LAPACK_sgttrs	lib/Eigen/src/misc/lapacke.h	10668;"	d
LAPACK_shgeqz	lib/Eigen/src/misc/lapacke.h	11246;"	d
LAPACK_shsein	lib/Eigen/src/misc/lapacke.h	11210;"	d
LAPACK_shseqr	lib/Eigen/src/misc/lapacke.h	11206;"	d
LAPACK_slacpy	lib/Eigen/src/misc/lapacke.h	11480;"	d
LAPACK_slag2d	lib/Eigen/src/misc/lapacke.h	11532;"	d
LAPACK_slagge	lib/Eigen/src/misc/lapacke.h	11540;"	d
LAPACK_slagsy	lib/Eigen/src/misc/lapacke.h	11550;"	d
LAPACK_slamch	lib/Eigen/src/misc/lapacke.h	11506;"	d
LAPACK_slange	lib/Eigen/src/misc/lapacke.h	11492;"	d
LAPACK_slansy	lib/Eigen/src/misc/lapacke.h	11498;"	d
LAPACK_slantr	lib/Eigen/src/misc/lapacke.h	11502;"	d
LAPACK_slapmr	lib/Eigen/src/misc/lapacke.h	11556;"	d
LAPACK_slapy2	lib/Eigen/src/misc/lapacke.h	11560;"	d
LAPACK_slapy3	lib/Eigen/src/misc/lapacke.h	11562;"	d
LAPACK_slarfb	lib/Eigen/src/misc/lapacke.h	11512;"	d
LAPACK_slarfg	lib/Eigen/src/misc/lapacke.h	11516;"	d
LAPACK_slarft	lib/Eigen/src/misc/lapacke.h	11520;"	d
LAPACK_slarfx	lib/Eigen/src/misc/lapacke.h	11524;"	d
LAPACK_slarnv	lib/Eigen/src/misc/lapacke.h	11472;"	d
LAPACK_slartgp	lib/Eigen/src/misc/lapacke.h	11564;"	d
LAPACK_slartgs	lib/Eigen/src/misc/lapacke.h	11566;"	d
LAPACK_slaset	lib/Eigen/src/misc/lapacke.h	11544;"	d
LAPACK_slasrt	lib/Eigen/src/misc/lapacke.h	11548;"	d
LAPACK_slaswp	lib/Eigen/src/misc/lapacke.h	11488;"	d
LAPACK_slatms	lib/Eigen/src/misc/lapacke.h	11528;"	d
LAPACK_slauum	lib/Eigen/src/misc/lapacke.h	11536;"	d
LAPACK_sopgtr	lib/Eigen/src/misc/lapacke.h	11126;"	d
LAPACK_sopmtr	lib/Eigen/src/misc/lapacke.h	11128;"	d
LAPACK_sorbdb	lib/Eigen/src/misc/lapacke.h	11590;"	d
LAPACK_sorcsd	lib/Eigen/src/misc/lapacke.h	11591;"	d
LAPACK_sorgbr	lib/Eigen/src/misc/lapacke.h	11098;"	d
LAPACK_sorghr	lib/Eigen/src/misc/lapacke.h	11190;"	d
LAPACK_sorglq	lib/Eigen/src/misc/lapacke.h	11042;"	d
LAPACK_sorgql	lib/Eigen/src/misc/lapacke.h	11054;"	d
LAPACK_sorgqr	lib/Eigen/src/misc/lapacke.h	11030;"	d
LAPACK_sorgrq	lib/Eigen/src/misc/lapacke.h	11066;"	d
LAPACK_sorgtr	lib/Eigen/src/misc/lapacke.h	11114;"	d
LAPACK_sormbr	lib/Eigen/src/misc/lapacke.h	11100;"	d
LAPACK_sormhr	lib/Eigen/src/misc/lapacke.h	11192;"	d
LAPACK_sormlq	lib/Eigen/src/misc/lapacke.h	11044;"	d
LAPACK_sormql	lib/Eigen/src/misc/lapacke.h	11058;"	d
LAPACK_sormqr	lib/Eigen/src/misc/lapacke.h	11032;"	d
LAPACK_sormrq	lib/Eigen/src/misc/lapacke.h	11070;"	d
LAPACK_sormrz	lib/Eigen/src/misc/lapacke.h	11078;"	d
LAPACK_sormtr	lib/Eigen/src/misc/lapacke.h	11116;"	d
LAPACK_spbcon	lib/Eigen/src/misc/lapacke.h	10736;"	d
LAPACK_spbequ	lib/Eigen/src/misc/lapacke.h	10906;"	d
LAPACK_spbrfs	lib/Eigen/src/misc/lapacke.h	10800;"	d
LAPACK_spbstf	lib/Eigen/src/misc/lapacke.h	11182;"	d
LAPACK_spbsv	lib/Eigen/src/misc/lapacke.h	10972;"	d
LAPACK_spbsvx	lib/Eigen/src/misc/lapacke.h	10976;"	d
LAPACK_spbtrf	lib/Eigen/src/misc/lapacke.h	10640;"	d
LAPACK_spbtrs	lib/Eigen/src/misc/lapacke.h	10684;"	d
LAPACK_spftrf	lib/Eigen/src/misc/lapacke.h	10633;"	d
LAPACK_spftri	lib/Eigen/src/misc/lapacke.h	10847;"	d
LAPACK_spftrs	lib/Eigen/src/misc/lapacke.h	10677;"	d
LAPACK_spocon	lib/Eigen/src/misc/lapacke.h	10728;"	d
LAPACK_spoequ	lib/Eigen/src/misc/lapacke.h	10894;"	d
LAPACK_spoequb	lib/Eigen/src/misc/lapacke.h	10899;"	d
LAPACK_sporfs	lib/Eigen/src/misc/lapacke.h	10788;"	d
LAPACK_sporfsx	lib/Eigen/src/misc/lapacke.h	10793;"	d
LAPACK_sposv	lib/Eigen/src/misc/lapacke.h	10950;"	d
LAPACK_sposvx	lib/Eigen/src/misc/lapacke.h	10956;"	d
LAPACK_sposvxx	lib/Eigen/src/misc/lapacke.h	10961;"	d
LAPACK_spotrf	lib/Eigen/src/misc/lapacke.h	10624;"	d
LAPACK_spotri	lib/Eigen/src/misc/lapacke.h	10842;"	d
LAPACK_spotrs	lib/Eigen/src/misc/lapacke.h	10672;"	d
LAPACK_sppcon	lib/Eigen/src/misc/lapacke.h	10732;"	d
LAPACK_sppequ	lib/Eigen/src/misc/lapacke.h	10902;"	d
LAPACK_spprfs	lib/Eigen/src/misc/lapacke.h	10796;"	d
LAPACK_sppsv	lib/Eigen/src/misc/lapacke.h	10964;"	d
LAPACK_sppsvx	lib/Eigen/src/misc/lapacke.h	10968;"	d
LAPACK_spptrf	lib/Eigen/src/misc/lapacke.h	10636;"	d
LAPACK_spptri	lib/Eigen/src/misc/lapacke.h	10850;"	d
LAPACK_spptrs	lib/Eigen/src/misc/lapacke.h	10680;"	d
LAPACK_spstrf	lib/Eigen/src/misc/lapacke.h	10629;"	d
LAPACK_sptcon	lib/Eigen/src/misc/lapacke.h	10740;"	d
LAPACK_spteqr	lib/Eigen/src/misc/lapacke.h	11158;"	d
LAPACK_sptrfs	lib/Eigen/src/misc/lapacke.h	10804;"	d
LAPACK_sptsv	lib/Eigen/src/misc/lapacke.h	10980;"	d
LAPACK_sptsvx	lib/Eigen/src/misc/lapacke.h	10984;"	d
LAPACK_spttrf	lib/Eigen/src/misc/lapacke.h	10644;"	d
LAPACK_spttrs	lib/Eigen/src/misc/lapacke.h	10688;"	d
LAPACK_ssbev	lib/Eigen/src/misc/lapacke.h	11330;"	d
LAPACK_ssbevd	lib/Eigen/src/misc/lapacke.h	11334;"	d
LAPACK_ssbevx	lib/Eigen/src/misc/lapacke.h	11338;"	d
LAPACK_ssbgst	lib/Eigen/src/misc/lapacke.h	11178;"	d
LAPACK_ssbgv	lib/Eigen/src/misc/lapacke.h	11406;"	d
LAPACK_ssbgvd	lib/Eigen/src/misc/lapacke.h	11410;"	d
LAPACK_ssbgvx	lib/Eigen/src/misc/lapacke.h	11414;"	d
LAPACK_ssbtrd	lib/Eigen/src/misc/lapacke.h	11136;"	d
LAPACK_ssfrk	lib/Eigen/src/misc/lapacke.h	11435;"	d
LAPACK_sspcon	lib/Eigen/src/misc/lapacke.h	10750;"	d
LAPACK_sspev	lib/Eigen/src/misc/lapacke.h	11318;"	d
LAPACK_sspevd	lib/Eigen/src/misc/lapacke.h	11322;"	d
LAPACK_sspevx	lib/Eigen/src/misc/lapacke.h	11326;"	d
LAPACK_sspgst	lib/Eigen/src/misc/lapacke.h	11174;"	d
LAPACK_sspgv	lib/Eigen/src/misc/lapacke.h	11394;"	d
LAPACK_sspgvd	lib/Eigen/src/misc/lapacke.h	11398;"	d
LAPACK_sspgvx	lib/Eigen/src/misc/lapacke.h	11402;"	d
LAPACK_ssprfs	lib/Eigen/src/misc/lapacke.h	10820;"	d
LAPACK_sspsv	lib/Eigen/src/misc/lapacke.h	11006;"	d
LAPACK_sspsvx	lib/Eigen/src/misc/lapacke.h	11010;"	d
LAPACK_ssptrd	lib/Eigen/src/misc/lapacke.h	11124;"	d
LAPACK_ssptrf	lib/Eigen/src/misc/lapacke.h	10654;"	d
LAPACK_ssptri	lib/Eigen/src/misc/lapacke.h	10860;"	d
LAPACK_ssptrs	lib/Eigen/src/misc/lapacke.h	10698;"	d
LAPACK_sstebz	lib/Eigen/src/misc/lapacke.h	11162;"	d
LAPACK_sstedc	lib/Eigen/src/misc/lapacke.h	11150;"	d
LAPACK_sstegr	lib/Eigen/src/misc/lapacke.h	11154;"	d
LAPACK_sstein	lib/Eigen/src/misc/lapacke.h	11164;"	d
LAPACK_sstemr	lib/Eigen/src/misc/lapacke.h	11146;"	d
LAPACK_ssteqr	lib/Eigen/src/misc/lapacke.h	11142;"	d
LAPACK_ssterf	lib/Eigen/src/misc/lapacke.h	11140;"	d
LAPACK_sstev	lib/Eigen/src/misc/lapacke.h	11342;"	d
LAPACK_sstevd	lib/Eigen/src/misc/lapacke.h	11344;"	d
LAPACK_sstevr	lib/Eigen/src/misc/lapacke.h	11348;"	d
LAPACK_sstevx	lib/Eigen/src/misc/lapacke.h	11346;"	d
LAPACK_ssycon	lib/Eigen/src/misc/lapacke.h	10744;"	d
LAPACK_ssyconv	lib/Eigen/src/misc/lapacke.h	11592;"	d
LAPACK_ssyequb	lib/Eigen/src/misc/lapacke.h	10911;"	d
LAPACK_ssyev	lib/Eigen/src/misc/lapacke.h	11302;"	d
LAPACK_ssyevd	lib/Eigen/src/misc/lapacke.h	11306;"	d
LAPACK_ssyevr	lib/Eigen/src/misc/lapacke.h	11314;"	d
LAPACK_ssyevx	lib/Eigen/src/misc/lapacke.h	11310;"	d
LAPACK_ssygst	lib/Eigen/src/misc/lapacke.h	11170;"	d
LAPACK_ssygv	lib/Eigen/src/misc/lapacke.h	11382;"	d
LAPACK_ssygvd	lib/Eigen/src/misc/lapacke.h	11386;"	d
LAPACK_ssygvx	lib/Eigen/src/misc/lapacke.h	11390;"	d
LAPACK_ssyrfs	lib/Eigen/src/misc/lapacke.h	10808;"	d
LAPACK_ssyrfsx	lib/Eigen/src/misc/lapacke.h	10813;"	d
LAPACK_ssysv	lib/Eigen/src/misc/lapacke.h	10988;"	d
LAPACK_ssysvx	lib/Eigen/src/misc/lapacke.h	10992;"	d
LAPACK_ssysvxx	lib/Eigen/src/misc/lapacke.h	10997;"	d
LAPACK_ssyswapr	lib/Eigen/src/misc/lapacke.h	11593;"	d
LAPACK_ssytrd	lib/Eigen/src/misc/lapacke.h	11112;"	d
LAPACK_ssytrf	lib/Eigen/src/misc/lapacke.h	10648;"	d
LAPACK_ssytri	lib/Eigen/src/misc/lapacke.h	10854;"	d
LAPACK_ssytri2	lib/Eigen/src/misc/lapacke.h	11594;"	d
LAPACK_ssytri2x	lib/Eigen/src/misc/lapacke.h	11595;"	d
LAPACK_ssytrs	lib/Eigen/src/misc/lapacke.h	10692;"	d
LAPACK_ssytrs2	lib/Eigen/src/misc/lapacke.h	11596;"	d
LAPACK_stbcon	lib/Eigen/src/misc/lapacke.h	10764;"	d
LAPACK_stbrfs	lib/Eigen/src/misc/lapacke.h	10834;"	d
LAPACK_stbtrs	lib/Eigen/src/misc/lapacke.h	10712;"	d
LAPACK_stfsm	lib/Eigen/src/misc/lapacke.h	11439;"	d
LAPACK_stftri	lib/Eigen/src/misc/lapacke.h	10871;"	d
LAPACK_stfttp	lib/Eigen/src/misc/lapacke.h	11443;"	d
LAPACK_stfttr	lib/Eigen/src/misc/lapacke.h	11447;"	d
LAPACK_stgevc	lib/Eigen/src/misc/lapacke.h	11250;"	d
LAPACK_stgexc	lib/Eigen/src/misc/lapacke.h	11254;"	d
LAPACK_stgsen	lib/Eigen/src/misc/lapacke.h	11258;"	d
LAPACK_stgsja	lib/Eigen/src/misc/lapacke.h	11274;"	d
LAPACK_stgsna	lib/Eigen/src/misc/lapacke.h	11266;"	d
LAPACK_stgsyl	lib/Eigen/src/misc/lapacke.h	11262;"	d
LAPACK_stpcon	lib/Eigen/src/misc/lapacke.h	10760;"	d
LAPACK_stpmqrt	lib/Eigen/src/misc/lapacke.h	11626;"	d
LAPACK_stpqrt2	lib/Eigen/src/misc/lapacke.h	11633;"	d
LAPACK_stprfb	lib/Eigen/src/misc/lapacke.h	11637;"	d
LAPACK_stprfs	lib/Eigen/src/misc/lapacke.h	10830;"	d
LAPACK_stptri	lib/Eigen/src/misc/lapacke.h	10874;"	d
LAPACK_stptrs	lib/Eigen/src/misc/lapacke.h	10708;"	d
LAPACK_stpttf	lib/Eigen/src/misc/lapacke.h	11451;"	d
LAPACK_stpttr	lib/Eigen/src/misc/lapacke.h	11455;"	d
LAPACK_strcon	lib/Eigen/src/misc/lapacke.h	10756;"	d
LAPACK_strevc	lib/Eigen/src/misc/lapacke.h	11214;"	d
LAPACK_strexc	lib/Eigen/src/misc/lapacke.h	11222;"	d
LAPACK_strrfs	lib/Eigen/src/misc/lapacke.h	10826;"	d
LAPACK_strsen	lib/Eigen/src/misc/lapacke.h	11226;"	d
LAPACK_strsna	lib/Eigen/src/misc/lapacke.h	11218;"	d
LAPACK_strsyl	lib/Eigen/src/misc/lapacke.h	11230;"	d
LAPACK_strtri	lib/Eigen/src/misc/lapacke.h	10866;"	d
LAPACK_strtrs	lib/Eigen/src/misc/lapacke.h	10704;"	d
LAPACK_strttf	lib/Eigen/src/misc/lapacke.h	11459;"	d
LAPACK_strttp	lib/Eigen/src/misc/lapacke.h	11463;"	d
LAPACK_stzrzf	lib/Eigen/src/misc/lapacke.h	11074;"	d
LAPACK_zbbcsd	lib/Eigen/src/misc/lapacke.h	11597;"	d
LAPACK_zbdsqr	lib/Eigen/src/misc/lapacke.h	11109;"	d
LAPACK_zcgesv	lib/Eigen/src/misc/lapacke.h	10921;"	d
LAPACK_zcposv	lib/Eigen/src/misc/lapacke.h	10955;"	d
LAPACK_zgbbrd	lib/Eigen/src/misc/lapacke.h	11097;"	d
LAPACK_zgbcon	lib/Eigen/src/misc/lapacke.h	10723;"	d
LAPACK_zgbequ	lib/Eigen/src/misc/lapacke.h	10889;"	d
LAPACK_zgbequb	lib/Eigen/src/misc/lapacke.h	10892;"	d
LAPACK_zgbrfs	lib/Eigen/src/misc/lapacke.h	10779;"	d
LAPACK_zgbrfsx	lib/Eigen/src/misc/lapacke.h	10782;"	d
LAPACK_zgbsv	lib/Eigen/src/misc/lapacke.h	10933;"	d
LAPACK_zgbsvx	lib/Eigen/src/misc/lapacke.h	10937;"	d
LAPACK_zgbsvxx	lib/Eigen/src/misc/lapacke.h	10940;"	d
LAPACK_zgbtrf	lib/Eigen/src/misc/lapacke.h	10619;"	d
LAPACK_zgbtrs	lib/Eigen/src/misc/lapacke.h	10667;"	d
LAPACK_zgebak	lib/Eigen/src/misc/lapacke.h	11205;"	d
LAPACK_zgebal	lib/Eigen/src/misc/lapacke.h	11201;"	d
LAPACK_zgebrd	lib/Eigen/src/misc/lapacke.h	11093;"	d
LAPACK_zgecon	lib/Eigen/src/misc/lapacke.h	10719;"	d
LAPACK_zgeequ	lib/Eigen/src/misc/lapacke.h	10881;"	d
LAPACK_zgeequb	lib/Eigen/src/misc/lapacke.h	10884;"	d
LAPACK_zgees	lib/Eigen/src/misc/lapacke.h	11353;"	d
LAPACK_zgeesx	lib/Eigen/src/misc/lapacke.h	11357;"	d
LAPACK_zgeev	lib/Eigen/src/misc/lapacke.h	11361;"	d
LAPACK_zgeevx	lib/Eigen/src/misc/lapacke.h	11365;"	d
LAPACK_zgehrd	lib/Eigen/src/misc/lapacke.h	11189;"	d
LAPACK_zgelq2	lib/Eigen/src/misc/lapacke.h	11511;"	d
LAPACK_zgelqf	lib/Eigen/src/misc/lapacke.h	11041;"	d
LAPACK_zgels	lib/Eigen/src/misc/lapacke.h	11281;"	d
LAPACK_zgelsd	lib/Eigen/src/misc/lapacke.h	11293;"	d
LAPACK_zgelss	lib/Eigen/src/misc/lapacke.h	11289;"	d
LAPACK_zgelsy	lib/Eigen/src/misc/lapacke.h	11285;"	d
LAPACK_zgemqrt	lib/Eigen/src/misc/lapacke.h	11613;"	d
LAPACK_zgeqlf	lib/Eigen/src/misc/lapacke.h	11053;"	d
LAPACK_zgeqp3	lib/Eigen/src/misc/lapacke.h	11029;"	d
LAPACK_zgeqpf	lib/Eigen/src/misc/lapacke.h	11025;"	d
LAPACK_zgeqr2	lib/Eigen/src/misc/lapacke.h	11479;"	d
LAPACK_zgeqrf	lib/Eigen/src/misc/lapacke.h	11021;"	d
LAPACK_zgeqrfp	lib/Eigen/src/misc/lapacke.h	11469;"	d
LAPACK_zgeqrt	lib/Eigen/src/misc/lapacke.h	11617;"	d
LAPACK_zgeqrt2	lib/Eigen/src/misc/lapacke.h	11621;"	d
LAPACK_zgeqrt3	lib/Eigen/src/misc/lapacke.h	11625;"	d
LAPACK_zgerfs	lib/Eigen/src/misc/lapacke.h	10771;"	d
LAPACK_zgerfsx	lib/Eigen/src/misc/lapacke.h	10774;"	d
LAPACK_zgerqf	lib/Eigen/src/misc/lapacke.h	11065;"	d
LAPACK_zgesdd	lib/Eigen/src/misc/lapacke.h	11373;"	d
LAPACK_zgesv	lib/Eigen/src/misc/lapacke.h	10919;"	d
LAPACK_zgesvd	lib/Eigen/src/misc/lapacke.h	11369;"	d
LAPACK_zgesvx	lib/Eigen/src/misc/lapacke.h	10925;"	d
LAPACK_zgesvxx	lib/Eigen/src/misc/lapacke.h	10928;"	d
LAPACK_zgetf2	lib/Eigen/src/misc/lapacke.h	11487;"	d
LAPACK_zgetrf	lib/Eigen/src/misc/lapacke.h	10615;"	d
LAPACK_zgetri	lib/Eigen/src/misc/lapacke.h	10841;"	d
LAPACK_zgetrs	lib/Eigen/src/misc/lapacke.h	10663;"	d
LAPACK_zggbak	lib/Eigen/src/misc/lapacke.h	11245;"	d
LAPACK_zggbal	lib/Eigen/src/misc/lapacke.h	11241;"	d
LAPACK_zgges	lib/Eigen/src/misc/lapacke.h	11421;"	d
LAPACK_zggesx	lib/Eigen/src/misc/lapacke.h	11425;"	d
LAPACK_zggev	lib/Eigen/src/misc/lapacke.h	11429;"	d
LAPACK_zggevx	lib/Eigen/src/misc/lapacke.h	11433;"	d
LAPACK_zggglm	lib/Eigen/src/misc/lapacke.h	11301;"	d
LAPACK_zgghrd	lib/Eigen/src/misc/lapacke.h	11237;"	d
LAPACK_zgglse	lib/Eigen/src/misc/lapacke.h	11297;"	d
LAPACK_zggqrf	lib/Eigen/src/misc/lapacke.h	11085;"	d
LAPACK_zggrqf	lib/Eigen/src/misc/lapacke.h	11089;"	d
LAPACK_zggsvd	lib/Eigen/src/misc/lapacke.h	11381;"	d
LAPACK_zggsvp	lib/Eigen/src/misc/lapacke.h	11273;"	d
LAPACK_zgtcon	lib/Eigen/src/misc/lapacke.h	10727;"	d
LAPACK_zgtrfs	lib/Eigen/src/misc/lapacke.h	10787;"	d
LAPACK_zgtsv	lib/Eigen/src/misc/lapacke.h	10945;"	d
LAPACK_zgtsvx	lib/Eigen/src/misc/lapacke.h	10949;"	d
LAPACK_zgttrf	lib/Eigen/src/misc/lapacke.h	10623;"	d
LAPACK_zgttrs	lib/Eigen/src/misc/lapacke.h	10671;"	d
LAPACK_zhbev	lib/Eigen/src/misc/lapacke.h	11333;"	d
LAPACK_zhbevd	lib/Eigen/src/misc/lapacke.h	11337;"	d
LAPACK_zhbevx	lib/Eigen/src/misc/lapacke.h	11341;"	d
LAPACK_zhbgst	lib/Eigen/src/misc/lapacke.h	11181;"	d
LAPACK_zhbgv	lib/Eigen/src/misc/lapacke.h	11409;"	d
LAPACK_zhbgvd	lib/Eigen/src/misc/lapacke.h	11413;"	d
LAPACK_zhbgvx	lib/Eigen/src/misc/lapacke.h	11417;"	d
LAPACK_zhbtrd	lib/Eigen/src/misc/lapacke.h	11139;"	d
LAPACK_zhecon	lib/Eigen/src/misc/lapacke.h	10749;"	d
LAPACK_zheequb	lib/Eigen/src/misc/lapacke.h	10914;"	d
LAPACK_zheev	lib/Eigen/src/misc/lapacke.h	11305;"	d
LAPACK_zheevd	lib/Eigen/src/misc/lapacke.h	11309;"	d
LAPACK_zheevr	lib/Eigen/src/misc/lapacke.h	11317;"	d
LAPACK_zheevx	lib/Eigen/src/misc/lapacke.h	11313;"	d
LAPACK_zhegst	lib/Eigen/src/misc/lapacke.h	11173;"	d
LAPACK_zhegv	lib/Eigen/src/misc/lapacke.h	11385;"	d
LAPACK_zhegvd	lib/Eigen/src/misc/lapacke.h	11389;"	d
LAPACK_zhegvx	lib/Eigen/src/misc/lapacke.h	11393;"	d
LAPACK_zherfs	lib/Eigen/src/misc/lapacke.h	10817;"	d
LAPACK_zherfsx	lib/Eigen/src/misc/lapacke.h	10818;"	d
LAPACK_zhesv	lib/Eigen/src/misc/lapacke.h	11001;"	d
LAPACK_zhesvx	lib/Eigen/src/misc/lapacke.h	11003;"	d
LAPACK_zhesvxx	lib/Eigen/src/misc/lapacke.h	11004;"	d
LAPACK_zheswapr	lib/Eigen/src/misc/lapacke.h	11598;"	d
LAPACK_zhetrd	lib/Eigen/src/misc/lapacke.h	11119;"	d
LAPACK_zhetrf	lib/Eigen/src/misc/lapacke.h	10653;"	d
LAPACK_zhetri	lib/Eigen/src/misc/lapacke.h	10859;"	d
LAPACK_zhetri2	lib/Eigen/src/misc/lapacke.h	11599;"	d
LAPACK_zhetri2x	lib/Eigen/src/misc/lapacke.h	11600;"	d
LAPACK_zhetrs	lib/Eigen/src/misc/lapacke.h	10697;"	d
LAPACK_zhetrs2	lib/Eigen/src/misc/lapacke.h	11601;"	d
LAPACK_zhfrk	lib/Eigen/src/misc/lapacke.h	11436;"	d
LAPACK_zhgeqz	lib/Eigen/src/misc/lapacke.h	11249;"	d
LAPACK_zhpcon	lib/Eigen/src/misc/lapacke.h	10755;"	d
LAPACK_zhpev	lib/Eigen/src/misc/lapacke.h	11321;"	d
LAPACK_zhpevd	lib/Eigen/src/misc/lapacke.h	11325;"	d
LAPACK_zhpevx	lib/Eigen/src/misc/lapacke.h	11329;"	d
LAPACK_zhpgst	lib/Eigen/src/misc/lapacke.h	11177;"	d
LAPACK_zhpgv	lib/Eigen/src/misc/lapacke.h	11397;"	d
LAPACK_zhpgvd	lib/Eigen/src/misc/lapacke.h	11401;"	d
LAPACK_zhpgvx	lib/Eigen/src/misc/lapacke.h	11405;"	d
LAPACK_zhprfs	lib/Eigen/src/misc/lapacke.h	10825;"	d
LAPACK_zhpsv	lib/Eigen/src/misc/lapacke.h	11015;"	d
LAPACK_zhpsvx	lib/Eigen/src/misc/lapacke.h	11017;"	d
LAPACK_zhptrd	lib/Eigen/src/misc/lapacke.h	11131;"	d
LAPACK_zhptrf	lib/Eigen/src/misc/lapacke.h	10659;"	d
LAPACK_zhptri	lib/Eigen/src/misc/lapacke.h	10865;"	d
LAPACK_zhptrs	lib/Eigen/src/misc/lapacke.h	10703;"	d
LAPACK_zhsein	lib/Eigen/src/misc/lapacke.h	11213;"	d
LAPACK_zhseqr	lib/Eigen/src/misc/lapacke.h	11209;"	d
LAPACK_zlacgv	lib/Eigen/src/misc/lapacke.h	11471;"	d
LAPACK_zlacpy	lib/Eigen/src/misc/lapacke.h	11483;"	d
LAPACK_zlag2c	lib/Eigen/src/misc/lapacke.h	11535;"	d
LAPACK_zlagge	lib/Eigen/src/misc/lapacke.h	11543;"	d
LAPACK_zlaghe	lib/Eigen/src/misc/lapacke.h	11555;"	d
LAPACK_zlagsy	lib/Eigen/src/misc/lapacke.h	11553;"	d
LAPACK_zlange	lib/Eigen/src/misc/lapacke.h	11495;"	d
LAPACK_zlanhe	lib/Eigen/src/misc/lapacke.h	11497;"	d
LAPACK_zlansy	lib/Eigen/src/misc/lapacke.h	11501;"	d
LAPACK_zlantr	lib/Eigen/src/misc/lapacke.h	11505;"	d
LAPACK_zlapmr	lib/Eigen/src/misc/lapacke.h	11559;"	d
LAPACK_zlarfb	lib/Eigen/src/misc/lapacke.h	11515;"	d
LAPACK_zlarfg	lib/Eigen/src/misc/lapacke.h	11519;"	d
LAPACK_zlarft	lib/Eigen/src/misc/lapacke.h	11523;"	d
LAPACK_zlarfx	lib/Eigen/src/misc/lapacke.h	11527;"	d
LAPACK_zlarnv	lib/Eigen/src/misc/lapacke.h	11475;"	d
LAPACK_zlaset	lib/Eigen/src/misc/lapacke.h	11547;"	d
LAPACK_zlaswp	lib/Eigen/src/misc/lapacke.h	11491;"	d
LAPACK_zlatms	lib/Eigen/src/misc/lapacke.h	11531;"	d
LAPACK_zlauum	lib/Eigen/src/misc/lapacke.h	11539;"	d
LAPACK_zpbcon	lib/Eigen/src/misc/lapacke.h	10739;"	d
LAPACK_zpbequ	lib/Eigen/src/misc/lapacke.h	10909;"	d
LAPACK_zpbrfs	lib/Eigen/src/misc/lapacke.h	10803;"	d
LAPACK_zpbstf	lib/Eigen/src/misc/lapacke.h	11185;"	d
LAPACK_zpbsv	lib/Eigen/src/misc/lapacke.h	10975;"	d
LAPACK_zpbsvx	lib/Eigen/src/misc/lapacke.h	10979;"	d
LAPACK_zpbtrf	lib/Eigen/src/misc/lapacke.h	10643;"	d
LAPACK_zpbtrs	lib/Eigen/src/misc/lapacke.h	10687;"	d
LAPACK_zpftrf	lib/Eigen/src/misc/lapacke.h	10634;"	d
LAPACK_zpftri	lib/Eigen/src/misc/lapacke.h	10848;"	d
LAPACK_zpftrs	lib/Eigen/src/misc/lapacke.h	10678;"	d
LAPACK_zpocon	lib/Eigen/src/misc/lapacke.h	10731;"	d
LAPACK_zpoequ	lib/Eigen/src/misc/lapacke.h	10897;"	d
LAPACK_zpoequb	lib/Eigen/src/misc/lapacke.h	10900;"	d
LAPACK_zporfs	lib/Eigen/src/misc/lapacke.h	10791;"	d
LAPACK_zporfsx	lib/Eigen/src/misc/lapacke.h	10794;"	d
LAPACK_zposv	lib/Eigen/src/misc/lapacke.h	10953;"	d
LAPACK_zposvx	lib/Eigen/src/misc/lapacke.h	10959;"	d
LAPACK_zposvxx	lib/Eigen/src/misc/lapacke.h	10962;"	d
LAPACK_zpotrf	lib/Eigen/src/misc/lapacke.h	10627;"	d
LAPACK_zpotri	lib/Eigen/src/misc/lapacke.h	10845;"	d
LAPACK_zpotrs	lib/Eigen/src/misc/lapacke.h	10675;"	d
LAPACK_zppcon	lib/Eigen/src/misc/lapacke.h	10735;"	d
LAPACK_zppequ	lib/Eigen/src/misc/lapacke.h	10905;"	d
LAPACK_zpprfs	lib/Eigen/src/misc/lapacke.h	10799;"	d
LAPACK_zppsv	lib/Eigen/src/misc/lapacke.h	10967;"	d
LAPACK_zppsvx	lib/Eigen/src/misc/lapacke.h	10971;"	d
LAPACK_zpptrf	lib/Eigen/src/misc/lapacke.h	10639;"	d
LAPACK_zpptri	lib/Eigen/src/misc/lapacke.h	10853;"	d
LAPACK_zpptrs	lib/Eigen/src/misc/lapacke.h	10683;"	d
LAPACK_zpstrf	lib/Eigen/src/misc/lapacke.h	10630;"	d
LAPACK_zptcon	lib/Eigen/src/misc/lapacke.h	10743;"	d
LAPACK_zpteqr	lib/Eigen/src/misc/lapacke.h	11161;"	d
LAPACK_zptrfs	lib/Eigen/src/misc/lapacke.h	10807;"	d
LAPACK_zptsv	lib/Eigen/src/misc/lapacke.h	10983;"	d
LAPACK_zptsvx	lib/Eigen/src/misc/lapacke.h	10987;"	d
LAPACK_zpttrf	lib/Eigen/src/misc/lapacke.h	10647;"	d
LAPACK_zpttrs	lib/Eigen/src/misc/lapacke.h	10691;"	d
LAPACK_zspcon	lib/Eigen/src/misc/lapacke.h	10753;"	d
LAPACK_zsprfs	lib/Eigen/src/misc/lapacke.h	10823;"	d
LAPACK_zspsv	lib/Eigen/src/misc/lapacke.h	11009;"	d
LAPACK_zspsvx	lib/Eigen/src/misc/lapacke.h	11013;"	d
LAPACK_zsptrf	lib/Eigen/src/misc/lapacke.h	10657;"	d
LAPACK_zsptri	lib/Eigen/src/misc/lapacke.h	10863;"	d
LAPACK_zsptrs	lib/Eigen/src/misc/lapacke.h	10701;"	d
LAPACK_zstedc	lib/Eigen/src/misc/lapacke.h	11153;"	d
LAPACK_zstegr	lib/Eigen/src/misc/lapacke.h	11157;"	d
LAPACK_zstein	lib/Eigen/src/misc/lapacke.h	11167;"	d
LAPACK_zstemr	lib/Eigen/src/misc/lapacke.h	11149;"	d
LAPACK_zsteqr	lib/Eigen/src/misc/lapacke.h	11145;"	d
LAPACK_zsycon	lib/Eigen/src/misc/lapacke.h	10747;"	d
LAPACK_zsyconv	lib/Eigen/src/misc/lapacke.h	11602;"	d
LAPACK_zsyequb	lib/Eigen/src/misc/lapacke.h	10912;"	d
LAPACK_zsyr	lib/Eigen/src/misc/lapacke.h	11643;"	d
LAPACK_zsyrfs	lib/Eigen/src/misc/lapacke.h	10811;"	d
LAPACK_zsyrfsx	lib/Eigen/src/misc/lapacke.h	10814;"	d
LAPACK_zsysv	lib/Eigen/src/misc/lapacke.h	10991;"	d
LAPACK_zsysvx	lib/Eigen/src/misc/lapacke.h	10995;"	d
LAPACK_zsysvxx	lib/Eigen/src/misc/lapacke.h	10998;"	d
LAPACK_zsyswapr	lib/Eigen/src/misc/lapacke.h	11603;"	d
LAPACK_zsytrf	lib/Eigen/src/misc/lapacke.h	10651;"	d
LAPACK_zsytri	lib/Eigen/src/misc/lapacke.h	10857;"	d
LAPACK_zsytri2	lib/Eigen/src/misc/lapacke.h	11604;"	d
LAPACK_zsytri2x	lib/Eigen/src/misc/lapacke.h	11605;"	d
LAPACK_zsytrs	lib/Eigen/src/misc/lapacke.h	10695;"	d
LAPACK_zsytrs2	lib/Eigen/src/misc/lapacke.h	11606;"	d
LAPACK_ztbcon	lib/Eigen/src/misc/lapacke.h	10767;"	d
LAPACK_ztbrfs	lib/Eigen/src/misc/lapacke.h	10837;"	d
LAPACK_ztbtrs	lib/Eigen/src/misc/lapacke.h	10715;"	d
LAPACK_ztfsm	lib/Eigen/src/misc/lapacke.h	11440;"	d
LAPACK_ztftri	lib/Eigen/src/misc/lapacke.h	10872;"	d
LAPACK_ztfttp	lib/Eigen/src/misc/lapacke.h	11444;"	d
LAPACK_ztfttr	lib/Eigen/src/misc/lapacke.h	11448;"	d
LAPACK_ztgevc	lib/Eigen/src/misc/lapacke.h	11253;"	d
LAPACK_ztgexc	lib/Eigen/src/misc/lapacke.h	11257;"	d
LAPACK_ztgsen	lib/Eigen/src/misc/lapacke.h	11261;"	d
LAPACK_ztgsja	lib/Eigen/src/misc/lapacke.h	11277;"	d
LAPACK_ztgsna	lib/Eigen/src/misc/lapacke.h	11269;"	d
LAPACK_ztgsyl	lib/Eigen/src/misc/lapacke.h	11265;"	d
LAPACK_ztpcon	lib/Eigen/src/misc/lapacke.h	10763;"	d
LAPACK_ztpmqrt	lib/Eigen/src/misc/lapacke.h	11629;"	d
LAPACK_ztpqrt	lib/Eigen/src/misc/lapacke.h	11632;"	d
LAPACK_ztpqrt2	lib/Eigen/src/misc/lapacke.h	11636;"	d
LAPACK_ztprfb	lib/Eigen/src/misc/lapacke.h	11640;"	d
LAPACK_ztprfs	lib/Eigen/src/misc/lapacke.h	10833;"	d
LAPACK_ztptri	lib/Eigen/src/misc/lapacke.h	10877;"	d
LAPACK_ztptrs	lib/Eigen/src/misc/lapacke.h	10711;"	d
LAPACK_ztpttf	lib/Eigen/src/misc/lapacke.h	11452;"	d
LAPACK_ztpttr	lib/Eigen/src/misc/lapacke.h	11456;"	d
LAPACK_ztrcon	lib/Eigen/src/misc/lapacke.h	10759;"	d
LAPACK_ztrevc	lib/Eigen/src/misc/lapacke.h	11217;"	d
LAPACK_ztrexc	lib/Eigen/src/misc/lapacke.h	11225;"	d
LAPACK_ztrrfs	lib/Eigen/src/misc/lapacke.h	10829;"	d
LAPACK_ztrsen	lib/Eigen/src/misc/lapacke.h	11229;"	d
LAPACK_ztrsna	lib/Eigen/src/misc/lapacke.h	11221;"	d
LAPACK_ztrsyl	lib/Eigen/src/misc/lapacke.h	11233;"	d
LAPACK_ztrtri	lib/Eigen/src/misc/lapacke.h	10869;"	d
LAPACK_ztrtrs	lib/Eigen/src/misc/lapacke.h	10707;"	d
LAPACK_ztrttf	lib/Eigen/src/misc/lapacke.h	11460;"	d
LAPACK_ztrttp	lib/Eigen/src/misc/lapacke.h	11464;"	d
LAPACK_ztzrzf	lib/Eigen/src/misc/lapacke.h	11077;"	d
LAPACK_zunbdb	lib/Eigen/src/misc/lapacke.h	11607;"	d
LAPACK_zuncsd	lib/Eigen/src/misc/lapacke.h	11608;"	d
LAPACK_zungbr	lib/Eigen/src/misc/lapacke.h	11103;"	d
LAPACK_zunghr	lib/Eigen/src/misc/lapacke.h	11195;"	d
LAPACK_zunglq	lib/Eigen/src/misc/lapacke.h	11047;"	d
LAPACK_zungql	lib/Eigen/src/misc/lapacke.h	11057;"	d
LAPACK_zungqr	lib/Eigen/src/misc/lapacke.h	11035;"	d
LAPACK_zungrq	lib/Eigen/src/misc/lapacke.h	11069;"	d
LAPACK_zungtr	lib/Eigen/src/misc/lapacke.h	11121;"	d
LAPACK_zunmbr	lib/Eigen/src/misc/lapacke.h	11105;"	d
LAPACK_zunmhr	lib/Eigen/src/misc/lapacke.h	11197;"	d
LAPACK_zunmlq	lib/Eigen/src/misc/lapacke.h	11049;"	d
LAPACK_zunmql	lib/Eigen/src/misc/lapacke.h	11061;"	d
LAPACK_zunmqr	lib/Eigen/src/misc/lapacke.h	11037;"	d
LAPACK_zunmrq	lib/Eigen/src/misc/lapacke.h	11073;"	d
LAPACK_zunmrz	lib/Eigen/src/misc/lapacke.h	11081;"	d
LAPACK_zunmtr	lib/Eigen/src/misc/lapacke.h	11123;"	d
LAPACK_zupgtr	lib/Eigen/src/misc/lapacke.h	11133;"	d
LAPACK_zupmtr	lib/Eigen/src/misc/lapacke.h	11135;"	d
LDLT	lib/Eigen/src/Cholesky/LDLT.h	/^    LDLT()$/;"	f	class:Eigen::LDLT
LDLT	lib/Eigen/src/Cholesky/LDLT.h	/^    explicit LDLT(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LDLT
LDLT	lib/Eigen/src/Cholesky/LDLT.h	/^    explicit LDLT(Index size)$/;"	f	class:Eigen::LDLT
LDLT	lib/Eigen/src/Cholesky/LDLT.h	/^    explicit LDLT(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LDLT
LDLT	lib/Eigen/src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
LDLTTraits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LDLT_Traits	lib/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LDLT_Traits	lib/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LLComparison	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> LLComparison(vfunctor op,const Lattice<lobj> &lhs,const Lattice<robj> &rhs)$/;"	f	namespace:Grid
LLT	lib/Eigen/src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT
LLT	lib/Eigen/src/Cholesky/LLT.h	/^    explicit LLT(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LLT
LLT	lib/Eigen/src/Cholesky/LLT.h	/^    explicit LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT
LLT	lib/Eigen/src/Cholesky/LLT.h	/^    explicit LLT(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LLT
LLT	lib/Eigen/src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
LLTTraits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LLT_Traits	lib/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LLT_Traits	lib/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LLVL	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon662
LMAX	benchmarks/Benchmark_su3.cc	38;"	d	file:
LMatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU
LOAD64	lib/simd/BGQQPX.h	43;"	d
LOAD64	lib/simd/IBM_qpx.h	101;"	d
LOAD64	lib/simd/Intel512common.h	92;"	d
LOAD64a	lib/simd/Intel512common.h	90;"	d
LOAD64i	lib/simd/Intel512common.h	91;"	d
LOAD_CHI	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	473;"	d	file:
LOAD_CHI	lib/qcd/action/fermion/StaggeredKernelsHand.cc	33;"	d	file:
LOAD_CHI	lib/qcd/action/fermion/WilsonKernelsHand.cc	48;"	d	file:
LOAD_CHI	lib/simd/BGQQPX.h	240;"	d
LOAD_CHI	lib/simd/IBM_qpx.h	286;"	d
LOAD_CHI	lib/simd/Intel512wilson.h	106;"	d
LOAD_CHIMU	lib/qcd/action/fermion/WilsonKernelsHand.cc	33;"	d	file:
LOAD_CHIMU	lib/simd/BGQQPX.h	255;"	d
LOAD_CHIMU	lib/simd/IBM_qpx.h	301;"	d
LOAD_CHIMU	lib/simd/Intel512wilson.h	105;"	d
LOAD_CHIMU01i	lib/simd/Intel512wilson.h	130;"	d
LOAD_CHIMU23i	lib/simd/Intel512wilson.h	138;"	d
LOAD_CHIMUi	lib/simd/Intel512wilson.h	126;"	d
LOAD_CHIa	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	499;"	d	file:
LOAD_CHIi	lib/simd/Intel512wilson.h	154;"	d
LOCK_CLEAR	lib/simd/IBM_qpx.h	86;"	d
LOCK_GAUGE	lib/simd/BGQQPX.h	130;"	d
LOCK_GAUGE	lib/simd/IBM_qpx.h	156;"	d
LOCK_GAUGE	lib/simd/Intel512wilson.h	101;"	d
LOCK_SET	lib/simd/IBM_qpx.h	85;"	d
LOG	extras/Hadrons/Global.hpp	99;"	d
LOG	extras/qed-fvol/Global.hpp	26;"	d
LOG	lib/Hadrons/Global.hpp	99;"	d
LOGICAL_BINOP	lib/tensors/Tensor_logical.h	/^LOGICAL_BINOP(&&);$/;"	m	namespace:Grid
LOGICAL_BINOP	lib/tensors/Tensor_logical.h	/^LOGICAL_BINOP(&);$/;"	m	namespace:Grid
LOGICAL_BINOP	lib/tensors/Tensor_logical.h	33;"	d
LSComparison	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> LSComparison(vfunctor op,const Lattice<lobj> &lhs,const robj &rhs)$/;"	f	namespace:Grid
LSUB	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon662
LUMatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase
LUMatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU
LUMatrixType	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU
LUNoMarker	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^enum { LUNoMarker = 3 };$/;"	e	enum:Eigen::internal::__anon658
LUSUP	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon662
LUTempSpace	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^inline Index LUTempSpace(Index&m, Index& w)$/;"	f	namespace:Eigen::internal
LU_GlobalLU_t	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^struct LU_GlobalLU_t {$/;"	s	namespace:Eigen::internal
LU_kernel_bmod	lib/Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^template <> struct LU_kernel_bmod<1>$/;"	s	namespace:Eigen::internal
LU_kernel_bmod	lib/Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^template <int SegSizeAtCompileTime> struct LU_kernel_bmod$/;"	s	namespace:Eigen::internal
LUnumTempV	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^inline Index LUnumTempV(Index& m, Index& w, Index& t, Index& b)$/;"	f	namespace:Eigen::internal
LaplacianAdjointField	lib/qcd/utils/CovariantLaplacian.h	/^  LaplacianAdjointField(GridBase* grid, OperatorFunction<GaugeField>& S, LaplacianParams& p, const RealD k = 1.0)$/;"	f	class:Grid::QCD::LaplacianAdjointField
LaplacianAdjointField	lib/qcd/utils/CovariantLaplacian.h	/^class LaplacianAdjointField: public Metric<typename Impl::Field> {$/;"	c	namespace:Grid::QCD
LaplacianAlgebraField	lib/qcd/utils/CovariantLaplacian.h	/^  LaplacianAlgebraField(GridBase* grid, const RealD k) : $/;"	f	class:Grid::QCD::LaplacianAlgebraField
LaplacianAlgebraField	lib/qcd/utils/CovariantLaplacian.h	/^class LaplacianAlgebraField {$/;"	c	namespace:Grid::QCD
LaplacianParams	lib/qcd/utils/CovariantLaplacian.h	/^  LaplacianParams(RealD lo      = 0.0, $/;"	f	struct:Grid::QCD::LaplacianParams
LaplacianParams	lib/qcd/utils/CovariantLaplacian.h	/^struct LaplacianParams : Serializable {$/;"	s	namespace:Grid::QCD
Large	lib/Eigen/src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon183
LargeEnough	lib/Eigen/src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
Lattice	lib/lattice/Lattice_base.h	/^    Lattice(const LatticeUnaryExpression<Op,T1> & expr) {$/;"	f	class:Grid::Lattice
Lattice	lib/lattice/Lattice_base.h	/^  Lattice(GridBase *grid) : _odata(grid->oSites()) {$/;"	f	class:Grid::Lattice
Lattice	lib/lattice/Lattice_base.h	/^  Lattice(const Lattice& r){ \/\/ copy constructor$/;"	f	class:Grid::Lattice
Lattice	lib/lattice/Lattice_base.h	/^  Lattice(const LatticeBinaryExpression<Op,T1,T2> & expr) {$/;"	f	class:Grid::Lattice
Lattice	lib/lattice/Lattice_base.h	/^  Lattice(const LatticeTrinaryExpression<Op,T1,T2,T3> & expr) {$/;"	f	class:Grid::Lattice
Lattice	lib/lattice/Lattice_base.h	/^class Lattice : public LatticeBase$/;"	c	namespace:Grid
LatticeAdjField	lib/qcd/utils/SUnAdjoint.h	/^      LatticeAdjField;$/;"	t	class:Grid::QCD::SU_Adjoint
LatticeAdjFieldD	lib/qcd/utils/SUnAdjoint.h	/^      LatticeAdjFieldD;$/;"	t	class:Grid::QCD::SU_Adjoint
LatticeAdjFieldF	lib/qcd/utils/SUnAdjoint.h	/^      LatticeAdjFieldF;$/;"	t	class:Grid::QCD::SU_Adjoint
LatticeAdjMatrix	lib/qcd/utils/SUnAdjoint.h	/^  typedef Lattice<vAMatrix>  LatticeAdjMatrix;$/;"	t	class:Grid::QCD::SU_Adjoint
LatticeAdjMatrixD	lib/qcd/utils/SUnAdjoint.h	/^  typedef Lattice<vAMatrixD> LatticeAdjMatrixD;$/;"	t	class:Grid::QCD::SU_Adjoint
LatticeAdjMatrixF	lib/qcd/utils/SUnAdjoint.h	/^  typedef Lattice<vAMatrixF> LatticeAdjMatrixF;$/;"	t	class:Grid::QCD::SU_Adjoint
LatticeAlgebraVector	lib/qcd/utils/SUn.h	/^  typedef Lattice<vAlgebraVector> LatticeAlgebraVector;$/;"	t	class:Grid::QCD::SU
LatticeAlgebraVectorD	lib/qcd/utils/SUn.h	/^  typedef Lattice<vAlgebraVectorD> LatticeAlgebraVectorD;$/;"	t	class:Grid::QCD::SU
LatticeAlgebraVectorF	lib/qcd/utils/SUn.h	/^  typedef Lattice<vAlgebraVectorF> LatticeAlgebraVectorF;$/;"	t	class:Grid::QCD::SU
LatticeBase	lib/lattice/Lattice_base.h	/^class LatticeBase$/;"	c	namespace:Grid
LatticeBinaryExpression	lib/lattice/Lattice_base.h	/^ LatticeBinaryExpression(const std::pair<Op,std::tuple<T1,T2> > &arg): std::pair<Op,std::tuple<T1,T2> >(arg) {};$/;"	f	class:Grid::LatticeBinaryExpression
LatticeBinaryExpression	lib/lattice/Lattice_base.h	/^class LatticeBinaryExpression : public std::pair<Op,std::tuple<T1,T2> > , public LatticeExpressionBase {$/;"	c	namespace:Grid
LatticeColourMatrix	lib/qcd/QCD.h	/^    typedef Lattice<vColourMatrix>          LatticeColourMatrix;$/;"	t	namespace:Grid::QCD
LatticeColourMatrixD	lib/qcd/QCD.h	/^    typedef Lattice<vColourMatrixD>         LatticeColourMatrixD;$/;"	t	namespace:Grid::QCD
LatticeColourMatrixF	lib/qcd/QCD.h	/^    typedef Lattice<vColourMatrixF>         LatticeColourMatrixF;$/;"	t	namespace:Grid::QCD
LatticeColourVector	lib/qcd/QCD.h	/^    typedef Lattice<vColourVector>          LatticeColourVector;$/;"	t	namespace:Grid::QCD
LatticeColourVectorD	lib/qcd/QCD.h	/^    typedef Lattice<vColourVectorD>         LatticeColourVectorD;$/;"	t	namespace:Grid::QCD
LatticeColourVectorF	lib/qcd/QCD.h	/^    typedef Lattice<vColourVectorF>         LatticeColourVectorF;$/;"	t	namespace:Grid::QCD
LatticeComplex	lib/qcd/QCD.h	/^    typedef Lattice<vTComplex>         LatticeComplex;$/;"	t	namespace:Grid::QCD
LatticeComplexD	lib/qcd/QCD.h	/^    typedef Lattice<vTComplexD>        LatticeComplexD;$/;"	t	namespace:Grid::QCD
LatticeComplexF	lib/qcd/QCD.h	/^    typedef Lattice<vTComplexF>        LatticeComplexF;$/;"	t	namespace:Grid::QCD
LatticeCoordinate	lib/lattice/Lattice_coordinate.h	/^    template<class iobj> inline void LatticeCoordinate(Lattice<iobj> &l,int mu)$/;"	f	namespace:Grid
LatticeDoubleStoredColourMatrix	lib/qcd/QCD.h	/^    typedef Lattice<vDoubleStoredColourMatrix>  LatticeDoubleStoredColourMatrix;$/;"	t	namespace:Grid::QCD
LatticeDoubleStoredColourMatrixD	lib/qcd/QCD.h	/^    typedef Lattice<vDoubleStoredColourMatrixD> LatticeDoubleStoredColourMatrixD;$/;"	t	namespace:Grid::QCD
LatticeDoubleStoredColourMatrixF	lib/qcd/QCD.h	/^    typedef Lattice<vDoubleStoredColourMatrixF> LatticeDoubleStoredColourMatrixF;$/;"	t	namespace:Grid::QCD
LatticeDoubledGaugeField	lib/qcd/QCD.h	/^    typedef LatticeDoubleStoredColourMatrix        LatticeDoubledGaugeField;$/;"	t	namespace:Grid::QCD
LatticeDoubledGaugeFieldD	lib/qcd/QCD.h	/^    typedef LatticeDoubleStoredColourMatrixD       LatticeDoubledGaugeFieldD;$/;"	t	namespace:Grid::QCD
LatticeDoubledGaugeFieldF	lib/qcd/QCD.h	/^    typedef LatticeDoubleStoredColourMatrixF       LatticeDoubledGaugeFieldF;$/;"	t	namespace:Grid::QCD
LatticeExpressionBase	lib/lattice/Lattice_base.h	/^class LatticeExpressionBase {};$/;"	c	namespace:Grid
LatticeFermion	lib/qcd/QCD.h	/^    typedef LatticeSpinColourVector      LatticeFermion;$/;"	t	namespace:Grid::QCD
LatticeFermionD	lib/qcd/QCD.h	/^    typedef LatticeSpinColourVectorD     LatticeFermionD;$/;"	t	namespace:Grid::QCD
LatticeFermionF	lib/qcd/QCD.h	/^    typedef LatticeSpinColourVectorF     LatticeFermionF;$/;"	t	namespace:Grid::QCD
LatticeField	lib/qcd/representations/adjoint.h	/^  typedef typename SU_Adjoint<ncolour>::LatticeAdjField LatticeField;$/;"	t	class:Grid::QCD::AdjointRep
LatticeField	lib/qcd/representations/fundamental.h	/^    typedef Field LatticeField;$/;"	t	class:Grid::QCD::EmptyRep
LatticeField	lib/qcd/representations/fundamental.h	/^  typedef LatticeGaugeField LatticeField;$/;"	t	class:Grid::QCD::FundamentalRep
LatticeField	lib/qcd/representations/two_index.h	/^  typedef typename SU_TwoIndex<ncolour, S>::LatticeTwoIndexField LatticeField;$/;"	t	class:Grid::QCD::TwoIndexRep
LatticeGaugeField	lib/qcd/QCD.h	/^    typedef LatticeLorentzColourMatrix             LatticeGaugeField;$/;"	t	namespace:Grid::QCD
LatticeGaugeFieldD	lib/qcd/QCD.h	/^    typedef LatticeLorentzColourMatrixD            LatticeGaugeFieldD;$/;"	t	namespace:Grid::QCD
LatticeGaugeFieldF	lib/qcd/QCD.h	/^    typedef LatticeLorentzColourMatrixF            LatticeGaugeFieldF;$/;"	t	namespace:Grid::QCD
LatticeGaugeTheory	lib/qcd/LatticeTheories.h	/^struct LatticeGaugeTheory : public LatticeTheory<Dimensions> {$/;"	s	namespace:Grid::LatticeTheories
LatticeHalfFermion	lib/qcd/QCD.h	/^    typedef LatticeHalfSpinColourVector  LatticeHalfFermion;$/;"	t	namespace:Grid::QCD
LatticeHalfFermionD	lib/qcd/QCD.h	/^    typedef LatticeHalfSpinColourVectorF LatticeHalfFermionD;$/;"	t	namespace:Grid::QCD
LatticeHalfFermionF	lib/qcd/QCD.h	/^    typedef LatticeHalfSpinColourVectorF LatticeHalfFermionF;$/;"	t	namespace:Grid::QCD
LatticeHalfSpinColourVector	lib/qcd/QCD.h	/^    typedef Lattice<vHalfSpinColourVector>  LatticeHalfSpinColourVector;$/;"	t	namespace:Grid::QCD
LatticeHalfSpinColourVectorD	lib/qcd/QCD.h	/^    typedef Lattice<vHalfSpinColourVectorD> LatticeHalfSpinColourVectorD;$/;"	t	namespace:Grid::QCD
LatticeHalfSpinColourVectorF	lib/qcd/QCD.h	/^    typedef Lattice<vHalfSpinColourVectorF> LatticeHalfSpinColourVectorF;$/;"	t	namespace:Grid::QCD
LatticeHalfSpinVector	lib/qcd/QCD.h	/^    typedef Lattice<vHalfSpinVector>        LatticeHalfSpinVector;$/;"	t	namespace:Grid::QCD
LatticeHalfSpinVectorD	lib/qcd/QCD.h	/^    typedef Lattice<vHalfSpinVectorD>       LatticeHalfSpinVectorD;$/;"	t	namespace:Grid::QCD
LatticeHalfSpinVectorF	lib/qcd/QCD.h	/^    typedef Lattice<vHalfSpinVectorF>       LatticeHalfSpinVectorF;$/;"	t	namespace:Grid::QCD
LatticeInteger	lib/qcd/QCD.h	/^    typedef Lattice<vTInteger>         LatticeInteger; \/\/ Predicates for "where"$/;"	t	namespace:Grid::QCD
LatticeLorentzColourMatrix	lib/qcd/QCD.h	/^    typedef Lattice<vLorentzColourMatrix>  LatticeLorentzColourMatrix;$/;"	t	namespace:Grid::QCD
LatticeLorentzColourMatrixD	lib/qcd/QCD.h	/^    typedef Lattice<vLorentzColourMatrixD> LatticeLorentzColourMatrixD;$/;"	t	namespace:Grid::QCD
LatticeLorentzColourMatrixF	lib/qcd/QCD.h	/^    typedef Lattice<vLorentzColourMatrixF> LatticeLorentzColourMatrixF;$/;"	t	namespace:Grid::QCD
LatticeMatrix	lib/qcd/representations/adjoint.h	/^  typedef typename SU_Adjoint<ncolour>::LatticeAdjMatrix LatticeMatrix;$/;"	t	class:Grid::QCD::AdjointRep
LatticeMatrix	lib/qcd/representations/fundamental.h	/^  typedef typename SU<ncolour>::LatticeMatrix LatticeMatrix;$/;"	t	class:Grid::QCD::FundamentalRep
LatticeMatrix	lib/qcd/representations/two_index.h	/^  typedef typename SU_TwoIndex<ncolour, S>::LatticeTwoIndexMatrix LatticeMatrix;$/;"	t	class:Grid::QCD::TwoIndexRep
LatticeMatrix	lib/qcd/utils/SUn.h	/^  typedef Lattice<vMatrix> LatticeMatrix;$/;"	t	class:Grid::QCD::SU
LatticeMatrixD	lib/qcd/utils/SUn.h	/^  typedef Lattice<vMatrixD> LatticeMatrixD;$/;"	t	class:Grid::QCD::SU
LatticeMatrixF	lib/qcd/utils/SUn.h	/^  typedef Lattice<vMatrixF> LatticeMatrixF;$/;"	t	class:Grid::QCD::SU
LatticePropagator	lib/qcd/QCD.h	/^    typedef LatticeSpinColourMatrix                LatticePropagator;$/;"	t	namespace:Grid::QCD
LatticePropagatorD	lib/qcd/QCD.h	/^    typedef LatticeSpinColourMatrixD               LatticePropagatorD;$/;"	t	namespace:Grid::QCD
LatticePropagatorF	lib/qcd/QCD.h	/^    typedef LatticeSpinColourMatrixF               LatticePropagatorF;$/;"	t	namespace:Grid::QCD
LatticePt	extras/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<LatticeBase>           LatticePt;$/;"	t	class:Environment
LatticePt	lib/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<LatticeBase>           LatticePt;$/;"	t	class:Environment
LatticeReal	lib/qcd/QCD.h	/^    typedef Lattice<vTReal>            LatticeReal;$/;"	t	namespace:Grid::QCD
LatticeRealD	lib/qcd/QCD.h	/^    typedef Lattice<vTRealD>           LatticeRealD;$/;"	t	namespace:Grid::QCD
LatticeRealF	lib/qcd/QCD.h	/^    typedef Lattice<vTRealF>           LatticeRealF;$/;"	t	namespace:Grid::QCD
LatticeSU2Matrix	lib/qcd/utils/SUn.h	/^  typedef Lattice<vSU2Matrix> LatticeSU2Matrix;$/;"	t	class:Grid::QCD::SU
LatticeSU2MatrixD	lib/qcd/utils/SUn.h	/^  typedef Lattice<vSU2MatrixD> LatticeSU2MatrixD;$/;"	t	class:Grid::QCD::SU
LatticeSU2MatrixF	lib/qcd/utils/SUn.h	/^  typedef Lattice<vSU2MatrixF> LatticeSU2MatrixF;$/;"	t	class:Grid::QCD::SU
LatticeSourceField	lib/qcd/representations/hmc_types.h	/^  typedef typename std::tuple_element<0,Representation_Fields>::type LatticeSourceField;$/;"	t	class:Grid::QCD::Representations
LatticeSpinColourMatrix	lib/qcd/QCD.h	/^    typedef Lattice<vSpinColourMatrix>      LatticeSpinColourMatrix;$/;"	t	namespace:Grid::QCD
LatticeSpinColourMatrixD	lib/qcd/QCD.h	/^    typedef Lattice<vSpinColourMatrixD>     LatticeSpinColourMatrixD;$/;"	t	namespace:Grid::QCD
LatticeSpinColourMatrixF	lib/qcd/QCD.h	/^    typedef Lattice<vSpinColourMatrixF>     LatticeSpinColourMatrixF;$/;"	t	namespace:Grid::QCD
LatticeSpinColourVector	lib/qcd/QCD.h	/^    typedef Lattice<vSpinColourVector>      LatticeSpinColourVector;$/;"	t	namespace:Grid::QCD
LatticeSpinColourVectorD	lib/qcd/QCD.h	/^    typedef Lattice<vSpinColourVectorD>     LatticeSpinColourVectorD;$/;"	t	namespace:Grid::QCD
LatticeSpinColourVectorF	lib/qcd/QCD.h	/^    typedef Lattice<vSpinColourVectorF>     LatticeSpinColourVectorF;$/;"	t	namespace:Grid::QCD
LatticeSpinMatrix	lib/qcd/QCD.h	/^    typedef Lattice<vSpinMatrix>            LatticeSpinMatrix;$/;"	t	namespace:Grid::QCD
LatticeSpinMatrixD	lib/qcd/QCD.h	/^    typedef Lattice<vSpinMatrixD>           LatticeSpinMatrixD;$/;"	t	namespace:Grid::QCD
LatticeSpinMatrixF	lib/qcd/QCD.h	/^    typedef Lattice<vSpinMatrixF>           LatticeSpinMatrixF;$/;"	t	namespace:Grid::QCD
LatticeSpinVector	lib/qcd/QCD.h	/^    typedef Lattice<vSpinVector>            LatticeSpinVector;$/;"	t	namespace:Grid::QCD
LatticeSpinVectorD	lib/qcd/QCD.h	/^    typedef Lattice<vSpinVectorD>           LatticeSpinVectorD;$/;"	t	namespace:Grid::QCD
LatticeSpinVectorF	lib/qcd/QCD.h	/^    typedef Lattice<vSpinVectorF>           LatticeSpinVectorF;$/;"	t	namespace:Grid::QCD
LatticeStaggeredFermion	lib/qcd/QCD.h	/^    typedef Lattice<vColourVector>          LatticeStaggeredFermion;    $/;"	t	namespace:Grid::QCD
LatticeStaggeredFermionD	lib/qcd/QCD.h	/^    typedef Lattice<vColourVectorD>         LatticeStaggeredFermionD;    $/;"	t	namespace:Grid::QCD
LatticeStaggeredFermionF	lib/qcd/QCD.h	/^    typedef Lattice<vColourVectorF>         LatticeStaggeredFermionF;    $/;"	t	namespace:Grid::QCD
LatticeStaggeredPropagator	lib/qcd/QCD.h	/^    typedef Lattice<vColourMatrix>          LatticeStaggeredPropagator; $/;"	t	namespace:Grid::QCD
LatticeStaggeredPropagatorD	lib/qcd/QCD.h	/^    typedef Lattice<vColourMatrixD>         LatticeStaggeredPropagatorD; $/;"	t	namespace:Grid::QCD
LatticeStaggeredPropagatorF	lib/qcd/QCD.h	/^    typedef Lattice<vColourMatrixF>         LatticeStaggeredPropagatorF; $/;"	t	namespace:Grid::QCD
LatticeTheories	lib/qcd/LatticeTheories.h	/^namespace LatticeTheories {$/;"	n	namespace:Grid
LatticeTheory	lib/qcd/LatticeTheories.h	/^struct LatticeTheory {$/;"	s	namespace:Grid::LatticeTheories
LatticeTrinaryExpression	lib/lattice/Lattice_base.h	/^ LatticeTrinaryExpression(const std::pair<Op,std::tuple<T1,T2,T3> > &arg): std::pair<Op,std::tuple<T1,T2,T3> >(arg) {};$/;"	f	class:Grid::LatticeTrinaryExpression
LatticeTrinaryExpression	lib/lattice/Lattice_base.h	/^class LatticeTrinaryExpression :public std::pair<Op,std::tuple<T1,T2,T3> >, public LatticeExpressionBase {$/;"	c	namespace:Grid
LatticeTwoIndexField	lib/qcd/utils/SUnTwoIndex.h	/^      LatticeTwoIndexField;$/;"	t	class:Grid::QCD::SU_TwoIndex
LatticeTwoIndexFieldD	lib/qcd/utils/SUnTwoIndex.h	/^      LatticeTwoIndexFieldD;$/;"	t	class:Grid::QCD::SU_TwoIndex
LatticeTwoIndexFieldF	lib/qcd/utils/SUnTwoIndex.h	/^      LatticeTwoIndexFieldF;$/;"	t	class:Grid::QCD::SU_TwoIndex
LatticeTwoIndexMatrix	lib/qcd/utils/SUnTwoIndex.h	/^  typedef Lattice<vTIMatrix> LatticeTwoIndexMatrix;$/;"	t	class:Grid::QCD::SU_TwoIndex
LatticeTwoIndexMatrixD	lib/qcd/utils/SUnTwoIndex.h	/^  typedef Lattice<vTIMatrixD> LatticeTwoIndexMatrixD;$/;"	t	class:Grid::QCD::SU_TwoIndex
LatticeTwoIndexMatrixF	lib/qcd/utils/SUnTwoIndex.h	/^  typedef Lattice<vTIMatrixF> LatticeTwoIndexMatrixF;$/;"	t	class:Grid::QCD::SU_TwoIndex
LatticeUnaryExpression	lib/lattice/Lattice_base.h	/^ LatticeUnaryExpression(const std::pair<Op,std::tuple<T1> > &arg): std::pair<Op,std::tuple<T1> >(arg) {};$/;"	f	class:Grid::LatticeUnaryExpression
LatticeUnaryExpression	lib/lattice/Lattice_base.h	/^class LatticeUnaryExpression  : public std::pair<Op,std::tuple<T1> > , public LatticeExpressionBase {$/;"	c	namespace:Grid
LazyCoeffBasedProductMode	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
LazyProduct	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
LeapFrog	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  LeapFrog(GridBase* grid, IntegratorParameters Par,$/;"	f	class:Grid::QCD::LeapFrog
LeapFrog	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^class LeapFrog : public Integrator<FieldImplementation, SmearingPolicy,$/;"	c	namespace:Grid::QCD
LeastSquareDiagonalPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner() : Base() {}$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
LeastSquareDiagonalPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    explicit LeastSquareDiagonalPreconditioner(const MatType& mat) : Base()$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
LeastSquareDiagonalPreconditioner	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class LeastSquareDiagonalPreconditioner : public DiagonalPreconditioner<_Scalar>$/;"	c	namespace:Eigen
LeastSquaresConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  LeastSquaresConjugateGradient() : Base() {}$/;"	f	class:Eigen::LeastSquaresConjugateGradient
LeastSquaresConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  explicit LeastSquaresConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::LeastSquaresConjugateGradient
LeastSquaresConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^class LeastSquaresConjugateGradient : public IterativeSolverBase<LeastSquaresConjugateGradient<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
Lebesgue	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  LebesgueOrder Lebesgue;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
Lebesgue	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    LebesgueOrder Lebesgue;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
Lebesgue	lib/qcd/action/fermion/WilsonFermion.h	/^  LebesgueOrder Lebesgue;$/;"	m	class:Grid::QCD::WilsonFermion
Lebesgue	lib/qcd/action/fermion/WilsonFermion5D.h	/^    LebesgueOrder Lebesgue;$/;"	m	class:Grid::QCD::WilsonFermion5D
LebesgueEvenOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  LebesgueOrder LebesgueEvenOdd;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
LebesgueEvenOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    LebesgueOrder LebesgueEvenOdd;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
LebesgueEvenOdd	lib/qcd/action/fermion/WilsonFermion.h	/^  LebesgueOrder LebesgueEvenOdd;$/;"	m	class:Grid::QCD::WilsonFermion
LebesgueEvenOdd	lib/qcd/action/fermion/WilsonFermion5D.h	/^    LebesgueOrder LebesgueEvenOdd;$/;"	m	class:Grid::QCD::WilsonFermion5D
LebesgueOrder	lib/stencil/Lebesgue.cc	/^LebesgueOrder::LebesgueOrder(GridBase *_grid) $/;"	f	class:Grid::LebesgueOrder
LebesgueOrder	lib/stencil/Lebesgue.h	/^  class LebesgueOrder { $/;"	c	namespace:Grid
Lexicographic	lib/util/Lexicographic.h	/^  class Lexicographic {$/;"	c	namespace:Grid
LexicographicToWorldRank	lib/communicator/Communicator_base.h	/^  std::vector<int>  LexicographicToWorldRank;$/;"	m	class:Grid::CartesianCommunicator
LgammaReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_lgamma_op<Scalar>, const Derived> LgammaReturnType;$/;"	t
Lhs	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_all<LhsType>::type Lhs;$/;"	t	class:Eigen::CwiseBinaryOp
Lhs	lib/Eigen/src/Core/Product.h	/^    typedef _Lhs Lhs;$/;"	t	class:Eigen::Product
Lhs	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
Lhs1	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename conditional<NeedToTranspose,RhsT,LhsT>::type Lhs1;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsAlignment	lib/Eigen/src/Core/ProductEvaluators.h	/^    LhsAlignment = EIGEN_PLAIN_ENUM_MIN(LhsEtorType::Alignment,LhsVecPacketSize*int(sizeof(typename LhsNestedCleaned::Scalar))),$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
LhsArg	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::Lhs LhsArg;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsArg	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^            Lhs1 const&, SparseView<Lhs1> >::type LhsArg;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsBlasTraits	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef internal::blas_traits<Lhs> LhsBlasTraits;$/;"	t	struct:Eigen::internal::generic_product_impl
LhsBlasTraits	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef internal::blas_traits<Lhs> LhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
LhsBlasTraits	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef internal::blas_traits<Lhs> LhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
LhsCleaned	lib/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::traits
LhsCleaned	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
LhsCoeffReadCost	lib/Eigen/src/Core/ProductEvaluators.h	/^    LhsCoeffReadCost = LhsEtorType::CoeffReadCost,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
LhsEtorType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<LhsNestedCleaned> LhsEtorType;$/;"	t	struct:Eigen::internal::product_evaluator
LhsEval	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef evaluator<ActualLhs> LhsEval;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsEval	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef evaluator<Lhs> LhsEval;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsEval	lib/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef evaluator<Lhs> LhsEval;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
LhsEvaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef evaluator<LhsArg> LhsEvaluator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsFlags	lib/Eigen/src/Core/CoreEvaluators.h	/^    LhsFlags = evaluator<Lhs>::Flags,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
LhsFlags	lib/Eigen/src/Core/ProductEvaluators.h	/^    LhsFlags = LhsEtorType::Flags,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
LhsInnerIterator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename evaluator<Lhs>::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsIsSelfAdjoint	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon370
LhsIsUpper	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon370
LhsIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<Lhs>::InnerIterator  LhsIterator;$/;"	t	struct:Eigen::internal::binary_evaluator
LhsIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<LhsArg>::InnerIterator  LhsIterator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<LhsArg>::InnerIterator LhsIterator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsIterator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename evaluator<ActualLhs>::InnerIterator LhsIterator;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsIterator	lib/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename evaluator<Lhs>::InnerIterator LhsIterator;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
LhsMatrixType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits
LhsMatrixType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
LhsMatrixTypeNested	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::ref_selector<LhsType>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
LhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	lib/Eigen/src/Core/Product.h	/^    typedef typename internal::ref_selector<Lhs>::type LhsNested;$/;"	t	class:Eigen::Product
LhsNested	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::nested_eval<Lhs,Rhs::ColsAtCompileTime>::type LhsNested;$/;"	t	struct:Eigen::internal::product_evaluator
LhsNested	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename nested_eval<Lhs,1>::type LhsNested;$/;"	t	struct:Eigen::internal::generic_product_impl
LhsNestedCleaned	lib/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;$/;"	t	class:Eigen::Product
LhsNestedCleaned	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;$/;"	t	struct:Eigen::internal::product_evaluator
LhsOuterStrideBytes	lib/Eigen/src/Core/ProductEvaluators.h	/^    LhsOuterStrideBytes = int(LhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename LhsNestedCleaned::Scalar)),$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
LhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
LhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
LhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
LhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
LhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
LhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
LhsPacketSize	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon371
LhsPacketSize	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon372
LhsProductTraits	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon377
LhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
LhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
LhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
LhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
LhsRowMajor	lib/Eigen/src/Core/ProductEvaluators.h	/^    LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
LhsScalar	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
LhsScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
LhsScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::generic_product_impl
LhsTraits	lib/Eigen/src/Core/Product.h	/^  typedef traits<LhsCleaned> LhsTraits;$/;"	t	struct:Eigen::internal::traits
LhsUpLo	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  enum { LhsUpLo = LhsMode&(Upper|Lower) };$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon367
LhsVecPacketSize	lib/Eigen/src/Core/ProductEvaluators.h	/^    LhsVecPacketSize = unpacket_traits<LhsVecPacketType>::size,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
LhsVecPacketType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename find_best_packet<Scalar,RowsAtCompileTime>::type LhsVecPacketType;$/;"	t	struct:Eigen::internal::product_evaluator
LieRandomize	lib/qcd/utils/SUn.h	/^  static void LieRandomize(GridParallelRNG &pRNG, LatticeMatrixType &out,$/;"	f	class:Grid::QCD::SU
LimeR	lib/parallelIO/IldgIO.h	/^   LimeReader *LimeR;$/;"	m	class:Grid::QCD::GridLimeReader
LimeW	lib/parallelIO/IldgIO.h	/^   LimeWriter *LimeW;$/;"	m	class:Grid::QCD::GridLimeWriter
LinSpaced	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinalgTimer	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    GridStopWatch LinalgTimer;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
LinearAccess	lib/Eigen/src/Core/CoreEvaluators.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(Flags0)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
LinearAccessBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
LinearAccessMask	lib/Eigen/src/Core/CoreEvaluators.h	/^    LinearAccessMask = XprType::IsVectorAtCompileTime ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon241
LinearAccessMask	lib/Eigen/src/Core/CoreEvaluators.h	/^    LinearAccessMask = bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime) ? ~int(0) : ~int(LinearAccessBit),$/;"	e	enum:Eigen::internal::evaluator::__anon235
LinearBlock	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_const<LinearBlockConst>::type                 LinearBlock;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
LinearBlock	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_const<LinearBlockConst>::type                 LinearBlock;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
LinearBlockConst	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Lhs::template ConstNColsBlockXpr<Dim>::Type          LinearBlockConst;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
LinearBlockConst	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Rhs::template ConstNRowsBlockXpr<Dim>::Type          LinearBlockConst;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
LinearFunction	lib/algorithms/LinearOperator.h	/^    template<class Field> class LinearFunction {$/;"	c	namespace:Grid
LinearMapper	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename DataMapper::LinearMapper LinearMapper;$/;"	t	struct:Eigen::internal::gebp_kernel
LinearMapper	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename DataMapper::LinearMapper LinearMapper;$/;"	t	struct:Eigen::internal::gemm_pack_lhs
LinearMapper	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename DataMapper::LinearMapper LinearMapper;$/;"	t	struct:Eigen::internal::gemm_pack_rhs
LinearMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef BlasLinearMapper<Scalar, Index, AlignmentType> LinearMapper;$/;"	t	class:Eigen::internal::blas_data_mapper
LinearMatrixType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform
LinearMatrixType	lib/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation
LinearOperator	tests/debug/test_Grid_jacobi.cc	/^class LinearOperator {$/;"	c	file:
LinearOperatorBase	lib/algorithms/LinearOperator.h	/^    template<class Field> class LinearOperatorBase {$/;"	c	namespace:Grid
LinearOperatorJacobi	tests/debug/test_Grid_jacobi.cc	/^  LinearOperatorJacobi(GridCartesian *grid)    $/;"	f	class:LinearOperatorJacobi	file:
LinearOperatorJacobi	tests/debug/test_Grid_jacobi.cc	/^class LinearOperatorJacobi : public LinearOperator<vobj>$/;"	c	file:
LinearPacketSize	lib/Eigen/src/Core/AssignEvaluator.h	/^    LinearPacketSize = unpacket_traits<LinearPacketType>::size,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon140
LinearPacketType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename find_best_packet<DstScalar,Dst::SizeAtCompileTime>::type LinearPacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
LinearPart	lib/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> LinearPart;$/;"	t	class:Eigen::Transform
LinearProduct	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Product<Lhs,LinearBlock,LazyProduct>                          LinearProduct;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
LinearProduct	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Product<LinearBlock,Rhs,LazyProduct>                          LinearProduct;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
LinearRequiredAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    LinearRequiredAlignment = unpacket_traits<LinearPacketType>::alignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon141
LinearTraversal	lib/Eigen/src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::TraversalType
LinearVectorizedTraversal	lib/Eigen/src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
LinkField	lib/qcd/action/gauge/GaugeImplTypes.h	/^  typedef Lattice<SiteLink>    LinkField; $/;"	t	class:Grid::QCD::GaugeImplTypes
LinkField	lib/qcd/action/gauge/Photon.h	/^    typedef Lattice<SiteLink>  LinkField;$/;"	t	class:Grid::QCD::QedGimpl
Linop_d	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    LinearOperatorBase<FieldD> &Linop_d;$/;"	m	class:Grid::MixedPrecisionConjugateGradient
Linop_f	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    LinearOperatorBase<FieldF> &Linop_f;$/;"	m	class:Grid::MixedPrecisionConjugateGradient
ListEl	lib/Eigen/src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector
LoadPar	extras/Hadrons/Modules/MGauge/Load.hpp	/^class LoadPar: Serializable$/;"	c
LoadPar	lib/Hadrons/Modules/MGauge/Load.hpp	/^class LoadPar: Serializable$/;"	c
Local	lib/stencil/Stencil.h	/^  void Local     (int point, int dimension,int shiftpm,int cbmask)$/;"	f	class:Grid::CartesianStencil
LocalDimensions	lib/cartesian/Cartesian_base.h	/^    inline const std::vector<int> &LocalDimensions(void)        { return _ldimensions;};$/;"	f	class:Grid::GridBase
LocalIndexToLocalCoor	lib/cartesian/Cartesian_base.h	/^    void LocalIndexToLocalCoor(int lidx,std::vector<int> &lcoor){$/;"	f	class:Grid::GridBase
LocalStarts	lib/cartesian/Cartesian_base.h	/^    inline const std::vector<int> LocalStarts(void)             { return _lstart;    };$/;"	f	class:Grid::GridBase
Log10ReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_log10_op<Scalar>, const Derived> Log10ReturnType;$/;"	t
Log1pReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_log1p_op<Scalar>, const Derived> Log1pReturnType;$/;"	t
LogMessage	lib/qcd/smearing/WilsonFlow.h	/^    void LogMessage() {$/;"	f	class:Grid::QCD::WilsonFlow
LogParameters	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::PlaqPlusRectangleAction
LogParameters	lib/qcd/action/gauge/WilsonGaugeAction.h	/^  virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::WilsonGaugeAction
LogParameters	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
LogParameters	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
LogParameters	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
LogParameters	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
LogParameters	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::TwoFlavourPseudoFermionAction
LogParameters	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
LogParameters	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
LogParameters	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      virtual std::string LogParameters(){$/;"	f	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
LogParameters	lib/qcd/action/scalar/ScalarAction.h	/^    virtual std::string LogParameters() {$/;"	f	class:Grid::ScalarAction
LogParameters	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    virtual std::string LogParameters() {$/;"	f	class:Grid::ScalarInteractionAction
LogRealFunctor	lib/simd/Grid_vector_unops.h	/^struct LogRealFunctor {$/;"	s	namespace:Grid
LogReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_log_op<Scalar>, const Derived> LogReturnType;$/;"	t
Logger	lib/log/Log.h	/^  Logger(std::string topNm, int on, std::string nm, Colours& col_class, std::string col)  : active(on),$/;"	f	class:Grid::Logger
Logger	lib/log/Log.h	/^class Logger {$/;"	c	namespace:Grid
Lookup	lib/allocator/AlignedAllocator.cc	/^void *PointerCache::Lookup(size_t bytes)$/;"	f	class:Grid::PointerCache
LorentzColour2x3	lib/parallelIO/MetaData.h	/^    typedef iLorentzColour2x3<Complex>  LorentzColour2x3;$/;"	t	namespace:Grid::QCD
LorentzColour2x3D	lib/parallelIO/MetaData.h	/^    typedef iLorentzColour2x3<ComplexD> LorentzColour2x3D;$/;"	t	namespace:Grid::QCD
LorentzColour2x3F	lib/parallelIO/MetaData.h	/^    typedef iLorentzColour2x3<ComplexF> LorentzColour2x3F;$/;"	t	namespace:Grid::QCD
LorentzColourMatrix	lib/qcd/QCD.h	/^    typedef iLorentzColourMatrix<Complex  > LorentzColourMatrix;$/;"	t	namespace:Grid::QCD
LorentzColourMatrixD	lib/qcd/QCD.h	/^    typedef iLorentzColourMatrix<ComplexD > LorentzColourMatrixD;$/;"	t	namespace:Grid::QCD
LorentzColourMatrixF	lib/qcd/QCD.h	/^    typedef iLorentzColourMatrix<ComplexF > LorentzColourMatrixF;$/;"	t	namespace:Grid::QCD
LorentzIndex	lib/qcd/QCD.h	66;"	d
Lower	lib/Eigen/src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::UpLoType
LowerPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef T LowerPrecVector ;$/;"	t	struct:Grid::QCD::SamePrecisionMapper
LowerPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vComplexF LowerPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
LowerPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vComplexH LowerPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
LowerPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vRealF LowerPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
LowerPrecVector	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef vRealH LowerPrecVector ;$/;"	t	struct:Grid::QCD::LowerPrecisionMapper
LowerPrecisionMapper	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  template <> struct LowerPrecisionMapper<vComplexD> {$/;"	s	namespace:Grid::QCD
LowerPrecisionMapper	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  template <> struct LowerPrecisionMapper<vComplexF> {$/;"	s	namespace:Grid::QCD
LowerPrecisionMapper	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  template <> struct LowerPrecisionMapper<vRealD> {$/;"	s	namespace:Grid::QCD
LowerPrecisionMapper	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  template <> struct LowerPrecisionMapper<vRealF> {$/;"	s	namespace:Grid::QCD
LowerPrecisionMapper	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  template <class T> struct LowerPrecisionMapper {  };$/;"	s	namespace:Grid::QCD
LpNormReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    template<int p> struct LpNormReturnType {$/;"	s	class:Eigen::VectorwiseOp
Ls	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    int Ls;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
Ls	lib/qcd/action/fermion/WilsonFermion5D.h	/^    int Ls;$/;"	m	class:Grid::QCD::WilsonFermion5D
Ls	lib/qcd/modules/FermionOperatorModules.h	/^  virtual unsigned int Ls(){$/;"	f	class:Grid::FermionOperatorModule
Ls	lib/qcd/modules/FermionOperatorModules.h	/^  virtual unsigned int Ls(){$/;"	f	class:Grid::QCD::DomainWallFermionModule
Ls	lib/qcd/modules/FermionOperatorModules.h	/^  virtual unsigned int Ls(){$/;"	f	class:Grid::QCD::MobiusFermionModule
Ls	tests/qdpxx/Test_qdpxx_munprec.cc	/^int    Ls=8;$/;"	v
LsVectorised	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const bool LsVectorised=false;$/;"	m	class:Grid::QCD::StaggeredImpl
LsVectorised	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const bool LsVectorised=false;$/;"	m	class:Grid::QCD::WilsonImpl
LsVectorised	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const bool LsVectorised=true;$/;"	m	class:Grid::QCD::StaggeredVec5dImpl
LsVectorised	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  static const bool LsVectorised=true;$/;"	m	class:Grid::QCD::DomainWallVec5dImpl
LsVectorised	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ static const bool LsVectorised=false;$/;"	m	class:Grid::QCD::GparityWilsonImpl
Ls_	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^    unsigned int Ls_;$/;"	m	class:TGaugeProp
Ls_	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^    unsigned int Ls_;$/;"	m	class:TGaugeProp
LuType	lib/Eigen/src/LU/FullPivLU.h	/^  typedef FullPivLU<MatrixType> LuType;$/;"	t	struct:Eigen::internal::Assignment
LuType	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef PartialPivLU<MatrixType> LuType;$/;"	t	struct:Eigen::internal::Assignment
LvalueBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
M	lib/algorithms/CoarsenedMatrix.h	/^    RealD M (const CoarseVector &in, CoarseVector &out){$/;"	f	class:Grid::CoarsenedMatrix
M	lib/algorithms/iterative/AdefGeneric.h	/^  virtual void M(Field & in,Field & out,Field & tmp){$/;"	f	class:TwoLevelFlexiblePcg::TwoLevelFlexiblePcgADef2
M	lib/qcd/action/fermion/CayleyFermion5D.cc	/^RealD CayleyFermion5D<Impl>::M    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
M	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    RealD  ContinuedFractionFermion5D<Impl>::M           (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
M	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^RealD ImprovedStaggeredFermion<Impl>::M(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
M	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^RealD ImprovedStaggeredFermion5D<Impl>::M(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
M	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    RealD  PartialFractionFermion5D<Impl>::M    (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
M	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^  virtual RealD M       (const Field& in, Field& out) { return sscale_norm(in,out,&kappa[0]);   }$/;"	f	class:Grid::KappaSimilarityTransform
M	lib/qcd/action/fermion/WilsonFermion.cc	/^RealD WilsonFermion<Impl>::M(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
M	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual RealD  M    (const FermionField &in, FermionField &out){assert(0); return 0.0;};$/;"	f	class:Grid::QCD::WilsonFermion5D
M	lib/qcd/utils/CovariantLaplacian.h	/^  void M(const AVector& in, AVector& out) {$/;"	f	class:Grid::QCD::LaplacianAlgebraField
M	lib/qcd/utils/CovariantLaplacian.h	/^void M(const GaugeField& in, GaugeField& out) {$/;"	f	class:Grid::QCD::LaplacianAdjointField
M	lib/qcd/utils/Metric.h	/^  Metric<MomentaField>& M;$/;"	m	class:Grid::QCD::GeneralisedMomenta
M	lib/qcd/utils/Metric.h	/^  virtual void M(const Field& in, Field& out){$/;"	f	class:Grid::QCD::TrivialMetric
M1	lib/algorithms/iterative/AdefGeneric.h	/^  virtual void M1(Field & in, Field & out,Field & tmp,Field & mp){$/;"	f	class:TwoLevelFlexiblePcg::TwoLevelFlexiblePcgADef2
M2	lib/algorithms/iterative/AdefGeneric.h	/^  virtual void M2(Field & in, Field & out){$/;"	f	class:TwoLevelFlexiblePcg::TwoLevelFlexiblePcgADef2
M3	lib/algorithms/iterative/AdefGeneric.h	/^  virtual RealD M3(Field & p, Field & mp,Field & mmp, Field & tmp){$/;"	f	class:TwoLevelFlexiblePcg::TwoLevelFlexiblePcgADef2
M5	lib/qcd/action/fermion/WilsonFermion5D.h	/^    double                        M5;$/;"	m	class:Grid::QCD::WilsonFermion5D
M5	tests/qdpxx/Test_qdpxx_munprec.cc	/^double M5=1.6;$/;"	v
M5D	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::M5D   (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
M5D	lib/qcd/action/fermion/CayleyFermion5Dcache.cc	/^void CayleyFermion5D<Impl>::M5D(const FermionField &psi,$/;"	f	class:Grid::QCD::CayleyFermion5D
M5D	lib/qcd/action/fermion/CayleyFermion5Dssp.cc	/^void CayleyFermion5D<Impl>::M5D(const FermionField &psi,$/;"	f	class:Grid::QCD::CayleyFermion5D
M5D	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^void CayleyFermion5D<Impl>::M5D(const FermionField &psi,$/;"	f	class:Grid::QCD::CayleyFermion5D
M5Dcalls	lib/qcd/action/fermion/CayleyFermion5D.h	/^     double M5Dcalls;$/;"	m	class:Grid::QCD::CayleyFermion5D
M5Ddag	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::M5Ddag (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
M5Ddag	lib/qcd/action/fermion/CayleyFermion5Dcache.cc	/^void CayleyFermion5D<Impl>::M5Ddag(const FermionField &psi,$/;"	f	class:Grid::QCD::CayleyFermion5D
M5Ddag	lib/qcd/action/fermion/CayleyFermion5Dssp.cc	/^void CayleyFermion5D<Impl>::M5Ddag(const FermionField &psi,$/;"	f	class:Grid::QCD::CayleyFermion5D
M5Ddag	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^void CayleyFermion5D<Impl>::M5Ddag(const FermionField &psi,$/;"	f	class:Grid::QCD::CayleyFermion5D
M5Dflops	lib/qcd/action/fermion/CayleyFermion5D.h	/^     double M5Dflops;$/;"	m	class:Grid::QCD::CayleyFermion5D
M5Dtime	lib/qcd/action/fermion/CayleyFermion5D.h	/^     double M5Dtime;$/;"	m	class:Grid::QCD::CayleyFermion5D
MAKE_CW_SUBDIAG	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	49;"	d
MAKE_CW_SUBDIAG	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	49;"	d
MAKE_DIAG	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	47;"	d
MAKE_DIAG	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	47;"	d
MAKE_DISC_CURR	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	51;"	d
MAKE_DISC_CURR	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	51;"	d
MAKE_DISC_LOOP	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	50;"	d
MAKE_DISC_LOOP	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	50;"	d
MAKE_DISC_MESON	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	49;"	d
MAKE_DISC_MESON	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	49;"	d
MAKE_SE_BODY	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	49;"	d
MAKE_SE_BODY	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	49;"	d
MAKE_SE_LOOP	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	50;"	d
MAKE_SE_LOOP	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	50;"	d
MAKE_WEAK_MODULE	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	82;"	d
MAKE_WEAK_MODULE	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	82;"	d
MASK_REGS	lib/simd/BGQQPX.h	65;"	d
MASK_REGS	lib/simd/IBM_qpx.h	104;"	d
MASK_REGS	lib/simd/Intel512common.h	39;"	d
MATRIX_FREE_CONJUGATE_GRADIENT_IS_COMPATIBLE_WITH_UPPER_UNION_LOWER_MODE_ONLY	lib/Eigen/src/Core/util/StaticAssert.h	/^        MATRIX_FREE_CONJUGATE_GRADIENT_IS_COMPATIBLE_WITH_UPPER_UNION_LOWER_MODE_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
MAX	lib/algorithms/approx/Zolotarev.cc	22;"	d	file:
MAX	lib/serialisation/MacroMagic.h	48;"	d
MAXLOG2RANKSPERNODE	lib/communicator/Communicator_base.h	/^  static const int      MAXLOG2RANKSPERNODE = 16;            $/;"	m	class:Grid::CartesianCommunicator
MAX_MPI_SHM_BYTES	lib/communicator/Communicator_base.cc	/^uint64_t            CartesianCommunicator::MAX_MPI_SHM_BYTES   = 128*1024*1024; $/;"	m	class:Grid::CartesianCommunicator	file:
MAX_MPI_SHM_BYTES	lib/communicator/Communicator_base.h	/^  static uint64_t MAX_MPI_SHM_BYTES;$/;"	m	class:Grid::CartesianCommunicator
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	204;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	206;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	348;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	362;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	505;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	507;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	53;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	647;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	123;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	125;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	147;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	42;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	68;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	70;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	90;"	d
MAYBEPERM	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	99;"	d
MAYBEPERM	lib/simd/BGQQPX.h	146;"	d
MDag	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^  virtual RealD MDag    (const Field& in, Field& out) { return sscale_norm(in,out,&kappaDag[0]);}$/;"	f	class:Grid::KappaSimilarityTransform
MDeriv	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::MDeriv  (GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::CayleyFermion5D
MDeriv	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^   void ContinuedFractionFermion5D<Impl>::MDeriv  (GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
MDeriv	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void MDeriv  (GaugeField &mat,const FermionField &U,const FermionField &V,int dag){DhopDeriv(mat,U,V,dag);};$/;"	f	class:Grid::QCD::FermionOperator
MDeriv	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^   void PartialFractionFermion5D<Impl>::MDeriv  (GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
MDeriv	lib/qcd/utils/CovariantLaplacian.h	/^  void MDeriv(const GaugeField& in, GaugeField& der) {$/;"	f	class:Grid::QCD::LaplacianAdjointField
MDeriv	lib/qcd/utils/CovariantLaplacian.h	/^  void MDeriv(const GaugeField& left, const GaugeField& right,$/;"	f	class:Grid::QCD::LaplacianAdjointField
MDeriv	lib/qcd/utils/Metric.h	/^  virtual void MDeriv(const Field& in, Field& out){$/;"	f	class:Grid::QCD::TrivialMetric
MDeriv	lib/qcd/utils/Metric.h	/^  virtual void MDeriv(const Field& left, const Field& right, Field& out){$/;"	f	class:Grid::QCD::TrivialMetric
MEM_MSG	extras/Hadrons/Application.cc	161;"	d	file:
MEM_MSG	extras/Hadrons/Environment.cc	328;"	d	file:
MEM_MSG	lib/Hadrons/Application.cc	161;"	d	file:
MEM_MSG	lib/Hadrons/Environment.cc	328;"	d	file:
METIS_SUPPORT_H	lib/Eigen/src/MetisSupport/MetisSupport.h	10;"	d
METRIC_H	lib/qcd/utils/Metric.h	31;"	d
MFlops	lib/algorithms/FFT.h	/^    double MFlops(void) {return flops\/usec;}$/;"	f	class:Grid::FFT
MIDDLE_CRUSH	tests/testu01/Test_smallcrush.cc	36;"	d	file:
MIN	lib/algorithms/approx/Zolotarev.cc	23;"	d	file:
MIN	lib/serialisation/MacroMagic.h	49;"	d
MIX2	lib/sitmo_rng/sitmo_prng_engine.hpp	388;"	d
MIX2	lib/sitmo_rng/sitmo_prng_engine.hpp	48;"	d
MIXK	lib/sitmo_rng/sitmo_prng_engine.hpp	387;"	d
MIXK	lib/sitmo_rng/sitmo_prng_engine.hpp	58;"	d
MInv	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^  virtual RealD MInv    (const Field& in, Field& out) { return sscale_norm(in,out,&kappaInv[0]);}$/;"	f	class:Grid::KappaSimilarityTransform
MInvDag	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^  virtual RealD MInvDag (const Field& in, Field& out) { return sscale_norm(in,out,&kappaInvDag[0]);}$/;"	f	class:Grid::KappaSimilarityTransform
MInvSquareRoot	lib/qcd/utils/CovariantLaplacian.h	/^  void MInvSquareRoot(GaugeField& P){$/;"	f	class:Grid::QCD::LaplacianAdjointField
MInvSquareRoot	lib/qcd/utils/Metric.h	/^  virtual void MInvSquareRoot(Field& P){$/;"	f	class:Grid::QCD::TrivialMetric
MODS_H	lib/qcd/modules/mods.h	30;"	d
MODULES_REGISTRATION_H	lib/qcd/modules/Registration.h	31;"	d
MODULE_REGISTER	extras/Hadrons/Module.hpp	39;"	d
MODULE_REGISTER	lib/Hadrons/Module.hpp	39;"	d
MODULE_REGISTER_NS	extras/Hadrons/Module.hpp	64;"	d
MODULE_REGISTER_NS	lib/Hadrons/Module.hpp	64;"	d
MPI_SHARED_MEM	lib/communicator/Communicator_mpi3_leader.cc	385;"	d	file:
MPI_SHARED_MEM_DEBUG	lib/communicator/Communicator_mpi3_leader.cc	345;"	d	file:
MPIoffloadEngine	lib/communicator/Communicator_mpi3_leader.cc	/^class MPIoffloadEngine { $/;"	c	namespace:Grid	file:
MSquareRoot	lib/qcd/utils/CovariantLaplacian.h	/^  void MSquareRoot(GaugeField& P){$/;"	f	class:Grid::QCD::LaplacianAdjointField
MSquareRoot	lib/qcd/utils/Metric.h	/^  virtual void MSquareRoot(Field& P){$/;"	f	class:Grid::QCD::TrivialMetric
MULT	lib/qcd/action/fermion/StaggeredKernelsHand.cc	41;"	d	file:
MULTI_SHIFT_FUNCTION	lib/algorithms/approx/MultiShiftFunction.h	30;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	205;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	207;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	258;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	259;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	349;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	363;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	506;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	508;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	54;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	559;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	560;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	648;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	100;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	124;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	126;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	148;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	43;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	69;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	71;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsAsmQPX.h	91;"	d
MULT_2SPIN	lib/qcd/action/fermion/WilsonKernelsHand.cc	58;"	d	file:
MULT_2SPIN_DIR_PF	lib/simd/IBM_qpx.h	259;"	d
MULT_2SPIN_DIR_PF	lib/simd/Intel512wilson.h	182;"	d
MULT_2SPIN_DIR_PFTM	lib/simd/BGQQPX.h	160;"	d
MULT_2SPIN_DIR_PFTP	lib/simd/BGQQPX.h	156;"	d
MULT_2SPIN_DIR_PFXM	lib/simd/BGQQPX.h	157;"	d
MULT_2SPIN_DIR_PFXP	lib/simd/BGQQPX.h	153;"	d
MULT_2SPIN_DIR_PFYM	lib/simd/BGQQPX.h	158;"	d
MULT_2SPIN_DIR_PFYP	lib/simd/BGQQPX.h	154;"	d
MULT_2SPIN_DIR_PFZM	lib/simd/BGQQPX.h	159;"	d
MULT_2SPIN_DIR_PFZP	lib/simd/BGQQPX.h	155;"	d
MULT_2SPIN_PF	lib/simd/IBM_qpx.h	260;"	d
MULT_2SPIN_PF	lib/simd/Intel512wilson.h	183;"	d
MULT_2SPIN_QPX	lib/simd/IBM_qpx_double.h	36;"	d
MULT_2SPIN_QPX	lib/simd/IBM_qpx_double.h	45;"	d
MULT_2SPIN_QPX	lib/simd/IBM_qpx_single.h	36;"	d
MULT_2SPIN_QPX	lib/simd/IBM_qpx_single.h	45;"	d
MULT_2SPIN_QPX_INTERNAL	lib/simd/IBM_qpx.h	203;"	d
MULT_2SPIN_QPX_LS	lib/simd/IBM_qpx_double.h	35;"	d
MULT_2SPIN_QPX_LS	lib/simd/IBM_qpx_double.h	44;"	d
MULT_2SPIN_QPX_LS	lib/simd/IBM_qpx_single.h	35;"	d
MULT_2SPIN_QPX_LS	lib/simd/IBM_qpx_single.h	44;"	d
MULT_2SPIN_QPX_LSd	lib/simd/IBM_qpx.h	198;"	d
MULT_2SPIN_QPX_LSf	lib/simd/IBM_qpx.h	199;"	d
MULT_2SPIN_QPXd	lib/simd/IBM_qpx.h	200;"	d
MULT_2SPIN_QPXf	lib/simd/IBM_qpx.h	201;"	d
MULT_ADD	lib/qcd/action/fermion/StaggeredKernelsHand.cc	62;"	d	file:
MULT_ADDSUB_2SPIN	lib/simd/Intel512wilson.h	698;"	d
MULT_ADDSUB_2SPIN_LS	lib/simd/Intel512wilson.h	793;"	d
MULT_ADDSUB_2SPIN_LSNOPF	lib/simd/Intel512wilson.h	855;"	d
MULT_ADDSUB_2SPIN_NEW	lib/simd/Intel512wilson.h	891;"	d
MULT_ADD_LS	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	107;"	d	file:
MULT_ADD_XYZT	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	300;"	d	file:
MULT_ADD_XYZTa	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	205;"	d	file:
MULT_LS	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	156;"	d	file:
MULT_SPIN	lib/simd/BGQQPX.h	162;"	d
MULT_XYZT	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	341;"	d	file:
MULT_XYZTa	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	431;"	d	file:
M_PI	lib/algorithms/approx/Zolotarev.cc	41;"	d	file:
M_internal	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void   PartialFractionFermion5D<Impl>::M_internal(const FermionField &psi, FermionField &chi,int dag)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
MachineCharacteristics	lib/parallelIO/MetaData.h	/^    inline void MachineCharacteristics(FieldMetaData &header)$/;"	f	namespace:Grid::QCD
MaddRealPart	lib/simd/Grid_avx.h	/^  struct MaddRealPart{$/;"	s	namespace:Grid::Optimization
MaddRealPart	lib/simd/Grid_avx512.h	/^  struct MaddRealPart{$/;"	s	namespace:Grid::Optimization
MaddRealPart	lib/simd/Grid_generic.h	/^  struct MaddRealPart{$/;"	s	namespace:Grid::Optimization
MaddRealPart	lib/simd/Grid_neon.h	/^  struct MaddRealPart{$/;"	s	namespace:Grid::Optimization
MaddRealPart	lib/simd/Grid_qpx.h	/^  struct MaddRealPart{$/;"	s	namespace:Grid::Optimization
MaddRealPart	lib/simd/Grid_sse4.h	/^  struct MaddRealPart{$/;"	s	namespace:Grid::Optimization
MaddRealPartSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::MaddRealPart MaddRealPartSIMD;$/;"	t	namespace:Grid
MaddRealPartSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::MaddRealPart MaddRealPartSIMD;$/;"	t	namespace:Grid
MaddRealPartSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::MaddRealPart MaddRealPartSIMD;$/;"	t	namespace:Grid
MaddRealPartSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::MaddRealPart MaddRealPartSIMD;$/;"	t	namespace:Grid
MaddRealPartSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::MaddRealPart MaddRealPartSIMD;$/;"	t	namespace:Grid
MaddRealPartSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::MaddRealPart MaddRealPartSIMD;$/;"	t	namespace:Grid
MagMeas	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^class MagMeas : public HmcObservable<typename Impl::Field> {$/;"	c	file:
MagMod	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^  MagMod(): ObsBase(NoParameters()){}$/;"	f	class:MagMod
MagMod	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^class MagMod: public ObservableModule<MagMeas<Impl>, NoParameters>{$/;"	c	file:
Map	lib/Eigen/src/Core/Map.h	/^    explicit inline Map(PointerArgType dataPtr, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index rows, Index cols, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index size, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen
Map	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const StorageIndex* indicesPtr)$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const StorageIndex* indicesPtr, Index size)$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex>,_PacketAccess>$/;"	c	namespace:Eigen
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	lib/Eigen/src/Core/Transpositions.h	/^    explicit inline Map(const StorageIndex* indicesPtr)$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Core/Transpositions.h	/^    inline Map(const StorageIndex* indicesPtr, Index size)$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>,PacketAccess>$/;"	c	namespace:Eigen
Map	lib/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC explicit EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC explicit EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	lib/Eigen/src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Map(Index rows, Index cols, Index nnz, StorageIndex* outerIndexPtr,$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Map(Index rows, Index cols, Index nnz, const StorageIndex* outerIndexPtr,$/;"	f	class:Eigen::Map
Map	lib/Eigen/src/SparseCore/SparseMap.h	/^class Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
Map	lib/Eigen/src/SparseCore/SparseMap.h	/^class Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
Map	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix
Map	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix
Map	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& a_mat)$/;"	f	struct:Eigen::SluMatrix
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	lib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapBase	lib/Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC explicit inline MapBase(PointerType dataPtr) : Base(dataPtr) {}$/;"	f	class:Eigen::MapBase
MapBase	lib/Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index rows, Index cols) : Base(dataPtr, rows, cols) {}$/;"	f	class:Eigen::MapBase
MapBase	lib/Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index vecSize) : Base(dataPtr, vecSize) {}$/;"	f	class:Eigen::MapBase
MapBase	lib/Eigen/src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : m_data(dataPtr), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase
MapBase	lib/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index rows, Index cols)$/;"	f	class:Eigen::MapBase
MapBase	lib/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize)$/;"	f	class:Eigen::MapBase
MapBase	lib/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
MapBase	lib/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen
MapCommRankToWorldRank	lib/communicator/Communicator_mpi3_leader.cc	/^void MPIoffloadEngine::MapCommRankToWorldRank(int &hashtag, int & comm_world_peer,int tag, MPI_Comm comm,int rank) {$/;"	f	class:Grid::MPIoffloadEngine
MapLU	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl
MapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase
MappedMatrixBlock	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Map<ScalarMatrix, 0,  OuterStride<> > MappedMatrixBlock;$/;"	t	class:Eigen::internal::SparseLUImpl
MappedRhs	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector
MappedSparseMatrix	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, StorageIndex* outerIndexPtr, StorageIndex* innerIndexPtr, Scalar* valuePtr, StorageIndex* innerNonZeroPtr = 0)$/;"	f	class:Eigen::MappedSparseMatrix
MappedSparseMatrix	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen
MappedSuperNodalMatrix	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
MappedSuperNodalMatrix	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix(Index m, Index n,  ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind,$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
MappedSuperNodalMatrix	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix$/;"	c	namespace:Eigen::internal
MaskLvalueBit	lib/Eigen/src/Core/Diagonal.h	/^    MaskLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon401
MaskPacketAccessBit	lib/Eigen/src/Core/CoreEvaluators.h	/^    MaskPacketAccessBit = (InnerStrideAtCompileTime == 1) ? PacketAccessBit : 0,$/;"	e	enum:Eigen::internal::evaluator::__anon237
MatTimer	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    GridStopWatch MatTimer;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
MatchAtCompileTime	lib/Eigen/src/Core/Ref.h	/^      MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch && ScalarTypeMatch$/;"	e	enum:Eigen::internal::traits::match::__anon150
MatchAtCompileTime	lib/Eigen/src/SparseCore/SparseRef.h	/^      MatchAtCompileTime = (Derived::Flags&CompressedAccessBit) && Derived::IsVectorAtCompileTime$/;"	e	enum:Eigen::internal::traits::match::__anon536
MatchAtCompileTime	lib/Eigen/src/SparseCore/SparseRef.h	/^      MatchAtCompileTime = (Derived::Flags&CompressedAccessBit) && StorageOrderMatch$/;"	e	enum:Eigen::internal::traits::match::__anon533
MatmInv	lib/qcd/action/fermion/CayleyFermion5D.h	/^      Vector<iSinglet<Simd> >  MatmInv;$/;"	m	class:Grid::QCD::CayleyFermion5D
MatmInvDag	lib/qcd/action/fermion/CayleyFermion5D.h	/^      Vector<iSinglet<Simd> >  MatmInvDag;$/;"	m	class:Grid::QCD::CayleyFermion5D
MatpInv	lib/qcd/action/fermion/CayleyFermion5D.h	/^      Vector<iSinglet<Simd> >  MatpInv;$/;"	m	class:Grid::QCD::CayleyFermion5D
MatpInvDag	lib/qcd/action/fermion/CayleyFermion5D.h	/^      Vector<iSinglet<Simd> >  MatpInvDag;$/;"	m	class:Grid::QCD::CayleyFermion5D
Matrix	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix() : Base()$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other) : Base(other)$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(const T& x)$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^    explicit Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix
Matrix	lib/Eigen/src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen
Matrix	lib/Eigen/src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
Matrix	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	/^        typedef FermionOperator<Impl> Matrix;$/;"	t	class:Grid::QCD::SchurDifferentiableOperator
Matrix	lib/qcd/utils/SUn.h	/^  typedef iSUnMatrix<Complex> Matrix;$/;"	t	class:Grid::QCD::SU
Matrix	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnMatrix<Complex> Matrix;$/;"	t	class:Grid::QCD::SU_TwoIndex
Matrix2	lib/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D
Matrix2s	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,2> Matrix2s;$/;"	t	class:Eigen::RealQZ
Matrix3	lib/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis
Matrix3	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase
MatrixAlignment	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = traits<MatrixType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon675
MatrixAlignment	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = traits<MatrixType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon676
MatrixBase	lib/Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase
MatrixBase	lib/Eigen/src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen
MatrixCols	lib/Eigen/src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon213
MatrixConjugateReturnType	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::SelfAdjointView
MatrixConjugateReturnType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView
MatrixD	lib/qcd/utils/SUn.h	/^  typedef iSUnMatrix<ComplexD> MatrixD;$/;"	t	class:Grid::QCD::SU
MatrixD	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnMatrix<ComplexD> MatrixD;$/;"	t	class:Grid::QCD::SU_TwoIndex
MatrixF	lib/qcd/utils/SUn.h	/^  typedef iSUnMatrix<ComplexF> MatrixF;$/;"	t	class:Grid::QCD::SU
MatrixF	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnMatrix<ComplexF> MatrixF;$/;"	t	class:Grid::QCD::SU_TwoIndex
MatrixFlags	lib/Eigen/src/Core/ProductEvaluators.h	/^    MatrixFlags = evaluator<MatrixType>::Flags,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
MatrixFree	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    MatrixFree = false$/;"	e	enum:Eigen::internal::generic_matrix_wrapper::__anon669
MatrixFree	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    MatrixFree = true$/;"	e	enum:Eigen::internal::generic_matrix_wrapper::__anon670
MatrixHReturnType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixL	lib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	lib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	lib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	lib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT
MatrixL	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT
MatrixL	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixL	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixOptions	lib/Eigen/src/SVD/BDCSVD.h	/^    MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::BDCSVD::__anon622
MatrixOptions	lib/Eigen/src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon620
MatrixOptions	lib/Eigen/src/SVD/SVDBase.h	/^    MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::SVDBase::__anon621
MatrixQReturnType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixQType	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR
MatrixRows	lib/Eigen/src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon213
MatrixTReturnType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization
MatrixType	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT
MatrixType	lib/Eigen/src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT
MatrixType	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase
MatrixType	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition
MatrixType	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT
MatrixType	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT
MatrixType	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT
MatrixType	lib/Eigen/src/Core/ProductEvaluators.h	/^    typedef typename nested_eval<ExpressionType, 1>::type MatrixType;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::remove_all<typename internal::conditional<int(Side)==OnTheRight,LhsNested,RhsNested>::type>::type MatrixType;$/;"	t	struct:Eigen::internal::generic_product_impl
MatrixType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename nested_eval<ExpressionType, 1>::type MatrixType;$/;"	t	struct:Eigen::internal::transposition_matrix_product
MatrixType	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointView
MatrixType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView
MatrixType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularViewImpl
MatrixType	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver
MatrixType	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur
MatrixType	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver
MatrixType	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedEigenSolver
MatrixType	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
MatrixType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixType	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealQZ
MatrixType	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur
MatrixType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
MatrixType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
MatrixType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization
MatrixType	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
MatrixType	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform
MatrixType	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB
MatrixType	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient
MatrixType	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase
MatrixType	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
MatrixType	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU
MatrixType	lib/Eigen/src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU
MatrixType	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl
MatrixType	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase
MatrixType	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT
MatrixType	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT
MatrixType	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU
MatrixType	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits
MatrixType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits
MatrixType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl
MatrixType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR
MatrixType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
MatrixType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixType	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR
MatrixType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor, StorageIndex> MatrixType;$/;"	t	class:Eigen::SPQR
MatrixType	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BDCSVD
MatrixType	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD
MatrixType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/SVD/SVDBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SVDBase
MatrixType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
MatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky
MatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT
MatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT
MatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
MatrixType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _StorageIndex> MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename nested_eval<ExpressionType, 1>::type MatrixType;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixType	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef _MatrixType MatrixType; $/;"	t	class:Eigen::SparseLU
MatrixType	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> MatrixType; $/;"	t	class:Eigen::internal::SparseLUImpl
MatrixType	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SparseQR
MatrixType	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::evaluator_traits
MatrixType	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::QRMatrixType MatrixType;$/;"	t	struct:Eigen::SparseQR_QProduct
MatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU
MatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU
MatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase
MatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU
MatrixType	lib/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base
MatrixType	lib/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	lib/Eigen/src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixTypeCleaned	lib/Eigen/src/Core/ProductEvaluators.h	/^    typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixTypeCleaned	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product
MatrixTypeCleaned	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeCleaned	lib/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixTypeInnerStride	lib/Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon394
MatrixTypeNested	lib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryView
MatrixTypeNested	lib/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/Core/Diagonal.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate
MatrixTypeNested	lib/Eigen/src/Core/Replicate.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/Core/Reverse.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNested	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/Core/Transpose.h	/^    typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	class:Eigen::Transpose
MatrixTypeNested	lib/Eigen/src/Core/Transpose.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView
MatrixTypeNested	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
MatrixTypeNested	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
MatrixTypeNested	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::TriangularViewImpl
MatrixTypeNested	lib/Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView
MatrixTypeNestedCleaned	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNestedCleaned	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularViewImpl
MatrixTypeNestedNonRef	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView
MatrixTypeNestedNonRef	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedNonRef	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularViewImpl
MatrixTypeNestedPlain	lib/Eigen/src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits
MatrixTypeOuterStride	lib/Eigen/src/Core/Diagonal.h	/^    MatrixTypeOuterStride = outer_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon401
MatrixTypeRealView	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization
MatrixU	lib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	lib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	lib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	lib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT
MatrixU	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT
MatrixU	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixU	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixUType	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef typename Base::MatrixUType MatrixUType;$/;"	t	class:Eigen::BDCSVD
MatrixUType	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename Base::MatrixUType MatrixUType;$/;"	t	class:Eigen::JacobiSVD
MatrixUType	lib/Eigen/src/SVD/SVDBase.h	/^  typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, MatrixOptions, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixUType;$/;"	t	class:Eigen::SVDBase
MatrixVType	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef typename Base::MatrixVType MatrixVType;$/;"	t	class:Eigen::BDCSVD
MatrixVType	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename Base::MatrixVType MatrixVType;$/;"	t	class:Eigen::JacobiSVD
MatrixVType	lib/Eigen/src/SVD/SVDBase.h	/^  typedef Matrix<Scalar, ColsAtCompileTime, ColsAtCompileTime, MatrixOptions, MaxColsAtCompileTime, MaxColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVDBase
MatrixWrapper	lib/Eigen/src/Core/ArrayWrapper.h	/^    explicit inline MatrixWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::MatrixWrapper
MatrixWrapper	lib/Eigen/src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen
MatrixWrapper	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef internal::generic_matrix_wrapper<MatrixType> MatrixWrapper;$/;"	t	class:Eigen::IterativeSolverBase
MatrixX	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef Matrix<Scalar, Dynamic, Dynamic, ColMajor> MatrixX;$/;"	t	class:Eigen::BDCSVD
MatrixXpr	lib/Eigen/src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
MatrixXr	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef Matrix<RealScalar, Dynamic, Dynamic, ColMajor> MatrixXr;$/;"	t	class:Eigen::BDCSVD
Max	lib/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
MaxCoeffReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_maxCoeff>::Type MaxCoeffReturnType;$/;"	t	class:Eigen::VectorwiseOp
MaxCols	lib/Eigen/src/Core/GeneralProduct.h	/^    MaxCols = traits<_Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon185
MaxColsAtCompileTime	lib/Eigen/src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon630
MaxColsAtCompileTime	lib/Eigen/src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon631
MaxColsAtCompileTime	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::CholmodBase::__anon14
MaxColsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
MaxColsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon388
MaxColsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon389
MaxColsAtCompileTime	lib/Eigen/src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon213
MaxColsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    MaxColsAtCompileTime = traits<XprType>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon237
MaxColsAtCompileTime	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon504
MaxColsAtCompileTime	lib/Eigen/src/Core/CwiseTernaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon219
MaxColsAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon129
MaxColsAtCompileTime	lib/Eigen/src/Core/Diagonal.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon401
MaxColsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon398
MaxColsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon400
MaxColsAtCompileTime	lib/Eigen/src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon172
MaxColsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = PermTraits::MaxColsAtCompileTime$/;"	e	enum:Eigen::InverseImpl::__anon502
MaxColsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon500
MaxColsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon501
MaxColsAtCompileTime	lib/Eigen/src/Core/Product.h	/^    MaxColsAtCompileTime = RhsTraits::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon126
MaxColsAtCompileTime	lib/Eigen/src/Core/ProductEvaluators.h	/^    MaxColsAtCompileTime = RhsNestedCleaned::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::product_evaluator::__anon176
MaxColsAtCompileTime	lib/Eigen/src/Core/Redux.h	/^    MaxColsAtCompileTime = XprType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
MaxColsAtCompileTime	lib/Eigen/src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon225
MaxColsAtCompileTime	lib/Eigen/src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
MaxColsAtCompileTime	lib/Eigen/src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon128
MaxColsAtCompileTime	lib/Eigen/src/Core/SolverBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon247
MaxColsAtCompileTime	lib/Eigen/src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon391
MaxColsAtCompileTime	lib/Eigen/src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon19
MaxColsAtCompileTime	lib/Eigen/src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon156
MaxColsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon581
MaxColsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon583
MaxColsAtCompileTime	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon576
MaxColsAtCompileTime	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon577
MaxColsAtCompileTime	lib/Eigen/src/Eigenvalues/RealQZ.h	/^        MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealQZ::__anon582
MaxColsAtCompileTime	lib/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon580
MaxColsAtCompileTime	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon584
MaxColsAtCompileTime	lib/Eigen/src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon607
MaxColsAtCompileTime	lib/Eigen/src/Geometry/Transform.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon592
MaxColsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon652
MaxColsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon651
MaxColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::DiagonalPreconditioner::__anon666
MaxColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::IncompleteCholesky::__anon665
MaxColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::IncompleteLUT::__anon672
MaxColsAtCompileTime	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::IterativeSolverBase::__anon671
MaxColsAtCompileTime	lib/Eigen/src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon678
MaxColsAtCompileTime	lib/Eigen/src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon674
MaxColsAtCompileTime	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PastixBase::__anon648
MaxColsAtCompileTime	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::PardisoImpl::__anon654
MaxColsAtCompileTime	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon644
MaxColsAtCompileTime	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon642
MaxColsAtCompileTime	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon646
MaxColsAtCompileTime	lib/Eigen/src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon647
MaxColsAtCompileTime	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::SPQR::__anon18
MaxColsAtCompileTime	lib/Eigen/src/SVD/BDCSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon622
MaxColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon620
MaxColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon617
MaxColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon618
MaxColsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon619
MaxColsAtCompileTime	lib/Eigen/src/SVD/SVDBase.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon621
MaxColsAtCompileTime	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon634
MaxColsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon514
MaxColsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon513
MaxColsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
MaxColsAtCompileTime	lib/Eigen/src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon539
MaxColsAtCompileTime	lib/Eigen/src/SparseLU/SparseLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SparseLU::__anon660
MaxColsAtCompileTime	lib/Eigen/src/SparseQR/SparseQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SparseQR::__anon511
MaxColsAtCompileTime	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SuperLUBase::__anon17
MaxColsAtCompileTime	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::UmfPackLU::__anon629
MaxDepth	lib/Eigen/src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(traits<_Lhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon185
MaxDepthAtCompileTime	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::internal::generic_product_impl::__anon364
MaxDiagSizeAtCompileTime	lib/Eigen/src/SVD/BDCSVD.h	/^    MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime, MaxColsAtCompileTime), $/;"	e	enum:Eigen::BDCSVD::__anon622
MaxDiagSizeAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon620
MaxDiagSizeAtCompileTime	lib/Eigen/src/SVD/SVDBase.h	/^    MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::SVDBase::__anon621
MaxInnerIterations	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    Integer MaxInnerIterations;$/;"	m	class:Grid::MixedPrecisionConjugateGradient
MaxIter	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  int MaxIter;   \/\/ Max iterations$/;"	m	class:Grid::ImplicitlyRestartedLanczos
MaxIterations	lib/algorithms/iterative/AdefGeneric.h	/^  Integer MaxIterations;$/;"	m	class:TwoLevelFlexiblePcg
MaxIterations	lib/algorithms/iterative/BlockConjugateGradient.h	/^  Integer MaxIterations;$/;"	m	class:Grid::BlockConjugateGradient
MaxIterations	lib/algorithms/iterative/ConjugateGradient.h	/^  Integer MaxIterations;$/;"	m	class:Grid::ConjugateGradient
MaxIterations	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^    Integer MaxIterations;$/;"	m	class:Grid::ConjugateGradientMultiShift
MaxIterations	lib/algorithms/iterative/ConjugateResidual.h	/^    Integer MaxIterations;$/;"	m	class:Grid::ConjugateResidual
MaxIterations	lib/algorithms/iterative/PrecConjugateResidual.h	/^    Integer MaxIterations;$/;"	m	class:Grid::PrecConjugateResidual
MaxIterations	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    Integer MaxIterations;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
MaxOuterIterations	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    Integer MaxOuterIterations;$/;"	m	class:Grid::MixedPrecisionConjugateGradient
MaxRows	lib/Eigen/src/Core/GeneralProduct.h	/^    MaxRows = traits<_Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon185
MaxRowsAtCompileTime	lib/Eigen/src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon630
MaxRowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
MaxRowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon388
MaxRowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon389
MaxRowsAtCompileTime	lib/Eigen/src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon213
MaxRowsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    MaxRowsAtCompileTime = traits<XprType>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon237
MaxRowsAtCompileTime	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon504
MaxRowsAtCompileTime	lib/Eigen/src/Core/CwiseTernaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon219
MaxRowsAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon129
MaxRowsAtCompileTime	lib/Eigen/src/Core/Diagonal.h	/^    MaxRowsAtCompileTime = int(MatrixType::MaxSizeAtCompileTime) == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon401
MaxRowsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon398
MaxRowsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon400
MaxRowsAtCompileTime	lib/Eigen/src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon172
MaxRowsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = PermTraits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::InverseImpl::__anon502
MaxRowsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon500
MaxRowsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon501
MaxRowsAtCompileTime	lib/Eigen/src/Core/Product.h	/^    MaxRowsAtCompileTime = LhsTraits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon126
MaxRowsAtCompileTime	lib/Eigen/src/Core/ProductEvaluators.h	/^    MaxRowsAtCompileTime = LhsNestedCleaned::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_evaluator::__anon176
MaxRowsAtCompileTime	lib/Eigen/src/Core/Redux.h	/^    MaxRowsAtCompileTime = XprType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
MaxRowsAtCompileTime	lib/Eigen/src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon225
MaxRowsAtCompileTime	lib/Eigen/src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
MaxRowsAtCompileTime	lib/Eigen/src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon128
MaxRowsAtCompileTime	lib/Eigen/src/Core/SolverBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon247
MaxRowsAtCompileTime	lib/Eigen/src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon391
MaxRowsAtCompileTime	lib/Eigen/src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon19
MaxRowsAtCompileTime	lib/Eigen/src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon156
MaxRowsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon581
MaxRowsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon583
MaxRowsAtCompileTime	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon576
MaxRowsAtCompileTime	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon577
MaxRowsAtCompileTime	lib/Eigen/src/Eigenvalues/RealQZ.h	/^        MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon582
MaxRowsAtCompileTime	lib/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon580
MaxRowsAtCompileTime	lib/Eigen/src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon607
MaxRowsAtCompileTime	lib/Eigen/src/Geometry/Transform.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon592
MaxRowsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon652
MaxRowsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon651
MaxRowsAtCompileTime	lib/Eigen/src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon678
MaxRowsAtCompileTime	lib/Eigen/src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon674
MaxRowsAtCompileTime	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon644
MaxRowsAtCompileTime	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon642
MaxRowsAtCompileTime	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon646
MaxRowsAtCompileTime	lib/Eigen/src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon647
MaxRowsAtCompileTime	lib/Eigen/src/SVD/BDCSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon622
MaxRowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon620
MaxRowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon616
MaxRowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon617
MaxRowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon618
MaxRowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon619
MaxRowsAtCompileTime	lib/Eigen/src/SVD/SVDBase.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon621
MaxRowsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon513
MaxRowsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon514
MaxRowsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
MaxRowsAtCompileTime	lib/Eigen/src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon539
MaxSize	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon585
MaxSize	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon579
MaxSizeAtCompileTime	lib/Eigen/src/Core/AssignEvaluator.h	/^    MaxSizeAtCompileTime = Dst::SizeAtCompileTime$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon139
MaxSizeAtCompileTime	lib/Eigen/src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
MaxSizeAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon129
MaxSizeAtCompileTime	lib/Eigen/src/Core/SolverBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon247
MaxSizeAtCompileTime	lib/Eigen/src/Core/TriangularMatrix.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon19
MaxSizeAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
MaxSizeMinusOne	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon585
MaxSizeMinusOne	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon579
MaxSmallDimAtCompileTime	lib/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon680
MaxSmallDimAtCompileTime	lib/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon679
MayInnerVectorize	lib/Eigen/src/Core/AssignEvaluator.h	/^    MayInnerVectorize  = MightVectorize$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
MayLinearVectorize	lib/Eigen/src/Core/AssignEvaluator.h	/^    MayLinearVectorize = bool(MightVectorize) && MayLinearize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
MayLinearVectorize	lib/Eigen/src/Core/Redux.h	/^    MayLinearVectorize = bool(MightVectorize) && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon116
MayLinearize	lib/Eigen/src/Core/AssignEvaluator.h	/^    MayLinearize = bool(StorageOrdersAgree) && (int(DstFlags) & int(SrcFlags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
MaySliceVectorize	lib/Eigen/src/Core/AssignEvaluator.h	/^    MaySliceVectorize  = bool(MightVectorize) && bool(DstHasDirectAccess)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
MaySliceVectorize	lib/Eigen/src/Core/Redux.h	/^    MaySliceVectorize  = bool(MightVectorize) && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon116
MayUnrollCompletely	lib/Eigen/src/Core/AssignEvaluator.h	/^    MayUnrollCompletely = int(Dst::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon144
MayUnrollInner	lib/Eigen/src/Core/AssignEvaluator.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon144
Mdag	lib/algorithms/CoarsenedMatrix.h	/^    RealD Mdag (const CoarseVector &in, CoarseVector &out){ $/;"	f	class:Grid::CoarsenedMatrix
Mdag	lib/qcd/action/fermion/CayleyFermion5D.cc	/^RealD CayleyFermion5D<Impl>::Mdag (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
Mdag	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    RealD  ContinuedFractionFermion5D<Impl>::Mdag        (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
Mdag	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^RealD ImprovedStaggeredFermion<Impl>::Mdag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
Mdag	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^RealD ImprovedStaggeredFermion5D<Impl>::Mdag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
Mdag	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    RealD  PartialFractionFermion5D<Impl>::Mdag (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Mdag	lib/qcd/action/fermion/WilsonFermion.cc	/^RealD WilsonFermion<Impl>::Mdag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
Mdag	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual RealD  Mdag (const FermionField &in, FermionField &out){assert(0); return 0.0;};$/;"	f	class:Grid::QCD::WilsonFermion5D
MdagM	lib/algorithms/SparseMatrix.h	/^      virtual void  MdagM(const Field &in, Field &out,RealD &ni,RealD &no) {$/;"	f	class:Grid::SparseMatrixBase
MdagMLinearOperator	lib/algorithms/LinearOperator.h	/^    MdagMLinearOperator(Matrix &Mat): _Mat(Mat){};$/;"	f	class:Grid::MdagMLinearOperator
MdagMLinearOperator	lib/algorithms/LinearOperator.h	/^    class MdagMLinearOperator : public LinearOperatorBase<Field> {$/;"	c	namespace:Grid
Mdiag	lib/algorithms/CoarsenedMatrix.h	/^    void Mdiag    (const CoarseVector &in,  CoarseVector &out){};$/;"	f	class:Grid::CoarsenedMatrix
Mdiag	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void  Mdiag  (const FermionField &in, FermionField &out) { Mooee(in,out);};   \/\/ Same as Mooee applied to both CB's$/;"	f	class:Grid::QCD::FermionOperator
Mdiag	lib/qcd/utils/CovariantLaplacian.h	/^  void Mdiag(const AVector& in, AVector& out) { assert(0); }$/;"	f	class:Grid::QCD::LaplacianAlgebraField
Mdiag	lib/qcd/utils/CovariantLaplacian.h	/^  void Mdiag(const GaugeField&, GaugeField&){ assert(0);}$/;"	f	class:Grid::QCD::LaplacianAdjointField
Mdir	lib/algorithms/CoarsenedMatrix.h	/^    void Mdir     (const CoarseVector &in,  CoarseVector &out,int dir, int disp){};$/;"	f	class:Grid::CoarsenedMatrix
Mdir	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void  CayleyFermion5D<Impl>::Mdir (const FermionField &psi, FermionField &chi,int dir,int disp){$/;"	f	class:Grid::QCD::CayleyFermion5D
Mdir	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void  ContinuedFractionFermion5D<Impl>::Mdir (const FermionField &psi, FermionField &chi,int dir,int disp){$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
Mdir	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::Mdir(const FermionField &in, FermionField &out, int dir, int disp) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
Mdir	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::Mdir(const FermionField &in, FermionField &out, int dir, int disp) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
Mdir	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void  PartialFractionFermion5D<Impl>::Mdir (const FermionField &psi, FermionField &chi,int dir,int disp){$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Mdir	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::Mdir(const FermionField &in, FermionField &out, int dir, int disp) {$/;"	f	class:Grid::QCD::WilsonFermion
Mdir	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual void   Mdir   (const FermionField &in, FermionField &out,int dir,int disp){assert(0);};   \/\/ case by case Wilson, Clover, Cayley, ContFrac, PartFrac$/;"	f	class:Grid::QCD::WilsonFermion5D
Mdir	lib/qcd/utils/CovariantLaplacian.h	/^  void Mdir(const AVector& in, AVector& out, int dir, int disp) { assert(0); }$/;"	f	class:Grid::QCD::LaplacianAlgebraField
Mdir	lib/qcd/utils/CovariantLaplacian.h	/^  void Mdir(const GaugeField&, GaugeField&, int, int){ assert(0);}$/;"	f	class:Grid::QCD::LaplacianAdjointField
MeanReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_mean>::Type MeanReturnType;$/;"	t	class:Eigen::VectorwiseOp
MeeDeriv	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void MeeDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag){mat=zero;};$/;"	f	class:Grid::QCD::FermionOperator
MemType	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	t	namespace:Eigen::internal	typeref:enum:Eigen::internal::__anon662
Meo5D	lib/qcd/action/fermion/CayleyFermion5D.cc	/^template<class Impl> void CayleyFermion5D<Impl>::Meo5D     (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MeoDeriv	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::MeoDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::CayleyFermion5D
MeoDeriv	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^  void ContinuedFractionFermion5D<Impl>::MeoDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
MeoDeriv	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void MeoDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag){DhopDerivEO(mat,U,V,dag);};$/;"	f	class:Grid::QCD::FermionOperator
MeoDeriv	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^   void PartialFractionFermion5D<Impl>::MeoDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Meooe	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::Meooe       (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
Meooe	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void   ContinuedFractionFermion5D<Impl>::Meooe       (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
Meooe	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::Meooe(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
Meooe	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::Meooe(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
Meooe	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void PartialFractionFermion5D<Impl>::Meooe       (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Meooe	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::Meooe(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
Meooe	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual void   Meooe       (const FermionField &in, FermionField &out){assert(0);};$/;"	f	class:Grid::QCD::WilsonFermion5D
Meooe5D	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::Meooe5D    (const FermionField &psi, FermionField &Din)$/;"	f	class:Grid::QCD::CayleyFermion5D
MeooeDag	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::MeooeDag    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MeooeDag	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void   ContinuedFractionFermion5D<Impl>::MeooeDag    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
MeooeDag	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::MeooeDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
MeooeDag	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::MeooeDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
MeooeDag	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void PartialFractionFermion5D<Impl>::MeooeDag    (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
MeooeDag	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::MeooeDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
MeooeDag	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual void   MeooeDag    (const FermionField &in, FermionField &out){assert(0);};$/;"	f	class:Grid::QCD::WilsonFermion5D
MeooeDag5D	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::MeooeDag5D    (const FermionField &psi, FermionField &Din)$/;"	f	class:Grid::QCD::CayleyFermion5D
Meooe_internal	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void   PartialFractionFermion5D<Impl>::Meooe_internal(const FermionField &psi, FermionField &chi,int dag)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Merge	lib/stencil/Stencil.h	/^  struct Merge {$/;"	s	class:Grid::CartesianStencil
Mergers	lib/stencil/Stencil.h	/^  std::vector<Merge> Mergers;$/;"	m	class:Grid::CartesianStencil
MergersSHM	lib/stencil/Stencil.h	/^  std::vector<Merge> MergersSHM;$/;"	m	class:Grid::CartesianStencil
MesonPar	extras/Hadrons/Modules/MContraction/Meson.hpp	/^class MesonPar: Serializable$/;"	c
MesonPar	lib/Hadrons/Modules/MContraction/Meson.hpp	/^class MesonPar: Serializable$/;"	c
MetisOrdering	lib/Eigen/src/MetisSupport/MetisSupport.h	/^class MetisOrdering$/;"	c	namespace:Eigen
Metric	lib/qcd/utils/Metric.h	/^class Metric{$/;"	c	namespace:Grid::QCD
Metropolis	tests/core/Test_GaugeAction.cc	/^  Metropolis(GridSerialRNG & _sRNG) : sRNG(_sRNG) {};$/;"	f	class:Metropolis
Metropolis	tests/core/Test_GaugeAction.cc	/^class Metropolis {$/;"	c	file:
Metropolis	tests/core/Test_RectPlaq.cc	/^  Metropolis(GridSerialRNG & _sRNG) : sRNG(_sRNG) {};$/;"	f	class:Metropolis
Metropolis	tests/core/Test_RectPlaq.cc	/^class Metropolis {$/;"	c	file:
MightEnableVml	lib/Eigen/src/Core/Assign_MKL.h	/^      MightEnableVml = StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess && Src::InnerStrideAtCompileTime==1 && Dst::InnerStrideAtCompileTime==1,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
MightLinearize	lib/Eigen/src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
MightVectorize	lib/Eigen/src/Core/AssignEvaluator.h	/^    MightVectorize = bool(StorageOrdersAgree)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
MightVectorize	lib/Eigen/src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon116
Min	lib/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
MinCoeffReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_minCoeff>::Type MinCoeffReturnType;$/;"	t	class:Eigen::VectorwiseOp
MinRowsAtCompileTime	lib/Eigen/src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon612
MinimumNorm2	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  MinimumNorm2(GridBase* grid, IntegratorParameters Par,$/;"	f	class:Grid::QCD::MinimumNorm2
MinimumNorm2	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^class MinimumNorm2 : public Integrator<FieldImplementation, SmearingPolicy,$/;"	c	namespace:Grid::QCD
Minv	lib/qcd/utils/CovariantLaplacian.h	/^  void Minv(const GaugeField& in, GaugeField& inverted){$/;"	f	class:Grid::QCD::LaplacianAdjointField
Minv	lib/qcd/utils/Metric.h	/^  virtual void Minv(const Field& in, Field& out){$/;"	f	class:Grid::QCD::TrivialMetric
MixedPrecisionConjugateGradient	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    MixedPrecisionConjugateGradient(RealD tol, Integer maxinnerit, Integer maxouterit, GridBase* _sp_grid, LinearOperatorBase<FieldF> &_Linop_f, LinearOperatorBase<FieldD> &_Linop_d) :$/;"	f	class:Grid::MixedPrecisionConjugateGradient
MixedPrecisionConjugateGradient	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^  class MixedPrecisionConjugateGradient : public LinearFunction<FieldD> {$/;"	c	namespace:Grid
MobiusFermion	lib/qcd/action/fermion/MobiusFermion.h	/^      MobiusFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::MobiusFermion
MobiusFermion	lib/qcd/action/fermion/MobiusFermion.h	/^    class MobiusFermion : public CayleyFermion5D<Impl>$/;"	c	namespace:Grid::QCD
MobiusFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<WilsonImplD> MobiusFermionD;$/;"	t	namespace:Grid::QCD
MobiusFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<WilsonImplDF> MobiusFermionDF;$/;"	t	namespace:Grid::QCD
MobiusFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<WilsonImplF> MobiusFermionF;$/;"	t	namespace:Grid::QCD
MobiusFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<WilsonImplFH> MobiusFermionFH;$/;"	t	namespace:Grid::QCD
MobiusFermionModule	lib/qcd/modules/FermionOperatorModules.h	/^class MobiusFermionModule: public FermionOperatorModule<MobiusFermion, FermionImpl, MobiusFermionParameters> {$/;"	c	namespace:Grid::QCD
MobiusFermionParameters	lib/qcd/modules/FermionOperatorModules.h	/^class MobiusFermionParameters : Serializable {$/;"	c	namespace:Grid::QCD
MobiusFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<WilsonImplR> MobiusFermionR;$/;"	t	namespace:Grid::QCD
MobiusFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<WilsonImplRL> MobiusFermionRL;$/;"	t	namespace:Grid::QCD
MobiusFermionVec5dD	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<DomainWallVec5dImplD> MobiusFermionVec5dD;$/;"	t	namespace:Grid::QCD
MobiusFermionVec5dDF	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<DomainWallVec5dImplDF> MobiusFermionVec5dDF;$/;"	t	namespace:Grid::QCD
MobiusFermionVec5dF	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<DomainWallVec5dImplF> MobiusFermionVec5dF;$/;"	t	namespace:Grid::QCD
MobiusFermionVec5dFH	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<DomainWallVec5dImplFH> MobiusFermionVec5dFH;$/;"	t	namespace:Grid::QCD
MobiusFermionVec5dR	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<DomainWallVec5dImplR> MobiusFermionVec5dR;$/;"	t	namespace:Grid::QCD
MobiusFermionVec5dRL	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusFermion<DomainWallVec5dImplRL> MobiusFermionVec5dRL;$/;"	t	namespace:Grid::QCD
MobiusHMCParameters	tests/hmc/Test_hmc_EOMobiusRatio.cc	/^  MobiusHMCParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::MobiusHMCParameters
MobiusHMCParameters	tests/hmc/Test_hmc_EOMobiusRatio.cc	/^  struct MobiusHMCParameters: Serializable {$/;"	s	namespace:Grid	file:
MobiusHMCParameters	tests/hmc/Test_hmc_EOMobiusRatioManyFlavour.cc	/^  MobiusHMCParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::MobiusHMCParameters
MobiusHMCParameters	tests/hmc/Test_hmc_EOMobiusRatioManyFlavour.cc	/^  struct MobiusHMCParameters: Serializable {$/;"	s	namespace:Grid	file:
MobiusVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef MobiusFermion<DomainWallVec5dImplR>                          MobiusVecFermionR;$/;"	t	file:
MobiusZolotarevFermion	lib/qcd/action/fermion/MobiusZolotarevFermion.h	/^       MobiusZolotarevFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::MobiusZolotarevFermion
MobiusZolotarevFermion	lib/qcd/action/fermion/MobiusZolotarevFermion.h	/^    class MobiusZolotarevFermion : public CayleyFermion5D<Impl>$/;"	c	namespace:Grid::QCD
MobiusZolotarevFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusZolotarevFermion<WilsonImplD> MobiusZolotarevFermionD;$/;"	t	namespace:Grid::QCD
MobiusZolotarevFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusZolotarevFermion<WilsonImplF> MobiusZolotarevFermionF;$/;"	t	namespace:Grid::QCD
MobiusZolotarevFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef MobiusZolotarevFermion<WilsonImplR> MobiusZolotarevFermionR;$/;"	t	namespace:Grid::QCD
MobiusZolotarevVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef MobiusZolotarevFermion<DomainWallVec5dImplR>                 MobiusZolotarevVecFermionR;$/;"	t	file:
ModIntFunctor	lib/simd/Grid_vector_unops.h	/^  ModIntFunctor(Integer _y) : y(_y){};$/;"	f	struct:Grid::ModIntFunctor
ModIntFunctor	lib/simd/Grid_vector_unops.h	/^struct ModIntFunctor {$/;"	s	namespace:Grid
ModPt	extras/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<ModuleBase>            ModPt;$/;"	t	class:Environment
ModPt	lib/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<ModuleBase>            ModPt;$/;"	t	class:Environment
Mode	lib/Eigen/src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode,$/;"	e	enum:Eigen::SelfAdjointView::__anon218
Mode	lib/Eigen/src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon217
Mode	lib/Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon21
Mode	lib/Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularViewImpl::__anon22
Mode	lib/Eigen/src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon19
Mode	lib/Eigen/src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon20
Mode	lib/Eigen/src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon591
Mode	lib/Eigen/src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon593
Mode	lib/Eigen/src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon595
Mode	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::SparseSelfAdjointView::__anon574
Module	extras/Hadrons/Module.hpp	/^    Module(const std::string name): ModuleBase(name) {};$/;"	f	class:Module
Module	extras/Hadrons/Module.hpp	/^Module<P>::Module(const std::string name)$/;"	f	class:Module
Module	extras/Hadrons/Module.hpp	/^class Module: public ModuleBase$/;"	c
Module	extras/Hadrons/Module.hpp	/^class Module<NoPar>: public ModuleBase$/;"	c
Module	lib/Hadrons/Module.hpp	/^    Module(const std::string name): ModuleBase(name) {};$/;"	f	class:Module
Module	lib/Hadrons/Module.hpp	/^Module<P>::Module(const std::string name)$/;"	f	class:Module
Module	lib/Hadrons/Module.hpp	/^class Module: public ModuleBase$/;"	c
Module	lib/Hadrons/Module.hpp	/^class Module<NoPar>: public ModuleBase$/;"	c
ModuleBase	extras/Hadrons/Module.cc	/^ModuleBase::ModuleBase(const std::string name)$/;"	f	class:ModuleBase
ModuleBase	extras/Hadrons/Module.hpp	/^class ModuleBase$/;"	c
ModuleBase	lib/Hadrons/Module.cc	/^ModuleBase::ModuleBase(const std::string name)$/;"	f	class:ModuleBase
ModuleBase	lib/Hadrons/Module.hpp	/^class ModuleBase$/;"	c
ModuleFactory	extras/Hadrons/ModuleFactory.hpp	/^class ModuleFactory: public Factory<ModuleBase>$/;"	c
ModuleFactory	lib/Hadrons/ModuleFactory.hpp	/^class ModuleFactory: public Factory<ModuleBase>$/;"	c
ModuleInfo	extras/Hadrons/Environment.hpp	/^    struct ModuleInfo$/;"	s	class:Environment
ModuleInfo	lib/Hadrons/Environment.hpp	/^    struct ModuleInfo$/;"	s	class:Environment
MoeDeriv	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::MoeDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::CayleyFermion5D
MoeDeriv	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^   void ContinuedFractionFermion5D<Impl>::MoeDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
MoeDeriv	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void MoeDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag){DhopDerivOE(mat,U,V,dag);};$/;"	f	class:Grid::QCD::FermionOperator
MoeDeriv	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^   void PartialFractionFermion5D<Impl>::MoeDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Mom	lib/qcd/utils/Metric.h	/^  MomentaField Mom;$/;"	m	class:Grid::QCD::GeneralisedMomenta
MomentaAction	lib/qcd/utils/Metric.h	/^  RealD MomentaAction(){$/;"	f	class:Grid::QCD::GeneralisedMomenta
MomentaDistribution	lib/qcd/utils/Metric.h	/^  void MomentaDistribution(GridParallelRNG& pRNG){$/;"	f	class:Grid::QCD::GeneralisedMomenta
MomentaField	lib/qcd/hmc/integrators/Integrator.h	/^  typedef typename FieldImplementation::Field MomentaField;  \/\/for readability$/;"	t	class:Grid::QCD::Integrator
MomentaField	lib/qcd/utils/Metric.h	/^  typedef typename Implementation::Field MomentaField;  \/\/for readability$/;"	t	class:Grid::QCD::GeneralisedMomenta
MomentaLinkField	lib/qcd/utils/Metric.h	/^  typedef typename Implementation::GaugeLinkField MomentaLinkField;  \/\/for readability$/;"	t	class:Grid::QCD::GeneralisedMomenta
MomentumSpacePropagator	lib/qcd/action/fermion/DomainWallFermion.h	/^      void  MomentumSpacePropagator(FermionField &out,const FermionField &in,RealD _m) { $/;"	f	class:Grid::QCD::DomainWallFermion
MomentumSpacePropagator	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void  MomentumSpacePropagator(FermionField &out,const FermionField &in,RealD _m) { assert(0);};$/;"	f	class:Grid::QCD::FermionOperator
MomentumSpacePropagator	lib/qcd/action/fermion/OverlapWilsonCayleyTanhFermion.h	/^     void  MomentumSpacePropagator(FermionField &out,const FermionField &in,RealD _m) { $/;"	f	class:Grid::QCD::OverlapWilsonCayleyTanhFermion
MomentumSpacePropagator	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::MomentumSpacePropagator(FermionField &out, const FermionField &in,RealD _m) $/;"	f	class:Grid::QCD::WilsonFermion
MomentumSpacePropagator	lib/qcd/action/gauge/Photon.h	/^  void Photon<Gimpl>::MomentumSpacePropagator(const GaugeField &in,$/;"	f	class:Grid::QCD::Photon
MomentumSpacePropagator	lib/qcd/action/scalar/ScalarImpl.h	/^    static void MomentumSpacePropagator(Field &out, RealD m)$/;"	f	class:Grid::ScalarImplTypes
MomentumSpacePropagatorHt	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::MomentumSpacePropagatorHt(FermionField &out,const FermionField &in, RealD mass) $/;"	f	class:Grid::QCD::WilsonFermion5D
MomentumSpacePropagatorHw	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::MomentumSpacePropagatorHw(FermionField &out,const FermionField &in,RealD mass) $/;"	f	class:Grid::QCD::WilsonFermion5D
MooDeriv	lib/qcd/action/fermion/FermionOperator.h	/^      virtual void MooDeriv(GaugeField &mat,const FermionField &U,const FermionField &V,int dag){mat=zero;}; \/\/ Clover can override these$/;"	f	class:Grid::QCD::FermionOperator
Mooee	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::Mooee       (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
Mooee	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void   ContinuedFractionFermion5D<Impl>::Mooee       (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
Mooee	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::Mooee(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
Mooee	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::Mooee(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
Mooee	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void PartialFractionFermion5D<Impl>::Mooee       (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Mooee	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::Mooee(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
Mooee	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual void   Mooee       (const FermionField &in, FermionField &out){assert(0);};$/;"	f	class:Grid::QCD::WilsonFermion5D
Mooee	lib/qcd/action/fermion/WilsonTMFermion.cc	/^  void WilsonTMFermion<Impl>::Mooee(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonTMFermion
MooeeDag	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::MooeeDag    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeDag	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void   ContinuedFractionFermion5D<Impl>::MooeeDag    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
MooeeDag	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::MooeeDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
MooeeDag	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::MooeeDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
MooeeDag	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void PartialFractionFermion5D<Impl>::MooeeDag    (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
MooeeDag	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::MooeeDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
MooeeDag	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual void   MooeeDag    (const FermionField &in, FermionField &out){assert(0);};$/;"	f	class:Grid::QCD::WilsonFermion5D
MooeeDag	lib/qcd/action/fermion/WilsonTMFermion.cc	/^  void WilsonTMFermion<Impl>::MooeeDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonTMFermion
MooeeInternal	lib/qcd/action/fermion/CayleyFermion5Ddense.cc	/^void CayleyFermion5D<Impl>::MooeeInternal(const FermionField &psi, FermionField &chi,int dag, int inv)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInternal	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^void CayleyFermion5D<Impl>::MooeeInternal(const FermionField &psi, FermionField &chi,int dag, int inv)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInternalAsm	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^void CayleyFermion5D<Impl>::MooeeInternalAsm(const FermionField &psi, FermionField &chi,$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInternalCompute	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::MooeeInternalCompute(int dag, int inv,$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInternalZAsm	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^void CayleyFermion5D<Impl>::MooeeInternalZAsm(const FermionField &psi, FermionField &chi,$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInv	lib/qcd/action/fermion/CayleyFermion5Dcache.cc	/^void CayleyFermion5D<Impl>::MooeeInv    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInv	lib/qcd/action/fermion/CayleyFermion5Ddense.cc	/^void CayleyFermion5D<Impl>::MooeeInv(const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInv	lib/qcd/action/fermion/CayleyFermion5Dssp.cc	/^void CayleyFermion5D<Impl>::MooeeInv    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInv	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^void CayleyFermion5D<Impl>::MooeeInv(const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInv	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void   ContinuedFractionFermion5D<Impl>::MooeeInv    (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
MooeeInv	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::MooeeInv(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
MooeeInv	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::MooeeInv(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
MooeeInv	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void PartialFractionFermion5D<Impl>::MooeeInv    (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
MooeeInv	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::MooeeInv(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
MooeeInv	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual void   MooeeInv    (const FermionField &in, FermionField &out){assert(0);};$/;"	f	class:Grid::QCD::WilsonFermion5D
MooeeInv	lib/qcd/action/fermion/WilsonTMFermion.cc	/^  void WilsonTMFermion<Impl>::MooeeInv(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonTMFermion
MooeeInvCalls	lib/qcd/action/fermion/CayleyFermion5D.h	/^     double MooeeInvCalls;$/;"	m	class:Grid::QCD::CayleyFermion5D
MooeeInvDag	lib/qcd/action/fermion/CayleyFermion5Dcache.cc	/^void CayleyFermion5D<Impl>::MooeeInvDag (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInvDag	lib/qcd/action/fermion/CayleyFermion5Ddense.cc	/^void CayleyFermion5D<Impl>::MooeeInvDag (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInvDag	lib/qcd/action/fermion/CayleyFermion5Dssp.cc	/^void CayleyFermion5D<Impl>::MooeeInvDag (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInvDag	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^void CayleyFermion5D<Impl>::MooeeInvDag (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::CayleyFermion5D
MooeeInvDag	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void   ContinuedFractionFermion5D<Impl>::MooeeInvDag (const FermionField &psi, FermionField &chi)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
MooeeInvDag	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^void ImprovedStaggeredFermion<Impl>::MooeeInvDag(const FermionField &in,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
MooeeInvDag	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^void ImprovedStaggeredFermion5D<Impl>::MooeeInvDag(const FermionField &in,$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
MooeeInvDag	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void PartialFractionFermion5D<Impl>::MooeeInvDag (const FermionField &in, FermionField &out)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
MooeeInvDag	lib/qcd/action/fermion/WilsonFermion.cc	/^void WilsonFermion<Impl>::MooeeInvDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonFermion
MooeeInvDag	lib/qcd/action/fermion/WilsonFermion5D.h	/^      virtual void   MooeeInvDag (const FermionField &in, FermionField &out){assert(0);};$/;"	f	class:Grid::QCD::WilsonFermion5D
MooeeInvDag	lib/qcd/action/fermion/WilsonTMFermion.cc	/^  void WilsonTMFermion<Impl>::MooeeInvDag(const FermionField &in, FermionField &out) {$/;"	f	class:Grid::QCD::WilsonTMFermion
MooeeInvFlops	lib/qcd/action/fermion/CayleyFermion5D.h	/^     double MooeeInvFlops;$/;"	m	class:Grid::QCD::CayleyFermion5D
MooeeInvTime	lib/qcd/action/fermion/CayleyFermion5D.h	/^     double MooeeInvTime;$/;"	m	class:Grid::QCD::CayleyFermion5D
MooeeInv_internal	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void   PartialFractionFermion5D<Impl>::MooeeInv_internal(const FermionField &psi, FermionField &chi,int dag)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
Mooee_internal	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void   PartialFractionFermion5D<Impl>::Mooee_internal(const FermionField &psi, FermionField &chi,int dag)$/;"	f	class:Grid::QCD::PartialFractionFermion5D
MortonOrder	lib/qcd/action/fermion/WilsonFermion.h	/^  static int MortonOrder;$/;"	m	class:Grid::QCD::WilsonFermionStatic
MoveOuter	lib/Eigen/src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permutation_matrix_product::__anon556
Mpc	lib/algorithms/LinearOperator.h	/^      virtual  RealD Mpc      (const Field &in, Field &out) {$/;"	f	class:Grid::SchurDiagMooeeOperator
Mpc	lib/algorithms/LinearOperator.h	/^      virtual  RealD Mpc      (const Field &in, Field &out) {$/;"	f	class:Grid::SchurDiagOneOperator
Mpc	lib/algorithms/LinearOperator.h	/^      virtual  RealD Mpc      (const Field &in, Field &out) {$/;"	f	class:Grid::SchurDiagTwoOperator
Mpc	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    virtual  RealD Mpc      (const Field &in, Field &out) {$/;"	f	class:Grid::SchurDiagTwoKappaOperator
MpcDag	lib/algorithms/LinearOperator.h	/^      virtual  RealD MpcDag   (const Field &in, Field &out){$/;"	f	class:Grid::SchurDiagMooeeOperator
MpcDag	lib/algorithms/LinearOperator.h	/^      virtual  RealD MpcDag   (const Field &in, Field &out){$/;"	f	class:Grid::SchurDiagOneOperator
MpcDag	lib/algorithms/LinearOperator.h	/^      virtual  RealD MpcDag   (const Field &in, Field &out){$/;"	f	class:Grid::SchurDiagTwoOperator
MpcDag	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    virtual  RealD MpcDag   (const Field &in, Field &out){$/;"	f	class:Grid::SchurDiagTwoKappaOperator
MpcDagDeriv	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	/^        void MpcDagDeriv(GaugeField &Force,const FermionField &U,const FermionField &V) {$/;"	f	class:Grid::QCD::SchurDifferentiableOperator
MpcDagMpc	lib/algorithms/LinearOperator.h	/^      virtual void MpcDagMpc(const Field &in, Field &out,RealD &ni,RealD &no) {$/;"	f	class:Grid::SchurOperatorBase
MpcDeriv	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	/^        void MpcDeriv(GaugeField &Force,const FermionField &U,const FermionField &V) {$/;"	f	class:Grid::QCD::SchurDifferentiableOperator
Mref	lib/qcd/utils/CovariantLaplacian.h	/^  void Mref(const GaugeField& in, GaugeField& out) {$/;"	f	class:Grid::QCD::LaplacianAdjointField
MulCost	lib/Eigen/src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon136
Mult	lib/simd/Grid_avx.h	/^  struct Mult{$/;"	s	namespace:Grid::Optimization
Mult	lib/simd/Grid_avx512.h	/^  struct Mult{$/;"	s	namespace:Grid::Optimization
Mult	lib/simd/Grid_generic.h	/^  struct Mult{$/;"	s	namespace:Grid::Optimization
Mult	lib/simd/Grid_imci.h	/^  struct Mult{$/;"	s	namespace:Grid::Optimization
Mult	lib/simd/Grid_neon.h	/^  struct Mult{$/;"	s	namespace:Grid::Optimization
Mult	lib/simd/Grid_qpx.h	/^  struct Mult{$/;"	s	namespace:Grid::Optimization
Mult	lib/simd/Grid_sse4.h	/^  struct Mult{$/;"	s	namespace:Grid::Optimization
MultComplex	lib/simd/Grid_avx.h	/^  struct MultComplex{$/;"	s	namespace:Grid::Optimization
MultComplex	lib/simd/Grid_avx512.h	/^  struct MultComplex{$/;"	s	namespace:Grid::Optimization
MultComplex	lib/simd/Grid_generic.h	/^  struct MultComplex{$/;"	s	namespace:Grid::Optimization
MultComplex	lib/simd/Grid_imci.h	/^  struct MultComplex{$/;"	s	namespace:Grid::Optimization
MultComplex	lib/simd/Grid_neon.h	/^  struct MultComplex{$/;"	s	namespace:Grid::Optimization
MultComplex	lib/simd/Grid_qpx.h	/^  struct MultComplex{$/;"	s	namespace:Grid::Optimization
MultComplex	lib/simd/Grid_sse4.h	/^  struct MultComplex{$/;"	s	namespace:Grid::Optimization
MultComplexSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::MultComplex  MultComplexSIMD;$/;"	t	namespace:Grid
MultComplexSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::MultComplex MultComplexSIMD;$/;"	t	namespace:Grid
MultComplexSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::MultComplex MultComplexSIMD;$/;"	t	namespace:Grid
MultComplexSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::MultComplex MultComplexSIMD;$/;"	t	namespace:Grid
MultComplexSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::MultComplex MultComplexSIMD;$/;"	t	namespace:Grid
MultComplexSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::MultComplex MultComplexSIMD;$/;"	t	namespace:Grid
MultComplexSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::MultComplex MultComplexSIMD;$/;"	t	namespace:Grid
MultRealPart	lib/simd/Grid_avx.h	/^  struct MultRealPart{$/;"	s	namespace:Grid::Optimization
MultRealPart	lib/simd/Grid_avx512.h	/^  struct MultRealPart{$/;"	s	namespace:Grid::Optimization
MultRealPart	lib/simd/Grid_generic.h	/^  struct MultRealPart{$/;"	s	namespace:Grid::Optimization
MultRealPart	lib/simd/Grid_neon.h	/^  struct MultRealPart{$/;"	s	namespace:Grid::Optimization
MultRealPart	lib/simd/Grid_qpx.h	/^  struct MultRealPart{$/;"	s	namespace:Grid::Optimization
MultRealPart	lib/simd/Grid_sse4.h	/^  struct MultRealPart{$/;"	s	namespace:Grid::Optimization
MultRealPartSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::MultRealPart MultRealPartSIMD;$/;"	t	namespace:Grid
MultRealPartSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::MultRealPart MultRealPartSIMD;$/;"	t	namespace:Grid
MultRealPartSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::MultRealPart MultRealPartSIMD;$/;"	t	namespace:Grid
MultRealPartSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::MultRealPart MultRealPartSIMD;$/;"	t	namespace:Grid
MultRealPartSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::MultRealPart MultRealPartSIMD;$/;"	t	namespace:Grid
MultRealPartSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::MultRealPart MultRealPartSIMD;$/;"	t	namespace:Grid
MultSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Mult        MultSIMD;$/;"	t	namespace:Grid
MultSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Mult        MultSIMD;$/;"	t	namespace:Grid
MultSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Mult        MultSIMD;$/;"	t	namespace:Grid
MultSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Mult        MultSIMD;$/;"	t	namespace:Grid
MultSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Mult        MultSIMD;$/;"	t	namespace:Grid
MultSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Mult        MultSIMD;$/;"	t	namespace:Grid
MultSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Mult        MultSIMD;$/;"	t	namespace:Grid
MultiGridPreconditioner	tests/solver/Test_dwf_hdcr.cc	/^  MultiGridPreconditioner(Aggregates &Agg, CoarseOperator &Coarse, $/;"	f	class:MultiGridPreconditioner
MultiGridPreconditioner	tests/solver/Test_dwf_hdcr.cc	/^class MultiGridPreconditioner : public LinearFunction< Lattice<Fobj> > {$/;"	c	file:
MultiShiftFunction	lib/algorithms/approx/MultiShiftFunction.h	/^  MultiShiftFunction(AlgRemez & remez,double tol,bool inverse)$/;"	f	class:Grid::MultiShiftFunction
MultiShiftFunction	lib/algorithms/approx/MultiShiftFunction.h	/^  MultiShiftFunction(int n,RealD _lo,RealD _hi): poles(n), residues(n), lo(_lo), hi(_hi) {;};$/;"	f	class:Grid::MultiShiftFunction
MultiShiftFunction	lib/algorithms/approx/MultiShiftFunction.h	/^  MultiShiftFunction(void){};$/;"	f	class:Grid::MultiShiftFunction
MultiShiftFunction	lib/algorithms/approx/MultiShiftFunction.h	/^class MultiShiftFunction {$/;"	c	namespace:Grid
MyGroup	lib/communicator/Communicator_base.h	/^  static std::vector<int> MyGroup;$/;"	m	class:Grid::CartesianCommunicator
MyGroup	lib/communicator/Communicator_mpi3.cc	/^std::vector<int> CartesianCommunicator::MyGroup;$/;"	m	class:Grid::CartesianCommunicator	file:
NCMatrix	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> NCMatrix;$/;"	t	class:Eigen::SparseLU
NCONFIGS	extras/qed-fvol/qed-fvol.cc	/^const int NCONFIGS = 10;$/;"	v
NColsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
NEDC	lib/perfmon/Stat.h	15;"	d
NEON	lib/Eigen/src/Core/util/Constants.h	/^    NEON = 0x4,$/;"	e	enum:Eigen::Architecture::Type
NERSC_CHECKPOINTER	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	30;"	d
NLOHMANN_JSON_HPP	lib/json/json.hpp	30;"	d
NLOOP	benchmarks/Benchmark_memory_bandwidth.cc	59;"	d	file:
NMC	lib/perfmon/Stat.h	14;"	d
NRowsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
NUMERIC_TYPE_MUST_BE_REAL	lib/Eigen/src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
NWILSON	extras/qed-fvol/qed-fvol.cc	/^const int NWILSON = 10;$/;"	v
NaturalOrdering	lib/Eigen/src/OrderingMethods/Ordering.h	/^class NaturalOrdering$/;"	c	namespace:Eigen
Nblock	lib/algorithms/iterative/BlockConjugateGradient.h	/^  int Nblock;$/;"	m	class:Grid::BlockConjugateGradient
Nc	lib/qcd/LatticeTheories.h	/^  static const int Nc = Colours;$/;"	m	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
Nc	lib/qcd/LatticeTheories.h	/^  static const int Nc = Colours;$/;"	m	struct:Grid::LatticeTheories::LatticeGaugeTheory
Nc	lib/qcd/QCD.h	/^    static const int Nc=3;$/;"	m	namespace:Grid::QCD
Ncache	lib/allocator/AlignedAllocator.h	/^    static const int Ncache=8;$/;"	m	class:Grid::PointerCache
Nd	lib/algorithms/FFT.h	/^    int Nd;$/;"	m	class:Grid::FFT
Nd	lib/cartesian/Cartesian_base.h	/^    inline int Nd    (void) const { return _ndimension;};$/;"	f	class:Grid::GridBase
Nd	lib/qcd/LatticeTheories.h	/^  static const int Nd = Dimensions;$/;"	m	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
Nd	lib/qcd/LatticeTheories.h	/^  static const int Nd = Dimensions;$/;"	m	struct:Grid::LatticeTheories::LatticeGaugeTheory
Nd	lib/qcd/LatticeTheories.h	/^  static const int Nd = Dimensions;$/;"	m	struct:Grid::LatticeTheories::LatticeTheory
Nd	lib/qcd/QCD.h	/^    static const int Nd=4;$/;"	m	namespace:Grid::QCD
Nds	lib/qcd/LatticeTheories.h	/^  static const int Nds = Dimensions * 2;  \/\/ double stored field$/;"	m	struct:Grid::LatticeTheories::LatticeTheory
Nds	lib/qcd/LatticeTheories.h	/^  static const int Nds = Dimensions * 2;$/;"	m	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
Nds	lib/qcd/LatticeTheories.h	/^  static const int Nds = Dimensions * 2;$/;"	m	struct:Grid::LatticeTheories::LatticeGaugeTheory
Nds	lib/qcd/QCD.h	/^    static const int Nds=8; \/\/ double stored gauge field$/;"	m	namespace:Grid::QCD
NeedToConjugate	lib/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon26
NeedToConjugate	lib/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon25
NeedsAlignment	lib/Eigen/src/Geometry/Quaternion.h	/^  enum { NeedsAlignment = internal::traits<Quaternion>::Alignment>0 };$/;"	e	enum:Eigen::Quaternion::__anon603
NeedsToAlign	lib/Eigen/src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = (SizeAtCompileTime != Dynamic) && (internal::traits<Derived>::Alignment>0) };$/;"	e	enum:Eigen::PlainObjectBase::__anon396
NegativeReturnType	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_opposite_op<Scalar>, const Derived> NegativeReturnType;$/;"	t
NegativeSemiDef	lib/Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
NerscCPModule	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^class NerscCPModule: public CheckPointerModule< ImplementationPolicy> {$/;"	c	namespace:Grid::QCD
NerscChecksum	lib/parallelIO/BinaryIO.h	/^  template<class fobj> static inline void NerscChecksum(GridBase *grid,std::vector<fobj> &fbuf,uint32_t &nersc_csum)$/;"	f	class:Grid::BinaryIO
NerscHmcCheckpointer	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^  NerscHmcCheckpointer(const CheckpointerParameters &Params_) { initialize(Params_); }$/;"	f	class:Grid::QCD::NerscHmcCheckpointer
NerscHmcCheckpointer	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^class NerscHmcCheckpointer : public BaseHmcCheckpointer<Gimpl> {$/;"	c	namespace:Grid::QCD
NerscIO	lib/parallelIO/NerscIO.h	/^    class NerscIO : public BinaryIO { $/;"	c	namespace:Grid::QCD
NestByRefBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
NestByValue	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC explicit inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue
NestByValue	lib/Eigen/src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen
NestLevel	gcc-bug-report/broken.cc	/^  enum { NestLevel = 0 };$/;"	e	enum:TypeMapper::__anon2	file:
NestLevel	gcc-bug-report/broken.cc	/^  enum { NestLevel = T::NestLevel };$/;"	e	enum:TypeMapper::__anon1	file:
NestLevel	gcc-bug-report/broken.cc	/^  enum { NestLevel = TypeMapper<obj>::NestLevel + 1};$/;"	e	enum:Recursive::__anon3	file:
Nested	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper
Nested	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix
Nested	lib/Eigen/src/Core/Inverse.h	/^  typedef typename internal::ref_selector<Inverse>::type Nested;$/;"	t	class:Eigen::Inverse
Nested	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef const PermutationMatrix& Nested;$/;"	t	class:Eigen::PermutationMatrix
Nested	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef Derived const& Nested;$/;"	t	class:Eigen::TriangularBase
Nested	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::ref_selector<SolveWithGuess>::type Nested;$/;"	t	class:Eigen::SolveWithGuess
NestedExpression	lib/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::remove_all<ExpressionType>::type NestedExpression;$/;"	t	class:Eigen::ArrayWrapper
NestedExpression	lib/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::remove_all<ExpressionType>::type NestedExpression;$/;"	t	class:Eigen::MatrixWrapper
NestedExpression	lib/Eigen/src/Core/Block.h	/^    typedef typename internal::remove_all<XprType>::type NestedExpression;$/;"	t	class:Eigen::Block
NestedExpression	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::remove_all<XprType>::type NestedExpression;$/;"	t	class:Eigen::CwiseUnaryOp
NestedExpression	lib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::CwiseUnaryView
NestedExpression	lib/Eigen/src/Core/Inverse.h	/^  typedef typename internal::remove_all<XprType>::type NestedExpression;$/;"	t	class:Eigen::Inverse
NestedExpression	lib/Eigen/src/Core/Replicate.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::Replicate
NestedExpression	lib/Eigen/src/Core/Reverse.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::Reverse
NestedExpression	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef MatrixTypeNestedCleaned NestedExpression;$/;"	t	class:Eigen::SelfAdjointView
NestedExpression	lib/Eigen/src/Core/Transpose.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::Transpose
NestedExpression	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned NestedExpression;$/;"	t	class:Eigen::TriangularView
NestedExpression	lib/Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixType NestedExpression;$/;"	t	class:Eigen::Homogeneous
NestedExpression	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type NestedExpression;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
NestedExpression	lib/Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::SparseView
NestedExpressionType	lib/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::ref_selector<ExpressionType>::non_const_type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper
NestedExpressionType	lib/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::ref_selector<ExpressionType>::non_const_type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper
NewInf	lib/Eigen/src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
NewSup	lib/Eigen/src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
NewWilsonLoops	extras/qed-fvol/WilsonLoops.h	/^template <class Gimpl> class NewWilsonLoops : public Gimpl {$/;"	c
Ngp	lib/qcd/QCD.h	/^    static const int Ngp=2; \/\/ gparity index range$/;"	m	namespace:Grid::QCD
Nhcs	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Nhcs = 1;$/;"	m	struct:Grid::QCD::CoeffComplexHalfComms
Nhcs	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Nhcs = 1;$/;"	m	struct:Grid::QCD::CoeffRealHalfComms
Nhcs	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Nhcs = 2;$/;"	m	struct:Grid::QCD::CoeffComplex
Nhcs	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Nhcs = 2;$/;"	m	struct:Grid::QCD::CoeffReal
Nhcs	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    static const int Nhcs = Options::Nhcs;$/;"	m	class:Grid::QCD::WilsonImpl
Nhcs	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  static const int Nhcs = Options::Nhcs;$/;"	m	class:Grid::QCD::DomainWallVec5dImpl
Nhcs	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ static const int Nhcs = Options::Nhcs;$/;"	m	class:Grid::QCD::GparityWilsonImpl
Nhs	lib/qcd/LatticeTheories.h	/^  static const int Nhs = Spin \/ 2;$/;"	m	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
Nhs	lib/qcd/QCD.h	/^    static const int Nhs=2; \/\/ half spinor$/;"	m	namespace:Grid::QCD
Nk	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  int Nk;        \/\/ Number of converged sought$/;"	m	class:Grid::ImplicitlyRestartedLanczos
Nm	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  int Nm;        \/\/ Nm -- total number of vectors$/;"	m	class:Grid::ImplicitlyRestartedLanczos
NoAlias	lib/Eigen/src/Core/NoAlias.h	/^    explicit NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias
NoAlias	lib/Eigen/src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
NoBlocking	lib/stencil/Lebesgue.cc	/^void LebesgueOrder::NoBlocking(void) $/;"	f	class:Grid::LebesgueOrder
NoChange	lib/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
NoChange_t	lib/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
NoConvergence	lib/Eigen/src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
NoPar	extras/Hadrons/Module.hpp	/^class NoPar {};$/;"	c
NoPar	lib/Hadrons/Module.hpp	/^class NoPar {};$/;"	c
NoParameters	lib/qcd/modules/Modules.h	/^class NoParameters{};$/;"	c	namespace:Grid
NoPivoting	lib/Eigen/src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
NoPreferredStorageOrderBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int NoPreferredStorageOrderBit = 0x200;$/;"	m	namespace:Eigen
NoQRPreconditioner	lib/Eigen/src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
NoSmearing	lib/qcd/smearing/GaugeConfiguration.h	/^  NoSmearing(): ThinField(NULL) {}$/;"	f	class:Grid::QCD::NoSmearing
NoSmearing	lib/qcd/smearing/GaugeConfiguration.h	/^class NoSmearing {$/;"	c	namespace:Grid::QCD
NoUnrolling	lib/Eigen/src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::UnrollingType
NodeCount	lib/communicator/Communicator_base.cc	/^int                      CartesianCommunicator::NodeCount(void)    { return ProcessorCount();};$/;"	f	class:Grid::CartesianCommunicator
NodeCount	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::NodeCount(void)    { return GroupSize;};$/;"	f	class:Grid::CartesianCommunicator
NodeCount	lib/communicator/Communicator_mpi3_leader.cc	/^int CartesianCommunicator::NodeCount(void)    { return HorizontalSize;};$/;"	f	class:Grid::CartesianCommunicator
NoiseLoopPar	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^class NoiseLoopPar: Serializable$/;"	c
NoiseLoopPar	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^class NoiseLoopPar: Serializable$/;"	c
NonConstImagReturnType	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;$/;"	t
NonConstRealReturnType	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type NonConstRealReturnType;$/;"	t
NonInteger	lib/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger         NonInteger;$/;"	t	class:Eigen::AlignedBox
NormReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_norm,RealScalar>::Type NormReturnType;$/;"	t	class:Eigen::VectorwiseOp
NormalEquations	lib/algorithms/iterative/NormalEquations.h	/^  NormalEquations(SparseMatrixBase<Field> &Matrix, OperatorFunction<Field> &HermitianSolver) $/;"	f	class:Grid::NormalEquations
NormalEquations	lib/algorithms/iterative/NormalEquations.h	/^  template<class Field> class NormalEquations : public OperatorFunction<Field>{$/;"	c	namespace:Grid
NormalReturnType	lib/Eigen/src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane
Not	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> Not(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
NotFunctor	lib/simd/Grid_vector_unops.h	/^struct NotFunctor {$/;"	s	namespace:Grid
Ns	lib/qcd/LatticeTheories.h	/^  static const int Ns = Spin;$/;"	m	struct:Grid::LatticeTheories::FermionicLatticeGaugeTheory
Ns	lib/qcd/QCD.h	/^    static const int Ns=4;$/;"	m	namespace:Grid::QCD
Nsimd	lib/cartesian/Cartesian_base.h	/^    inline int Nsimd(void)  const { return _isites; };\/\/ Synonymous with iSites$/;"	f	class:Grid::GridBase
Nsimd	lib/simd/Grid_vector_types.h	/^  static inline constexpr int Nsimd(void) {$/;"	f	class:Grid::Grid_simd
Nstep	lib/qcd/smearing/WilsonFlow.h	/^    unsigned int Nstep;$/;"	m	class:Grid::QCD::WilsonFlow
Nstop	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  int Nstop;     \/\/ Number of evecs checked for convergence$/;"	m	class:Grid::ImplicitlyRestartedLanczos
NullaryExpr	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NumGenerators	lib/qcd/utils/SUnTwoIndex.h	/^  static const int NumGenerators = SU<ncolour>::AdjointDimension;$/;"	m	class:Grid::QCD::SU_TwoIndex
NumOp	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      FermionOperator<Impl> & NumOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
NumOp	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      FermionOperator<Impl> & NumOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
NumOp	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      FermionOperator<Impl> & NumOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
NumOp	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      FermionOperator<Impl> & NumOp;\/\/ the basic operator$/;"	m	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
NumTraits	lib/Eigen/src/Core/arch/CUDA/Half.h	/^template<> struct NumTraits<Eigen::half>$/;"	s	namespace:Eigen
NumTypes	lib/perfmon/PerfCount.h	/^  static int NumTypes(void){ $/;"	f	class:Grid::PerformanceCounter
NumberOfRegisters	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
NumberOfRegisters	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
NumberOfRegisters	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
NumericalIssue	lib/Eigen/src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
Nw	lib/qcd/action/fermion/WilsonCompressor.h	/^  constexpr static int Nw=sizeof(SiteHalfSpinor)\/sizeof(vComplexHigh);$/;"	m	class:Grid::QCD::WilsonCompressorTemplate
OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG	lib/Eigen/src/Core/util/StaticAssert.h	/^        OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
ONE	lib/algorithms/approx/Zolotarev.cc	46;"	d	file:
ONE	lib/algorithms/approx/Zolotarev.cc	525;"	d	file:
ONE	lib/algorithms/approx/Zolotarev.cc	526;"	d	file:
ONES_COMPLEMENT	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	101;"	d
OUT_OF_RANGE_ACCESS	lib/Eigen/src/Core/util/StaticAssert.h	/^        OUT_OF_RANGE_ACCESS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
OVERLAP_WILSON_CAYLEY_TANH_FERMION_H	lib/qcd/action/fermion/OverlapWilsonCayleyTanhFermion.h	30;"	d
OVERLAP_WILSON_CAYLEY_ZOLOTAREV_FERMION_H	lib/qcd/action/fermion/OverlapWilsonCayleyZolotarevFermion.h	30;"	d
OVERLAP_WILSON_CONTFRAC_TANH_FERMION_H	lib/qcd/action/fermion/OverlapWilsonContfracTanhFermion.h	30;"	d
OVERLAP_WILSON_CONTFRAC_ZOLOTAREV_FERMION_H	lib/qcd/action/fermion/OverlapWilsonContfracZolotarevFermion.h	30;"	d
OVERLAP_WILSON_PARTFRAC_TANH_FERMION_H	lib/qcd/action/fermion/OverlapWilsonPartialFractionTanhFermion.h	30;"	d
OVERLAP_WILSON_PARTFRAC_ZOLOTAREV_FERMION_H	lib/qcd/action/fermion/OverlapWilsonPartialFractionZolotarevFermion.h	30;"	d
ObjFunc	extras/Hadrons/GeneticScheduler.hpp	/^    typedef std::function<int(const Gene &)> ObjFunc;$/;"	t	class:GeneticScheduler
ObjFunc	lib/Hadrons/GeneticScheduler.hpp	/^    typedef std::function<int(const Gene &)> ObjFunc;$/;"	t	class:GeneticScheduler
ObjInfo	extras/Hadrons/Environment.hpp	/^    struct ObjInfo$/;"	s	class:Environment
ObjInfo	lib/Hadrons/Environment.hpp	/^    struct ObjInfo$/;"	s	class:Environment
Object	extras/Hadrons/Environment.hpp	/^class Object$/;"	c
Object	lib/Hadrons/Environment.hpp	/^class Object$/;"	c
ObjectId	extras/Hadrons/Application.cc	/^class ObjectId: Serializable$/;"	c	file:
ObjectId	lib/Hadrons/Application.cc	/^class ObjectId: Serializable$/;"	c	file:
ObsBase	lib/qcd/modules/ObservableModules.h	/^  typedef ObservableModule<PlaquetteLogger<Impl>, NoParameters> ObsBase;$/;"	t	class:Grid::QCD::PlaquetteMod
ObsBase	lib/qcd/modules/ObservableModules.h	/^  typedef ObservableModule<TopologicalCharge<Impl>, TopologyObsParameters> ObsBase;$/;"	t	class:Grid::QCD::TopologicalChargeMod
ObsBase	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^  typedef ObservableModule<MagMeas<Impl>, NoParameters> ObsBase;$/;"	t	class:MagMod	file:
ObsListType	lib/qcd/hmc/HMC.h	/^  typedef std::vector< HmcObservable<Field> * > ObsListType;$/;"	t	class:Grid::QCD::HybridMonteCarlo
ObservableBaseModule	lib/qcd/hmc/HMCResourceManager.h	/^  typedef HMCModuleBase< QCD::HmcObservable<typename ImplementationPolicy::Field> > ObservableBaseModule;$/;"	t	class:Grid::QCD::HMCResourceManager
ObservableModule	lib/qcd/modules/ObservableModules.h	/^  ObservableModule(OPar Par) : Parametrized<OPar>(Par) {}$/;"	f	class:Grid::ObservableModule
ObservableModule	lib/qcd/modules/ObservableModules.h	/^  ObservableModule(Reader<ReaderClass>& Reader) : Parametrized<OPar>(Reader){};$/;"	f	class:Grid::ObservableModule
ObservableModule	lib/qcd/modules/ObservableModules.h	/^class ObservableModule$/;"	c	namespace:Grid
ObservablePtr	lib/qcd/modules/ObservableModules.h	/^  std::unique_ptr<ObservableType> ObservablePtr;$/;"	m	class:Grid::ObservableModule
Observables	lib/qcd/hmc/HMC.h	/^	ObsListType Observables;$/;"	m	class:Grid::QCD::HybridMonteCarlo
ObservablesList	lib/qcd/hmc/HMCResourceManager.h	/^  std::vector<std::unique_ptr<ObservableBaseModule> > ObservablesList;$/;"	m	class:Grid::QCD::HMCResourceManager
Odd	lib/cartesian/Cartesian_red_black.h	/^  static const int Odd    =CbBlack;$/;"	m	namespace:Grid
OffsetCol	lib/Eigen/src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon166
OffsetRow	lib/Eigen/src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon166
OnTheLeft	lib/Eigen/src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::SideType
OnTheRight	lib/Eigen/src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::SideType
OneFlavourEOFModule	lib/qcd/modules/ActionModules.h	/^   OneFlavourEOFModule(Reader<ReaderClass>& R): Base(R) {$/;"	f	class:Grid::QCD::OneFlavourEOFModule
OneFlavourEOFModule	lib/qcd/modules/ActionModules.h	/^class OneFlavourEOFModule: $/;"	c	namespace:Grid::QCD
OneFlavourEvenOddRatioRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      OneFlavourEvenOddRatioRationalPseudoFermionAction(FermionOperator<Impl>  &_NumOp, $/;"	f	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
OneFlavourEvenOddRatioRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^    class OneFlavourEvenOddRatioRationalPseudoFermionAction : public Action<typename Impl::GaugeField> {$/;"	c	namespace:Grid::QCD
OneFlavourEvenOddRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  OneFlavourEvenOddRationalPseudoFermionAction(FermionOperator<Impl> &Op,$/;"	f	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
OneFlavourEvenOddRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^class OneFlavourEvenOddRationalPseudoFermionAction$/;"	c	namespace:Grid::QCD
OneFlavourFModule	lib/qcd/modules/ActionModules.h	/^   OneFlavourFModule(Reader<ReaderClass>& R): Base(R) {$/;"	f	class:Grid::QCD::OneFlavourFModule
OneFlavourFModule	lib/qcd/modules/ActionModules.h	/^class OneFlavourFModule: public PseudoFermionModuleBase<Impl, OneFlavourRationalPseudoFermionAction, OneFlavourRationalParams>{$/;"	c	namespace:Grid::QCD
OneFlavourRatioEOFModule	lib/qcd/modules/ActionModules.h	/^   OneFlavourRatioEOFModule(Reader<ReaderClass>& R): Base(R) {$/;"	f	class:Grid::QCD::OneFlavourRatioEOFModule
OneFlavourRatioEOFModule	lib/qcd/modules/ActionModules.h	/^class OneFlavourRatioEOFModule: $/;"	c	namespace:Grid::QCD
OneFlavourRatioFModule	lib/qcd/modules/ActionModules.h	/^   OneFlavourRatioFModule(Reader<ReaderClass>& R): Base(R) {$/;"	f	class:Grid::QCD::OneFlavourRatioFModule
OneFlavourRatioFModule	lib/qcd/modules/ActionModules.h	/^class OneFlavourRatioFModule: $/;"	c	namespace:Grid::QCD
OneFlavourRatioRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      OneFlavourRatioRationalPseudoFermionAction(FermionOperator<Impl>  &_NumOp, $/;"	f	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
OneFlavourRatioRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^    class OneFlavourRatioRationalPseudoFermionAction : public Action<typename Impl::GaugeField> {$/;"	c	namespace:Grid::QCD
OneFlavourRationalParams	lib/qcd/action/ActionParams.h	/^    OneFlavourRationalParams(	RealD _lo      = 0.0, $/;"	f	struct:Grid::QCD::OneFlavourRationalParams
OneFlavourRationalParams	lib/qcd/action/ActionParams.h	/^  struct OneFlavourRationalParams : Serializable {$/;"	s	namespace:Grid::QCD
OneFlavourRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      OneFlavourRationalPseudoFermionAction(FermionOperator<Impl>  &Op, $/;"	f	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
OneFlavourRationalPseudoFermionAction	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^    class OneFlavourRationalPseudoFermionAction : public Action<typename Impl::GaugeField> {$/;"	c	namespace:Grid::QCD
Ones	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase
Ones	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index newSize)$/;"	f	class:Eigen::DenseBase
Ones	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Op	lib/algorithms/LinearOperator.h	/^      void Op     (const Field &in, Field &out){$/;"	f	class:Grid::HermitianLinearOperator
Op	lib/algorithms/LinearOperator.h	/^      void Op     (const Field &in, Field &out){$/;"	f	class:Grid::MdagMLinearOperator
Op	lib/algorithms/LinearOperator.h	/^      void Op     (const Field &in, Field &out){$/;"	f	class:Grid::SchurOperatorBase
Op	lib/algorithms/LinearOperator.h	/^      void Op     (const Field &in, Field &out){$/;"	f	class:Grid::ShiftedMdagMLinearOperator
Op	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void Op     (const Field &in, Field &out){$/;"	f	class:Grid::QCD::Gamma5HermitianLinearOperator
Op	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void Op     (const Field &in, Field &out){$/;"	f	class:Grid::QCD::Gamma5R5HermitianLinearOperator
Op	tests/debug/Test_synthetic_lanczos.cc	/^  void Op     (const Field &in, Field &out){$/;"	f	class:DumbOperator
Op	tests/hmc/Test_multishift_sqrt.cc	/^  void Op     (const Field &in, Field &out){$/;"	f	class:DumbOperator
OpDiag	lib/algorithms/LinearOperator.h	/^      void OpDiag (const Field &in, Field &out) {$/;"	f	class:Grid::HermitianLinearOperator
OpDiag	lib/algorithms/LinearOperator.h	/^      void OpDiag (const Field &in, Field &out) {$/;"	f	class:Grid::MdagMLinearOperator
OpDiag	lib/algorithms/LinearOperator.h	/^      void OpDiag (const Field &in, Field &out) {$/;"	f	class:Grid::SchurOperatorBase
OpDiag	lib/algorithms/LinearOperator.h	/^      void OpDiag (const Field &in, Field &out) {$/;"	f	class:Grid::ShiftedMdagMLinearOperator
OpDiag	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void OpDiag (const Field &in, Field &out) {$/;"	f	class:Grid::QCD::Gamma5HermitianLinearOperator
OpDiag	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void OpDiag (const Field &in, Field &out) {$/;"	f	class:Grid::QCD::Gamma5R5HermitianLinearOperator
OpDiag	tests/debug/Test_synthetic_lanczos.cc	/^  void OpDiag (const Field &in, Field &out) {};$/;"	f	class:DumbOperator
OpDiag	tests/hmc/Test_multishift_sqrt.cc	/^  void OpDiag (const Field &in, Field &out) {};$/;"	f	class:DumbOperator
OpDir	lib/algorithms/LinearOperator.h	/^      void OpDir  (const Field &in, Field &out,int dir,int disp) {$/;"	f	class:Grid::HermitianLinearOperator
OpDir	lib/algorithms/LinearOperator.h	/^      void OpDir  (const Field &in, Field &out,int dir,int disp) {$/;"	f	class:Grid::MdagMLinearOperator
OpDir	lib/algorithms/LinearOperator.h	/^      void OpDir  (const Field &in, Field &out,int dir,int disp) {$/;"	f	class:Grid::SchurOperatorBase
OpDir	lib/algorithms/LinearOperator.h	/^      void OpDir  (const Field &in, Field &out,int dir,int disp) {$/;"	f	class:Grid::ShiftedMdagMLinearOperator
OpDir	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void OpDir  (const Field &in, Field &out,int dir,int disp) {$/;"	f	class:Grid::QCD::Gamma5HermitianLinearOperator
OpDir	lib/qcd/action/fermion/g5HermitianLinop.h	/^  void OpDir  (const Field &in, Field &out,int dir,int disp) {$/;"	f	class:Grid::QCD::Gamma5R5HermitianLinearOperator
OpDir	tests/debug/Test_synthetic_lanczos.cc	/^  void OpDir  (const Field &in, Field &out,int dir,int disp){};$/;"	f	class:DumbOperator
OpDir	tests/hmc/Test_multishift_sqrt.cc	/^  void OpDir  (const Field &in, Field &out,int dir,int disp){};$/;"	f	class:DumbOperator
Open	lib/perfmon/PerfCount.h	/^  void Open(void) $/;"	f	class:Grid::PerformanceCounter
OperatorFunction	lib/algorithms/LinearOperator.h	/^    template<class Field> class OperatorFunction {$/;"	c	namespace:Grid
OperatorMultiFunction	lib/algorithms/LinearOperator.h	/^    template<class Field> class OperatorMultiFunction {$/;"	c	namespace:Grid
OppositeExtendedType	lib/Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct OppositeExtendedType {$/;"	s	class:Eigen::VectorwiseOp
Opt	lib/qcd/action/fermion/StaggeredKernels.cc	/^int StaggeredKernelsStatic::Opt= StaggeredKernelsStatic::OptGeneric;$/;"	m	class:Grid::QCD::StaggeredKernelsStatic	file:
Opt	lib/qcd/action/fermion/StaggeredKernels.h	/^  static int Opt;  \/\/ these are a temporary hack$/;"	m	class:Grid::QCD::StaggeredKernelsStatic
Opt	lib/qcd/action/fermion/WilsonKernels.cc	/^int WilsonKernelsStatic::Opt   = WilsonKernelsStatic::OptGeneric;$/;"	m	class:Grid::QCD::WilsonKernelsStatic	file:
Opt	lib/qcd/action/fermion/WilsonKernels.h	/^  static int Opt;  $/;"	m	class:Grid::QCD::WilsonKernelsStatic
OptGeneric	lib/qcd/action/fermion/StaggeredKernels.h	/^  enum { OptGeneric, OptHandUnroll, OptInlineAsm };$/;"	e	enum:Grid::QCD::StaggeredKernelsStatic::__anon8
OptGeneric	lib/qcd/action/fermion/WilsonKernels.h	/^  enum { OptGeneric, OptHandUnroll, OptInlineAsm };$/;"	e	enum:Grid::QCD::WilsonKernelsStatic::__anon9
OptHandUnroll	lib/qcd/action/fermion/StaggeredKernels.h	/^  enum { OptGeneric, OptHandUnroll, OptInlineAsm };$/;"	e	enum:Grid::QCD::StaggeredKernelsStatic::__anon8
OptHandUnroll	lib/qcd/action/fermion/WilsonKernels.h	/^  enum { OptGeneric, OptHandUnroll, OptInlineAsm };$/;"	e	enum:Grid::QCD::WilsonKernelsStatic::__anon9
OptInlineAsm	lib/qcd/action/fermion/StaggeredKernels.h	/^  enum { OptGeneric, OptHandUnroll, OptInlineAsm };$/;"	e	enum:Grid::QCD::StaggeredKernelsStatic::__anon8
OptInlineAsm	lib/qcd/action/fermion/WilsonKernels.h	/^  enum { OptGeneric, OptHandUnroll, OptInlineAsm };$/;"	e	enum:Grid::QCD::WilsonKernelsStatic::__anon9
Optimization	lib/simd/Grid_avx.h	/^namespace Optimization {$/;"	n	namespace:Grid
Optimization	lib/simd/Grid_avx512.h	/^namespace Optimization {$/;"	n	namespace:Grid
Optimization	lib/simd/Grid_generic.h	/^namespace Optimization {$/;"	n	namespace:Grid
Optimization	lib/simd/Grid_generic_types.h	/^namespace Optimization {$/;"	n	namespace:Grid
Optimization	lib/simd/Grid_imci.h	/^namespace Optimization {$/;"	n	namespace:Grid
Optimization	lib/simd/Grid_neon.h	/^namespace Optimization {$/;"	n	namespace:Grid
Optimization	lib/simd/Grid_qpx.h	/^namespace Optimization {$/;"	n	namespace:Grid
Optimization	lib/simd/Grid_sse4.h	/^namespace Optimization {$/;"	n	namespace:Grid
Options	lib/Eigen/src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon167
Options	lib/Eigen/src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
Options	lib/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon388
Options	lib/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon389
Options	lib/Eigen/src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon135
Options	lib/Eigen/src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon172
Options	lib/Eigen/src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon173
Options	lib/Eigen/src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon395
Options	lib/Eigen/src/Core/Ref.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon149
Options	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon581
Options	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon583
Options	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon576
Options	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon577
Options	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon585
Options	lib/Eigen/src/Eigenvalues/RealQZ.h	/^        Options = MatrixType::Options,$/;"	e	enum:Eigen::RealQZ::__anon582
Options	lib/Eigen/src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon580
Options	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon584
Options	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon579
Options	lib/Eigen/src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon606
Options	lib/Eigen/src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon605
Options	lib/Eigen/src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon593
Options	lib/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon619
Options	lib/Eigen/src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon516
Options	lib/Eigen/src/SparseCore/SparseRef.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon532
Options	lib/Eigen/src/SparseCore/SparseRef.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon535
Options	lib/Eigen/src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon542
OrFunctor	lib/simd/Grid_vector_unops.h	/^struct OrFunctor {$/;"	s	namespace:Grid
OrOrFunctor	lib/simd/Grid_vector_unops.h	/^struct OrOrFunctor {$/;"	s	namespace:Grid
OrderingType	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::IncompleteCholesky
OrderingType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::OrderingType OrderingType;$/;"	t	class:Eigen::SimplicialCholeskyBase
OrderingType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _Ordering OrderingType;$/;"	t	struct:Eigen::internal::traits
OrderingType	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseLU
OrderingType	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseQR
Orthogonalise	lib/algorithms/CoarsenedMatrix.h	/^    void Orthogonalise(void){$/;"	f	class:Grid::Aggregation
OtherCols	lib/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon596
OtherCols	lib/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon597
OtherRows	lib/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon596
OtherRows	lib/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon597
OtherRows	lib/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon598
OuterLoopNormMult	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    RealD OuterLoopNormMult; \/\/Stop the outer loop and move to a final double prec solve when the residual is OuterLoopNormMult * Tolerance$/;"	m	class:Grid::MixedPrecisionConjugateGradient
OuterProduct	lib/Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
OuterRandomAccessPattern	lib/Eigen/src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
OuterSize	lib/Eigen/src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon549
OuterSize	lib/Eigen/src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::internal::sparse_matrix_block_impl::__anon551
OuterStride	lib/Eigen/src/Core/AssignEvaluator.h	/^    OuterStride = int(outer_stride_at_compile_time<Dst>::ret),$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon139
OuterStride	lib/Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride
OuterStride	lib/Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC OuterStride(Index v) : Base(v,0) {} \/\/ FIXME making this explicit could break valid code$/;"	f	class:Eigen::OuterStride
OuterStride	lib/Eigen/src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen
OuterStrideAtCompileTime	lib/Eigen/src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon213
OuterStrideAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsArgType$/;"	e	enum:Eigen::internal::evaluator::__anon237
OuterStrideAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::evaluator::__anon235
OuterStrideAtCompileTime	lib/Eigen/src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon394
OuterStrideAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon129
OuterStrideAtCompileTime	lib/Eigen/src/Core/Diagonal.h	/^    OuterStrideAtCompileTime = 0$/;"	e	enum:Eigen::internal::traits::__anon401
OuterStrideAtCompileTime	lib/Eigen/src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon134
OuterStrideAtCompileTime	lib/Eigen/src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon172
OuterStrideAtCompileTime	lib/Eigen/src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon164
OuterStrideAtCompileTime	lib/Eigen/src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon391
OuterStrideMatch	lib/Eigen/src/Core/Ref.h	/^      OuterStrideMatch = Derived::IsVectorAtCompileTime$/;"	e	enum:Eigen::internal::traits::match::__anon150
OuterType	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef internal::variable_if_dynamic<Index,Derived::IsVectorAtCompileTime?0:Dynamic> OuterType;$/;"	t	class:Eigen::SparseCompressedBase::InnerIterator
OuterType	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef internal::variable_if_dynamic<Index,Derived::IsVectorAtCompileTime?0:Dynamic> OuterType;$/;"	t	class:Eigen::SparseCompressedBase::ReverseInnerIterator
OuterVector	lib/Eigen/src/SparseCore/SparseBlock.h	/^      OuterVector =  (BlockCols==1 && ArgType::IsRowMajor)$/;"	e	enum:Eigen::internal::unary_evaluator::__anon553
OuterVectorInnerIterator	lib/Eigen/src/SparseCore/SparseBlock.h	/^  EIGEN_STRONG_INLINE OuterVectorInnerIterator(const unary_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
OuterVectorInnerIterator	lib/Eigen/src/SparseCore/SparseBlock.h	/^class unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::OuterVectorInnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
OverlapWilsonCayleyTanhFermion	lib/qcd/action/fermion/OverlapWilsonCayleyTanhFermion.h	/^    OverlapWilsonCayleyTanhFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::OverlapWilsonCayleyTanhFermion
OverlapWilsonCayleyTanhFermion	lib/qcd/action/fermion/OverlapWilsonCayleyTanhFermion.h	/^    class OverlapWilsonCayleyTanhFermion : public MobiusFermion<Impl>$/;"	c	namespace:Grid::QCD
OverlapWilsonCayleyTanhFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonCayleyTanhFermion<WilsonImplD> OverlapWilsonCayleyTanhFermionD;$/;"	t	namespace:Grid::QCD
OverlapWilsonCayleyTanhFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonCayleyTanhFermion<WilsonImplF> OverlapWilsonCayleyTanhFermionF;$/;"	t	namespace:Grid::QCD
OverlapWilsonCayleyTanhFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonCayleyTanhFermion<WilsonImplR> OverlapWilsonCayleyTanhFermionR;$/;"	t	namespace:Grid::QCD
OverlapWilsonCayleyTanhVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef OverlapWilsonCayleyTanhFermion<DomainWallVec5dImplR>         OverlapWilsonCayleyTanhVecFermionR;$/;"	t	file:
OverlapWilsonCayleyZolotarevFermion	lib/qcd/action/fermion/OverlapWilsonCayleyZolotarevFermion.h	/^    OverlapWilsonCayleyZolotarevFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::OverlapWilsonCayleyZolotarevFermion
OverlapWilsonCayleyZolotarevFermion	lib/qcd/action/fermion/OverlapWilsonCayleyZolotarevFermion.h	/^    class OverlapWilsonCayleyZolotarevFermion : public MobiusZolotarevFermion<Impl>$/;"	c	namespace:Grid::QCD
OverlapWilsonCayleyZolotarevFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonCayleyZolotarevFermion<WilsonImplD> OverlapWilsonCayleyZolotarevFermionD;$/;"	t	namespace:Grid::QCD
OverlapWilsonCayleyZolotarevFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonCayleyZolotarevFermion<WilsonImplF> OverlapWilsonCayleyZolotarevFermionF;$/;"	t	namespace:Grid::QCD
OverlapWilsonCayleyZolotarevFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonCayleyZolotarevFermion<WilsonImplR> OverlapWilsonCayleyZolotarevFermionR;$/;"	t	namespace:Grid::QCD
OverlapWilsonCayleyZolotarevVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef OverlapWilsonCayleyZolotarevFermion<DomainWallVec5dImplR>    OverlapWilsonCayleyZolotarevVecFermionR;$/;"	t	file:
OverlapWilsonContFracTanhFermion	lib/qcd/action/fermion/OverlapWilsonContfracTanhFermion.h	/^    OverlapWilsonContFracTanhFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::OverlapWilsonContFracTanhFermion
OverlapWilsonContFracTanhFermion	lib/qcd/action/fermion/OverlapWilsonContfracTanhFermion.h	/^    class OverlapWilsonContFracTanhFermion : public ContinuedFractionFermion5D<Impl>$/;"	c	namespace:Grid::QCD
OverlapWilsonContFracTanhFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonContFracTanhFermion<WilsonImplD> OverlapWilsonContFracTanhFermionD;$/;"	t	namespace:Grid::QCD
OverlapWilsonContFracTanhFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonContFracTanhFermion<WilsonImplF> OverlapWilsonContFracTanhFermionF;$/;"	t	namespace:Grid::QCD
OverlapWilsonContFracTanhFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonContFracTanhFermion<WilsonImplR> OverlapWilsonContFracTanhFermionR;$/;"	t	namespace:Grid::QCD
OverlapWilsonContFracZolotarevFermion	lib/qcd/action/fermion/OverlapWilsonContfracZolotarevFermion.h	/^    OverlapWilsonContFracZolotarevFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::OverlapWilsonContFracZolotarevFermion
OverlapWilsonContFracZolotarevFermion	lib/qcd/action/fermion/OverlapWilsonContfracZolotarevFermion.h	/^    class OverlapWilsonContFracZolotarevFermion : public ContinuedFractionFermion5D<Impl>$/;"	c	namespace:Grid::QCD
OverlapWilsonContFracZolotarevFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonContFracZolotarevFermion<WilsonImplD> OverlapWilsonContFracZolotarevFermionD;$/;"	t	namespace:Grid::QCD
OverlapWilsonContFracZolotarevFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonContFracZolotarevFermion<WilsonImplF> OverlapWilsonContFracZolotarevFermionF;$/;"	t	namespace:Grid::QCD
OverlapWilsonContFracZolotarevFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonContFracZolotarevFermion<WilsonImplR> OverlapWilsonContFracZolotarevFermionR;$/;"	t	namespace:Grid::QCD
OverlapWilsonPartialFractionTanhFermion	lib/qcd/action/fermion/OverlapWilsonPartialFractionTanhFermion.h	/^    OverlapWilsonPartialFractionTanhFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::OverlapWilsonPartialFractionTanhFermion
OverlapWilsonPartialFractionTanhFermion	lib/qcd/action/fermion/OverlapWilsonPartialFractionTanhFermion.h	/^    class OverlapWilsonPartialFractionTanhFermion : public PartialFractionFermion5D<Impl>$/;"	c	namespace:Grid::QCD
OverlapWilsonPartialFractionTanhFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonPartialFractionTanhFermion<WilsonImplD> OverlapWilsonPartialFractionTanhFermionD;$/;"	t	namespace:Grid::QCD
OverlapWilsonPartialFractionTanhFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonPartialFractionTanhFermion<WilsonImplF> OverlapWilsonPartialFractionTanhFermionF;$/;"	t	namespace:Grid::QCD
OverlapWilsonPartialFractionTanhFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonPartialFractionTanhFermion<WilsonImplR> OverlapWilsonPartialFractionTanhFermionR;$/;"	t	namespace:Grid::QCD
OverlapWilsonPartialFractionZolotarevFermion	lib/qcd/action/fermion/OverlapWilsonPartialFractionZolotarevFermion.h	/^    OverlapWilsonPartialFractionZolotarevFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::OverlapWilsonPartialFractionZolotarevFermion
OverlapWilsonPartialFractionZolotarevFermion	lib/qcd/action/fermion/OverlapWilsonPartialFractionZolotarevFermion.h	/^    class OverlapWilsonPartialFractionZolotarevFermion : public PartialFractionFermion5D<Impl>$/;"	c	namespace:Grid::QCD
OverlapWilsonPartialFractionZolotarevFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonPartialFractionZolotarevFermion<WilsonImplD> OverlapWilsonPartialFractionZolotarevFermionD;$/;"	t	namespace:Grid::QCD
OverlapWilsonPartialFractionZolotarevFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonPartialFractionZolotarevFermion<WilsonImplF> OverlapWilsonPartialFractionZolotarevFermionF;$/;"	t	namespace:Grid::QCD
OverlapWilsonPartialFractionZolotarevFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef OverlapWilsonPartialFractionZolotarevFermion<WilsonImplR> OverlapWilsonPartialFractionZolotarevFermionR;$/;"	t	namespace:Grid::QCD
P	lib/qcd/hmc/integrators/Integrator.h	/^  GeneralisedMomenta<FieldImplementation > P;$/;"	m	class:Grid::QCD::Integrator
PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	lib/Eigen/src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
PACK_OUTPUT	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	1046;"	d
PACK_OUTPUT_2	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	1160;"	d
PACK_OUTPUT_D	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	1202;"	d
PACK_OUTPUT_SQ_D	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	1198;"	d
PALIGN_NEON	lib/Eigen/src/Core/arch/NEON/PacketMath.h	478;"	d
PALIGN_NEON	lib/Eigen/src/Core/arch/NEON/PacketMath.h	498;"	d
PALIGN_NEON	lib/Eigen/src/Core/arch/NEON/PacketMath.h	697;"	d
PALIGN_NEON	lib/Eigen/src/Core/arch/NEON/PacketMath.h	710;"	d
PARALLEL_CRITICAL	lib/threads/Threads.h	45;"	d
PARALLEL_CRITICAL	lib/threads/Threads.h	51;"	d
PARALLEL_FOR_LOOP	lib/threads/Threads.h	41;"	d
PARALLEL_FOR_LOOP	lib/threads/Threads.h	47;"	d
PARALLEL_FOR_LOOP_INTERN	lib/threads/Threads.h	42;"	d
PARALLEL_FOR_LOOP_INTERN	lib/threads/Threads.h	48;"	d
PARALLEL_NESTED_LOOP2	lib/threads/Threads.h	43;"	d
PARALLEL_NESTED_LOOP2	lib/threads/Threads.h	49;"	d
PARALLEL_REGION	lib/threads/Threads.h	44;"	d
PARALLEL_REGION	lib/threads/Threads.h	50;"	d
PARANOID_SYMMETRIC_HEAP	lib/allocator/AlignedAllocator.h	210;"	d
PASTIX_COMPLEX	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	16;"	d
PASTIX_DCOMPLEX	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	17;"	d
PCT	lib/perfmon/PerfCount.h	/^  int PCT;$/;"	m	class:Grid::PerformanceCounter
PERFORMANCE_COUNTER_NUM_TYPES	lib/perfmon/PerfCount.h	/^    PERFORMANCE_COUNTER_NUM_TYPES=19$/;"	e	enum:Grid::PerformanceCounter::PerformanceCounterType
PERI_PLUS	lib/communicator/Communicator_mpi3_leader.cc	596;"	d	file:
PERMUTE01	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	767;"	d	file:
PERMUTE23	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	771;"	d	file:
PERMUTE_DIR	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	574;"	d	file:
PERMUTE_DIR	lib/qcd/action/fermion/StaggeredKernelsHand.cc	84;"	d	file:
PERMUTE_DIR	lib/qcd/action/fermion/WilsonKernelsHand.cc	89;"	d	file:
PERMUTE_DIR0	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	762;"	d	file:
PERMUTE_DIR0	lib/simd/BGQQPX.h	151;"	d
PERMUTE_DIR0	lib/simd/IBM_qpx.h	591;"	d
PERMUTE_DIR0	lib/simd/Intel512wilson.h	665;"	d
PERMUTE_DIR1	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	757;"	d	file:
PERMUTE_DIR1	lib/simd/BGQQPX.h	150;"	d
PERMUTE_DIR1	lib/simd/IBM_qpx.h	589;"	d
PERMUTE_DIR1	lib/simd/Intel512wilson.h	673;"	d
PERMUTE_DIR2	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	752;"	d	file:
PERMUTE_DIR2	lib/simd/BGQQPX.h	149;"	d
PERMUTE_DIR2	lib/simd/IBM_qpx.h	588;"	d
PERMUTE_DIR2	lib/simd/Intel512wilson.h	681;"	d
PERMUTE_DIR3	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	747;"	d	file:
PERMUTE_DIR3	lib/simd/BGQQPX.h	148;"	d
PERMUTE_DIR3	lib/simd/IBM_qpx.h	587;"	d
PERMUTE_DIR3	lib/simd/Intel512wilson.h	689;"	d
PF_CHI	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	513;"	d	file:
PF_CHIa	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	514;"	d	file:
PF_GAUGE	lib/simd/BGQQPX.h	66;"	d
PF_GAUGE	lib/simd/IBM_qpx.h	105;"	d
PF_GAUGE	lib/simd/Intel512wilson.h	563;"	d
PF_GAUGE_LS	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	537;"	d	file:
PF_GAUGE_LSa	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	538;"	d	file:
PF_GAUGE_XYZT	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	522;"	d	file:
PF_GAUGE_XYZTa	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	523;"	d	file:
PMU_MEM	lib/perfmon/Stat.cc	140;"	d	file:
POWER10	tests/core/Test_cshift_red_black.cc	35;"	d	file:
POWER10	tests/core/Test_cshift_red_black_rotate.cc	35;"	d	file:
PP1	lib/algorithms/approx/Zolotarev.cc	56;"	d	file:
PP2	lib/algorithms/approx/Zolotarev.cc	55;"	d	file:
PPC_INST_DCBLC	lib/simd/IBM_qpx.h	80;"	d
PPC_INST_DCBTLS	lib/simd/IBM_qpx.h	79;"	d
PRECISION	lib/algorithms/approx/Zolotarev.h	13;"	d
PREFETCH1_CHIMU	lib/simd/BGQQPX.h	67;"	d
PREFETCH1_CHIMU	lib/simd/IBM_qpx.h	106;"	d
PREFETCH1_CHIMU	lib/simd/Intel512wilson.h	649;"	d
PREFETCH_CHIMU	lib/simd/BGQQPX.h	68;"	d
PREFETCH_CHIMU	lib/simd/IBM_qpx.h	107;"	d
PREFETCH_CHIMU	lib/simd/Intel512wilson.h	629;"	d
PREFETCH_CHIMU	lib/simd/Intel512wilson.h	646;"	d
PREPARE	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	611;"	d	file:
PREPARE_LS	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	604;"	d	file:
PREPARE_XYZT	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	597;"	d	file:
PRINTIT	lib/stencil/Stencil.h	1011;"	d
PRINTIT	lib/stencil/Stencil.h	1032;"	d
PUGIXML_API	lib/pugixml/pugixml.h	53;"	d
PUGIXML_CHAR	lib/pugixml/pugixml.h	78;"	d
PUGIXML_CHAR	lib/pugixml/pugixml.h	81;"	d
PUGIXML_CLASS	lib/pugixml/pugixml.h	58;"	d
PUGIXML_DEPRECATED	lib/pugixml/pugixml.h	43;"	d
PUGIXML_DEPRECATED	lib/pugixml/pugixml.h	45;"	d
PUGIXML_DEPRECATED	lib/pugixml/pugixml.h	47;"	d
PUGIXML_FUNCTION	lib/pugixml/pugixml.h	63;"	d
PUGIXML_HAS_LONG_LONG	lib/pugixml/pugixml.h	69;"	d
PUGIXML_HAS_LONG_LONG	lib/pugixml/pugixml.h	71;"	d
PUGIXML_SOURCE	lib/pugixml/pugixml.h	1373;"	d
PUGIXML_TEXT	lib/pugixml/pugixml.h	77;"	d
PUGIXML_TEXT	lib/pugixml/pugixml.h	80;"	d
PUGIXML_VERSION	lib/pugixml/pugixml.h	16;"	d
PUGI__CHECK_ERROR	lib/pugixml/pugixml.cc	12458;"	d	file:
PUGI__CHECK_ERROR	lib/pugixml/pugixml.cc	2584;"	d	file:
PUGI__DMC_VOLATILE	lib/pugixml/pugixml.cc	101;"	d	file:
PUGI__DMC_VOLATILE	lib/pugixml/pugixml.cc	12436;"	d	file:
PUGI__DMC_VOLATILE	lib/pugixml/pugixml.cc	99;"	d	file:
PUGI__ENDSEG	lib/pugixml/pugixml.cc	12456;"	d	file:
PUGI__ENDSEG	lib/pugixml/pugixml.cc	2582;"	d	file:
PUGI__ENDSWITH	lib/pugixml/pugixml.cc	12448;"	d	file:
PUGI__ENDSWITH	lib/pugixml/pugixml.cc	2574;"	d	file:
PUGI__FN	lib/pugixml/pugixml.cc	118;"	d	file:
PUGI__FN	lib/pugixml/pugixml.cc	12440;"	d	file:
PUGI__FN_NO_INLINE	lib/pugixml/pugixml.cc	119;"	d	file:
PUGI__FN_NO_INLINE	lib/pugixml/pugixml.cc	12441;"	d	file:
PUGI__GETPAGE	lib/pugixml/pugixml.cc	12443;"	d	file:
PUGI__GETPAGE	lib/pugixml/pugixml.cc	437;"	d	file:
PUGI__GETPAGE_IMPL	lib/pugixml/pugixml.cc	12442;"	d	file:
PUGI__GETPAGE_IMPL	lib/pugixml/pugixml.cc	432;"	d	file:
PUGI__GETPAGE_IMPL	lib/pugixml/pugixml.cc	434;"	d	file:
PUGI__IS_CHARTYPE	lib/pugixml/pugixml.cc	12446;"	d	file:
PUGI__IS_CHARTYPE	lib/pugixml/pugixml.cc	1864;"	d	file:
PUGI__IS_CHARTYPEX	lib/pugixml/pugixml.cc	12447;"	d	file:
PUGI__IS_CHARTYPEX	lib/pugixml/pugixml.cc	1865;"	d	file:
PUGI__IS_CHARTYPE_IMPL	lib/pugixml/pugixml.cc	12445;"	d	file:
PUGI__IS_CHARTYPE_IMPL	lib/pugixml/pugixml.cc	1859;"	d	file:
PUGI__IS_CHARTYPE_IMPL	lib/pugixml/pugixml.cc	1861;"	d	file:
PUGI__MSVC_CRT_VERSION	lib/pugixml/pugixml.cc	112;"	d	file:
PUGI__MSVC_CRT_VERSION	lib/pugixml/pugixml.cc	12437;"	d	file:
PUGI__NODETYPE	lib/pugixml/pugixml.cc	12444;"	d	file:
PUGI__NODETYPE	lib/pugixml/pugixml.cc	438;"	d	file:
PUGI__NO_INLINE	lib/pugixml/pugixml.cc	12433;"	d	file:
PUGI__NO_INLINE	lib/pugixml/pugixml.cc	80;"	d	file:
PUGI__NO_INLINE	lib/pugixml/pugixml.cc	82;"	d	file:
PUGI__NO_INLINE	lib/pugixml/pugixml.cc	84;"	d	file:
PUGI__NS_BEGIN	lib/pugixml/pugixml.cc	116;"	d	file:
PUGI__NS_BEGIN	lib/pugixml/pugixml.cc	12438;"	d	file:
PUGI__NS_END	lib/pugixml/pugixml.cc	117;"	d	file:
PUGI__NS_END	lib/pugixml/pugixml.cc	12439;"	d	file:
PUGI__OPTSET	lib/pugixml/pugixml.cc	12450;"	d	file:
PUGI__OPTSET	lib/pugixml/pugixml.cc	2576;"	d	file:
PUGI__POPNODE	lib/pugixml/pugixml.cc	12452;"	d	file:
PUGI__POPNODE	lib/pugixml/pugixml.cc	2578;"	d	file:
PUGI__PUSHNODE	lib/pugixml/pugixml.cc	12451;"	d	file:
PUGI__PUSHNODE	lib/pugixml/pugixml.cc	2577;"	d	file:
PUGI__SCANFOR	lib/pugixml/pugixml.cc	12453;"	d	file:
PUGI__SCANFOR	lib/pugixml/pugixml.cc	2579;"	d	file:
PUGI__SCANWHILE	lib/pugixml/pugixml.cc	12454;"	d	file:
PUGI__SCANWHILE	lib/pugixml/pugixml.cc	2580;"	d	file:
PUGI__SCANWHILE_UNROLL	lib/pugixml/pugixml.cc	12455;"	d	file:
PUGI__SCANWHILE_UNROLL	lib/pugixml/pugixml.cc	2581;"	d	file:
PUGI__SKIPWS	lib/pugixml/pugixml.cc	12449;"	d	file:
PUGI__SKIPWS	lib/pugixml/pugixml.cc	2575;"	d	file:
PUGI__STATIC_ASSERT	lib/pugixml/pugixml.cc	12435;"	d	file:
PUGI__STATIC_ASSERT	lib/pugixml/pugixml.cc	95;"	d	file:
PUGI__THROW_ERROR	lib/pugixml/pugixml.cc	12457;"	d	file:
PUGI__THROW_ERROR	lib/pugixml/pugixml.cc	2583;"	d	file:
PUGI__UNLIKELY	lib/pugixml/pugixml.cc	12434;"	d	file:
PUGI__UNLIKELY	lib/pugixml/pugixml.cc	89;"	d	file:
PUGI__UNLIKELY	lib/pugixml/pugixml.cc	91;"	d	file:
Packet	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^} Packet;$/;"	t	namespace:Eigen::internal	typeref:union:Eigen::internal::__anon308
Packet	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs
Packet	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::internal::BlasLinearMapper
Packet	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::internal::blas_data_mapper
Packet	lib/stencil/Stencil.h	/^  struct Packet {$/;"	s	class:Grid::CartesianStencil
Packet16f	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^typedef __m512 Packet16f;$/;"	t	namespace:Eigen::internal
Packet16i	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^typedef __m512i Packet16i;$/;"	t	namespace:Eigen::internal
Packet16uc	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Packet16uc	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector unsigned char       Packet16uc;$/;"	t	namespace:Eigen::internal
Packet1cd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1cd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1cd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1cd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1d	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float64x1_t Packet1d;$/;"	t	namespace:Eigen::internal
Packet2bl	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef Packet2ul                    Packet2bl;$/;"	t	namespace:Eigen::internal
Packet2bl	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool long         Packet2bl;$/;"	t	namespace:Eigen::internal
Packet2cd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd() {}$/;"	f	struct:Eigen::internal::Packet2cd
Packet2cd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cd(const __m256d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cd
Packet2cd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^struct Packet2cd$/;"	s	namespace:Eigen::internal
Packet2cf	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf() : v(p4f_ZERO) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2d	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector double              Packet2d;$/;"	t	namespace:Eigen::internal
Packet2d	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float64x2_t Packet2d;$/;"	t	namespace:Eigen::internal
Packet2d	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef eigen_packet_wrapper<__m128d> Packet2d;$/;"	t	namespace:Eigen::internal
Packet2d	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector double              Packet2d;$/;"	t	namespace:Eigen::internal
Packet2f	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float32x2_t Packet2f;$/;"	t	namespace:Eigen::internal
Packet2i	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef int32x2_t   Packet2i;$/;"	t	namespace:Eigen::internal
Packet2l	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector long long           Packet2l;$/;"	t	namespace:Eigen::internal
Packet2l	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector long long           Packet2l;$/;"	t	namespace:Eigen::internal
Packet2ul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned long long  Packet2ul;$/;"	t	namespace:Eigen::internal
Packet2ul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector unsigned long long  Packet2ul;$/;"	t	namespace:Eigen::internal
Packet4bi	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4bi	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector __bool int          Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4cf	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf() {}$/;"	f	struct:Eigen::internal::Packet4cf
Packet4cf	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet4cf(const __m256& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet4cf
Packet4cf	lib/Eigen/src/Core/arch/AVX/Complex.h	/^struct Packet4cf$/;"	s	namespace:Eigen::internal
Packet4d	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^typedef __m256d Packet4d;$/;"	t	namespace:Eigen::internal
Packet4f	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float32x4_t Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef eigen_packet_wrapper<__m128>  Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^} Packet4f;$/;"	t	namespace:Eigen::internal	typeref:struct:Eigen::internal::__anon307
Packet4i	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef int32x4_t   Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef eigen_packet_wrapper<__m128i> Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector int                 Packet4i;$/;"	t	namespace:Eigen::internal
Packet4ui	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef uint32x4_t  Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector unsigned int        Packet4ui;$/;"	t	namespace:Eigen::internal
Packet8d	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^typedef __m512d Packet8d;$/;"	t	namespace:Eigen::internal
Packet8f	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^typedef __m256  Packet8f;$/;"	t	namespace:Eigen::internal
Packet8i	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^typedef __m256i Packet8i;$/;"	t	namespace:Eigen::internal
Packet8i	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
Packet8i	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector short int           Packet8i;$/;"	t	namespace:Eigen::internal
PacketAccess	lib/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon503
PacketAccess	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon268
PacketAccess	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon269
PacketAccess	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon270
PacketAccess	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon478
PacketAccess	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasDiv$/;"	e	enum:Eigen::internal::functor_traits::__anon481
PacketAccess	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon480
PacketAccess	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon479
PacketAccess	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::Vectorizable && packet_traits<SrcScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon477
PacketAccess	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = packet_traits<Scalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon482
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon409
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon410
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon414
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon415
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon416
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon408
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon407
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon406
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasAdd && packet_traits<RhsScalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon403
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasDiv && packet_traits<RhsScalar>::HasDiv,$/;"	e	enum:Eigen::internal::functor_traits::__anon413
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon404
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasSub && packet_traits<RhsScalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon412
PacketAccess	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon411
PacketAccess	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^         PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon483
PacketAccess	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^    PacketAccess =   (!NumTraits<Scalar>::IsInteger) && packet_traits<Scalar>::HasSetLinear && packet_traits<Scalar>::HasBlend,$/;"	e	enum:Eigen::internal::functor_traits::__anon485
PacketAccess	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon484
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon435
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon436
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon437
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon438
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon433
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon434
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon422
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon423
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon424
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon425
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon426
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon427
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon428
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon429
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon430
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon419
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon420
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon421
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon417
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon418
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon440
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon439
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon431
PacketAccess	lib/Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon432
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon472
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon473
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon474
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon475
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon460
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon461
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasATan$/;"	e	enum:Eigen::internal::functor_traits::__anon462
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon442
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasArg$/;"	e	enum:Eigen::internal::functor_traits::__anon445
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasCeil$/;"	e	enum:Eigen::internal::functor_traits::__anon471
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon444
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon457
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasCosh$/;"	e	enum:Eigen::internal::functor_traits::__anon465
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasExp,$/;"	e	enum:Eigen::internal::functor_traits::__anon451
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasFloor$/;"	e	enum:Eigen::internal::functor_traits::__anon470
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasLog,$/;"	e	enum:Eigen::internal::functor_traits::__anon452
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasLog1p,$/;"	e	enum:Eigen::internal::functor_traits::__anon453
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon441
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasRound$/;"	e	enum:Eigen::internal::functor_traits::__anon469
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasRsqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon456
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSign$/;"	e	enum:Eigen::internal::functor_traits::__anon476
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon458
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSinh$/;"	e	enum:Eigen::internal::functor_traits::__anon464
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon455
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon459
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasTanh,$/;"	e	enum:Eigen::internal::functor_traits::__anon463
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon447
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon448
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon449
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon450
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon468
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog10 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon454
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon443
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon466
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon467
PacketAccess	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon446
PacketAccessBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
PacketAccessMask	lib/Eigen/src/Core/CoreEvaluators.h	/^    PacketAccessMask = bool(HasNoInnerStride) ? ~int(0) : ~int(PacketAccessBit),$/;"	e	enum:Eigen::internal::evaluator::__anon235
PacketAlignment	lib/Eigen/src/Core/CoreEvaluators.h	/^    PacketAlignment = unpacket_traits<PacketScalar>::alignment,$/;"	e	enum:Eigen::internal::evaluator::__anon237
PacketBlock	lib/Eigen/src/Core/GenericPacketMath.h	/^template <typename Packet,int N=unpacket_traits<Packet>::size> struct PacketBlock {$/;"	s	namespace:Eigen::internal
PacketReturnType	lib/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
PacketReturnType	lib/Eigen/src/Core/Redux.h	/^  typedef typename XprType::PacketReturnType PacketReturnType;$/;"	t	class:Eigen::internal::redux_evaluator
PacketReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase
PacketScalar	lib/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase
PacketScalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::evaluator
PacketScalar	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::find_best_packet<Scalar,SizeAtCompileTime>::type PacketScalar;$/;"	t	class:Eigen::DenseBase
PacketScalar	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase
PacketScalar	lib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	lib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	lib/Eigen/src/Core/Matrix.h	/^  typedef typename find_best_packet<_Scalar,size>::type PacketScalar;$/;"	t	struct:Eigen::internal::traits
PacketScalar	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase
PacketScalar	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase
PacketScalar	lib/Eigen/src/Core/Redux.h	/^  typedef typename XprType::PacketScalar PacketScalar;$/;"	t	class:Eigen::internal::redux_evaluator
PacketScalar	lib/Eigen/src/Core/Redux.h	/^  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl
PacketScalar	lib/Eigen/src/Core/Redux.h	/^  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
PacketScalar	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase
PacketSize	lib/Eigen/src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon632
PacketSize	lib/Eigen/src/Core/GeneralProduct.h	/^    PacketSize      = internal::packet_traits<Scalar>::size$/;"	e	enum:Eigen::internal::gemv_static_vector_if::__anon212
PacketSize	lib/Eigen/src/Core/Redux.h	/^    PacketSize = redux_traits<Func, Derived>::PacketSize,$/;"	e	enum:Eigen::internal::redux_impl::__anon124
PacketSize	lib/Eigen/src/Core/Redux.h	/^    PacketSize = redux_traits<Func, Derived>::PacketSize,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon122
PacketSize	lib/Eigen/src/Core/Redux.h	/^    PacketSize = unpacket_traits<PacketType>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon115
PacketSize	lib/Eigen/src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon166
PacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon378
PacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon379
PacketSize	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon369
PacketType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename AssignmentTraits::PacketType PacketType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
PacketType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::PacketType PacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
PacketType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::PacketType PacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_InnerUnrolling
PacketType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::PacketType PacketType;$/;"	t	struct:Eigen::internal::dense_assignment_loop
PacketType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename conditional<int(Traversal)==LinearVectorizedTraversal, LinearPacketType, InnerPacketType>::type PacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
PacketType	lib/Eigen/src/Core/Redux.h	/^    typedef typename find_best_packet<typename Derived::Scalar,Derived::SizeAtCompileTime>::type PacketType;$/;"	t	struct:Eigen::internal::redux_traits
PacketType	lib/Eigen/src/Core/Redux.h	/^  typedef typename redux_traits<Func, Derived>::PacketType PacketType;$/;"	t	struct:Eigen::internal::redux_impl
Packets	lib/stencil/Stencil.h	/^  std::vector<Packet> Packets;$/;"	m	class:Grid::CartesianStencil
Painter	lib/log/Log.h	/^  Colours &Painter;$/;"	m	class:Grid::Logger
Par	extras/Hadrons/Module.hpp	/^    typedef P Par;$/;"	t	class:Module
Par	lib/Hadrons/Module.hpp	/^    typedef P Par;$/;"	t	class:Module
Par_	lib/qcd/modules/Modules.h	/^  Parameters Par_;$/;"	m	class:Grid::Parametrized
ParameterFile	lib/qcd/hmc/GenericHMCrunner.h	/^  std::string ParameterFile;$/;"	m	class:Grid::QCD::HMCWrapperTemplate
ParameterType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Array<StorageIndex,64,1,DontAlign> ParameterType;$/;"	t	class:Eigen::PardisoImpl
Parameters	extras/Hadrons/GeneticScheduler.hpp	/^    struct Parameters$/;"	s	class:GeneticScheduler
Parameters	lib/Hadrons/GeneticScheduler.hpp	/^    struct Parameters$/;"	s	class:GeneticScheduler
Parameters	lib/qcd/modules/ActionModules.h	/^  typedef APar Parameters;$/;"	t	class:Grid::ActionModule
Parameters	lib/qcd/modules/Modules.h	/^  typedef NoParameters Parameters;$/;"	t	class:Grid::Parametrized
Parameters	lib/qcd/modules/Modules.h	/^  typedef P Parameters;$/;"	t	class:Grid::Parametrized
Parameters	lib/qcd/modules/ObservableModules.h	/^  typedef OPar Parameters;$/;"	t	class:Grid::ObservableModule
Parametrized	lib/qcd/modules/Modules.h	/^  Parametrized(Parameters Par):Par_(Par){};$/;"	f	class:Grid::Parametrized
Parametrized	lib/qcd/modules/Modules.h	/^  Parametrized(Parameters Par){};$/;"	f	class:Grid::Parametrized
Parametrized	lib/qcd/modules/Modules.h	/^  Parametrized(Reader<ReaderClass> & R, std::string section_name = "parameters"){$/;"	f	class:Grid::Parametrized
Parametrized	lib/qcd/modules/Modules.h	/^  Parametrized(Reader<ReaderClass> & Reader){};$/;"	f	class:Grid::Parametrized
Parametrized	lib/qcd/modules/Modules.h	/^class Parametrized<NoParameters>{$/;"	c	namespace:Grid
Parametrized	lib/qcd/modules/Modules.h	/^class Parametrized{$/;"	c	namespace:Grid
ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^EIGEN_DEVICE_FUNC inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
Params	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    ImplParams Params;$/;"	m	class:Grid::QCD::StaggeredImpl
Params	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    ImplParams Params;$/;"	m	class:Grid::QCD::StaggeredVec5dImpl
Params	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    ImplParams Params;$/;"	m	class:Grid::QCD::WilsonImpl
Params	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  ImplParams Params;$/;"	m	class:Grid::QCD::DomainWallVec5dImpl
Params	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ ImplParams Params;$/;"	m	class:Grid::QCD::GparityWilsonImpl
Params	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  typedef OneFlavourRationalParams Params;$/;"	t	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
Params	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      typedef OneFlavourRationalParams Params;$/;"	t	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
Params	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      typedef OneFlavourRationalParams Params;$/;"	t	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
Params	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      typedef OneFlavourRationalParams Params;$/;"	t	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
Params	lib/qcd/hmc/HMC.h	/^  const HMCparameters Params;$/;"	m	class:Grid::QCD::HybridMonteCarlo
Params	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  CheckpointerParameters Params;$/;"	m	class:Grid::QCD::BinaryHmcCheckpointer
Params	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^  CheckpointerParameters Params;$/;"	m	class:Grid::QCD::ILDGHmcCheckpointer
Params	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^  CheckpointerParameters Params;$/;"	m	class:Grid::QCD::NerscHmcCheckpointer
Params	lib/qcd/hmc/integrators/Integrator.h	/^  IntegratorParameters Params;$/;"	m	class:Grid::QCD::Integrator
Params_	lib/qcd/hmc/HMCModules.h	/^   RNGModuleParameters Params_;$/;"	m	class:Grid::QCD::RNGModule
PardisoImpl	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
PardisoImpl	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
PardisoLDLT	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    explicit PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen
PardisoLLT	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    explicit PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen
PardisoLU	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU
PardisoLU	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    explicit PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
PardisoLU	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen
Pars	lib/qcd/observables/topological_charge.h	/^    TopologyObsParameters Pars;$/;"	m	class:Grid::QCD::TopologicalCharge
PartialFractionFermion5D	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    PartialFractionFermion5D<Impl>::PartialFractionFermion5D(GaugeField &_Umu,$/;"	f	class:Grid::QCD::PartialFractionFermion5D
PartialFractionFermion5D	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^    class PartialFractionFermion5D : public WilsonFermion5D<Impl>$/;"	c	namespace:Grid::QCD
PartialPivLU	lib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	lib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	lib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	lib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	lib/Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
PartialReduxExpr	lib/Eigen/src/Core/VectorwiseOp.h	/^    explicit PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr
PartialReduxExpr	lib/Eigen/src/Core/VectorwiseOp.h	/^class PartialReduxExpr : public internal::dense_xpr_base< PartialReduxExpr<MatrixType, MemberOp, Direction> >::type,$/;"	c	namespace:Eigen
PastixBase	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase
PastixBase	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
PastixLDLT	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    explicit PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLLT	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    explicit PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLU	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU
PastixLU	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    explicit PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU
PastixLU	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekColour(const Lattice<vobj> &rhs,int i) -> decltype(PeekIndex<ColourIndex>(rhs,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekColour(const Lattice<vobj> &rhs,int i,int j) -> decltype(PeekIndex<ColourIndex>(rhs,0,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekColour(const vobj &rhs,int i) -> decltype(PeekIndex<ColourIndex>(rhs,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekColour(const vobj &rhs,int i,int j) -> decltype(PeekIndex<ColourIndex>(rhs,0,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekLorentz(const Lattice<vobj> &rhs,int i) -> decltype(PeekIndex<LorentzIndex>(rhs,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekLorentz(const vobj &rhs,int i) -> decltype(PeekIndex<LorentzIndex>(rhs,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekSpin(const Lattice<vobj> &rhs,int i) -> decltype(PeekIndex<SpinIndex>(rhs,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekSpin(const Lattice<vobj> &rhs,int i,int j) -> decltype(PeekIndex<SpinIndex>(rhs,0,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekSpin(const vobj &rhs,int i) -> decltype(PeekIndex<SpinIndex>(rhs,0))$/;"	f	namespace:Grid::QCD
PeekIndex	lib/qcd/QCD.h	/^    template<class vobj> auto peekSpin(const vobj &rhs,int i,int j) -> decltype(PeekIndex<SpinIndex>(rhs,0,0))$/;"	f	namespace:Grid::QCD
PerformanceCounter	lib/perfmon/PerfCount.h	/^  PerformanceCounter(int _pct) {$/;"	f	class:Grid::PerformanceCounter
PerformanceCounter	lib/perfmon/PerfCount.h	/^class PerformanceCounter {$/;"	c	namespace:Grid
PerformanceCounterConfig	lib/perfmon/PerfCount.h	/^  } PerformanceCounterConfig; $/;"	t	class:Grid::PerformanceCounter	typeref:struct:Grid::PerformanceCounter::__anon691
PerformanceCounterConfigs	lib/perfmon/PerfCount.cc	/^const PerformanceCounter::PerformanceCounterConfig PerformanceCounter::PerformanceCounterConfigs [] = {$/;"	m	class:Grid::PerformanceCounter	file:
PerformanceCounterConfigs	lib/perfmon/PerfCount.h	/^  static const PerformanceCounterConfig PerformanceCounterConfigs [];$/;"	m	class:Grid::PerformanceCounter
PerformanceCounterType	lib/perfmon/PerfCount.h	/^  enum PerformanceCounterType {$/;"	g	class:Grid::PerformanceCounter
PeriodicBC	lib/qcd/utils/CovariantCshift.h	/^namespace PeriodicBC { $/;"	n	namespace:Grid::QCD
PeriodicGaugeImpl	lib/qcd/action/gauge/GaugeImplementations.h	/^template <class GimplTypes> class PeriodicGaugeImpl : public GimplTypes {$/;"	c	namespace:Grid::QCD
PeriodicGimplAdjD	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef PeriodicGaugeImpl<GimplAdjointTypesD> PeriodicGimplAdjD; \/\/ Double$/;"	t	namespace:Grid::QCD
PeriodicGimplAdjF	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef PeriodicGaugeImpl<GimplAdjointTypesF> PeriodicGimplAdjF; \/\/ Float$/;"	t	namespace:Grid::QCD
PeriodicGimplAdjR	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef PeriodicGaugeImpl<GimplAdjointTypesR> PeriodicGimplAdjR; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
PeriodicGimplD	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef PeriodicGaugeImpl<GimplTypesD> PeriodicGimplD; \/\/ Double$/;"	t	namespace:Grid::QCD
PeriodicGimplF	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef PeriodicGaugeImpl<GimplTypesF> PeriodicGimplF; \/\/ Float$/;"	t	namespace:Grid::QCD
PeriodicGimplR	lib/qcd/action/gauge/GaugeImplementations.h	/^typedef PeriodicGaugeImpl<GimplTypesR> PeriodicGimplR; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
Perm	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,StorageIndex> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
PermIndexType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename PermutationType::StorageIndex PermIndexType;$/;"	t	class:Eigen::ColPivHouseholderQR
PermIndexType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename PermutationType::Index PermIndexType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
PermPermProduct	lib/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
PermPermProduct_t	lib/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
PermTester	tests/Test_simd.cc	/^void PermTester(const functor &func)$/;"	f
PermTraits	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> PermTraits;$/;"	t	class:Eigen::InverseImpl
PermutationBase	lib/Eigen/src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
PermutationMap	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Map<PermutationMatrix<Dynamic,Dynamic,int> > PermutationMap;$/;"	t	class:Eigen::SuperLUBase
PermutationMap	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::PermutationMap PermutationMap;$/;"	t	class:Eigen::SuperLU
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(const InverseImpl<Other,PermutationStorage>& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(Index size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex> >$/;"	c	namespace:Eigen
PermutationPType	lib/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU
PermutationQType	lib/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU
PermutationShape	lib/Eigen/src/Core/util/Constants.h	/^struct PermutationShape       { static std::string debugName() { return "PermutationShape"; } };$/;"	s	namespace:Eigen
PermutationStorage	lib/Eigen/src/Core/util/Constants.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
PermutationType	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT
PermutationType	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef typename OrderingType::PermutationType PermutationType;$/;"	t	class:Eigen::IncompleteCholesky
PermutationType	lib/Eigen/src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU
PermutationType	lib/Eigen/src/MetisSupport/MetisSupport.h	/^  typedef PermutationMatrix<Dynamic,Dynamic,StorageIndex> PermutationType;$/;"	t	class:Eigen::MetisOrdering
PermutationType	lib/Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType; $/;"	t	class:Eigen::COLAMDOrdering
PermutationType	lib/Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::AMDOrdering
PermutationType	lib/Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::NaturalOrdering
PermutationType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR
PermutationType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      PermutationType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
PermutationType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR
PermutationType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef Map<PermutationMatrix<Dynamic, Dynamic, StorageIndex> > PermutationType;$/;"	t	class:Eigen::SPQR
PermutationType	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::SparseLU
PermutationType	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::SparseQR
PermutationWrapper	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& indices)$/;"	f	class:Eigen::PermutationWrapper
PermutationWrapper	lib/Eigen/src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen
Permute	lib/simd/Grid_avx.h	/^  struct Permute{$/;"	s	namespace:Grid::Optimization
Permute	lib/simd/Grid_avx512.h	/^  struct Permute{$/;"	s	namespace:Grid::Optimization
Permute	lib/simd/Grid_generic.h	/^  struct Permute{$/;"	s	namespace:Grid::Optimization
Permute	lib/simd/Grid_imci.h	/^   struct Permute{$/;"	s	namespace:Grid::Optimization
Permute	lib/simd/Grid_neon.h	/^  struct Permute{$/;"	s	namespace:Grid::Optimization
Permute	lib/simd/Grid_qpx.h	/^  struct Permute{$/;"	s	namespace:Grid::Optimization
Permute	lib/simd/Grid_sse4.h	/^  struct Permute{$/;"	s	namespace:Grid::Optimization
Permute0	lib/simd/Grid_avx.h	/^    static inline __m256 Permute0(__m256 in){$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_avx.h	/^    static inline __m256d Permute0(__m256d in){$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_avx512.h	/^    static inline __m512 Permute0(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_avx512.h	/^    static inline __m512d Permute0(__m512d in){$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_imci.h	/^    static inline __m512 Permute0(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_imci.h	/^    static inline __m512d Permute0(__m512d in){\/\/ Hack no intrinsic for 256 swaps of __m512d$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_neon.h	/^    static inline float32x4_t Permute0(float32x4_t in){ \/\/ N:ok$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_neon.h	/^    static inline float64x2_t Permute0(float64x2_t in){ \/\/ N:ok$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_qpx.h	/^    static inline vector4double Permute0(vector4double v){ \/\/0123 -> 2301$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_sse4.h	/^    static inline __m128 Permute0(__m128 in){$/;"	f	struct:Grid::Optimization::Permute
Permute0	lib/simd/Grid_sse4.h	/^    static inline __m128d Permute0(__m128d in){ \/\/AB -> BA$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_avx.h	/^    static inline __m256 Permute1(__m256 in){$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_avx.h	/^    static inline __m256d Permute1(__m256d in){ \/\/AB CD -> BA DC$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_avx512.h	/^    static inline __m512 Permute1(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_avx512.h	/^    static inline __m512d Permute1(__m512d in){$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_imci.h	/^    static inline __m512 Permute1(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_imci.h	/^    static inline __m512d Permute1(__m512d in){$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_neon.h	/^    static inline float32x4_t Permute1(float32x4_t in){ \/\/ N:ok$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_neon.h	/^    static inline float64x2_t Permute1(float64x2_t in){ \/\/ N:not used by Boyle$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_qpx.h	/^    static inline vector4double Permute1(vector4double v){ \/\/0123 -> 1032$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_sse4.h	/^    static inline __m128 Permute1(__m128 in){$/;"	f	struct:Grid::Optimization::Permute
Permute1	lib/simd/Grid_sse4.h	/^    static inline __m128d Permute1(__m128d in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_avx.h	/^    static inline __m256 Permute2(__m256 in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_avx.h	/^    static inline __m256d Permute2(__m256d in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_avx512.h	/^    static inline __m512 Permute2(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_avx512.h	/^    static inline __m512d Permute2(__m512d in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_imci.h	/^    static inline __m512 Permute2(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_imci.h	/^    static inline __m512d Permute2(__m512d in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_neon.h	/^    static inline float32x4_t Permute2(float32x4_t in){ \/\/ N:not used by Boyle$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_neon.h	/^    static inline float64x2_t Permute2(float64x2_t in){ \/\/ N:not used by Boyle$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_qpx.h	/^    static inline vector4double Permute2(vector4double v){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_sse4.h	/^    static inline __m128 Permute2(__m128 in){$/;"	f	struct:Grid::Optimization::Permute
Permute2	lib/simd/Grid_sse4.h	/^    static inline __m128d Permute2(__m128d in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_avx.h	/^    static inline __m256 Permute3(__m256 in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_avx.h	/^    static inline __m256d Permute3(__m256d in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_avx512.h	/^    static inline __m512 Permute3(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_avx512.h	/^    static inline __m512d Permute3(__m512d in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_imci.h	/^    static inline __m512 Permute3(__m512 in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_imci.h	/^    static inline __m512d Permute3(__m512d in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_neon.h	/^    static inline float32x4_t Permute3(float32x4_t in){ \/\/ N:not used by Boyle$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_neon.h	/^    static inline float64x2_t Permute3(float64x2_t in){ \/\/ N:not used by Boyle$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_qpx.h	/^    static inline vector4double Permute3(vector4double v){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_sse4.h	/^    static inline __m128 Permute3(__m128 in){$/;"	f	struct:Grid::Optimization::Permute
Permute3	lib/simd/Grid_sse4.h	/^    static inline __m128d Permute3(__m128d in){$/;"	f	struct:Grid::Optimization::Permute
PermuteDim	lib/cartesian/Cartesian_base.h	/^    inline int PermuteDim(int dimension){$/;"	f	class:Grid::GridBase
PermuteType	lib/cartesian/Cartesian_base.h	/^    inline int PermuteType(int dimension){$/;"	f	class:Grid::GridBase
Phi	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      FermionField Phi; \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
Phi	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      FermionField Phi; \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
Phi	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  FermionField Phi;  \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::TwoFlavourPseudoFermionAction
Phi	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      FermionField Phi; \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
PhiEven	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  FermionField PhiEven;  \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
PhiEven	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      FermionField PhiEven; \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
PhiEven	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      FermionField PhiEven;  \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
PhiEven	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      FermionField PhiEven;  \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
PhiOdd	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  FermionField PhiOdd;   \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
PhiOdd	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      FermionField PhiOdd; \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
PhiOdd	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      FermionField PhiOdd;   \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
PhiOdd	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      FermionField PhiOdd;   \/\/ the pseudo fermion field for this trajectory$/;"	m	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
Photon	lib/qcd/action/gauge/Photon.h	/^  Photon<Gimpl>::Photon(Gauge gauge, ZmScheme zmScheme)$/;"	f	class:Grid::QCD::Photon
Photon	lib/qcd/action/gauge/Photon.h	/^  class Photon$/;"	c	namespace:Grid::QCD
PhotonR	lib/qcd/action/gauge/Photon.h	/^  typedef Photon<QedGimplR>  PhotonR;$/;"	t	namespace:Grid::QCD
Pivoting	lib/Eigen/src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
PlainArray	lib/Eigen/src/Core/DenseBase.h	/^          > PlainArray;$/;"	t	class:Eigen::DenseBase
PlainMatrix	lib/Eigen/src/Core/DenseBase.h	/^          > PlainMatrix;$/;"	t	class:Eigen::DenseBase
PlainObject	lib/Eigen/src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array
PlainObject	lib/Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ArrayBase
PlainObject	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::PlainObject         PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	lib/Eigen/src/Core/DenseBase.h	/^                                 PlainMatrix, PlainArray>::type PlainObject;$/;"	t	class:Eigen::DenseBase
PlainObject	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase
PlainObject	lib/Eigen/src/Core/Inverse.h	/^  typedef typename InverseType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::unary_evaluator
PlainObject	lib/Eigen/src/Core/Inverse.h	/^  typedef typename XprType::PlainObject                       PlainObject;$/;"	t	class:Eigen::Inverse
PlainObject	lib/Eigen/src/Core/Inverse.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	lib/Eigen/src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix
PlainObject	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::MatrixBase
PlainObject	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef PlainPermutationType PlainObject;$/;"	t	class:Eigen::PermutationBase
PlainObject	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	lib/Eigen/src/Core/ReturnByValue.h	/^  typedef typename internal::traits<Derived>::ReturnType PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView
PlainObject	lib/Eigen/src/Core/Solve.h	/^                 RhsType::MaxColsAtCompileTime> PlainObject;  $/;"	t	struct:Eigen::internal::solve_traits
PlainObject	lib/Eigen/src/Core/Solve.h	/^  typedef typename SolveType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	lib/Eigen/src/Core/Solve.h	/^  typedef typename internal::traits<Solve>::PlainObject PlainObject;$/;"	t	class:Eigen::Solve
PlainObject	lib/Eigen/src/Core/Solve.h	/^  typedef typename solve_traits<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularViewImpl
PlainObject	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::unary_evaluator
PlainObject	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename SolveType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::traits<SolveWithGuess>::PlainObject PlainObject;$/;"	t	class:Eigen::SolveWithGuess
PlainObject	lib/Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::FullPivLU
PlainObject	lib/Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::PartialPivLU
PlainObject	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::ColPivHouseholderQR
PlainObject	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
PlainObject	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::FullPivHouseholderQR
PlainObject	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor, StorageIndex> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase
PlainObject	lib/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename permutation_matrix_product<Lhs,OnTheRight,false,SparseShape>::ReturnType PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	lib/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename permutation_matrix_product<Rhs,OnTheLeft,false,SparseShape>::ReturnType PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	lib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::unary_evaluator
PlainObject	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	lib/Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename sparse_eval<RhsType, RhsType::RowsAtCompileTime, RhsType::ColsAtCompileTime,traits<RhsType>::Flags>::type PlainObject;$/;"	t	struct:Eigen::internal::solve_traits
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^    explicit PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	lib/Eigen/src/Core/PlainObjectBase.h	/^class PlainObjectBase : public doxygen::dense_xpr_base_dispatcher<Derived>$/;"	c	namespace:Eigen
PlainObjectType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef PlainObjectBase<Derived> PlainObjectType;$/;"	t	struct:Eigen::internal::evaluator
PlainObjectType	lib/Eigen/src/Core/Ref.h	/^  typedef _PlainObjectType PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectType	lib/Eigen/src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::PlainObjectType PlainObjectType;$/;"	t	class:Eigen::RefBase
PlainObjectType	lib/Eigen/src/SparseCore/SparseMap.h	/^  typedef SparseMatrix<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectType	lib/Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseMatrix<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	class:Eigen::Ref
PlainObjectType	lib/Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseVector<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	class:Eigen::Ref
PlainObjectType	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef SparseMatrix<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectType	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef SparseVector<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectTypeCleaned	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::remove_all<PlainObjectType>::type PlainObjectTypeCleaned;$/;"	t	struct:Eigen::internal::evaluator
PlainPermutationType	lib/Eigen/src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase
PlainPermutationType	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::InverseImpl
PlaqPlusRectangleAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^    PlaqPlusRectangleAction(RealD b,RealD c): c_plaq(b),c_rect(c){};$/;"	f	class:Grid::QCD::PlaqPlusRectangleAction
PlaqPlusRectangleAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^    class PlaqPlusRectangleAction : public Action<typename Gimpl::GaugeField> {$/;"	c	namespace:Grid::QCD
PlaqPlusRectangleActionD	lib/qcd/action/gauge/Gauge.h	/^typedef PlaqPlusRectangleAction<PeriodicGimplD>    PlaqPlusRectangleActionD;$/;"	t	namespace:Grid::QCD
PlaqPlusRectangleActionF	lib/qcd/action/gauge/Gauge.h	/^typedef PlaqPlusRectangleAction<PeriodicGimplF>    PlaqPlusRectangleActionF;$/;"	t	namespace:Grid::QCD
PlaqPlusRectangleActionR	lib/qcd/action/gauge/Gauge.h	/^typedef PlaqPlusRectangleAction<PeriodicGimplR>    PlaqPlusRectangleActionR;$/;"	t	namespace:Grid::QCD
PlaqPlusRectangleGMod	lib/qcd/modules/Registration.h	/^typedef QCD::PlaqPlusRectangleGModule<ImplementationPolicy> PlaqPlusRectangleGMod;$/;"	t
PlaqPlusRectangleGModule	lib/qcd/modules/ActionModules.h	/^class PlaqPlusRectangleGModule: public ActionModule<PlaqPlusRectangleAction<Impl>, PlaqPlusRectangleGaugeActionParameters> {$/;"	c	namespace:Grid::QCD
PlaqPlusRectangleGaugeActionParameters	lib/qcd/modules/ActionModules.h	/^class PlaqPlusRectangleGaugeActionParameters : Serializable {$/;"	c	namespace:Grid::QCD
PlaquetteLogger	lib/qcd/observables/plaquette.h	/^class PlaquetteLogger : public HmcObservable<typename Impl::Field> {$/;"	c	namespace:Grid::QCD
PlaquetteMod	lib/qcd/modules/ObservableModules.h	/^  PlaquetteMod(): ObsBase(NoParameters()){}$/;"	f	class:Grid::QCD::PlaquetteMod
PlaquetteMod	lib/qcd/modules/ObservableModules.h	/^class PlaquetteMod: public ObservableModule<PlaquetteLogger<Impl>, NoParameters>{$/;"	c	namespace:Grid::QCD
PlaquetteObsParameters	lib/qcd/modules/ObservableModules.h	/^class PlaquetteObsParameters : Serializable {$/;"	c	namespace:Grid::QCD
PlotApprox	lib/algorithms/approx/Chebyshev.h	/^    void   PlotApprox(std::ostream &out) {$/;"	f	class:Grid::Chebyshev
PmuStat	lib/perfmon/Stat.h	/^class PmuStat$/;"	c	namespace:Grid
Point	lib/qcd/action/fermion/WilsonCompressor.h	/^  void Point(int p) { mu=p; };$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
Point	lib/stencil/SimpleCompressor.h	/^  void Point(int) {};$/;"	f	class:Grid::SimpleCompressor
PointPar	extras/Hadrons/Modules/MSink/Point.hpp	/^class PointPar: Serializable$/;"	c
PointPar	extras/Hadrons/Modules/MSource/Point.hpp	/^class PointPar: Serializable$/;"	c
PointPar	lib/Hadrons/Modules/MSink/Point.hpp	/^class PointPar: Serializable$/;"	c
PointPar	lib/Hadrons/Modules/MSource/Point.hpp	/^class PointPar: Serializable$/;"	c
PointerArgType	lib/Eigen/src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map
PointerCache	lib/allocator/AlignedAllocator.h	/^  class PointerCache {$/;"	c	namespace:Grid
PointerCacheEntry	lib/allocator/AlignedAllocator.h	/^    } PointerCacheEntry;$/;"	t	class:Grid::PointerCache	typeref:struct:Grid::PointerCache::__anon11
PointerInfo	lib/allocator/AlignedAllocator.h	/^    } PointerInfo;$/;"	t	class:Grid::PointerCache	typeref:struct:Grid::PointerCache::__anon12
PointerType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::PointerType PointerType;$/;"	t	struct:Eigen::internal::mapbase_evaluator
PointerType	lib/Eigen/src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map
PointerType	lib/Eigen/src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase
PointerType	lib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase
PokeIndex	lib/lattice/Lattice_peekpoke.h	/^      void PokeIndex(Lattice<vobj> &lhs,const Lattice<decltype(peekIndex<Index>(lhs._odata[0],0,0))> & rhs,int i,int j)$/;"	f	namespace:Grid
PokeIndex	lib/lattice/Lattice_peekpoke.h	/^    void PokeIndex(Lattice<vobj> &lhs,const Lattice<decltype(peekIndex<Index>(lhs._odata[0],0))> & rhs,int i)$/;"	f	namespace:Grid
Polynomial	lib/algorithms/approx/Chebyshev.h	/^    Polynomial(std::vector<RealD> &_Coeffs) : Coeffs(_Coeffs) { };$/;"	f	class:Grid::Polynomial
Polynomial	lib/algorithms/approx/Chebyshev.h	/^  class Polynomial : public OperatorFunction<Field> {$/;"	c	namespace:Grid
PositiveSemiDef	lib/Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
PowRealFunctor	lib/simd/Grid_vector_unops.h	/^  PowRealFunctor(double _y) : y(_y){};$/;"	f	struct:Grid::PowRealFunctor
PowRealFunctor	lib/simd/Grid_vector_unops.h	/^struct PowRealFunctor {$/;"	s	namespace:Grid
PowerHalf	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  MultiShiftFunction PowerHalf;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
PowerHalf	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      MultiShiftFunction PowerHalf   ;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
PowerHalf	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      MultiShiftFunction PowerHalf   ;$/;"	m	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
PowerHalf	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      MultiShiftFunction PowerHalf   ;$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
PowerHalf	lib/qcd/utils/CovariantLaplacian.h	/^  MultiShiftFunction PowerHalf;    $/;"	m	class:Grid::QCD::LaplacianAdjointField
PowerInvHalf	lib/qcd/utils/CovariantLaplacian.h	/^  MultiShiftFunction PowerInvHalf;    $/;"	m	class:Grid::QCD::LaplacianAdjointField
PowerMethod	tests/solver/Test_dwf_hdcr.cc	/^  void PowerMethod(const FineField &in) {$/;"	f	class:MultiGridPreconditioner
PowerNegHalf	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  MultiShiftFunction PowerNegHalf;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
PowerNegHalf	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      MultiShiftFunction PowerNegHalf;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
PowerNegHalf	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      MultiShiftFunction PowerNegHalf;$/;"	m	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
PowerNegHalf	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      MultiShiftFunction PowerNegHalf;$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
PowerNegQuarter	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  MultiShiftFunction PowerNegQuarter;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
PowerNegQuarter	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      MultiShiftFunction PowerNegQuarter;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
PowerNegQuarter	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      MultiShiftFunction PowerNegQuarter;$/;"	m	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
PowerNegQuarter	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      MultiShiftFunction PowerNegQuarter;$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
PowerQuarter	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  MultiShiftFunction PowerQuarter;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
PowerQuarter	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      MultiShiftFunction PowerQuarter;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
PowerQuarter	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      MultiShiftFunction PowerQuarter;$/;"	m	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
PowerQuarter	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      MultiShiftFunction PowerQuarter;$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
PrecConjugateResidual	lib/algorithms/iterative/PrecConjugateResidual.h	/^    PrecConjugateResidual(RealD tol,Integer maxit,LinearFunction<Field> &Prec) : Tolerance(tol), MaxIterations(maxit),      Preconditioner(Prec)$/;"	f	class:Grid::PrecConjugateResidual
PrecConjugateResidual	lib/algorithms/iterative/PrecConjugateResidual.h	/^    class PrecConjugateResidual : public OperatorFunction<Field> {$/;"	c	namespace:Grid
PrecGeneralisedConjugateResidual	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    class PrecGeneralisedConjugateResidual : public OperatorFunction<Field> {$/;"	c	namespace:Grid
PrecGeneralisedConjugateResidual	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^   PrecGeneralisedConjugateResidual(RealD tol,Integer maxit,LinearFunction<Field> &Prec,int _mmax,int _nstep) : $/;"	f	class:Grid::PrecGeneralisedConjugateResidual
PrecTimer	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    GridStopWatch PrecTimer;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
PrecisionChange	lib/simd/Grid_avx.h	/^  struct PrecisionChange {$/;"	s	namespace:Grid::Optimization
PrecisionChange	lib/simd/Grid_avx512.h	/^  struct PrecisionChange {$/;"	s	namespace:Grid::Optimization
PrecisionChange	lib/simd/Grid_generic.h	/^  struct PrecisionChange {$/;"	s	namespace:Grid::Optimization
PrecisionChange	lib/simd/Grid_neon.h	/^  struct PrecisionChange {$/;"	s	namespace:Grid::Optimization
PrecisionChange	lib/simd/Grid_qpx.h	/^  struct PrecisionChange {$/;"	s	namespace:Grid::Optimization
PrecisionChange	lib/simd/Grid_sse4.h	/^  struct PrecisionChange {$/;"	s	namespace:Grid::Optimization
PrecomputeByteOffsets	lib/stencil/Stencil.h	/^  void PrecomputeByteOffsets(void){$/;"	f	class:Grid::CartesianStencil
PreconditionIfMoreColsThanRows	lib/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon614
PreconditionIfMoreRowsThanCols	lib/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon614
Preconditioner	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB
Preconditioner	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient
Preconditioner	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase
Preconditioner	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
Preconditioner	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	lib/algorithms/Preconditioner.h	/^  template<class Field> class Preconditioner :  public LinearFunction<Field> { $/;"	c	namespace:Grid
Preconditioner	lib/algorithms/iterative/PrecConjugateResidual.h	/^    LinearFunction<Field> &Preconditioner;$/;"	m	class:Grid::PrecConjugateResidual
Preconditioner	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    LinearFunction<Field> &Preconditioner;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
Prepare	lib/stencil/Stencil.h	/^  void Prepare(void)$/;"	f	class:Grid::CartesianStencil
PrepareMetaData	lib/parallelIO/MetaData.h	/^ template<> inline void PrepareMetaData<vLorentzColourMatrixD>(Lattice<vLorentzColourMatrixD> & field, FieldMetaData &header)$/;"	f	namespace:Grid::QCD
PrepareMetaData	lib/parallelIO/MetaData.h	/^ template<> inline void PrepareMetaData<vLorentzColourMatrixF>(Lattice<vLorentzColourMatrixF> & field, FieldMetaData &header)$/;"	f	namespace:Grid::QCD
PrepareMetaData	lib/parallelIO/MetaData.h	/^template<class vobj> inline void PrepareMetaData(Lattice<vobj> & field, FieldMetaData &header)$/;"	f	namespace:Grid::QCD
ProcessorCoorFromRank	lib/communicator/Communicator_mpi.cc	/^void  CartesianCommunicator::ProcessorCoorFromRank(int rank, std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
ProcessorCoorFromRank	lib/communicator/Communicator_mpi3.cc	/^void  CartesianCommunicator::ProcessorCoorFromRank(int rank, std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
ProcessorCoorFromRank	lib/communicator/Communicator_mpi3_leader.cc	/^void  CartesianCommunicator::ProcessorCoorFromRank(int rank, std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
ProcessorCoorFromRank	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::ProcessorCoorFromRank(int rank, std::vector<int> &coor){  coor = _processor_coor; }$/;"	f	class:Grid::CartesianCommunicator
ProcessorCoorFromRank	lib/communicator/Communicator_shmem.cc	/^void  CartesianCommunicator::ProcessorCoorFromRank(int rank, std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
ProcessorCoorLocalCoorToGlobalCoor	lib/cartesian/Cartesian_base.h	/^    void ProcessorCoorLocalCoorToGlobalCoor(std::vector<int> &Pcoor,std::vector<int> &Lcoor,std::vector<int> &gcoor)$/;"	f	class:Grid::GridBase
ProcessorCount	lib/communicator/Communicator_base.cc	/^int                      CartesianCommunicator::ProcessorCount(void)    { return _Nprocessors; };$/;"	f	class:Grid::CartesianCommunicator
ProcessorGrid	lib/communicator/Communicator_base.cc	/^const std::vector<int> & CartesianCommunicator::ProcessorGrid(void)     { return _processors; };$/;"	f	class:Grid::CartesianCommunicator
ProdReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_prod>::Type ProdReturnType;$/;"	t	class:Eigen::VectorwiseOp
ProdXprType	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Product<LhsT,RhsT,DefaultProduct> ProdXprType;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
Product	lib/Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)$/;"	f	class:Eigen::Product
Product	lib/Eigen/src/Core/Product.h	/^class Product : public ProductImpl<_Lhs,_Rhs,Option,$/;"	c	namespace:Eigen
Product	lib/qcd/hmc/HMCRunnerModule.h	/^  typedef typename Base::Product Product;$/;"	t	class:Grid::HMCModule
Product	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  typedef typename Base::Product Product;$/;"	t	class:Grid::CheckPointerModule
Product	lib/qcd/modules/ActionModules.h	/^  typedef typename Base::Product Product;$/;"	t	class:Grid::ActionModule
Product	lib/qcd/modules/FermionOperatorModules.h	/^  typedef typename Base::Product Product;$/;"	t	class:Grid::FermionOperatorModule
Product	lib/qcd/modules/Modules.h	/^  typedef Prod Product;$/;"	t	class:Grid::HMCModuleBase
Product	lib/qcd/modules/ObservableModules.h	/^  typedef typename Base::Product Product;$/;"	t	class:Grid::ObservableModule
Product	lib/qcd/modules/SolverModules.h	/^  typedef typename Base::Product Product;$/;"	t	class:Grid::SolverModule
ProductImpl	lib/Eigen/src/Core/Product.h	/^class ProductImpl : public internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type$/;"	c	namespace:Eigen
ProductImpl	lib/Eigen/src/Core/Product.h	/^class ProductImpl<Lhs,Rhs,Option,Dense>$/;"	c	namespace:Eigen
ProductImplType	lib/Eigen/src/Core/util/Constants.h	/^enum ProductImplType$/;"	g	namespace:Eigen
ProductType	lib/Eigen/src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
ProductXpr	lib/Eigen/src/Core/Product.h	/^  typedef Product<Lhs,Rhs,Option> ProductXpr;$/;"	t	class:Eigen::internal::dense_product_base
Proj	lib/qcd/action/fermion/WilsonCompressor.h	/^  static void Proj(hsp &result,const fsp &in,int mu,int dag){$/;"	f	class:Grid::QCD::WilsonProjector
ProjectOnGroup	lib/tensors/Tensor_Ta.h	/^    inline iMatrix<vtype,N> ProjectOnGroup(const iMatrix<vtype,N> &arg)$/;"	f	namespace:Grid
ProjectOnGroup	lib/tensors/Tensor_Ta.h	/^  template<class vtype,int N> inline iVector<vtype,N> ProjectOnGroup(const iVector<vtype,N>&r)$/;"	f	namespace:Grid
ProjectOnGroup	lib/tensors/Tensor_Ta.h	/^  template<class vtype> inline iScalar<vtype> ProjectOnGroup(const iScalar<vtype>&r)$/;"	f	namespace:Grid
ProjectToSubspace	lib/algorithms/CoarsenedMatrix.h	/^    void ProjectToSubspace(CoarseVector &CoarseVec,const FineField &FineVec){$/;"	f	class:Grid::Aggregation
Projective	lib/Eigen/src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
Projective2d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Projective2f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Projective3d	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Projective3f	lib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
PromoteFromSubspace	lib/algorithms/CoarsenedMatrix.h	/^    void PromoteFromSubspace(const CoarseVector &CoarseVec,FineField &FineVec){$/;"	f	class:Grid::Aggregation
PropToFerm	lib/qcd/QCD.h	/^    void PropToFerm(Ferm &f, const Prop &p, const int s, const int c)$/;"	f	namespace:Grid::QCD
PropagatorField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SitePropagator>        PropagatorField;$/;"	t	class:Grid::QCD::WilsonImpl
PropagatorField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SitePropagator> PropagatorField;$/;"	t	class:Grid::QCD::StaggeredImpl
PropagatorField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef Lattice<SitePropagator> PropagatorField;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
PropagatorField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef Lattice<SitePropagator>      PropagatorField;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
PropagatorField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef Lattice<SitePropagator> PropagatorField;$/;"	t	class:Grid::QCD::GparityWilsonImpl
PropagatorField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Field                PropagatorField;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
PropagatorField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef Field              PropagatorField;$/;"	t	class:Grid::ScalarImplTypes
PseudoFermionModuleBase	lib/qcd/modules/ActionModules.h	/^class PseudoFermionModuleBase: public ActionModule<FermionA<Impl>, Params> {$/;"	c	namespace:Grid::QCD
QCD	lib/parallelIO/IldgIO.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/parallelIO/MetaData.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/parallelIO/NerscIO.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/LatticeTheories.h	/^struct QCD : public FermionicLatticeGaugeTheory<4, 3, 4> {$/;"	s	namespace:Grid::LatticeTheories
QCD	lib/qcd/QCD.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/ActionBase.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/ActionParams.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/ActionSet.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/CayleyFermion5D.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/CayleyFermion5D.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/CayleyFermion5Dcache.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/CayleyFermion5Ddense.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/CayleyFermion5Dssp.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/CayleyFermion5Dvec.cc	/^namespace QCD {  $/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^  namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/DomainWallFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/Fermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/FermionOperator.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/ImprovedStaggeredFermion.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/MobiusFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/MobiusZolotarevFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/OverlapWilsonCayleyTanhFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/OverlapWilsonCayleyZolotarevFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/OverlapWilsonContfracTanhFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/OverlapWilsonContfracZolotarevFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/OverlapWilsonPartialFractionTanhFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/OverlapWilsonPartialFractionZolotarevFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^  namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/ScaledShamirFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/ShamirZolotarevFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/StaggeredKernels.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/StaggeredKernels.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/StaggeredKernelsHand.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/WilsonCompressor.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/WilsonFermion.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/WilsonFermion.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/WilsonFermion5D.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/WilsonFermion5D.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/WilsonKernels.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/WilsonKernels.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/WilsonKernelsAsm.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/WilsonKernelsHand.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/WilsonTMFermion.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/action/fermion/WilsonTMFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/ZMobiusFermion.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/fermion/g5HermitianLinop.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/gauge/Gauge.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/gauge/GaugeImplTypes.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/gauge/GaugeImplementations.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/gauge/Photon.h	/^namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^  namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/gauge/WilsonGaugeAction.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	/^  namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^  namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^  namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^  namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/TwoFlavour.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^  namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^  namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^  namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/action/scalar/Scalar.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/GenericHMCrunner.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/HMC.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/HMCModules.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/HMCResourceManager.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/integrators/Integrator.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/modules/ActionModules.h	/^namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/modules/FermionOperatorModules.h	/^namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/modules/ObservableModules.h	/^namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/observables/plaquette.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/observables/topological_charge.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/representations/adjoint.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/representations/fundamental.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/representations/hmc_types.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/representations/two_index.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/smearing/APEsmearing.h	/^  	namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/smearing/GaugeConfiguration.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/smearing/StoutSmearing.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/smearing/WilsonFlow.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/spin/Dirac.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/spin/Gamma.cc	/^namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/spin/Gamma.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/spin/TwoSpinor.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/utils/CovariantCshift.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/utils/CovariantLaplacian.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/utils/LinalgUtils.h	/^namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/utils/Metric.h	/^namespace QCD{$/;"	n	namespace:Grid
QCD	lib/qcd/utils/SUn.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/utils/SUnAdjoint.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/utils/SUnTwoIndex.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/utils/SpaceTimeGrid.cc	/^  namespace QCD {$/;"	n	namespace:Grid	file:
QCD	lib/qcd/utils/SpaceTimeGrid.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD	lib/qcd/utils/WilsonLoops.h	/^namespace QCD {$/;"	n	namespace:Grid
QCD_ACTION_CORE	lib/qcd/action/ActionCore.h	31;"	d
QCD_EVEN_ODD_SCHUR_DIFFERENTIABLE_H	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	30;"	d
QCD_PHOTON_ACTION_H	lib/qcd/action/gauge/Photon.h	29;"	d
QCD_PLAQ_PLUS_RECTANGLE_ACTION_H	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	30;"	d
QCD_PSEUDOFERMION_AGGREGATE_H	lib/qcd/action/pseudofermion/PseudoFermion.h	30;"	d
QCD_PSEUDOFERMION_ONE_FLAVOUR_EVEN_ODD_RATIONAL_H	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	31;"	d
QCD_PSEUDOFERMION_ONE_FLAVOUR_EVEN_ODD_RATIONAL_RATIO_H	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	29;"	d
QCD_PSEUDOFERMION_ONE_FLAVOUR_RATIONAL_H	lib/qcd/action/pseudofermion/OneFlavourRational.h	29;"	d
QCD_PSEUDOFERMION_ONE_FLAVOUR_RATIONAL_RATIO_H	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	29;"	d
QCD_PSEUDOFERMION_TWO_FLAVOUR_EVEN_ODD_H	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	31;"	d
QCD_PSEUDOFERMION_TWO_FLAVOUR_EVEN_ODD_RATIO_H	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	30;"	d
QCD_PSEUDOFERMION_TWO_FLAVOUR_H	lib/qcd/action/pseudofermion/TwoFlavour.h	31;"	d
QCD_PSEUDOFERMION_TWO_FLAVOUR_RATIO_H	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	31;"	d
QCD_SPIN_H	lib/qcd/spin/Spin.h	2;"	d
QCD_UTILS_COVARIANT_CSHIFT_H	lib/qcd/utils/CovariantCshift.h	30;"	d
QCD_UTILS_H	lib/qcd/utils/Utils.h	2;"	d
QCD_UTILS_WILSON_LOOPS_H	lib/qcd/utils/WilsonLoops.h	33;"	d
QCD_UTIL_SUN2INDEX_H	lib/qcd/utils/SUnTwoIndex.h	26;"	d
QCD_UTIL_SUNADJOINT_H	lib/qcd/utils/SUnAdjoint.h	2;"	d
QCD_UTIL_SUN_H	lib/qcd/utils/SUn.h	33;"	d
QCD_WILSON_GAUGE_ACTION_H	lib/qcd/action/gauge/WilsonGaugeAction.h	34;"	d
QED	lib/qcd/LatticeTheories.h	/^struct QED : public FermionicLatticeGaugeTheory<4, 1, 4> {\/\/fill$/;"	s	namespace:Grid::LatticeTheories
QEDFVOL_ERROR	extras/qed-fvol/Global.hpp	27;"	d
QEDFVOL_WILSONLOOPS_H	extras/qed-fvol/WilsonLoops.h	2;"	d
QRMatrixType	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> QRMatrixType;$/;"	t	class:Eigen::SparseQR
QRPreconditioners	lib/Eigen/src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
QRType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QedFVolLogger	extras/qed-fvol/Global.hpp	/^    QedFVolLogger(int on, std::string nm): Logger("QedFVol", on, nm,$/;"	f	class:QedFVolLogger
QedFVolLogger	extras/qed-fvol/Global.hpp	/^class QedFVolLogger: public Logger$/;"	c
QedFVol_Global_hpp_	extras/qed-fvol/Global.hpp	2;"	d
QedGimpl	lib/qcd/action/gauge/Photon.h	/^  class QedGimpl$/;"	c	namespace:Grid::QCD
QedGimplR	lib/qcd/action/gauge/Photon.h	/^  typedef QedGimpl<vComplex> QedGimplR;$/;"	t	namespace:Grid::QCD
QedPeriodicGimplR	extras/qed-fvol/qed-fvol.cc	/^typedef PeriodicGaugeImpl<QedGimplR>    QedPeriodicGimplR;$/;"	t	file:
QrType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^  typedef ColPivHouseholderQR<MatrixType> QrType;$/;"	t	struct:Eigen::internal::Assignment
QrType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef FullPivHouseholderQR<MatrixType> QrType;$/;"	t	struct:Eigen::internal::Assignment
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Quaternion() {}$/;"	f	class:Eigen::Quaternion
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Quaternion(const Scalar& w, const Scalar& x, const Scalar& y, const Scalar& z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion
Quaternion	lib/Eigen/src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen
QuaternionBase	lib/Eigen/src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen
QuaternionMapAlignedd	lib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
QuaternionMapAlignedf	lib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
QuaternionMapd	lib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
QuaternionMapf	lib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
QuaternionType	lib/Eigen/src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis
Quaterniond	lib/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaternionf	lib/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
QueueCommand	lib/communicator/Communicator_mpi3_leader.cc	/^uint64_t Slave::QueueCommand(int command,void *buf, int bytes, int tag, MPI_Comm comm,int commrank) $/;"	f	class:Grid::Slave
QueueMultiplexedRecv	lib/communicator/Communicator_mpi3_leader.cc	/^  static void QueueMultiplexedRecv(void *buf, int bytes, int tag, MPI_Comm comm,int rank) {$/;"	f	class:Grid::MPIoffloadEngine
QueueMultiplexedSend	lib/communicator/Communicator_mpi3_leader.cc	/^  static void QueueMultiplexedSend(void *buf, int bytes, int tag, MPI_Comm comm,int rank) {$/;"	f	class:Grid::MPIoffloadEngine
QueueMultiplexedSendRecv	lib/communicator/Communicator_mpi3_leader.cc	/^  static void QueueMultiplexedSendRecv(void *xbuf, void *rbuf, int bytes, int xtag, int rtag, MPI_Comm comm,int dest,int src) {$/;"	f	class:Grid::MPIoffloadEngine
QueueRecv	lib/communicator/Communicator_mpi3_leader.cc	/^  static void QueueRecv(int slave, void *buf, int bytes, int tag, MPI_Comm comm,int rank) {$/;"	f	class:Grid::MPIoffloadEngine
QueueRoundRobinSendRecv	lib/communicator/Communicator_mpi3_leader.cc	/^  static void QueueRoundRobinSendRecv(void *xbuf, void *rbuf, int bytes, int xtag, int rtag, MPI_Comm comm,int dest,int src) {$/;"	f	class:Grid::MPIoffloadEngine
QueueSend	lib/communicator/Communicator_mpi3_leader.cc	/^  static void QueueSend(int slave,void *buf, int bytes, int tag, MPI_Comm comm,int rank) {$/;"	f	class:Grid::MPIoffloadEngine
QueueSendRecv	lib/communicator/Communicator_mpi3_leader.cc	/^  static void QueueSendRecv(int slave,void *xbuf, void *rbuf, int bytes, int xtag, int rtag, MPI_Comm comm,int dest,int src) $/;"	f	class:Grid::MPIoffloadEngine
QueueSendRecv	lib/communicator/Communicator_mpi3_leader.cc	/^void Slave::QueueSendRecv(void *xbuf, void *rbuf, int bytes, int xtag, int rtag, MPI_Comm comm,int dest,int src) $/;"	f	class:Grid::Slave
QuickSplit	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^Index QuickSplit(VectorV &row, VectorI &ind, Index ncut)$/;"	f	namespace:Eigen::internal
R	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      RealD R;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
R	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      RealD R;$/;"	m	class:Grid::QCD::PartialFractionFermion5D
RBCGMod	lib/qcd/modules/Registration.h	/^typedef QCD::RBCGModule<ImplementationPolicy> RBCGMod;$/;"	t
RBCGModule	lib/qcd/modules/ActionModules.h	/^class RBCGModule: public ActionModule<RBCGaugeAction<Impl>, RBCGaugeActionParameters> {$/;"	c	namespace:Grid::QCD
RBCGaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      RBCGaugeAction(RealD beta,RealD c1) : PlaqPlusRectangleAction<Gimpl>(beta*(1.0-8.0*c1), beta*c1) {};$/;"	f	class:Grid::QCD::RBCGaugeAction
RBCGaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^    class RBCGaugeAction : public PlaqPlusRectangleAction<Gimpl> {$/;"	c	namespace:Grid::QCD
RBCGaugeActionParameters	lib/qcd/modules/ActionModules.h	/^class RBCGaugeActionParameters : Serializable {$/;"	c	namespace:Grid::QCD
RBPrecCGPar	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^class RBPrecCGPar: Serializable$/;"	c
RBPrecCGPar	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^class RBPrecCGPar: Serializable$/;"	c
RConnections	lib/communicator/Communicator_shmem.cc	/^static Vector< HandShake > RConnections;$/;"	m	namespace:Grid	file:
REDUCE	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	546;"	d	file:
REDUCEa	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	563;"	d	file:
REG	lib/util/Init.cc	426;"	d	file:
REGISTER	lib/qcd/action/fermion/StaggeredKernelsHand.cc	31;"	d	file:
REGISTER	lib/qcd/action/fermion/WilsonKernelsHand.cc	31;"	d	file:
REP	lib/simd/BGQQPX.h	110;"	d
REP	lib/simd/IBM_qpx.h	74;"	d
REPRESENTATIONS_H	lib/qcd/representations/Representations.h	2;"	d
RESULT	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	125;"	d
RESULT	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	196;"	d
RESULT	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	63;"	d
RESULT	lib/qcd/action/fermion/WilsonKernelsAsmBody.h	94;"	d
RMHMCActionParameters	tests/hmc/Test_hmc_DBW2_Implicit.cc	/^  RMHMCActionParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::RMHMCActionParameters
RMHMCActionParameters	tests/hmc/Test_hmc_DBW2_Implicit.cc	/^struct RMHMCActionParameters: Serializable {$/;"	s	namespace:Grid	file:
RMHMCActionParameters	tests/hmc/Test_hmc_WilsonGauge_Implicit.cc	/^  RMHMCActionParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::RMHMCActionParameters
RMHMCActionParameters	tests/hmc/Test_hmc_WilsonGauge_Implicit.cc	/^struct RMHMCActionParameters: Serializable {$/;"	s	namespace:Grid	file:
RNGModule	lib/qcd/hmc/HMCModules.h	/^  RNGModule(){};$/;"	f	class:Grid::QCD::RNGModule
RNGModule	lib/qcd/hmc/HMCModules.h	/^class RNGModule{$/;"	c	namespace:Grid::QCD
RNGModuleParameters	lib/qcd/hmc/HMCModules.h	/^  RNGModuleParameters(): serial_seeds("1"), parallel_seeds("1"){}$/;"	f	struct:Grid::QCD::RNGModuleParameters
RNGModuleParameters	lib/qcd/hmc/HMCModules.h	/^  RNGModuleParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::QCD::RNGModuleParameters
RNGModuleParameters	lib/qcd/hmc/HMCModules.h	/^struct RNGModuleParameters: Serializable {$/;"	s	namespace:Grid::QCD
RNG_FAST_DISCARD	lib/lattice/Lattice_rng.h	39;"	d
RNG_FAST_DISCARD	lib/lattice/Lattice_rng.h	41;"	d
RNGfillable	lib/lattice/Lattice_rng.h	/^  inline int RNGfillable(GridBase *coarse,GridBase *fine)$/;"	f	namespace:Grid
RNGfillable_general	lib/lattice/Lattice_rng.h	/^  inline int RNGfillable_general(GridBase *coarse,GridBase *fine)$/;"	f	namespace:Grid
RNGs	lib/qcd/hmc/HMCResourceManager.h	/^  RNGModule RNGs;$/;"	m	class:Grid::QCD::HMCResourceManager
ROW_IS_ALIVE	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	118;"	d
ROW_IS_DEAD	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	116;"	d
ROW_IS_MARKED_DEAD	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	117;"	d
RSqrtRealFunctor	lib/simd/Grid_vector_unops.h	/^struct RSqrtRealFunctor {$/;"	s	namespace:Grid
Random	lib/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase
Random	lib/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Random	lib/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase
RandomAccessLinSpacedReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
RandomAccessPattern	lib/Eigen/src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
RandomGaugeTransform	lib/qcd/utils/SUn.h	/^  static void RandomGaugeTransform(GridParallelRNG &pRNG, GaugeField &Umu, GaugeMat &g){$/;"	f	class:Grid::QCD::SU
RandomReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_random_op<Scalar>,PlainObject> RandomReturnType;$/;"	t	class:Eigen::DenseBase
RankCount	lib/communicator/Communicator_base.cc	/^int                      CartesianCommunicator::RankCount(void)    { return ProcessorCount();};$/;"	f	class:Grid::CartesianCommunicator
RankCount	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::RankCount(void)    { return WorldSize;};$/;"	f	class:Grid::CartesianCommunicator
RankFromProcessorCoor	lib/communicator/Communicator_mpi.cc	/^int CartesianCommunicator::RankFromProcessorCoor(std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
RankFromProcessorCoor	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::RankFromProcessorCoor(std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
RankFromProcessorCoor	lib/communicator/Communicator_mpi3_leader.cc	/^int CartesianCommunicator::RankFromProcessorCoor(std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
RankFromProcessorCoor	lib/communicator/Communicator_none.cc	/^int  CartesianCommunicator::RankFromProcessorCoor(std::vector<int> &coor) {  return 0;}$/;"	f	class:Grid::CartesianCommunicator
RankFromProcessorCoor	lib/communicator/Communicator_shmem.cc	/^int CartesianCommunicator::RankFromProcessorCoor(std::vector<int> &coor)$/;"	f	class:Grid::CartesianCommunicator
RankIndexCbToFullGlobalCoor	lib/cartesian/Cartesian_base.h	/^    void RankIndexCbToFullGlobalCoor(int rank, int o_idx, int i_idx, int cb,std::vector<int> &fcoor)$/;"	f	class:Grid::GridBase
RankIndexToGlobalCoor	lib/cartesian/Cartesian_base.h	/^    void RankIndexToGlobalCoor(int rank, int o_idx, int i_idx , std::vector<int> &gcoor)$/;"	f	class:Grid::GridBase
RankWorld	lib/communicator/Communicator_mpi.cc	/^int CartesianCommunicator::RankWorld(void){ $/;"	f	class:Grid::CartesianCommunicator
RankWorld	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::RankWorld(void){ $/;"	f	class:Grid::CartesianCommunicator
RankWorld	lib/communicator/Communicator_none.cc	/^int  CartesianCommunicator::RankWorld(void){return 0;}$/;"	f	class:Grid::CartesianCommunicator
RankWorld	lib/communicator/Communicator_shmem.cc	/^int CartesianCommunicator::RankWorld(void){ $/;"	f	class:Grid::CartesianCommunicator
RawConfig	lib/perfmon/PerfCount.cc	35;"	d	file:
ReadCommandLine	lib/qcd/hmc/GenericHMCrunner.h	/^  void ReadCommandLine(int argc, char **argv) {$/;"	f	class:Grid::QCD::HMCWrapperTemplate
ReadCost	lib/Eigen/src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon136
ReadOnlyAccessors	lib/Eigen/src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
ReadOnlyMapBase	lib/Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;$/;"	t	class:Eigen::MapBase
ReadOnlyMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;$/;"	t	class:Eigen::SparseMapBase
Reader	lib/serialisation/BaseIO.h	/^  Reader<T>::Reader(void)$/;"	f	class:Grid::Reader
Reader	lib/serialisation/BaseIO.h	/^  class Reader$/;"	c	namespace:Grid
Real	lib/Eigen/src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits
Real	lib/simd/Grid_vector_types.h	/^  typedef typename RealPart<Scalar_type>::type Real;$/;"	t	class:Grid::Grid_simd
Real	lib/simd/Simd.h	/^  typedef RealD   Real;$/;"	t	namespace:Grid
Real	lib/simd/Simd.h	/^  typedef RealF  Real;$/;"	t	namespace:Grid
RealD	lib/simd/Simd.h	/^  typedef  double RealD;$/;"	t	namespace:Grid
RealF	lib/simd/Simd.h	/^  typedef  float  RealF;$/;"	t	namespace:Grid
RealFunctor	lib/simd/Grid_vector_unops.h	/^struct RealFunctor {$/;"	s	namespace:Grid
RealPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits
RealPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
RealPart	lib/simd/Grid_vector_types.h	/^struct RealPart {$/;"	s	namespace:Grid
RealPart	lib/simd/Grid_vector_types.h	/^struct RealPart<std::complex<T> > {$/;"	s	namespace:Grid
RealQZ	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      RealQZ(const MatrixType& A, const MatrixType& B, bool computeQZ = true) :$/;"	f	class:Eigen::RealQZ
RealQZ	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      explicit RealQZ(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime) :$/;"	f	class:Eigen::RealQZ
RealQZ	lib/Eigen/src/Eigenvalues/RealQZ.h	/^  template<typename _MatrixType> class RealQZ$/;"	c	namespace:Eigen
RealReturnType	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type RealReturnType;$/;"	t
RealRowVectorType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RealRowVectorType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      RealRowVectorType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
RealScalar	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT
RealScalar	lib/Eigen/src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT
RealScalar	lib/Eigen/src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace
RealScalar	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase
RealScalar	lib/Eigen/src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase
RealScalar	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase
RealScalar	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase
RealScalar	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::RealScalar RealScalar;$/;"	t	class:Eigen::DiagonalBase
RealScalar	lib/Eigen/src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector
RealScalar	lib/Eigen/src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::arg_default_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef T RealScalar;$/;"	t	struct:Eigen::internal::imag_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef T RealScalar;$/;"	t	struct:Eigen::internal::real_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl_default
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_default_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_default_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl
RealScalar	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl
RealScalar	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase
RealScalar	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase
RealScalar	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView
RealScalar	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp
RealScalar	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver
RealScalar	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur
RealScalar	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver
RealScalar	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
RealScalar	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition
RealScalar	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
RealScalar	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization
RealScalar	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
RealScalar	lib/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox
RealScalar	lib/Eigen/src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane
RealScalar	lib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
RealScalar	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine
RealScalar	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase
RealScalar	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::LeastSquareDiagonalPreconditioner
RealScalar	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB
RealScalar	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient
RealScalar	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar; $/;"	t	class:Eigen::IncompleteCholesky
RealScalar	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT
RealScalar	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase
RealScalar	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
RealScalar	lib/Eigen/src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation
RealScalar	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl
RealScalar	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase
RealScalar	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits
RealScalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT
RealScalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT
RealScalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU
RealScalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl
RealScalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits
RealScalar	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR
RealScalar	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
RealScalar	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR
RealScalar	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR
RealScalar	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SPQR
RealScalar	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::BDCSVD
RealScalar	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD
RealScalar	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
RealScalar	lib/Eigen/src/SVD/SVDBase.h	/^  typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVDBase
RealScalar	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RealScalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky
RealScalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
RealScalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT
RealScalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT
RealScalar	lib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector
RealScalar	lib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
RealScalar	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage
RealScalar	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase
RealScalar	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
RealScalar	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::RealScalar RealScalar; $/;"	t	class:Eigen::SparseLU
RealScalar	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef typename ScalarVector::RealScalar RealScalar; $/;"	t	class:Eigen::internal::SparseLUImpl
RealScalar	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SparseQR
RealScalar	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU
RealScalar	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU
RealScalar	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase
RealScalar	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU
RealSchur	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    explicit RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur
RealSchur	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    explicit RealSchur(const EigenBase<InputType>& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur
RealSchur	lib/Eigen/src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
RealVectorType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Realified	lib/tensors/Tensor_class.h	/^  typedef iMatrix<typename GridTypeMapper<vtype>::Realified, N> Realified;$/;"	t	class:Grid::iMatrix
Realified	lib/tensors/Tensor_class.h	/^  typedef iScalar<typename GridTypeMapper<vtype>::Realified> Realified;$/;"	t	class:Grid::iScalar
Realified	lib/tensors/Tensor_class.h	/^  typedef iVector<typename GridTypeMapper<vtype>::Realified, N> Realified;$/;"	t	class:Grid::iVector
Realified	lib/tensors/Tensor_traits.h	/^    typedef RealD Realified;$/;"	t	class:Grid::GridTypeMapper
Realified	lib/tensors/Tensor_traits.h	/^    typedef RealF Realified;$/;"	t	class:Grid::GridTypeMapper
Realified	lib/tensors/Tensor_traits.h	/^    typedef typename T::Realified Realified;$/;"	t	class:Grid::GridTypeMapper
Realified	lib/tensors/Tensor_traits.h	/^    typedef vRealD Realified;$/;"	t	class:Grid::GridTypeMapper
Realified	lib/tensors/Tensor_traits.h	/^    typedef vRealF Realified;$/;"	t	class:Grid::GridTypeMapper
Realified	lib/tensors/Tensor_traits.h	/^    typedef vRealH Realified;$/;"	t	class:Grid::GridTypeMapper
Realified	lib/tensors/Tensor_traits.h	/^    typedef void Realified;$/;"	t	class:Grid::GridTypeMapper
Reconstruct	lib/serialisation/BaseIO.h	/^  Reconstruct<V>::Reconstruct(const std::vector<Element> &flatVector,$/;"	f	class:Grid::Reconstruct
Reconstruct	lib/serialisation/BaseIO.h	/^  class Reconstruct$/;"	c	namespace:Grid
RectPlaq	tests/core/Test_RectPlaq.cc	/^void RectPlaq(const std::vector<LatticeColourMatrix> &U, LatticeComplex &RectPlaqValue )$/;"	f
RectPlaqDeriv	tests/core/Test_RectPlaq.cc	/^void RectPlaqDeriv(const std::vector<LatticeColourMatrix> &U, LatticeComplex &RectPlaqValue )$/;"	f
RectStaple	lib/qcd/utils/WilsonLoops.h	/^  static void RectStaple(GaugeMat &Stap, const GaugeLorentz &Umu, int mu) {$/;"	f	class:Grid::QCD::WilsonLoops
RectStaple	lib/qcd/utils/WilsonLoops.h	/^  static void RectStaple(const GaugeLorentz &Umu, GaugeMat &Stap,$/;"	f	class:Grid::QCD::WilsonLoops
RectStapleDouble	lib/qcd/utils/WilsonLoops.h	/^  static void RectStapleDouble(GaugeMat &U2, const GaugeMat &U, int mu) {$/;"	f	class:Grid::QCD::WilsonLoops
RectStapleOptimised	lib/qcd/utils/WilsonLoops.h	/^  static void RectStapleOptimised(GaugeMat &Stap, std::vector<GaugeMat> &U2,$/;"	f	class:Grid::QCD::WilsonLoops
RectStapleUnoptimised	lib/qcd/utils/WilsonLoops.h	/^  static void RectStapleUnoptimised(GaugeMat &Stap, const GaugeLorentz &Umu,$/;"	f	class:Grid::QCD::WilsonLoops
Recursive	gcc-bug-report/broken.cc	/^template<class obj> class Recursive {$/;"	c	file:
RedBlackGrid	lib/qcd/action/fermion/FermionOperator.h	/^      GridBase * RedBlackGrid(void) { return FermionRedBlackGrid(); };$/;"	f	class:Grid::QCD::FermionOperator
Reduce	lib/simd/Grid_avx.h	/^  struct Reduce{$/;"	s	namespace:Grid::Optimization
Reduce	lib/simd/Grid_avx512.h	/^  struct Reduce{$/;"	s	namespace:Grid::Optimization
Reduce	lib/simd/Grid_generic.h	/^  struct Reduce{$/;"	s	namespace:Grid::Optimization
Reduce	lib/simd/Grid_imci.h	/^  struct Reduce{$/;"	s	namespace:Grid::Optimization
Reduce	lib/simd/Grid_neon.h	/^  struct Reduce{$/;"	s	namespace:Grid::Optimization
Reduce	lib/simd/Grid_qpx.h	/^  struct Reduce{$/;"	s	namespace:Grid::Optimization
Reduce	lib/simd/Grid_sse4.h	/^  struct Reduce{$/;"	s	namespace:Grid::Optimization
Reduce	lib/simd/Grid_vector_types.h	/^  friend inline Scalar_type Reduce(const Grid_simd &in) {$/;"	f	class:Grid::Grid_simd
Reduce	lib/simd/Simd.h	/^  inline ComplexD Reduce(const ComplexD& r){ return r; }$/;"	f	namespace:Grid
Reduce	lib/simd/Simd.h	/^  inline ComplexF Reduce(const ComplexF& r){ return r; }$/;"	f	namespace:Grid
Reduce	lib/simd/Simd.h	/^  inline RealD Reduce(const RealD& r){ return r; }$/;"	f	namespace:Grid
Reduce	lib/simd/Simd.h	/^  inline RealF Reduce(const RealF& r){ return r; }$/;"	f	namespace:Grid
ReductionTester	tests/Test_simd.cc	/^void ReductionTester(const functor &func)$/;"	f
ReduxReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp
Ref	lib/Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(PlainObjectBase<Derived>& expr,$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(const DenseBase<Derived>& expr,$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(const Ref& other) : Base(other) {$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(const RefBase<OtherRef>& other) {$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/Core/Ref.h	/^template<typename PlainObjectType, int Options, typename StrideType> class Ref$/;"	c	namespace:Eigen
Ref	lib/Eigen/src/Core/Ref.h	/^template<typename TPlainObjectType, int Options, typename StrideType> class Ref<const TPlainObjectType, Options, StrideType>$/;"	c	namespace:Eigen
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(MappedSparseMatrix<MatScalar,OtherOptions,MatIndex>& expr)$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(SparseMatrix<MatScalar,OtherOptions,MatIndex>& expr)$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(SparseVector<MatScalar,OtherOptions,MatIndex>& expr)$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const Ref& other) : Base(other), m_hasCopy(false) {$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const RefBase<OtherRef>& other) : m_hasCopy(false) {$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const SparseCompressedBase<Derived>& expr)$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const SparseMatrixBase<Derived>& expr) : m_hasCopy(false)$/;"	f	class:Eigen::Ref
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^class Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType >$/;"	c	namespace:Eigen
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^class Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType >$/;"	c	namespace:Eigen
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^class Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^class Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
RefBase	lib/Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC RefBase()$/;"	f	class:Eigen::RefBase
RefBase	lib/Eigen/src/Core/Ref.h	/^template<typename Derived> class RefBase$/;"	c	namespace:Eigen
RefactoredXpr	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename helper::Xpr RefactoredXpr;$/;"	t	struct:Eigen::internal::product_evaluator
RegisterLoadCheckPointerFunction	lib/qcd/hmc/HMCResourceManager.h	36;"	d
Registrar	lib/qcd/modules/Modules.h	/^  Registrar(std::string className) {$/;"	f	class:Grid::Registrar
Registrar	lib/qcd/modules/Modules.h	/^class Registrar {$/;"	c	namespace:Grid
RemoveCRV	lib/tensors/Tensor_index.h	236;"	d
RemoveCRV	lib/tensors/Tensor_index.h	405;"	d
Reorder	lib/stencil/Lebesgue.h	/^    inline IndexInteger Reorder(IndexInteger ss) { $/;"	f	class:Grid::LebesgueOrder
Replicate	lib/Eigen/src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate
Replicate	lib/Eigen/src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& matrix)$/;"	f	class:Eigen::Replicate
Replicate	lib/Eigen/src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen
Replicate	lib/lattice/Lattice_transfer.h	/^void Replicate(Lattice<vobj> &coarse,Lattice<vobj> & fine)$/;"	f	namespace:Grid
ReplicateReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,(isVertical?Dynamic:1),(isHorizontal?Dynamic:1)> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp
Report	lib/lattice/Lattice_rng.h	/^    void Report(){$/;"	f	class:Grid::GridParallelRNG
Report	lib/perfmon/PerfCount.h	/^  void Report(void) {$/;"	f	class:Grid::PerformanceCounter
Report	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::Report(void)$/;"	f	class:Grid::QCD::WilsonFermion5D
Report	lib/stencil/Stencil.h	/^  void Report(void) {$/;"	f	class:Grid::CartesianStencil
RepresentationPolicy	tests/hmc/Test_hmc_Factories.cc	/^typedef QCD::NoHirep          RepresentationPolicy;$/;"	t	namespace:Grid	file:
Representation_Fields	lib/qcd/representations/hmc_types.h	/^  typedef std::tuple<typename Reptypes::LatticeField...> Representation_Fields;$/;"	t	class:Grid::QCD::Representations
Representation_type	lib/qcd/representations/hmc_types.h	/^  typedef std::tuple<Reptypes...> Representation_type;$/;"	t	class:Grid::QCD::Representations
Representations	lib/qcd/hmc/integrators/Integrator.h	/^  RepresentationPolicy Representations;$/;"	m	class:Grid::QCD::Integrator
Representations	lib/qcd/representations/hmc_types.h	/^  explicit Representations(GridBase* grid) : rep(Reptypes(grid)...){};$/;"	f	class:Grid::QCD::Representations
Representations	lib/qcd/representations/hmc_types.h	/^class Representations {$/;"	c	namespace:Grid::QCD
RequireInitialization	lib/Eigen/src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon136
Res	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
ResPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
ResPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
ResPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon377
ResPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
ResPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
ResPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
ResPacketSize	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon371
ResPacketSize	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon372
ResScalar	lib/Eigen/src/Core/Dot.h	/^  typedef typename conj_prod::result_type ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck
ResScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel
ResScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product
ResScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel
ResScalar	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResScalar	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResScalar	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product
Reseed	lib/lattice/Lattice_rng.h	/^    static RngEngine Reseed(RngEngine &eng)$/;"	f	class:Grid::GridRNGbase
Reseed	lib/lattice/Lattice_rng.h	/^    static RngEngine Reseed(RngEngine &eng,std::vector<uint32_t> & newseed,$/;"	f	class:Grid::GridRNGbase
Reset	lib/perfmon/Timer.h	/^  void     Reset(void){$/;"	f	class:Grid::GridStopWatch
Resource	lib/qcd/modules/ActionModules.h	/^  typedef R Resource;$/;"	t	class:Grid::ActionModuleBase
Resources	lib/qcd/hmc/GenericHMCrunner.h	/^  HMCResourceManager<Implementation> Resources;$/;"	m	class:Grid::QCD::HMCWrapperTemplate
Result	extras/Hadrons/Modules/MContraction/Baryon.hpp	/^    class Result: Serializable$/;"	c	class:TBaryon
Result	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^    class Result: Serializable$/;"	c	class:TDiscLoop
Result	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^    class Result: Serializable$/;"	c	class:TGamma3pt
Result	extras/Hadrons/Modules/MContraction/Meson.hpp	/^    class Result: Serializable$/;"	c	class:TMeson
Result	lib/Hadrons/Modules/MContraction/Baryon.hpp	/^    class Result: Serializable$/;"	c	class:TBaryon
Result	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^    class Result: Serializable$/;"	c	class:TDiscLoop
Result	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^    class Result: Serializable$/;"	c	class:TGamma3pt
Result	lib/Hadrons/Modules/MContraction/Meson.hpp	/^    class Result: Serializable$/;"	c	class:TMeson
ResultAlignment	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = traits<ResultType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon675
ResultAlignment	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = traits<ResultType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon676
ResultMode	lib/Eigen/src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon599
ResultScalar	lib/Eigen/src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
ResultType	lib/Eigen/src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
ResultType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	lib/Eigen/src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl
ReturnByValue	lib/Eigen/src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen
ReturnOpposite	lib/Eigen/src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon387
ReturnType	lib/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue
ReturnType	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^                      typename Scalar_=Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp
ReturnType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType; \/\/ FIXME shall it be a BandMatrix?$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	lib/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	lib/Eigen/src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename SPQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,StorageIndex> >::type ReturnType;$/;"	t	struct:Eigen::internal::permutation_matrix_product
ReturnType	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef typename SparseQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	lib/Eigen/src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
Reverse	lib/Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC explicit inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse
Reverse	lib/Eigen/src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen
ReverseCol	lib/Eigen/src/Core/CoreEvaluators.h	/^    ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
ReverseCol	lib/Eigen/src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon166
ReverseInnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    ReverseInnerIterator(const SparseCompressedBase& mat, Index outer)$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
ReverseInnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit ReverseInnerIterator(const SparseCompressedBase& mat)$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
ReverseInnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit ReverseInnerIterator(const internal::CompressedStorage<Scalar,StorageIndex>& data)$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
ReverseInnerIterator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^class SparseCompressedBase<Derived>::ReverseInnerIterator$/;"	c	class:Eigen::SparseCompressedBase
ReverseInnerIterator	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::ReverseInnerIterator ReverseInnerIterator;$/;"	t	class:Eigen::SparseMatrix
ReverseInnerIterator	lib/Eigen/src/SparseCore/SparseVector.h	/^    typedef typename Base::ReverseInnerIterator ReverseInnerIterator;$/;"	t	class:Eigen::SparseVector
ReverseInnerIterator	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef typename SparseVectorType::ReverseInnerIterator ReverseInnerIterator;$/;"	t	struct:Eigen::internal::evaluator
ReversePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^    ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
ReversePacket	lib/Eigen/src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon166
ReverseReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase
ReverseReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef Reverse<ExpressionType, Direction> ReverseReturnType;$/;"	t	class:Eigen::VectorwiseOp
ReverseRow	lib/Eigen/src/Core/CoreEvaluators.h	/^    ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon245
ReverseRow	lib/Eigen/src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon166
Rhs	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_all<RhsType>::type Rhs;$/;"	t	class:Eigen::CwiseBinaryOp
Rhs	lib/Eigen/src/Core/Product.h	/^    typedef _Rhs Rhs;$/;"	t	class:Eigen::Product
Rhs	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
RhsAlignment	lib/Eigen/src/Core/ProductEvaluators.h	/^    RhsAlignment = EIGEN_PLAIN_ENUM_MIN(RhsEtorType::Alignment,RhsVecPacketSize*int(sizeof(typename RhsNestedCleaned::Scalar))),$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
RhsArg	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::Rhs RhsArg;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
RhsBlasTraits	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef internal::blas_traits<Rhs> RhsBlasTraits;$/;"	t	struct:Eigen::internal::generic_product_impl
RhsBlasTraits	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef internal::blas_traits<Rhs> RhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
RhsBlasTraits	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef internal::blas_traits<Rhs> RhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
RhsCleaned	lib/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Rhs>::type RhsCleaned;$/;"	t	struct:Eigen::internal::traits
RhsCoeffReadCost	lib/Eigen/src/Core/ProductEvaluators.h	/^    RhsCoeffReadCost = RhsEtorType::CoeffReadCost,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
RhsEtorType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<RhsNestedCleaned> RhsEtorType;$/;"	t	struct:Eigen::internal::product_evaluator
RhsEval	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef evaluator<ActualRhs> RhsEval;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
RhsEvaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef evaluator<RhsArg> RhsEvaluator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
RhsFlags	lib/Eigen/src/Core/CoreEvaluators.h	/^    RhsFlags = evaluator<Rhs>::Flags,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
RhsFlags	lib/Eigen/src/Core/ProductEvaluators.h	/^    RhsFlags = RhsEtorType::Flags,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
RhsIsSelfAdjoint	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon370
RhsIsUpper	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon370
RhsIsVectorAtCompileTime	lib/Eigen/src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon131
RhsIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<Rhs>::InnerIterator  RhsIterator;$/;"	t	struct:Eigen::internal::binary_evaluator
RhsIterator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<RhsArg>::InnerIterator  RhsIterator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
RhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::ref_selector<RhsType>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
RhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	lib/Eigen/src/Core/Product.h	/^    typedef typename internal::ref_selector<Rhs>::type RhsNested;$/;"	t	class:Eigen::Product
RhsNested	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::nested_eval<Rhs,Lhs::RowsAtCompileTime>::type RhsNested;$/;"	t	struct:Eigen::internal::product_evaluator
RhsNested	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename nested_eval<Rhs,1>::type RhsNested;$/;"	t	struct:Eigen::internal::generic_product_impl
RhsNested	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl
RhsNestedCleaned	lib/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;$/;"	t	class:Eigen::Product
RhsNestedCleaned	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::product_evaluator
RhsNestedCleaned	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval
RhsOuterStrideBytes	lib/Eigen/src/Core/ProductEvaluators.h	/^    RhsOuterStrideBytes = int(RhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename RhsNestedCleaned::Scalar)),$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
RhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
RhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacketType,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
RhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
RhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
RhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
RhsPacketSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
RhsPacketSize	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon371
RhsPacketSize	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon372
RhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon377
RhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
RhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
RhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
RhsProgress	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
RhsRowMajor	lib/Eigen/src/Core/ProductEvaluators.h	/^    RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
RhsScalar	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
RhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
RhsScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
RhsScalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::generic_product_impl
RhsTraits	lib/Eigen/src/Core/Product.h	/^  typedef traits<RhsCleaned> RhsTraits;$/;"	t	struct:Eigen::internal::traits
RhsUpLo	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  enum { RhsUpLo = RhsMode&(Upper|Lower)  };$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon368
RhsVecPacketSize	lib/Eigen/src/Core/ProductEvaluators.h	/^    RhsVecPacketSize = unpacket_traits<RhsVecPacketType>::size,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
RhsVecPacketType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename find_best_packet<Scalar,ColsAtCompileTime>::type RhsVecPacketType;$/;"	t	struct:Eigen::internal::product_evaluator
RhsVectors	lib/Eigen/src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon132
RngEngine	lib/lattice/Lattice_rng.h	/^    typedef sitmo::prng_engine 	RngEngine;$/;"	t	class:Grid::GridRNGbase
RngEngine	lib/lattice/Lattice_rng.h	/^    typedef std::mt19937 RngEngine;$/;"	t	class:Grid::GridRNGbase
RngEngine	lib/lattice/Lattice_rng.h	/^    typedef std::ranlux48 RngEngine;$/;"	t	class:Grid::GridRNGbase
RngEngine	tests/testu01/Test_smallcrush.cc	/^typedef Grid::GridRNGbase::RngEngine RngEngine;$/;"	t	file:
RngPt	extras/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<GridParallelRNG>       RngPt;$/;"	t	class:Environment
RngPt	lib/Hadrons/Environment.hpp	/^    typedef std::unique_ptr<GridParallelRNG>       RngPt;$/;"	t	class:Environment
RngStateCount	lib/lattice/Lattice_rng.h	/^    static const int    	RngStateCount = 13;$/;"	m	class:Grid::GridRNGbase
RngStateCount	lib/lattice/Lattice_rng.h	/^    static const int     RngStateCount = std::mt19937::state_size;$/;"	m	class:Grid::GridRNGbase
RngStateCount	lib/lattice/Lattice_rng.h	/^    static const int RngStateCount = 15;$/;"	m	class:Grid::GridRNGbase
RngStateType	lib/lattice/Lattice_rng.h	/^    typedef uint32_t     RngStateType;$/;"	t	class:Grid::GridRNGbase
RngStateType	lib/lattice/Lattice_rng.h	/^    typedef uint64_t    	RngStateType;$/;"	t	class:Grid::GridRNGbase
RngStateType	lib/lattice/Lattice_rng.h	/^    typedef uint64_t      RngStateType;$/;"	t	class:Grid::GridRNGbase
Rotate	lib/simd/Grid_avx.h	/^  struct Rotate{$/;"	s	namespace:Grid::Optimization
Rotate	lib/simd/Grid_avx512.h	/^  struct Rotate{$/;"	s	namespace:Grid::Optimization
Rotate	lib/simd/Grid_generic.h	/^  struct Rotate{$/;"	s	namespace:Grid::Optimization
Rotate	lib/simd/Grid_imci.h	/^  struct Rotate{$/;"	s	namespace:Grid::Optimization
Rotate	lib/simd/Grid_neon.h	/^  struct Rotate{$/;"	s	namespace:Grid::Optimization
Rotate	lib/simd/Grid_qpx.h	/^  struct Rotate{$/;"	s	namespace:Grid::Optimization
Rotate	lib/simd/Grid_sse4.h	/^  struct Rotate{$/;"	s	namespace:Grid::Optimization
RotateBit	lib/simd/Simd.h	51;"	d
Rotation2D	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC Rotation2D() {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC explicit Rotation2D(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::Rotation2D
Rotation2D	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC explicit inline Rotation2D(const Scalar& a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D
Rotation2D	lib/Eigen/src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen
Rotation2Dd	lib/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Df	lib/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
RotationBase	lib/Eigen/src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationMatrixType	lib/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase
RoundReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_round_op<Scalar>, const Derived> RoundReturnType;$/;"	t
RowMajor	lib/Eigen/src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::StorageOptions
RowMajorBit	lib/Eigen/src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
RowType	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD
RowVectorType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RowVectorType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
RowVectorType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
RowVectorType	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR
RowVectorType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RowXpr	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase
RowXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowXpr;$/;"	t
Rows	lib/Eigen/src/Core/GeneralProduct.h	/^    Rows    = traits<_Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon185
Rows	lib/Eigen/src/Geometry/Homogeneous.h	/^    Rows = Lhs::RowsAtCompileTime$/;"	e	enum:Eigen::internal::homogeneous_right_product_refactoring_helper::__anon609
Rows	lib/Eigen/src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon593
RowsAtCompileTime	lib/Eigen/src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon630
RowsAtCompileTime	lib/Eigen/src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon631
RowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
RowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon388
RowsAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon389
RowsAtCompileTime	lib/Eigen/src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon213
RowsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    RowsAtCompileTime = PlainObjectType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon227
RowsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    RowsAtCompileTime = XprType::RowsAtCompileTime$/;"	e	enum:Eigen::internal::unary_evaluator::__anon238
RowsAtCompileTime	lib/Eigen/src/Core/CoreEvaluators.h	/^    RowsAtCompileTime = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon237
RowsAtCompileTime	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon504
RowsAtCompileTime	lib/Eigen/src/Core/CwiseTernaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon219
RowsAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon129
RowsAtCompileTime	lib/Eigen/src/Core/Diagonal.h	/^    RowsAtCompileTime = (int(DiagIndex) == DynamicIndex || int(MatrixType::SizeAtCompileTime) == Dynamic) ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon401
RowsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon398
RowsAtCompileTime	lib/Eigen/src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon400
RowsAtCompileTime	lib/Eigen/src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon250
RowsAtCompileTime	lib/Eigen/src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon172
RowsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = PermTraits::RowsAtCompileTime,$/;"	e	enum:Eigen::InverseImpl::__anon502
RowsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon500
RowsAtCompileTime	lib/Eigen/src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon501
RowsAtCompileTime	lib/Eigen/src/Core/Product.h	/^    RowsAtCompileTime    = LhsTraits::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon126
RowsAtCompileTime	lib/Eigen/src/Core/ProductEvaluators.h	/^    RowsAtCompileTime = LhsNestedCleaned::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_evaluator::__anon176
RowsAtCompileTime	lib/Eigen/src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon225
RowsAtCompileTime	lib/Eigen/src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon165
RowsAtCompileTime	lib/Eigen/src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon128
RowsAtCompileTime	lib/Eigen/src/Core/SolverBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon247
RowsAtCompileTime	lib/Eigen/src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon391
RowsAtCompileTime	lib/Eigen/src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon19
RowsAtCompileTime	lib/Eigen/src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon156
RowsAtCompileTime	lib/Eigen/src/Core/Visitor.h	/^    RowsAtCompileTime = XprType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_evaluator::__anon222
RowsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon581
RowsAtCompileTime	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon583
RowsAtCompileTime	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon576
RowsAtCompileTime	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon577
RowsAtCompileTime	lib/Eigen/src/Eigenvalues/RealQZ.h	/^        RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon582
RowsAtCompileTime	lib/Eigen/src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon580
RowsAtCompileTime	lib/Eigen/src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon607
RowsAtCompileTime	lib/Eigen/src/Geometry/Transform.h	/^    RowsAtCompileTime = _Mode==Projective ? Dim1 : _Dim,$/;"	e	enum:Eigen::internal::traits::__anon592
RowsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon652
RowsAtCompileTime	lib/Eigen/src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon651
RowsAtCompileTime	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon644
RowsAtCompileTime	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon642
RowsAtCompileTime	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon646
RowsAtCompileTime	lib/Eigen/src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon647
RowsAtCompileTime	lib/Eigen/src/SVD/BDCSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon622
RowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon620
RowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon616
RowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon617
RowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon618
RowsAtCompileTime	lib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon619
RowsAtCompileTime	lib/Eigen/src/SVD/SVDBase.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon621
RowsAtCompileTime	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon613
RowsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon513
RowsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon514
RowsAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
RowsAtCompileTime	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      RowsAtCompileTime = internal::traits<SparseSelfAdjointView>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseSelfAdjointView::__anon574
RowsAtCompileTime	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      RowsAtCompileTime = internal::traits<SparseSymmetricPermutationProduct>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseSymmetricPermutationProduct::__anon575
RowsAtCompileTime	lib/Eigen/src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon539
RowsAtCompileTime	lib/Eigen/src/SparseQR/SparseQR.h	/^      RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon510
RowsAtCompileTime	lib/Eigen/src/SparseQR/SparseQR.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::SparseQRMatrixQReturnType::__anon512
RowsBlockXpr	lib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowsBlockXpr;$/;"	t
RowsPlusOne	lib/Eigen/src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon607
RowwiseReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase
RsqrtReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_rsqrt_op<Scalar>, const Derived> RsqrtReturnType;$/;"	t
RtoFundamentalProject	lib/qcd/representations/adjoint.h	/^  LatticeGaugeField RtoFundamentalProject(const LatticeField &in,$/;"	f	class:Grid::QCD::AdjointRep
RtoFundamentalProject	lib/qcd/representations/fundamental.h	/^    LatticeField RtoFundamentalProject(const LatticeField& in, Real scale = 1.0) const{}\/\/ do nothing$/;"	f	class:Grid::QCD::EmptyRep
RtoFundamentalProject	lib/qcd/representations/fundamental.h	/^  LatticeField RtoFundamentalProject(const LatticeField& in, Real scale = 1.0) const{$/;"	f	class:Grid::QCD::FundamentalRep
RtoFundamentalProject	lib/qcd/representations/two_index.h	/^  LatticeGaugeField RtoFundamentalProject(const LatticeField &in,$/;"	f	class:Grid::QCD::TwoIndexRep
Run	lib/qcd/hmc/GenericHMCrunner.h	/^  void Run(){$/;"	f	class:Grid::QCD::HMCWrapperTemplate
Run	lib/qcd/hmc/GenericHMCrunner.h	/^  void Run(SmearingPolicy &S) {$/;"	f	class:Grid::QCD::HMCWrapperTemplate
Runner	lib/qcd/hmc/GenericHMCrunner.h	/^  void Runner(SmearingPolicy &Smearing) {$/;"	f	class:Grid::QCD::HMCWrapperTemplate
S	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::PlaqPlusRectangleAction
S	lib/qcd/action/gauge/WilsonGaugeAction.h	/^  virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::WilsonGaugeAction
S	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
S	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
S	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
S	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
S	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::TwoFlavourPseudoFermionAction
S	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
S	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
S	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      virtual RealD S(const GaugeField &U) {$/;"	f	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
S	lib/qcd/action/scalar/ScalarAction.h	/^    virtual RealD S(const Field &p) {$/;"	f	class:Grid::ScalarAction
S	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    virtual RealD S(const Field &p) {$/;"	f	class:Grid::ScalarInteractionAction
S	lib/qcd/hmc/integrators/Integrator.h	/^  RealD S(Field& U) {  \/\/ here also U not used$/;"	f	class:Grid::QCD::Integrator
SAP	tests/solver/Test_dwf_hdcr.cc	/^  void SAP (const FineField & src,FineField & psi){$/;"	f	class:MultiGridPreconditioner
SAVE_CHI	lib/simd/Intel512wilson.h	108;"	d
SAVE_CHIi	lib/simd/Intel512wilson.h	172;"	d
SAVE_RESULT	lib/simd/BGQQPX.h	217;"	d
SAVE_RESULT	lib/simd/IBM_qpx.h	262;"	d
SAVE_RESULT	lib/simd/Intel512wilson.h	109;"	d
SAVE_RESULTi	lib/simd/Intel512wilson.h	570;"	d
SAVE_UCHI	lib/simd/Intel512wilson.h	107;"	d
SAVE_UCHIi	lib/simd/Intel512wilson.h	162;"	d
SAccPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::AccPacket SAccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SCALAR_ACTION_H	lib/qcd/action/scalar/ScalarAction.h	34;"	d
SCALAR_IMPL	lib/qcd/action/scalar/ScalarImpl.h	2;"	d
SCALAR_INT_ACTION_H	lib/qcd/action/scalar/ScalarInteractionAction.h	31;"	d
SCALAR_OBJS_H	lib/qcd/utils/ScalarObjs.h	30;"	d
SCALAR_TYPE_ALIASES	extras/Hadrons/Global.hpp	75;"	d
SCALAR_TYPE_ALIASES	lib/Hadrons/Global.hpp	75;"	d
SCIDAC_BINARY_DATA	lib/parallelIO/IldgIOtypes.h	50;"	d
SCIDAC_CHECKSUM	lib/parallelIO/IldgIOtypes.h	45;"	d
SCIDAC_FILE_XML	lib/parallelIO/IldgIOtypes.h	47;"	d
SCIDAC_PRIVATE_FILE_XML	lib/parallelIO/IldgIOtypes.h	46;"	d
SCIDAC_PRIVATE_RECORD_XML	lib/parallelIO/IldgIOtypes.h	48;"	d
SCIDAC_RECORD_XML	lib/parallelIO/IldgIOtypes.h	49;"	d
SCIDAC_SITELIST	lib/parallelIO/IldgIOtypes.h	52;"	d
SCMatrix	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef internal::MappedSuperNodalMatrix<Scalar, StorageIndex> SCMatrix;$/;"	t	class:Eigen::SparseLU
SDP_AsCwiseProduct	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  SDP_AsCwiseProduct$/;"	e	enum:Eigen::internal::__anon544
SDP_AsScalarProduct	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  SDP_AsScalarProduct,$/;"	e	enum:Eigen::internal::__anon544
SEM_INIT	lib/communicator/Communicator_mpi3_leader.cc	57;"	d	file:
SEM_INIT_EXCL	lib/communicator/Communicator_mpi3_leader.cc	58;"	d	file:
SEM_POST	lib/communicator/Communicator_mpi3_leader.cc	59;"	d	file:
SEM_WAIT	lib/communicator/Communicator_mpi3_leader.cc	60;"	d	file:
SEP	extras/Hadrons/Application.cc	38;"	d	file:
SEP	extras/Hadrons/Environment.cc	327;"	d	file:
SEP	lib/Hadrons/Application.cc	38;"	d	file:
SEP	lib/Hadrons/Environment.cc	327;"	d	file:
SG	lib/qcd/smearing/WilsonFlow.h	/^    mutable WilsonGaugeAction<Gimpl> SG;$/;"	m	class:Grid::QCD::WilsonFlow
SHMEM_VET	lib/communicator/Communicator_shmem.cc	35;"	d	file:
SHMEM_VET_DEBUG	lib/communicator/Communicator_shmem.cc	37;"	d	file:
SHM_HUGETLB	lib/communicator/Communicator_mpi3.cc	45;"	d	file:
SHUF_CHIMU23i	lib/simd/Intel512wilson.h	146;"	d
SIMD_Dtype	lib/simd/Grid_avx.h	/^  typedef __m256d SIMD_Dtype; \/\/ Double precision type$/;"	t	namespace:Grid
SIMD_Dtype	lib/simd/Grid_avx512.h	/^  typedef __m512d SIMD_Dtype; \/\/ Double precision type$/;"	t	namespace:Grid
SIMD_Dtype	lib/simd/Grid_generic.h	/^  typedef Optimization::vecd SIMD_Dtype; \/\/ Double precision type$/;"	t	namespace:Grid
SIMD_Dtype	lib/simd/Grid_imci.h	/^  typedef __m512d SIMD_Dtype; \/\/ Double precision type$/;"	t	namespace:Grid
SIMD_Dtype	lib/simd/Grid_neon.h	/^  typedef float64x2_t  SIMD_Dtype; \/\/ Double precision type$/;"	t	namespace:Grid
SIMD_Dtype	lib/simd/Grid_qpx.h	/^typedef vector4double              SIMD_Dtype; \/\/ Double precision type$/;"	t	namespace:Grid
SIMD_Dtype	lib/simd/Grid_sse4.h	/^  typedef __m128d SIMD_Dtype; \/\/ Double precision type$/;"	t	namespace:Grid
SIMD_Ftype	lib/simd/Grid_avx.h	/^  typedef __m256  SIMD_Ftype; \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Ftype	lib/simd/Grid_avx512.h	/^  typedef __m512  SIMD_Ftype;  \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Ftype	lib/simd/Grid_generic.h	/^  typedef Optimization::vecf SIMD_Ftype; \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Ftype	lib/simd/Grid_imci.h	/^  typedef __m512 SIMD_Ftype;  \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Ftype	lib/simd/Grid_neon.h	/^  typedef float32x4_t  SIMD_Ftype; \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Ftype	lib/simd/Grid_qpx.h	/^typedef Optimization::vector4float SIMD_Ftype;  \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Ftype	lib/simd/Grid_sse4.h	/^  typedef __m128  SIMD_Ftype;  \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Htype	lib/simd/Grid_avx.h	/^  typedef __m256i SIMD_Htype;  \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Htype	lib/simd/Grid_avx512.h	/^  typedef __m512i SIMD_Htype;  \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Htype	lib/simd/Grid_generic.h	/^  typedef Optimization::vech SIMD_Htype; \/\/ Reduced precision type$/;"	t	namespace:Grid
SIMD_Htype	lib/simd/Grid_neon.h	/^  typedef float16x8_t  SIMD_Htype; \/\/ Half precision type$/;"	t	namespace:Grid
SIMD_Htype	lib/simd/Grid_qpx.h	/^typedef Optimization::vech         SIMD_Htype;  \/\/ Half precision type$/;"	t	namespace:Grid
SIMD_Htype	lib/simd/Grid_sse4.h	/^  typedef __m128i SIMD_Htype;  \/\/ Single precision type$/;"	t	namespace:Grid
SIMD_Itype	lib/simd/Grid_avx.h	/^  typedef __m256i SIMD_Itype; \/\/ Integer type$/;"	t	namespace:Grid
SIMD_Itype	lib/simd/Grid_avx512.h	/^  typedef __m512i SIMD_Itype; \/\/ Integer type$/;"	t	namespace:Grid
SIMD_Itype	lib/simd/Grid_generic.h	/^  typedef Optimization::veci SIMD_Itype; \/\/ Integer type$/;"	t	namespace:Grid
SIMD_Itype	lib/simd/Grid_imci.h	/^  typedef __m512i SIMD_Itype; \/\/ Integer type$/;"	t	namespace:Grid
SIMD_Itype	lib/simd/Grid_neon.h	/^  typedef uint32x4_t   SIMD_Itype; \/\/ Integer type$/;"	t	namespace:Grid
SIMD_Itype	lib/simd/Grid_qpx.h	/^typedef Optimization::veci         SIMD_Itype; \/\/ Integer type$/;"	t	namespace:Grid
SIMD_Itype	lib/simd/Grid_sse4.h	/^  typedef __m128i SIMD_Itype; \/\/ Integer type$/;"	t	namespace:Grid
SIMPL	extras/Hadrons/Global.hpp	58;"	d
SIMPL	lib/Hadrons/Global.hpp	58;"	d
SINGLETON	extras/Hadrons/Global.hpp	114;"	d
SINGLETON	lib/Hadrons/Global.hpp	114;"	d
SINGLETON_DEFCTOR	extras/Hadrons/Global.hpp	126;"	d
SINGLETON_DEFCTOR	lib/Hadrons/Global.hpp	126;"	d
SINK_TYPE_ALIASES	extras/Hadrons/Global.hpp	83;"	d
SINK_TYPE_ALIASES	lib/Hadrons/Global.hpp	83;"	d
SITE_SIZE_TYPE	extras/Hadrons/Environment.hpp	37;"	d
SITE_SIZE_TYPE	lib/Hadrons/Environment.hpp	37;"	d
SITMO_PRNG_ENGINE_HPP	lib/sitmo_rng/sitmo_prng_engine.hpp	36;"	d
SLComparison	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> SLComparison(vfunctor op,const lobj &lhs,const Lattice<robj> &rhs)$/;"	f	namespace:Grid
SLhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::LhsPacket SLhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SMALL_CRUSH	tests/testu01/Test_smallcrush.cc	37;"	d	file:
SOLVER_MODULES_H	lib/qcd/modules/SolverModules.h	30;"	d
SOLVER_TYPE_ALIASES	extras/Hadrons/Global.hpp	79;"	d
SOLVER_TYPE_ALIASES	lib/Hadrons/Global.hpp	79;"	d
SOURCE_PUGIXML_CPP	lib/pugixml/pugixml.cc	15;"	d	file:
SPARSELU_COLUMN_BMOD_H	lib/Eigen/src/SparseLU/SparseLU_column_bmod.h	32;"	d
SPARSELU_COLUMN_DFS_H	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	31;"	d
SPARSELU_COPY_TO_UCOL_H	lib/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	30;"	d
SPARSELU_HEAP_RELAX_SNODE_H	lib/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	29;"	d
SPARSELU_IMPL_H	lib/Eigen/src/SparseLU/SparseLUImpl.h	10;"	d
SPARSELU_KERNEL_BMOD_H	lib/Eigen/src/SparseLU/SparseLU_kernel_bmod.h	12;"	d
SPARSELU_PANEL_BMOD_H	lib/Eigen/src/SparseLU/SparseLU_panel_bmod.h	32;"	d
SPARSELU_PANEL_DFS_H	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	31;"	d
SPARSELU_PIVOTL_H	lib/Eigen/src/SparseLU/SparseLU_pivotL.h	31;"	d
SPARSELU_PRUNEL_H	lib/Eigen/src/SparseLU/SparseLU_pruneL.h	31;"	d
SPARSELU_RELAX_SNODE_H	lib/Eigen/src/SparseLU/SparseLU_relax_snode.h	29;"	d
SPARSE_COLETREE_H	lib/Eigen/src/SparseCore/SparseColEtree.h	32;"	d
SPQR	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR() $/;"	f	class:Eigen::SPQR
SPQR	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    explicit SPQR(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR
SPQR	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^class SPQR : public SparseSolverBase<SPQR<_MatrixType> >$/;"	c	namespace:Eigen
SPQRMatrixQReturnType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQReturnType
SPQRMatrixQReturnType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQReturnType{$/;"	s	namespace:Eigen
SPQRMatrixQTransposeReturnType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType
SPQRMatrixQTransposeReturnType	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQTransposeReturnType{$/;"	s	namespace:Eigen
SPQR_QProduct	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct(const SPQRType& spqr, const Derived& other, bool transpose) : m_spqr(spqr),m_other(other),m_transpose(transpose) {}$/;"	f	struct:Eigen::SPQR_QProduct
SPQR_QProduct	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQR_QProduct : ReturnByValue<SPQR_QProduct<SPQRType,Derived> >$/;"	s	namespace:Eigen
SPQR_free	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void SPQR_free()$/;"	f	class:Eigen::SPQR
SResPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::ResPacket SResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SResScalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::ResScalar SResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel
SRhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::RhsPacket SRhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SSE	lib/Eigen/src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
STORAGE_INDEX_MUST_MATCH	lib/Eigen/src/Core/util/StaticAssert.h	/^        STORAGE_INDEX_MUST_MATCH,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
STORAGE_KIND_MUST_MATCH	lib/Eigen/src/Core/util/StaticAssert.h	/^        STORAGE_KIND_MUST_MATCH,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
STORAGE_LAYOUT_DOES_NOT_MATCH	lib/Eigen/src/Core/util/StaticAssert.h	/^        STORAGE_LAYOUT_DOES_NOT_MATCH,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
STOUT_SMEAR_	lib/qcd/smearing/StoutSmearing.h	6;"	d
STREAMING_STORES	lib/lattice/Lattice_base.h	34;"	d
STREAM_STORE	lib/simd/Intel512common.h	142;"	d
STRINGIFY	lib/algorithms/approx/Zolotarev.cc	57;"	d	file:
SU	lib/qcd/utils/SUn.h	/^class SU {$/;"	c	namespace:Grid::QCD
SU2	lib/qcd/utils/SUn.h	/^typedef SU<2> SU2;$/;"	t	namespace:Grid::QCD
SU2Adjoint	lib/qcd/utils/SUnAdjoint.h	/^typedef SU_Adjoint<2> SU2Adjoint;$/;"	t	namespace:Grid::QCD
SU2Matrix	lib/qcd/utils/SUn.h	/^  typedef iSU2Matrix<Complex> SU2Matrix;$/;"	t	class:Grid::QCD::SU
SU2MatrixD	lib/qcd/utils/SUn.h	/^  typedef iSU2Matrix<ComplexD> SU2MatrixD;$/;"	t	class:Grid::QCD::SU
SU2MatrixF	lib/qcd/utils/SUn.h	/^  typedef iSU2Matrix<ComplexF> SU2MatrixF;$/;"	t	class:Grid::QCD::SU
SU2TwoIndexAntiSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<2, AntiSymmetric> SU2TwoIndexAntiSymm;$/;"	t	namespace:Grid::QCD
SU2TwoIndexSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<2, Symmetric> SU2TwoIndexSymm;$/;"	t	namespace:Grid::QCD
SU2WilsonLoops	lib/qcd/utils/WilsonLoops.h	/^typedef WilsonLoops<PeriodicGimplR> SU2WilsonLoops;$/;"	t	namespace:Grid::QCD
SU3	lib/qcd/utils/SUn.h	/^typedef SU<3> SU3;$/;"	t	namespace:Grid::QCD
SU3Adjoint	lib/qcd/utils/SUnAdjoint.h	/^typedef SU_Adjoint<3> SU3Adjoint;$/;"	t	namespace:Grid::QCD
SU3TwoIndexAntiSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<3, AntiSymmetric> SU3TwoIndexAntiSymm;$/;"	t	namespace:Grid::QCD
SU3TwoIndexSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<3, Symmetric> SU3TwoIndexSymm;$/;"	t	namespace:Grid::QCD
SU3WilsonLoops	lib/qcd/utils/WilsonLoops.h	/^typedef WilsonLoops<PeriodicGimplR> SU3WilsonLoops;$/;"	t	namespace:Grid::QCD
SU4	lib/qcd/utils/SUn.h	/^typedef SU<4> SU4;$/;"	t	namespace:Grid::QCD
SU4Adjoint	lib/qcd/utils/SUnAdjoint.h	/^typedef SU_Adjoint<4> SU4Adjoint;$/;"	t	namespace:Grid::QCD
SU4TwoIndexAntiSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<4, AntiSymmetric> SU4TwoIndexAntiSymm;$/;"	t	namespace:Grid::QCD
SU4TwoIndexSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<4, Symmetric> SU4TwoIndexSymm;$/;"	t	namespace:Grid::QCD
SU5	lib/qcd/utils/SUn.h	/^typedef SU<5> SU5;$/;"	t	namespace:Grid::QCD
SU5Adjoint	lib/qcd/utils/SUnAdjoint.h	/^typedef SU_Adjoint<5> SU5Adjoint;$/;"	t	namespace:Grid::QCD
SU5TwoIndexAntiSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<5, AntiSymmetric> SU5TwoIndexAntiSymm;$/;"	t	namespace:Grid::QCD
SU5TwoIndexSymm	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<5, Symmetric> SU5TwoIndexSymm;$/;"	t	namespace:Grid::QCD
SUM_MAX	lib/algorithms/approx/Remez.h	28;"	d
SUM_MU	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	57;"	d
SUM_MU	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	57;"	d
SUN2INDEX_H_H	lib/qcd/representations/two_index.h	7;"	d
SU_Adjoint	lib/qcd/utils/SUnAdjoint.h	/^class SU_Adjoint : public SU<ncolour> {$/;"	c	namespace:Grid::QCD
SU_TwoIndex	lib/qcd/utils/SUnTwoIndex.h	/^class SU_TwoIndex : public SU<ncolour> {$/;"	c	namespace:Grid::QCD
SVA_Inner	lib/Eigen/src/SparseCore/SparseVector.h	/^  SVA_Inner,$/;"	e	enum:Eigen::internal::__anon540
SVA_Outer	lib/Eigen/src/SparseCore/SparseVector.h	/^  SVA_Outer$/;"	e	enum:Eigen::internal::__anon540
SVA_RuntimeSwitch	lib/Eigen/src/SparseCore/SparseVector.h	/^  SVA_RuntimeSwitch,$/;"	e	enum:Eigen::internal::__anon540
SVD	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
SVDBase	lib/Eigen/src/SVD/SVDBase.h	/^  SVDBase()$/;"	f	class:Eigen::SVDBase
SVDBase	lib/Eigen/src/SVD/SVDBase.h	/^class SVDBase$/;"	c	namespace:Eigen
S_diag	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	/^    S_diag = 0,$/;"	e	enum:__anon4
S_diag	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	/^    S_diag = 0,$/;"	e	enum:__anon687
S_hireps	lib/qcd/hmc/integrators/Integrator.h	/^  } S_hireps{};$/;"	s	class:Grid::QCD::Integrator
SameNode	lib/stencil/Stencil.h	/^  inline int SameNode(int point) { $/;"	f	class:Grid::CartesianStencil
SamePrecisionMapper	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  template <class T> struct SamePrecisionMapper {$/;"	s	namespace:Grid::QCD
SameType	lib/Eigen/src/Core/CoreEvaluators.h	/^    SameType = is_same<typename Arg1::Scalar,typename Arg2::Scalar>::value && is_same<typename Arg1::Scalar,typename Arg3::Scalar>::value,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
SameType	lib/Eigen/src/Core/CoreEvaluators.h	/^    SameType = is_same<typename Lhs::Scalar,typename Rhs::Scalar>::value,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
SameType	lib/Eigen/src/Core/ProductEvaluators.h	/^    SameType = is_same<typename LhsNestedCleaned::Scalar,typename RhsNestedCleaned::Scalar>::value,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
Scalar	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT
Scalar	lib/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT
Scalar	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase
Scalar	lib/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase
Scalar	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorType::Scalar Scalar;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
Scalar	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix
Scalar	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper
Scalar	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase
Scalar	lib/Eigen/src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer
Scalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator_wrapper_base
Scalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator
Scalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::block_evaluator
Scalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator
Scalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::mapbase_evaluator
Scalar	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	lib/Eigen/src/Core/CoreIterators.h	/^  typedef typename internal::traits<XprType>::Scalar Scalar;$/;"	t	class:Eigen::InnerIterator
Scalar	lib/Eigen/src/Core/CoreIterators.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	class:Eigen::internal::inner_iterator_selector
Scalar	lib/Eigen/src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/CwiseTernaryOp.h	/^      const typename Arg3::Scalar&)>::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase
Scalar	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase
Scalar	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix
Scalar	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase
Scalar	lib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/Inverse.h	/^  typedef typename XprType::Scalar                            Scalar;$/;"	t	class:Eigen::Inverse
Scalar	lib/Eigen/src/Core/Inverse.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::InverseImpl
Scalar	lib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	lib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	lib/Eigen/src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/MatrixBase.h	/^      typedef typename ScalarBinaryOpTraits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
Scalar	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase
Scalar	lib/Eigen/src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias
Scalar	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef void Scalar;$/;"	t	class:Eigen::PermutationBase
Scalar	lib/Eigen/src/Core/PermutationMatrix.h	/^  typedef void Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase
Scalar	lib/Eigen/src/Core/Product.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::dense_product_base
Scalar	lib/Eigen/src/Core/Product.h	/^  typedef typename ScalarBinaryOpTraits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/ProductEvaluators.h	/^   typedef typename ScalarBinaryOpTraits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::diagonal_product_evaluator_base
Scalar	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	struct:Eigen::internal::product_evaluator
Scalar	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl
Scalar	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl_base
Scalar	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::product_evaluator
Scalar	lib/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl
Scalar	lib/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller
Scalar	lib/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
Scalar	lib/Eigen/src/Core/Redux.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::redux_evaluator
Scalar	lib/Eigen/src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView
Scalar	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Scalar	lib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
Scalar	lib/Eigen/src/Core/SolverBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SolverBase
Scalar	lib/Eigen/src/Core/Swap.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
Scalar	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase
Scalar	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView
Scalar	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularViewType>::Scalar Scalar;$/;"	t	class:Eigen::TriangularViewImpl
Scalar	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Scalar	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Kernel::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_loop
Scalar	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp
Scalar	lib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar; $/;"	t	struct:Eigen::internal::max_coeff_visitor
Scalar	lib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor
Scalar	lib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor
Scalar	lib/Eigen/src/Core/Visitor.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::visitor_evaluator
Scalar	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits
Scalar	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl
Scalar	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
Scalar	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
Scalar	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper
Scalar	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::conj_helper
Scalar	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver
Scalar	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur
Scalar	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver
Scalar	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
Scalar	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition
Scalar	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealQZ
Scalar	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur
Scalar	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Scalar	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Scalar	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization
Scalar	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Scalar	lib/Eigen/src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox
Scalar	lib/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis
Scalar	lib/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane
Scalar	lib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Scalar	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine
Scalar	lib/Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map
Scalar	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion
Scalar	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl
Scalar	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase
Scalar	lib/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D
Scalar	lib/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase
Scalar	lib/Eigen/src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling
Scalar	lib/Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform
Scalar	lib/Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation
Scalar	lib/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence
Scalar	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner
Scalar	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::LeastSquareDiagonalPreconditioner
Scalar	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB
Scalar	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient
Scalar	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT
Scalar	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase
Scalar	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
Scalar	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::traits<SolveWithGuess>::Scalar Scalar;$/;"	t	class:Eigen::SolveWithGuess
Scalar	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase
Scalar	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits
Scalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT
Scalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT
Scalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU
Scalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl
Scalar	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits
Scalar	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR
Scalar	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
Scalar	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR
Scalar	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR
Scalar	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SPQR
Scalar	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Scalar Scalar;$/;"	t	struct:Eigen::SPQR_QProduct
Scalar	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BDCSVD
Scalar	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD
Scalar	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Scalar	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
Scalar	lib/Eigen/src/SVD/SVDBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVDBase
Scalar	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Scalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky
Scalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
Scalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT
Scalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT
Scalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector
Scalar	lib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
Scalar	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage
Scalar	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MappedSparseMatrix
Scalar	lib/Eigen/src/SparseCore/SparseAssign.h	/^  typedef typename DstXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::Assignment
Scalar	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator
Scalar	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::binary_evaluator
Scalar	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
Scalar	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Scalar	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename ProdXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
Scalar	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl
Scalar	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename SparseXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
Scalar	lib/Eigen/src/SparseCore/SparseMap.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SparseMapBase
Scalar	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase
Scalar	lib/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permutation_matrix_product
Scalar	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView
Scalar	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
Scalar	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
Scalar	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::SparseTransposeImpl
Scalar	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	lib/Eigen/src/SparseCore/SparseView.h	/^        typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Scalar	lib/Eigen/src/SparseCore/SparseView.h	/^    typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	lib/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
Scalar	lib/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
Scalar	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Scalar Scalar; $/;"	t	class:Eigen::SparseLU
Scalar	lib/Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType
Scalar	lib/Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType
Scalar	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Scalar Scalar; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
Scalar	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename ScalarVector::Scalar Scalar;$/;"	t	struct:Eigen::internal::column_dfs_traits
Scalar	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseQR
Scalar	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef typename DstXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::Assignment
Scalar	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType
Scalar	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQR_QProduct
Scalar	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU
Scalar	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU
Scalar	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase
Scalar	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU
Scalar	lib/qcd/LatticeTheories.h	/^struct Scalar : public LatticeTheory<Dimensions> {};$/;"	s	namespace:Grid::LatticeTheories
ScalarAction	lib/qcd/action/scalar/ScalarAction.h	/^    ScalarAction(RealD ms, RealD l) : mass_square(ms), lambda(l) {}$/;"	f	class:Grid::ScalarAction
ScalarAction	lib/qcd/action/scalar/ScalarAction.h	/^class ScalarAction : public QCD::Action<typename Impl::Field> {$/;"	c	namespace:Grid
ScalarActionD	lib/qcd/action/scalar/Scalar.h	/^  typedef ScalarAction<ScalarImplD>                 ScalarActionD;$/;"	t	namespace:Grid::QCD
ScalarActionF	lib/qcd/action/scalar/Scalar.h	/^  typedef ScalarAction<ScalarImplF>                 ScalarActionF;$/;"	t	namespace:Grid::QCD
ScalarActionParameters	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^  ScalarActionParameters(Reader<ReaderClass>& Reader){$/;"	f	class:Grid::ScalarActionParameters
ScalarActionParameters	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^class ScalarActionParameters : Serializable {$/;"	c	namespace:Grid	file:
ScalarActionR	lib/qcd/action/scalar/Scalar.h	/^  typedef ScalarAction<ScalarImplR>                 ScalarActionR;$/;"	t	namespace:Grid::QCD
ScalarAdjGenericHMCRunner	lib/qcd/hmc/GenericHMCrunner.h	/^    ScalarAdjGenericHMCRunner;$/;"	t	namespace:Grid::QCD
ScalarAdjImplD	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarAdjMatrixImplTypes<vComplexD, QCD::Nc> ScalarAdjImplD;$/;"	t	namespace:Grid
ScalarAdjImplF	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarAdjMatrixImplTypes<vComplexF, QCD::Nc> ScalarAdjImplF;$/;"	t	namespace:Grid
ScalarAdjImplR	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarAdjMatrixImplTypes<vComplex,  QCD::Nc> ScalarAdjImplR;$/;"	t	namespace:Grid
ScalarAdjMatrixImplTypes	lib/qcd/action/scalar/ScalarImpl.h	/^  class ScalarAdjMatrixImplTypes {$/;"	c	namespace:Grid
ScalarGenericHMCRunner	lib/qcd/hmc/GenericHMCrunner.h	/^    ScalarGenericHMCRunner;$/;"	t	namespace:Grid::QCD
ScalarImplCD	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarImplTypes<vComplexD> ScalarImplCD;$/;"	t	namespace:Grid
ScalarImplCF	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarImplTypes<vComplexF> ScalarImplCF;$/;"	t	namespace:Grid
ScalarImplCR	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarImplTypes<vComplex> ScalarImplCR;$/;"	t	namespace:Grid
ScalarImplD	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarImplTypes<vRealD> ScalarImplD;$/;"	t	namespace:Grid
ScalarImplF	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarImplTypes<vRealF> ScalarImplF;$/;"	t	namespace:Grid
ScalarImplR	lib/qcd/action/scalar/ScalarImpl.h	/^  typedef ScalarImplTypes<vReal> ScalarImplR;$/;"	t	namespace:Grid
ScalarImplTypes	lib/qcd/action/scalar/ScalarImpl.h	/^class ScalarImplTypes {$/;"	c	namespace:Grid
ScalarInteractionAction	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    ScalarInteractionAction(RealD ms, RealD l) : mass_square(ms), lambda(l), displacements(2*Ndim,0), directions(2*Ndim,0){$/;"	f	class:Grid::ScalarInteractionAction
ScalarInteractionAction	lib/qcd/action/scalar/ScalarInteractionAction.h	/^  class ScalarInteractionAction : public QCD::Action<typename Impl::Field> {$/;"	c	namespace:Grid
ScalarIsComplex	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::PardisoImpl::__anon654
ScalarMatrix	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> ScalarMatrix;$/;"	t	class:Eigen::internal::SparseLUImpl
ScalarObs	lib/qcd/utils/ScalarObjs.h	/^class ScalarObs {$/;"	c	namespace:Grid
ScalarPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits
ScalarPointer	lib/Eigen/src/SparseCore/SparseMap.h	/^                         Scalar *, const Scalar *>::type ScalarPointer;$/;"	t	class:Eigen::SparseMapBase
ScalarTraits	lib/Eigen/src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox
ScalarTypeMatch	lib/Eigen/src/Core/Ref.h	/^      ScalarTypeMatch = internal::is_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::match::__anon150
ScalarVector	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::ScalarVector ScalarVector;$/;"	t	class:Eigen::SparseMatrix
ScalarVector	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::SparseMatrixBase
ScalarVector	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::SparseLU
ScalarVector	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl
ScalarVector	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
ScalarVector	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef Matrix<Scalar, Dynamic, 1> ScalarVector;$/;"	t	class:Eigen::SparseQR
ScalarWithConstIfNotLvalue	lib/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper
ScalarWithConstIfNotLvalue	lib/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper
ScalarWithConstIfNotLvalue	lib/Eigen/src/Core/Diagonal.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::Diagonal
ScalarWithConstIfNotLvalue	lib/Eigen/src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase
ScalarWithConstIfNotLvalue	lib/Eigen/src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl
ScaledShamirFermion	lib/qcd/action/fermion/ScaledShamirFermion.h	/^    ScaledShamirFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::ScaledShamirFermion
ScaledShamirFermion	lib/qcd/action/fermion/ScaledShamirFermion.h	/^    class ScaledShamirFermion : public MobiusFermion<Impl>$/;"	c	namespace:Grid::QCD
ScaledShamirFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef ScaledShamirFermion<WilsonImplD> ScaledShamirFermionD;$/;"	t	namespace:Grid::QCD
ScaledShamirFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef ScaledShamirFermion<WilsonImplF> ScaledShamirFermionF;$/;"	t	namespace:Grid::QCD
ScaledShamirFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef ScaledShamirFermion<WilsonImplR> ScaledShamirFermionR;$/;"	t	namespace:Grid::QCD
ScaledShamirVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef ScaledShamirFermion<DomainWallVec5dImplR>                    ScaledShamirVecFermionR;$/;"	t	file:
Scaling	lib/Eigen/src/Geometry/Scaling.h	/^inline DiagonalMatrix<Scalar,2> Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	namespace:Eigen
Scaling	lib/Eigen/src/Geometry/Scaling.h	/^inline DiagonalMatrix<Scalar,3> Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	namespace:Eigen
Scaling	lib/Eigen/src/Geometry/Scaling.h	/^inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen
Scaling	lib/Eigen/src/Geometry/Scaling.h	/^inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen
Scaling	lib/Eigen/src/Geometry/Scaling.h	/^inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen
Scaling	lib/Eigen/src/Geometry/Scaling.h	/^inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen
ScatterPlane	lib/stencil/Stencil.h	/^  void ScatterPlane (int point,int dimension,int plane,int cbmask,int offset, int wrap)$/;"	f	class:Grid::CartesianStencil
Scatter_plane_merge	lib/cshift/Cshift_common.h	/^template<class vobj> void Scatter_plane_merge(Lattice<vobj> &rhs,std::vector<typename vobj::scalar_object *> pointers,int dimension,int plane,int cbmask)$/;"	f	namespace:Grid
Scatter_plane_simple	lib/cshift/Cshift_common.h	/^template<class vobj> void Scatter_plane_simple (Lattice<vobj> &rhs,commVector<vobj> &buffer, int dimension,int plane,int cbmask)$/;"	f	namespace:Grid
SchurDiagMooeeOperator	lib/algorithms/LinearOperator.h	/^      SchurDiagMooeeOperator (Matrix &Mat): _Mat(Mat){};$/;"	f	class:Grid::SchurDiagMooeeOperator
SchurDiagMooeeOperator	lib/algorithms/LinearOperator.h	/^      class SchurDiagMooeeOperator :  public SchurOperatorBase<Field> {$/;"	c	namespace:Grid
SchurDiagOneOperator	lib/algorithms/LinearOperator.h	/^      SchurDiagOneOperator (Matrix &Mat): _Mat(Mat){};$/;"	f	class:Grid::SchurDiagOneOperator
SchurDiagOneOperator	lib/algorithms/LinearOperator.h	/^      class SchurDiagOneOperator :  public SchurOperatorBase<Field> {$/;"	c	namespace:Grid
SchurDiagTwoKappaOperator	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    SchurDiagTwoKappaOperator (Matrix &Mat): _S(Mat), _Mat(Mat) {};$/;"	f	class:Grid::SchurDiagTwoKappaOperator
SchurDiagTwoKappaOperator	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    class SchurDiagTwoKappaOperator :  public SchurOperatorBase<Field> {$/;"	c	namespace:Grid
SchurDiagTwoOperator	lib/algorithms/LinearOperator.h	/^      SchurDiagTwoOperator (Matrix &Mat): _Mat(Mat){};$/;"	f	class:Grid::SchurDiagTwoOperator
SchurDiagTwoOperator	lib/algorithms/LinearOperator.h	/^      class SchurDiagTwoOperator :  public SchurOperatorBase<Field> {$/;"	c	namespace:Grid
SchurDifferentiableOperator	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	/^        SchurDifferentiableOperator (Matrix &Mat) : SchurDiagMooeeOperator<Matrix,FermionField>(Mat) {};$/;"	f	class:Grid::QCD::SchurDifferentiableOperator
SchurDifferentiableOperator	lib/qcd/action/pseudofermion/EvenOddSchurDifferentiable.h	/^    class SchurDifferentiableOperator :  public SchurDiagMooeeOperator<FermionOperator<Impl>,typename Impl::FermionField> $/;"	c	namespace:Grid::QCD
SchurOperatorBase	lib/algorithms/LinearOperator.h	/^      class SchurOperatorBase :  public LinearOperatorBase<Field> {$/;"	c	namespace:Grid
SchurRedBlackDiagMooeeSolve	lib/algorithms/iterative/SchurRedBlack.h	/^  SchurRedBlackDiagMooeeSolve(OperatorFunction<Field> &HermitianRBSolver)  :$/;"	f	class:Grid::SchurRedBlackDiagMooeeSolve
SchurRedBlackDiagMooeeSolve	lib/algorithms/iterative/SchurRedBlack.h	/^  template<class Field> class SchurRedBlackDiagMooeeSolve {$/;"	c	namespace:Grid
ScidacChecksum	lib/parallelIO/BinaryIO.h	/^  template<class fobj> static inline void ScidacChecksum(GridBase *grid,std::vector<fobj> &fbuf,uint32_t &scidac_csuma,uint32_t &scidac_csumb)$/;"	f	class:Grid::BinaryIO
ScidacMetaData	lib/parallelIO/IldgIO.h	/^ template<class vobj> void ScidacMetaData(Lattice<vobj> & field,$/;"	f	namespace:Grid::QCD
ScidacRecordTypeString	lib/parallelIO/IldgIO.h	/^ template<class vobj> std::string ScidacRecordTypeString(Lattice<vobj> & lat,int &colors, int &spins, int & typesize,int &datacount) { $/;"	f	namespace:Grid::QCD
ScidacRecordTypeString	lib/parallelIO/IldgIO.h	/^ template<class vobj> std::string ScidacRecordTypeString(int &colors, int &spins, int & typesize,int &datacount) { $/;"	f	namespace:Grid::QCD
ScidacWordMnemonic	lib/parallelIO/IldgIO.h	/^ template<> inline std::string ScidacWordMnemonic< int32_t>(void){ return std::string("I32_t"); }$/;"	f	namespace:Grid::QCD
ScidacWordMnemonic	lib/parallelIO/IldgIO.h	/^ template<> inline std::string ScidacWordMnemonic< int64_t>(void){ return std::string("I64_t"); }$/;"	f	namespace:Grid::QCD
ScidacWordMnemonic	lib/parallelIO/IldgIO.h	/^ template<> inline std::string ScidacWordMnemonic<double>  (void){ return std::string("D"); }$/;"	f	namespace:Grid::QCD
ScidacWordMnemonic	lib/parallelIO/IldgIO.h	/^ template<> inline std::string ScidacWordMnemonic<float>   (void){ return std::string("F"); }$/;"	f	namespace:Grid::QCD
ScidacWordMnemonic	lib/parallelIO/IldgIO.h	/^ template<> inline std::string ScidacWordMnemonic<uint32_t>(void){ return std::string("U32_t"); }$/;"	f	namespace:Grid::QCD
ScidacWordMnemonic	lib/parallelIO/IldgIO.h	/^ template<> inline std::string ScidacWordMnemonic<uint64_t>(void){ return std::string("U64_t"); }$/;"	f	namespace:Grid::QCD
ScidacWordMnemonic	lib/parallelIO/IldgIO.h	/^ template<class word> inline std::string ScidacWordMnemonic(void){ return std::string("unknown"); }$/;"	f	namespace:Grid::QCD
ScidacWriter	lib/parallelIO/IldgIO.h	/^class ScidacWriter : public GridLimeWriter {$/;"	c	namespace:Grid::QCD
Score_is_abs	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef void Score_is_abs;$/;"	t	struct:Eigen::internal::scalar_score_coeff_op
See	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      std::vector<double> See;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
Seed	lib/lattice/Lattice_rng.h	/^    template<class source> void Seed(source &src, int gen)$/;"	f	class:Grid::GridRNGbase
SeedFixedIntegers	lib/lattice/Lattice_rng.h	/^    void SeedFixedIntegers(const std::vector<int> &seeds){$/;"	f	class:Grid::GridParallelRNG
SeedFixedIntegers	lib/lattice/Lattice_rng.h	/^    void SeedFixedIntegers(const std::vector<int> &seeds){$/;"	f	class:Grid::GridSerialRNG
SeedFixedIntegers	lib/qcd/hmc/HMCResourceManager.h	/^  void SeedFixedIntegers() {$/;"	f	class:Grid::QCD::HMCResourceManager
SegmentReturnType	lib/Eigen/src/plugins/BlockMethods.h	/^typedef VectorBlock<Derived> SegmentReturnType;$/;"	t
Select	lib/Eigen/src/Core/Select.h	/^    Select(const ConditionMatrixType& a_conditionMatrix,$/;"	f	class:Eigen::Select
Select	lib/Eigen/src/Core/Select.h	/^class Select : public internal::dense_xpr_base< Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >::type,$/;"	c	namespace:Eigen
Selector	lib/Eigen/src/Core/GenericPacketMath.h	/^template <size_t N> struct Selector {$/;"	s	namespace:Eigen::internal
SelfAdjoint	lib/Eigen/src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::UpLoType
SelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    explicit SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    explicit SelfAdjointEigenSolver(const EigenBase<InputType>& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
SelfAdjointShape	lib/Eigen/src/Core/util/Constants.h	/^struct SelfAdjointShape       { static std::string debugName() { return "SelfAdjointShape"; } };$/;"	s	namespace:Eigen
SelfAdjointView	lib/Eigen/src/Core/SelfAdjointView.h	/^    explicit inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView
SelfAdjointView	lib/Eigen/src/Core/SelfAdjointView.h	/^template<typename _MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen
SelfAdjointViewReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
SelfAdjointViewReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SparseSelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::SparseMatrixBase
SemInit	lib/communicator/Communicator_mpi3_leader.cc	/^  void SemInit(void) {$/;"	f	class:Grid::Slave
SemInitExcl	lib/communicator/Communicator_mpi3_leader.cc	/^  void SemInitExcl(void) {$/;"	f	class:Grid::Slave
SendRecvPacket	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::SendRecvPacket(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendRecvPacket	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::SendRecvPacket(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendRecvPacket	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::SendRecvPacket(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendRecvPacket	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::SendRecvPacket(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendRecvPacket	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::SendRecvPacket(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFrom	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::SendToRecvFrom(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFrom	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::SendToRecvFrom(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFrom	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::SendToRecvFrom(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFrom	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::SendToRecvFrom(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFrom	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::SendToRecvFrom(void *xmit,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromBegin	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::SendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromBegin	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::SendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromBegin	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::SendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromBegin	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::SendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromBegin	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::SendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromComplete	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::SendToRecvFromComplete(std::vector<CommsRequest_t> &list)$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromComplete	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::SendToRecvFromComplete(std::vector<CommsRequest_t> &list)$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromComplete	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::SendToRecvFromComplete(std::vector<CommsRequest_t> &list)$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromComplete	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::SendToRecvFromComplete(std::vector<CommsRequest_t> &list)$/;"	f	class:Grid::CartesianCommunicator
SendToRecvFromComplete	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::SendToRecvFromComplete(std::vector<CommsRequest_t> &list)$/;"	f	class:Grid::CartesianCommunicator
SeqGammaPar	extras/Hadrons/Modules/MSource/SeqGamma.hpp	/^class SeqGammaPar: Serializable$/;"	c
SeqGammaPar	lib/Hadrons/Modules/MSource/SeqGamma.hpp	/^class SeqGammaPar: Serializable$/;"	c
Sequential	lib/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
SequentialLinSpacedReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
Sequential_t	lib/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
Serialiser	tests/hmc/Test_hmc_Factories.cc	/^typedef Grid::XmlReader       Serialiser;$/;"	t	namespace:Grid	file:
Serializable	lib/serialisation/BaseIO.h	/^  class Serializable$/;"	c	namespace:Grid
SetAction	lib/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
SetCoefficientsInternal	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::SetCoefficientsInternal(RealD zolo_hi,std::vector<Coeff_t> & gamma,RealD b,RealD c)$/;"	f	class:Grid::QCD::CayleyFermion5D
SetCoefficientsTanh	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::SetCoefficientsTanh(Approx::zolotarev_data *zdata,RealD b,RealD c)$/;"	f	class:Grid::QCD::CayleyFermion5D
SetCoefficientsTanh	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void ContinuedFractionFermion5D<Impl>::SetCoefficientsTanh(Approx::zolotarev_data *zdata,RealD scale)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
SetCoefficientsTanh	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void  PartialFractionFermion5D<Impl>::SetCoefficientsTanh(Approx::zolotarev_data *zdata,RealD scale){$/;"	f	class:Grid::QCD::PartialFractionFermion5D
SetCoefficientsZolotarev	lib/qcd/action/fermion/CayleyFermion5D.cc	/^void CayleyFermion5D<Impl>::SetCoefficientsZolotarev(RealD zolo_hi,Approx::zolotarev_data *zdata,RealD b,RealD c)$/;"	f	class:Grid::QCD::CayleyFermion5D
SetCoefficientsZolotarev	lib/qcd/action/fermion/ContinuedFractionFermion5D.cc	/^    void ContinuedFractionFermion5D<Impl>::SetCoefficientsZolotarev(RealD zolo_hi,Approx::zolotarev_data *zdata)$/;"	f	class:Grid::QCD::ContinuedFractionFermion5D
SetCoefficientsZolotarev	lib/qcd/action/fermion/PartialFractionFermion5D.cc	/^    void  PartialFractionFermion5D<Impl>::SetCoefficientsZolotarev(RealD zolo_hi,Approx::zolotarev_data *zdata){$/;"	f	class:Grid::QCD::PartialFractionFermion5D
SetCommunicatorPolicy	lib/communicator/Communicator_base.h	/^  static void SetCommunicatorPolicy(CommunicatorPolicy_t policy ) { CommunicatorPolicy = policy; }$/;"	f	class:Grid::CartesianCommunicator
SetCores	lib/threads/Threads.h	/^  static void SetCores(int cr) { $/;"	f	class:Grid::GridThread
SetDiag	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon380
SetDiag	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon381
SetEngine	lib/lattice/Lattice_rng.h	/^    void SetEngine(RngEngine &Eng, int gen){$/;"	f	class:Grid::GridRNGbase
SetMaxThreads	lib/threads/Threads.h	/^  static void SetMaxThreads(void) { $/;"	f	class:Grid::GridThread
SetRNGSeeds	lib/qcd/hmc/HMCResourceManager.h	/^  void SetRNGSeeds(RNGModuleParameters& Params) { RNGs.set_RNGSeeds(Params); }$/;"	f	class:Grid::QCD::HMCResourceManager
SetState	lib/lattice/Lattice_rng.h	/^    void SetState(std::vector<RngStateType> & saved,RngEngine &eng){$/;"	f	class:Grid::GridRNGbase
SetState	lib/lattice/Lattice_rng.h	/^    void SetState(std::vector<RngStateType> & saved,int gen){$/;"	f	class:Grid::GridRNGbase
SetThreads	lib/threads/Threads.h	/^  static void SetThreads(int thr) { $/;"	f	class:Grid::GridThread
ShamirZolotarevFermion	lib/qcd/action/fermion/ShamirZolotarevFermion.h	/^    ShamirZolotarevFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::ShamirZolotarevFermion
ShamirZolotarevFermion	lib/qcd/action/fermion/ShamirZolotarevFermion.h	/^    class ShamirZolotarevFermion : public MobiusZolotarevFermion<Impl>$/;"	c	namespace:Grid::QCD
ShamirZolotarevFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef ShamirZolotarevFermion<WilsonImplD> ShamirZolotarevFermionD;$/;"	t	namespace:Grid::QCD
ShamirZolotarevFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef ShamirZolotarevFermion<WilsonImplF> ShamirZolotarevFermionF;$/;"	t	namespace:Grid::QCD
ShamirZolotarevFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef ShamirZolotarevFermion<WilsonImplR> ShamirZolotarevFermionR;$/;"	t	namespace:Grid::QCD
ShamirZolotarevVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef ShamirZolotarevFermion<DomainWallVec5dImplR>                 ShamirZolotarevVecFermionR;$/;"	t	file:
Shape	lib/Eigen/src/Core/BandMatrix.h	/^  typedef BandShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef typename storage_kind_to_shape<typename traits<T>::StorageKind>::Shape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits_base
Shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<Dense>                  { typedef DenseShape Shape;           };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<PermutationStorage>     { typedef PermutationShape Shape;     };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<SolverStorage>          { typedef SolverShape Shape;           };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<TranspositionsStorage>  { typedef TranspositionsShape Shape;  };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	lib/Eigen/src/Core/DiagonalMatrix.h	/^template<> struct storage_kind_to_shape<DiagonalShape> { typedef DiagonalShape Shape; };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef SelfAdjointShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename glue_shapes<typename evaluator_traits<MatrixType>::Shape, TriangularShape>::type Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef HomogeneousShape Shape;  $/;"	t	struct:Eigen::internal::evaluator_traits
Shape	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequenceShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	lib/Eigen/src/SparseCore/SparseAssign.h	/^  typedef SparseShape Shape;$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef SparseSelfAdjointShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef SparseShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
ShiftStaple	lib/qcd/action/gauge/GaugeImplementations.h	/^  static inline GaugeLinkField ShiftStaple(const GaugeLinkField &Link, int mu) {$/;"	f	class:Grid::QCD::ConjugateGaugeImpl
ShiftStaple	lib/qcd/action/gauge/GaugeImplementations.h	/^  static inline GaugeLinkField ShiftStaple(const GaugeLinkField &Link, int mu) {$/;"	f	class:Grid::QCD::PeriodicGaugeImpl
ShiftedMdagMLinearOperator	lib/algorithms/LinearOperator.h	/^    ShiftedMdagMLinearOperator(Matrix &Mat,RealD shift): _Mat(Mat), _shift(shift){};$/;"	f	class:Grid::ShiftedMdagMLinearOperator
ShiftedMdagMLinearOperator	lib/algorithms/LinearOperator.h	/^    class ShiftedMdagMLinearOperator : public LinearOperatorBase<Field> {$/;"	c	namespace:Grid
ShiftedRanks	lib/communicator/Communicator_mpi.cc	/^void CartesianCommunicator::ShiftedRanks(int dim,int shift,int &source,int &dest)$/;"	f	class:Grid::CartesianCommunicator
ShiftedRanks	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::ShiftedRanks(int dim,int shift,int &dest,int &source)$/;"	f	class:Grid::CartesianCommunicator
ShiftedRanks	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::ShiftedRanks(int dim,int shift,int &source,int &dest)$/;"	f	class:Grid::CartesianCommunicator
ShiftedRanks	lib/communicator/Communicator_none.cc	/^void CartesianCommunicator::ShiftedRanks(int dim,int shift,int &source,int &dest)$/;"	f	class:Grid::CartesianCommunicator
ShiftedRanks	lib/communicator/Communicator_shmem.cc	/^void CartesianCommunicator::ShiftedRanks(int dim,int shift,int &source,int &dest)$/;"	f	class:Grid::CartesianCommunicator
ShmBufStorageVector	lib/communicator/Communicator_base.cc	/^commVector<uint8_t> CartesianCommunicator::ShmBufStorageVector;$/;"	m	class:Grid::CartesianCommunicator	file:
ShmBufStorageVector	lib/communicator/Communicator_base.h	/^  static commVector<uint8_t> ShmBufStorageVector;$/;"	m	class:Grid::CartesianCommunicator
ShmBuffer	lib/communicator/Communicator_base.cc	/^void *CartesianCommunicator::ShmBuffer(int rank) {$/;"	f	class:Grid::CartesianCommunicator
ShmBuffer	lib/communicator/Communicator_mpi3.cc	/^void *CartesianCommunicator::ShmBuffer(int rank)$/;"	f	class:Grid::CartesianCommunicator
ShmBuffer	lib/communicator/Communicator_mpi3_leader.cc	/^void *CartesianCommunicator::ShmBuffer(int rank) {$/;"	f	class:Grid::CartesianCommunicator
ShmBufferFreeAll	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::ShmBufferFreeAll(void) { $/;"	f	class:Grid::CartesianCommunicator
ShmBufferMalloc	lib/communicator/Communicator_base.cc	/^void *CartesianCommunicator::ShmBufferMalloc(size_t bytes){$/;"	f	class:Grid::CartesianCommunicator
ShmBufferSelf	lib/communicator/Communicator_base.cc	/^void *CartesianCommunicator::ShmBufferSelf(void) { return ShmCommBuf; }$/;"	f	class:Grid::CartesianCommunicator
ShmBufferSelf	lib/communicator/Communicator_mpi3.cc	/^void *CartesianCommunicator::ShmBufferSelf(void)$/;"	f	class:Grid::CartesianCommunicator
ShmBufferSelf	lib/communicator/Communicator_mpi3_leader.cc	/^void *CartesianCommunicator::ShmBufferSelf(void) { return ShmCommBuf; }$/;"	f	class:Grid::CartesianCommunicator
ShmBufferTranslate	lib/communicator/Communicator_base.cc	/^void *CartesianCommunicator::ShmBufferTranslate(int rank,void * local_p) { $/;"	f	class:Grid::CartesianCommunicator
ShmBufferTranslate	lib/communicator/Communicator_mpi3.cc	/^void *CartesianCommunicator::ShmBufferTranslate(int rank,void * local_p)$/;"	f	class:Grid::CartesianCommunicator
ShmBufferTranslate	lib/communicator/Communicator_mpi3_leader.cc	/^void *CartesianCommunicator::ShmBufferTranslate(int rank,void * local_p) { $/;"	f	class:Grid::CartesianCommunicator
ShmComm	lib/communicator/Communicator_base.h	/^  static MPI_Comm ShmComm;$/;"	m	class:Grid::CartesianCommunicator
ShmComm	lib/communicator/Communicator_mpi3.cc	/^MPI_Comm CartesianCommunicator::ShmComm;$/;"	m	class:Grid::CartesianCommunicator	file:
ShmCommBuf	lib/communicator/Communicator_base.cc	/^void *              CartesianCommunicator::ShmCommBuf;$/;"	m	class:Grid::CartesianCommunicator	file:
ShmCommBuf	lib/communicator/Communicator_base.h	/^  static void * ShmCommBuf;$/;"	m	class:Grid::CartesianCommunicator
ShmCommBufs	lib/communicator/Communicator_base.h	/^  static std::vector<void *> ShmCommBufs;$/;"	m	class:Grid::CartesianCommunicator
ShmCommBufs	lib/communicator/Communicator_mpi3.cc	/^std::vector<void *> CartesianCommunicator::ShmCommBufs;$/;"	m	class:Grid::CartesianCommunicator	file:
ShmCoor	lib/communicator/Communicator_base.h	/^  std::vector<int> ShmCoor;$/;"	m	class:Grid::CartesianCommunicator
ShmDims	lib/communicator/Communicator_base.h	/^  std::vector<int>  ShmDims;$/;"	m	class:Grid::CartesianCommunicator
ShmInitGeneric	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::ShmInitGeneric(void){$/;"	f	class:Grid::CartesianCommunicator
ShmRank	lib/communicator/Communicator_base.h	/^  static int ShmRank;$/;"	m	class:Grid::CartesianCommunicator
ShmRank	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::ShmRank;$/;"	m	class:Grid::CartesianCommunicator	file:
ShmSetup	lib/communicator/Communicator_base.h	/^  static int ShmSetup;$/;"	m	class:Grid::CartesianCommunicator
ShmSetup	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::ShmSetup = 0;$/;"	m	class:Grid::CartesianCommunicator	file:
ShmSetup	lib/communicator/Communicator_mpi3_leader.cc	/^  static int ShmSetup;$/;"	m	class:Grid::MPIoffloadEngine	file:
ShmSetup	lib/communicator/Communicator_mpi3_leader.cc	/^int MPIoffloadEngine::ShmSetup = 0;$/;"	m	class:Grid::MPIoffloadEngine	file:
ShmSize	lib/communicator/Communicator_base.h	/^  static int ShmSize;$/;"	m	class:Grid::CartesianCommunicator
ShmSize	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::ShmSize;$/;"	m	class:Grid::CartesianCommunicator	file:
ShmWindow	lib/communicator/Communicator_base.h	/^  static MPI_Win ShmWindow; $/;"	m	class:Grid::CartesianCommunicator
ShmWindow	lib/communicator/Communicator_mpi3.cc	/^MPI_Win  CartesianCommunicator::ShmWindow;$/;"	m	class:Grid::CartesianCommunicator	file:
Side	lib/Eigen/src/Core/ProductEvaluators.h	/^  enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::internal::generic_product_impl::__anon175
SideType	lib/Eigen/src/Core/util/Constants.h	/^enum SideType {$/;"	g	namespace:Eigen
SignMatrix	lib/Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	g	namespace:Eigen::internal
SignReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sign_op<Scalar>, const Derived> SignReturnType;$/;"	t
Simd	lib/qcd/action/gauge/GaugeImplTypes.h	/^  typedef S Simd;$/;"	t	class:Grid::QCD::GaugeImplTypes
Simd	lib/qcd/action/gauge/Photon.h	/^    typedef S Simd;$/;"	t	class:Grid::QCD::QedGimpl
Simd	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef S Simd;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
Simd	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef S Simd;$/;"	t	class:Grid::ScalarImplTypes
SimdApply	lib/simd/Grid_vector_types.h	/^  friend inline Grid_simd SimdApply(const functor &func, const Grid_simd &v) {$/;"	f	class:Grid::Grid_simd
SimdApplyBinop	lib/simd/Grid_vector_types.h	/^  friend inline Grid_simd SimdApplyBinop(const functor &func,$/;"	f	class:Grid::Grid_simd
SimdL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef typename Options::template PrecisionMapper<Simd>::LowerPrecVector SimdL;$/;"	t	class:Grid::QCD::WilsonImpl
SimdL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef typename Options::template PrecisionMapper<Simd>::LowerPrecVector SimdL;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SimdL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef typename Options::template PrecisionMapper<Simd>::LowerPrecVector SimdL;$/;"	t	class:Grid::QCD::GparityWilsonImpl
SimpleCompressor	lib/stencil/SimpleCompressor.h	/^class SimpleCompressor {$/;"	c	namespace:Grid
SimplicialCholesky	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholesky	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialCholesky	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholeskyBase	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
SimplicialCholeskyLDLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyLLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyMode	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
SimplicialLDLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLDLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialLDLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT
SimplicialLLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialLLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
SinRealFunctor	lib/simd/Grid_vector_unops.h	/^struct SinRealFunctor {$/;"	s	namespace:Grid
SinReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sin_op<Scalar>, const Derived> SinReturnType;$/;"	t
SinglePrecGrid	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    GridBase* SinglePrecGrid; \/\/Grid for single-precision fields$/;"	m	class:Grid::MixedPrecisionConjugateGradient
SingletonVector	lib/Eigen/src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector
SingletonVector	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix
SingularValuesType	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef typename Base::SingularValuesType SingularValuesType;$/;"	t	class:Eigen::BDCSVD
SingularValuesType	lib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename Base::SingularValuesType SingularValuesType;$/;"	t	class:Eigen::JacobiSVD
SingularValuesType	lib/Eigen/src/SVD/SVDBase.h	/^  typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::SVDBase
SinhReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sinh_op<Scalar>, const Derived> SinhReturnType;$/;"	t
SiteComplex	lib/qcd/action/gauge/GaugeImplTypes.h	/^  typedef iImplScalar<Simd>     SiteComplex;$/;"	t	class:Grid::QCD::GaugeImplTypes
SiteComplex	lib/qcd/action/gauge/Photon.h	/^    typedef SiteField             SiteComplex;$/;"	t	class:Grid::QCD::QedGimpl
SiteComplex	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef SiteField        SiteComplex;$/;"	t	class:Grid::ScalarImplTypes
SiteComplex	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef iImplComplex<Simd> SiteComplex;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
SiteDoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplDoubledGaugeField<Simd> SiteDoubledGaugeField;$/;"	t	class:Grid::QCD::StaggeredImpl
SiteDoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplDoubledGaugeField<Simd> SiteDoubledGaugeField;$/;"	t	class:Grid::QCD::WilsonImpl
SiteDoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplDoubledGaugeField<typename Simd::scalar_type>  SiteDoubledGaugeField;  \/\/ This is a scalar$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
SiteDoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef iImplDoubledGaugeField<typename Simd::scalar_type>  SiteDoubledGaugeField;  \/\/ This is a scalar$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SiteDoubledGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef iImplDoubledGaugeField<Simd> SiteDoubledGaugeField;$/;"	t	class:Grid::QCD::GparityWilsonImpl
SiteField	lib/qcd/action/gauge/GaugeImplTypes.h	/^  typedef iImplGaugeField<Simd> SiteField;$/;"	t	class:Grid::QCD::GaugeImplTypes
SiteField	lib/qcd/action/gauge/Photon.h	/^    typedef iImplGaugeField<Simd> SiteField;$/;"	t	class:Grid::QCD::QedGimpl
SiteField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef iImplField<Simd>   SiteField;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
SiteField	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef iImplField<Simd> SiteField;$/;"	t	class:Grid::ScalarImplTypes
SiteHalfCommSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplHalfCommSpinor<SimdL>   SiteHalfCommSpinor;$/;"	t	class:Grid::QCD::WilsonImpl
SiteHalfCommSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef iImplHalfCommSpinor<SimdL>   SiteHalfCommSpinor;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SiteHalfCommSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef iImplHalfCommSpinor<SimdL>   SiteHalfCommSpinor;$/;"	t	class:Grid::QCD::GparityWilsonImpl
SiteHalfCommSpinor	lib/qcd/action/fermion/WilsonCompressor.h	/^  typedef _HCspinor SiteHalfCommSpinor;$/;"	t	class:Grid::QCD::WilsonCompressorTemplate
SiteHalfSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplHalfSpinor<Simd>        SiteHalfSpinor;$/;"	t	class:Grid::QCD::StaggeredImpl
SiteHalfSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplHalfSpinor<Simd>        SiteHalfSpinor;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
SiteHalfSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplHalfSpinor<Simd>        SiteHalfSpinor;$/;"	t	class:Grid::QCD::WilsonImpl
SiteHalfSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef iImplHalfSpinor<Simd>        SiteHalfSpinor;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SiteHalfSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef iImplHalfSpinor<Simd>        SiteHalfSpinor;$/;"	t	class:Grid::QCD::GparityWilsonImpl
SiteHalfSpinor	lib/qcd/action/fermion/WilsonCompressor.h	/^  typedef _Hspinor     SiteHalfSpinor;$/;"	t	class:Grid::QCD::WilsonCompressorTemplate
SiteLink	lib/qcd/action/gauge/GaugeImplTypes.h	/^  typedef iImplGaugeLink<Simd>  SiteLink;$/;"	t	class:Grid::QCD::GaugeImplTypes
SiteLink	lib/qcd/action/gauge/Photon.h	/^    typedef iImplGaugeLink<Simd>  SiteLink;$/;"	t	class:Grid::QCD::QedGimpl
SitePropagator	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplPropagator<Simd>        SitePropagator;$/;"	t	class:Grid::QCD::StaggeredImpl
SitePropagator	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplPropagator<Simd>        SitePropagator;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
SitePropagator	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplPropagator<Simd>        SitePropagator;$/;"	t	class:Grid::QCD::WilsonImpl
SitePropagator	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef iImplPropagator<Simd>        SitePropagator;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SitePropagator	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef iImplPropagator<Simd>        SitePropagator;$/;"	t	class:Grid::QCD::GparityWilsonImpl
SitePropagator	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef SiteField          SitePropagator;$/;"	t	class:Grid::ScalarAdjMatrixImplTypes
SitePropagator	lib/qcd/action/scalar/ScalarImpl.h	/^    typedef SiteField        SitePropagator;$/;"	t	class:Grid::ScalarImplTypes
SiteScalarGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplGaugeField<typename Simd::scalar_type>         SiteScalarGaugeField;  \/\/ scalar$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
SiteScalarGaugeField	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef iImplGaugeField<typename Simd::scalar_type>         SiteScalarGaugeField;  \/\/ scalar$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SiteScalarGaugeLink	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplGaugeLink<typename Simd::scalar_type>          SiteScalarGaugeLink;  \/\/ scalar$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
SiteScalarGaugeLink	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef iImplGaugeLink<typename Simd::scalar_type>          SiteScalarGaugeLink;  \/\/ scalar$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SiteSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplSpinor<Simd>            SiteSpinor;$/;"	t	class:Grid::QCD::StaggeredImpl
SiteSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplSpinor<Simd>            SiteSpinor;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
SiteSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef iImplSpinor<Simd>            SiteSpinor;$/;"	t	class:Grid::QCD::WilsonImpl
SiteSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef iImplSpinor<Simd>            SiteSpinor;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
SiteSpinor	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef iImplSpinor<Simd>            SiteSpinor;$/;"	t	class:Grid::QCD::GparityWilsonImpl
SiteSpinor	lib/qcd/action/fermion/WilsonCompressor.h	/^  typedef _Spinor         SiteSpinor;$/;"	t	class:Grid::QCD::WilsonCompressorTemplate
Size	extras/Hadrons/Environment.hpp	/^    typedef SITE_SIZE_TYPE                         Size;$/;"	t	class:Environment
Size	lib/Eigen/src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon124
Size	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon585
Size	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon584
Size	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon579
Size	lib/Hadrons/Environment.hpp	/^    typedef SITE_SIZE_TYPE                         Size;$/;"	t	class:Environment
SizeA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon362
SizeAtCompileTime	lib/Eigen/src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon386
SizeAtCompileTime	lib/Eigen/src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon129
SizeAtCompileTime	lib/Eigen/src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon250
SizeAtCompileTime	lib/Eigen/src/Core/Redux.h	/^    SizeAtCompileTime = XprType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon125
SizeAtCompileTime	lib/Eigen/src/Core/SolverBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon247
SizeAtCompileTime	lib/Eigen/src/Core/TriangularMatrix.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon19
SizeAtCompileTime	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
SizeB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon362
SizeMinusOne	lib/Eigen/src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon152
SizeMinusOne	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon585
SizeMinusOne	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon579
Skip	lib/lattice/Lattice_rng.h	/^    static void Skip(RngEngine &eng)$/;"	f	class:Grid::GridRNGbase
SkipDiag	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipDiag = (Mode&ZeroDiag) ? 1 : 0,$/;"	e	enum:Eigen::TriangularViewImpl::__anon559
SkipDiag	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^         SkipDiag = (Mode&ZeroDiag) ? 1 : 0,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon560
SkipFirst	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::TriangularViewImpl::__anon559
SkipFirst	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  enum { SkipFirst = ((Mode&Lower) && !(ArgType::Flags&RowMajorBit))$/;"	e	enum:Eigen::internal::unary_evaluator::__anon560
SkipLast	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::TriangularViewImpl::__anon559
SkipLast	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^         SkipLast = !SkipFirst,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon560
Slave	lib/communicator/Communicator_mpi3_leader.cc	/^  Slave() {};$/;"	f	class:Grid::Slave
Slave	lib/communicator/Communicator_mpi3_leader.cc	/^class Slave {$/;"	c	namespace:Grid	file:
SlaveState	lib/communicator/Communicator_mpi3_leader.cc	/^class SlaveState {$/;"	c	namespace:Grid	file:
Slaves	lib/communicator/Communicator_mpi3_leader.cc	/^  static std::vector<Slave> Slaves;$/;"	m	class:Grid::MPIoffloadEngine	file:
Slaves	lib/communicator/Communicator_mpi3_leader.cc	/^std::vector<Slave> MPIoffloadEngine::Slaves;$/;"	m	class:Grid::MPIoffloadEngine	file:
SliceVectorizedTraversal	lib/Eigen/src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
SluMatrix	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix
SluMatrix	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
SluMatrix	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen
SluMatrixMapHelper	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
SluMatrixMapHelper	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Small	lib/Eigen/src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon183
SmallPanelWidth	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon380
SmallPanelWidth	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon381
Smear	lib/qcd/smearing/BaseSmearing.h	/^class Smear{$/;"	c
SmearBase	lib/qcd/smearing/StoutSmearing.h	/^  const Smear<Gimpl>* SmearBase;$/;"	m	class:Grid::QCD::Smear_Stout
Smear_APE	lib/qcd/smearing/APEsmearing.h	/^  				Smear_APE():rho(set_rho(1.0)){}$/;"	f	class:Grid::QCD::Smear_APE
Smear_APE	lib/qcd/smearing/APEsmearing.h	/^  				Smear_APE(const std::vector<double>& rho_):rho(rho_){} \/\/ check vector size$/;"	f	class:Grid::QCD::Smear_APE
Smear_APE	lib/qcd/smearing/APEsmearing.h	/^  				Smear_APE(double rho_val):rho(set_rho(rho_val)){}$/;"	f	class:Grid::QCD::Smear_APE
Smear_APE	lib/qcd/smearing/APEsmearing.h	/^  		class Smear_APE: public Smear<Gimpl>{$/;"	c	namespace:Grid::QCD
Smear_Stout	lib/qcd/smearing/StoutSmearing.h	/^  Smear_Stout(Smear<Gimpl>* base) : SmearBase(base) {$/;"	f	class:Grid::QCD::Smear_Stout
Smear_Stout	lib/qcd/smearing/StoutSmearing.h	/^  Smear_Stout(double rho = 1.0) : SmearBase(new Smear_APE<Gimpl>(rho)) {$/;"	f	class:Grid::QCD::Smear_Stout
Smear_Stout	lib/qcd/smearing/StoutSmearing.h	/^class Smear_Stout : public Smear<Gimpl> {$/;"	c	namespace:Grid::QCD
SmearedConfiguration	lib/qcd/smearing/GaugeConfiguration.h	/^  SmearedConfiguration()$/;"	f	class:Grid::QCD::SmearedConfiguration
SmearedConfiguration	lib/qcd/smearing/GaugeConfiguration.h	/^  SmearedConfiguration(GridCartesian* UGrid, unsigned int Nsmear,$/;"	f	class:Grid::QCD::SmearedConfiguration
SmearedConfiguration	lib/qcd/smearing/GaugeConfiguration.h	/^class SmearedConfiguration {$/;"	c	namespace:Grid::QCD
SmearedSet	lib/qcd/smearing/GaugeConfiguration.h	/^  std::vector<GaugeField> SmearedSet;$/;"	m	class:Grid::QCD::SmearedConfiguration
Smearer	lib/qcd/hmc/integrators/Integrator.h	/^  SmearingPolicy& Smearer;$/;"	m	class:Grid::QCD::Integrator
SmearingParameters	tests/hmc/Test_hmc_EOMobiusRatio.cc	/^    SmearingParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::SmearingParameters
SmearingParameters	tests/hmc/Test_hmc_EOMobiusRatio.cc	/^  struct SmearingParameters: Serializable {$/;"	s	namespace:Grid	file:
SmearingParameters	tests/hmc/Test_hmc_EOMobiusRatioManyFlavour.cc	/^    SmearingParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::SmearingParameters
SmearingParameters	tests/hmc/Test_hmc_EOMobiusRatioManyFlavour.cc	/^  struct SmearingParameters: Serializable {$/;"	s	namespace:Grid	file:
SmootherTest	tests/solver/Test_dwf_hdcr.cc	/^  void SmootherTest (const FineField & in){$/;"	f	class:MultiGridPreconditioner
Solve	lib/Eigen/src/Core/Solve.h	/^  Solve(const Decomposition &dec, const RhsType &rhs)$/;"	f	class:Eigen::Solve
Solve	lib/Eigen/src/Core/Solve.h	/^class Solve : public SolveImpl<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>$/;"	c	namespace:Eigen
SolveImpl	lib/Eigen/src/Core/Solve.h	/^class SolveImpl : public internal::generic_xpr_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type$/;"	c	namespace:Eigen
SolveImpl	lib/Eigen/src/Core/Solve.h	/^class SolveImpl<Decomposition,RhsType,Dense>$/;"	c	namespace:Eigen
SolveType	lib/Eigen/src/Core/Solve.h	/^  typedef Solve<Decomposition,RhsType> SolveType;$/;"	t	struct:Eigen::internal::evaluator
SolveType	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef SolveWithGuess<Decomposition,RhsType,GuessType> SolveType;$/;"	t	struct:Eigen::internal::evaluator
SolveWithGuess	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  SolveWithGuess(const Decomposition &dec, const RhsType &rhs, const GuessType &guess)$/;"	f	class:Eigen::SolveWithGuess
SolveWithGuess	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^class SolveWithGuess : public internal::generic_xpr_base<SolveWithGuess<Decomposition,RhsType,GuessType>, MatrixXpr, typename internal::traits<RhsType>::StorageKind>::type$/;"	c	namespace:Eigen
Solver	lib/qcd/utils/CovariantLaplacian.h	/^  OperatorFunction<typename Impl::Field> &Solver;$/;"	m	class:Grid::QCD::LaplacianAdjointField
SolverBase	lib/Eigen/src/Core/SolverBase.h	/^    SolverBase()$/;"	f	class:Eigen::SolverBase
SolverBase	lib/Eigen/src/Core/SolverBase.h	/^class SolverBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
SolverBase	lib/qcd/modules/SolverModules.h	/^  typedef SolverModule<ConjugateGradient, Field, SolverParameters> SolverBase;$/;"	t	class:Grid::ConjugateGradientModule
SolverBase	lib/qcd/modules/SolverModules.h	/^  typedef SolverModule<ConjugateResidual, Field, SolverParameters> SolverBase;$/;"	t	class:Grid::ConjugateResidualModule
SolverModule	lib/qcd/modules/SolverModules.h	/^  SolverModule(Reader<ReaderClass>& Reader) : Parametrized<SPar>(Reader){};$/;"	f	class:Grid::SolverModule
SolverModule	lib/qcd/modules/SolverModules.h	/^  SolverModule(SPar Par) : Parametrized<SPar>(Par) {}$/;"	f	class:Grid::SolverModule
SolverModule	lib/qcd/modules/SolverModules.h	/^class SolverModule$/;"	c	namespace:Grid
SolverObjName	lib/qcd/modules/SolverModules.h	/^class SolverObjName: Serializable {$/;"	c	namespace:Grid
SolverParameters	lib/qcd/modules/SolverModules.h	/^class SolverParameters : Serializable {$/;"	c	namespace:Grid
SolverPtr	lib/qcd/modules/SolverModules.h	/^  std::unique_ptr< SolverType<Field> > SolverPtr;$/;"	m	class:Grid::SolverModule
SolverShape	lib/Eigen/src/Core/util/Constants.h	/^struct SolverShape            { static std::string debugName() { return "SolverShape"; } };$/;"	s	namespace:Eigen
SolverStorage	lib/Eigen/src/Core/util/Constants.h	/^struct SolverStorage {};$/;"	s	namespace:Eigen
SortEigen	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^class SortEigen {$/;"	c	namespace:Grid
SpaceTimeGrid	lib/qcd/utils/SpaceTimeGrid.h	/^class SpaceTimeGrid {$/;"	c	namespace:Grid::QCD
Sparse	lib/Eigen/src/Core/util/Constants.h	/^struct Sparse {};$/;"	s	namespace:Eigen
Sparse2Dense	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct Sparse2Dense  {};$/;"	s	namespace:Eigen::internal
Sparse2Sparse	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct Sparse2Sparse {};$/;"	s	namespace:Eigen::internal
SparseCompressedBase	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    SparseCompressedBase() {}$/;"	f	class:Eigen::SparseCompressedBase
SparseCompressedBase	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^class SparseCompressedBase$/;"	c	namespace:Eigen
SparseLU	lib/Eigen/src/SparseLU/SparseLU.h	/^    SparseLU():m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU
SparseLU	lib/Eigen/src/SparseLU/SparseLU.h	/^    explicit SparseLU(const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
SparseLU	lib/Eigen/src/SparseLU/SparseLU.h	/^class SparseLU : public SparseSolverBase<SparseLU<_MatrixType,_OrderingType> >, public internal::SparseLUImpl<typename _MatrixType::Scalar, typename _MatrixType::StorageIndex>$/;"	c	namespace:Eigen
SparseLUImpl	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^class SparseLUImpl$/;"	c	namespace:Eigen::internal
SparseLUMatrixLReturnType	lib/Eigen/src/SparseLU/SparseLU.h	/^  explicit SparseLUMatrixLReturnType(const MappedSupernodalType& mapL) : m_mapL(mapL)$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
SparseLUMatrixLReturnType	lib/Eigen/src/SparseLU/SparseLU.h	/^struct SparseLUMatrixLReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen
SparseLUMatrixUReturnType	lib/Eigen/src/SparseLU/SparseLU.h	/^  SparseLUMatrixUReturnType(const MatrixLType& mapL, const MatrixUType& mapU)$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
SparseLUMatrixUReturnType	lib/Eigen/src/SparseLU/SparseLU.h	/^struct SparseLUMatrixUReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen
SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase() {}$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index rows, Index cols, Index nnz, IndexPointer outerIndexPtr, IndexPointer innerIndexPtr,$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index rows, Index cols, Index nnz, StorageIndex* outerIndexPtr, StorageIndex* innerIndexPtr,$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index size, Index nnz, IndexPointer innerIndexPtr, ScalarPointer valuePtr)$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index size, Index nnz, StorageIndex* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^class SparseMapBase<Derived,ReadOnlyAccessors>$/;"	c	namespace:Eigen
SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^class SparseMapBase<Derived,WriteAccessors>$/;"	c	namespace:Eigen
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    SparseMatrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    explicit SparseMatrix(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseSelfAdjointView<OtherDerived, UpLo>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen
SparseMatrixBase	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase
SparseMatrixBase	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase$/;"	c	namespace:Eigen
SparseMatrixBase	lib/algorithms/SparseMatrix.h	/^    template<class Field> class SparseMatrixBase {$/;"	c	namespace:Grid
SparseMatrixType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,StorageIndex> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl
SparseMatrixType	lib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef SparseMatrix<_Scalar, _Options, _StorageIndex> SparseMatrixType;$/;"	t	class:Eigen::BlockImpl
SparseMatrixType	lib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef const SparseMatrix<_Scalar, _Options, _StorageIndex> SparseMatrixType;$/;"	t	class:Eigen::BlockImpl
SparseMatrixType	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar,_Options,_StorageIndex> SparseMatrixType;$/;"	t	struct:Eigen::internal::evaluator
SparseQR	lib/Eigen/src/SparseQR/SparseQR.h	/^    SparseQR () :  m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR
SparseQR	lib/Eigen/src/SparseQR/SparseQR.h	/^    explicit SparseQR(const MatrixType& mat) : m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR
SparseQR	lib/Eigen/src/SparseQR/SparseQR.h	/^class SparseQR : public SparseSolverBase<SparseQR<_MatrixType,_OrderingType> >$/;"	c	namespace:Eigen
SparseQRMatrixQReturnType	lib/Eigen/src/SparseQR/SparseQR.h	/^  explicit SparseQRMatrixQReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
SparseQRMatrixQReturnType	lib/Eigen/src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQReturnType : public EigenBase<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen
SparseQRMatrixQTransposeReturnType	lib/Eigen/src/SparseQR/SparseQR.h	/^  explicit SparseQRMatrixQTransposeReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType
SparseQRMatrixQTransposeReturnType	lib/Eigen/src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQTransposeReturnType$/;"	s	namespace:Eigen
SparseQR_QProduct	lib/Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct(const SparseQRType& qr, const Derived& other, bool transpose) : $/;"	f	struct:Eigen::SparseQR_QProduct
SparseQR_QProduct	lib/Eigen/src/SparseQR/SparseQR.h	/^struct SparseQR_QProduct : ReturnByValue<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen
SparseRefBase	lib/Eigen/src/SparseCore/SparseRef.h	/^  SparseRefBase()$/;"	f	class:Eigen::internal::SparseRefBase
SparseRefBase	lib/Eigen/src/SparseCore/SparseRef.h	/^template<typename Derived> class SparseRefBase$/;"	c	namespace:Eigen::internal
SparseSelfAdjoint2Sparse	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct SparseSelfAdjoint2Sparse {};$/;"	s	namespace:Eigen::internal
SparseSelfAdjointShape	lib/Eigen/src/SparseCore/SparseUtil.h	/^struct SparseSelfAdjointShape { static std::string debugName() { return "SparseSelfAdjointShape"; } };$/;"	s	namespace:Eigen::internal
SparseSelfAdjointView	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    explicit inline SparseSelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView
SparseSelfAdjointView	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int _Mode> class SparseSelfAdjointView$/;"	c	namespace:Eigen
SparseShape	lib/Eigen/src/Core/util/Constants.h	/^struct SparseShape            { static std::string debugName() { return "SparseShape"; } };$/;"	s	namespace:Eigen
SparseSolverBase	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    SparseSolverBase()$/;"	f	class:Eigen::SparseSolverBase
SparseSolverBase	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^class SparseSolverBase : internal::noncopyable$/;"	c	namespace:Eigen
SparseSymmetricPermutationProduct	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
SparseSymmetricPermutationProduct	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen
SparseTransposeImpl	lib/Eigen/src/SparseCore/SparseTranspose.h	/^  class SparseTransposeImpl$/;"	c	namespace:Eigen::internal
SparseTransposeImpl	lib/Eigen/src/SparseCore/SparseTranspose.h	/^  class SparseTransposeImpl<MatrixType,CompressedAccessBit>$/;"	c	namespace:Eigen::internal
SparseTriangularShape	lib/Eigen/src/SparseCore/SparseUtil.h	/^struct SparseTriangularShape  { static std::string debugName() { return "SparseTriangularShape"; } };$/;"	s	namespace:Eigen::internal
SparseVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    explicit inline SparseVector(Index size) : m_size(0) { check_template_parameters(); resize(size); }$/;"	f	class:Eigen::SparseVector
SparseVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { check_template_parameters(); resize(0); }$/;"	f	class:Eigen::SparseVector
SparseVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { check_template_parameters(); resize(rows,cols); }$/;"	f	class:Eigen::SparseVector
SparseVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
SparseVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
SparseVector	lib/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen
SparseVectorType	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef SparseVector<_Scalar,_Options,_Index> SparseVectorType;$/;"	t	struct:Eigen::internal::evaluator
SparseView	lib/Eigen/src/SparseCore/SparseView.h	/^  explicit SparseView(const MatrixType& mat, const Scalar& reference = Scalar(0),$/;"	f	class:Eigen::SparseView
SparseView	lib/Eigen/src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen
SparseXprInnerIterator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename evaluator<SparseXprType>::InnerIterator SparseXprInnerIterator;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
SparseXprIter	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename evaluator<SparseXprType>::InnerIterator SparseXprIter;$/;"	t	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
Specialized	lib/Eigen/src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::SpecializedType
SpecializedType	lib/Eigen/src/Core/util/Constants.h	/^enum SpecializedType {$/;"	g	namespace:Eigen
SpinColourMatrix	lib/qcd/QCD.h	/^    typedef iSpinColourMatrix<Complex  >    SpinColourMatrix;$/;"	t	namespace:Grid::QCD
SpinColourMatrixD	lib/qcd/QCD.h	/^    typedef iSpinColourMatrix<ComplexD >    SpinColourMatrixD;$/;"	t	namespace:Grid::QCD
SpinColourMatrixF	lib/qcd/QCD.h	/^    typedef iSpinColourMatrix<ComplexF >    SpinColourMatrixF;$/;"	t	namespace:Grid::QCD
SpinColourVector	lib/qcd/QCD.h	/^    typedef iSpinColourVector<Complex >     SpinColourVector;$/;"	t	namespace:Grid::QCD
SpinColourVectorD	lib/qcd/QCD.h	/^    typedef iSpinColourVector<ComplexD>     SpinColourVectorD;$/;"	t	namespace:Grid::QCD
SpinColourVectorF	lib/qcd/QCD.h	/^    typedef iSpinColourVector<ComplexF>     SpinColourVectorF;$/;"	t	namespace:Grid::QCD
SpinIndex	lib/qcd/QCD.h	65;"	d
SpinMatrix	lib/qcd/LatticeTheories.h	/^    typedef FLGT::iSpinMatrix<Complex  >          SpinMatrix;$/;"	t	struct:Grid::LatticeTheories::QCD
SpinMatrix	lib/qcd/QCD.h	/^    typedef iSpinMatrix<Complex  >          SpinMatrix;$/;"	t	namespace:Grid::QCD
SpinMatrixD	lib/qcd/LatticeTheories.h	/^    typedef FLGT::iSpinMatrix<ComplexD >          SpinMatrixD;$/;"	t	struct:Grid::LatticeTheories::QCD
SpinMatrixD	lib/qcd/QCD.h	/^    typedef iSpinMatrix<ComplexD >          SpinMatrixD;$/;"	t	namespace:Grid::QCD
SpinMatrixF	lib/qcd/LatticeTheories.h	/^    typedef FLGT::iSpinMatrix<ComplexF >          SpinMatrixF;$/;"	t	struct:Grid::LatticeTheories::QCD
SpinMatrixF	lib/qcd/QCD.h	/^    typedef iSpinMatrix<ComplexF >          SpinMatrixF;$/;"	t	namespace:Grid::QCD
SpinVector	lib/qcd/QCD.h	/^    typedef iSpinVector<Complex >           SpinVector;$/;"	t	namespace:Grid::QCD
SpinVectorD	lib/qcd/QCD.h	/^    typedef iSpinVector<ComplexD>           SpinVectorD;$/;"	t	namespace:Grid::QCD
SpinVectorF	lib/qcd/QCD.h	/^    typedef iSpinVector<ComplexF>           SpinVectorF;$/;"	t	namespace:Grid::QCD
SpinorIndex	lib/qcd/QCD.h	/^    const int SpinorIndex = 2;$/;"	m	namespace:Grid::QCD
SqrtApproximation	tests/debug/Test_cheby.cc	/^RealD SqrtApproximation(RealD x){$/;"	f
SqrtApproximation	tests/hmc/Test_multishift_sqrt.cc	/^RealD SqrtApproximation(RealD x){$/;"	f
SqrtRealFunctor	lib/simd/Grid_vector_unops.h	/^struct SqrtRealFunctor {$/;"	s	namespace:Grid
SqrtReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived> SqrtReturnType;$/;"	t
SquareMatrixType	lib/Eigen/src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase
SquareMatrixType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase
SquareReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_square_op<Scalar>, const Derived> SquareReturnType;$/;"	t
SquaredNormReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_squaredNorm,RealScalar>::Type SquaredNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
SrcAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon147
SrcAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,$/;"	e	enum:Eigen::internal::dense_assignment_loop::__anon148
SrcAlignment	lib/Eigen/src/Core/AssignEvaluator.h	/^    SrcAlignment = SrcEvaluator::Alignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon138
SrcCoeffRatio	lib/Eigen/src/Core/GenericPacketMath.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon509
SrcCoeffRatio	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon301
SrcCoeffRatio	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon302
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon272
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon273
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon274
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon275
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon276
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon277
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon278
SrcCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 2,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon271
SrcCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon341
SrcCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon342
SrcCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon344
SrcCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 2,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon343
SrcEvaluatorType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef SrcEvaluatorTypeT SrcEvaluatorType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
SrcEvaluatorType	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::SrcEvaluatorType SrcEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcEvaluatorType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::SrcEvaluatorType SrcEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcFlags	lib/Eigen/src/Core/AssignEvaluator.h	/^    SrcFlags = SrcEvaluator::Flags$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon137
SrcHasDirectAccess	lib/Eigen/src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
SrcIsRowMajor	lib/Eigen/src/Core/AssignEvaluator.h	/^    SrcIsRowMajor = SrcFlags&RowMajorBit,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
SrcStorageOrder	lib/Eigen/src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permutation_matrix_product::__anon556
SrcXprType	lib/Eigen/src/Core/AssignEvaluator.h	/^  typedef typename SrcEvaluatorTypeT::XprType SrcXprType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
SrcXprType	lib/Eigen/src/Core/ProductEvaluators.h	/^                        const Product<Lhs,Rhs,DefaultProduct> > SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs,Rhs,Options> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::SrcXprType SrcXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcXprType	lib/Eigen/src/Core/Solve.h	/^  typedef Solve<CwiseUnaryOp<internal::scalar_conjugate_op<typename DecType::Scalar>, const Transpose<const DecType> >,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/Core/Solve.h	/^  typedef Solve<DecType,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/Core/Solve.h	/^  typedef Solve<Transpose<const DecType>,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::SrcXprType SrcXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcXprType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Homogeneous<ArgType,Horizontal> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Homogeneous<ArgType,Vertical> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef SolveWithGuess<DecType,RhsType,GuessType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/LU/FullPivLU.h	/^  typedef Inverse<LuType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/LU/InverseImpl.h	/^  typedef Inverse<XprType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef Inverse<LuType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^  typedef Inverse<QrType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef Inverse<CodType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef Inverse<QrType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/SparseCore/SparseAssign.h	/^  typedef Solve<DecType,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef Product<Lhs,Rhs,AliasFreeProduct> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef SparseSymmetricPermutationProduct<MatrixType,Mode> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef SparseQRMatrixQReturnType<SparseQRType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
StableNormReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_stableNorm,RealScalar>::Type StableNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
StaggeredImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    StaggeredImpl(const ImplParams &p = ImplParams()) : Params(p){};$/;"	f	class:Grid::QCD::StaggeredImpl
StaggeredImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^class StaggeredImpl : public PeriodicGaugeImpl<GaugeImplTypes<S, Representation::Dimension > > {$/;"	c	namespace:Grid::QCD
StaggeredImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef StaggeredImpl<vComplexD, FundamentalRepresentation > StaggeredImplD;  \/\/ Double$/;"	t	namespace:Grid::QCD
StaggeredImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef StaggeredImpl<vComplexF, FundamentalRepresentation > StaggeredImplF;  \/\/ Float$/;"	t	namespace:Grid::QCD
StaggeredImplParams	lib/qcd/action/ActionParams.h	/^    StaggeredImplParams()  {};$/;"	f	struct:Grid::QCD::StaggeredImplParams
StaggeredImplParams	lib/qcd/action/ActionParams.h	/^  struct StaggeredImplParams {$/;"	s	namespace:Grid::QCD
StaggeredImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef StaggeredImpl<vComplex,  FundamentalRepresentation > StaggeredImplR;   \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
StaggeredKernels	lib/qcd/action/fermion/StaggeredKernels.cc	/^StaggeredKernels<Impl>::StaggeredKernels(const ImplParams &p) : Base(p){};$/;"	f	class:Grid::QCD::StaggeredKernels
StaggeredKernels	lib/qcd/action/fermion/StaggeredKernels.h	/^template<class Impl> class StaggeredKernels : public FermionOperator<Impl> , public StaggeredKernelsStatic { $/;"	c	namespace:Grid::QCD
StaggeredKernelsStatic	lib/qcd/action/fermion/StaggeredKernels.h	/^class StaggeredKernelsStatic { $/;"	c	namespace:Grid::QCD
StaggeredVec5dImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    StaggeredVec5dImpl(const ImplParams &p = ImplParams()) : Params(p){};$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
StaggeredVec5dImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  class StaggeredVec5dImpl : public PeriodicGaugeImpl<GaugeImplTypes<S, Representation::Dimension > > {$/;"	c	namespace:Grid::QCD
StaggeredVec5dImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef StaggeredVec5dImpl<vComplexD, FundamentalRepresentation > StaggeredVec5dImplD;  \/\/ Double$/;"	t	namespace:Grid::QCD
StaggeredVec5dImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef StaggeredVec5dImpl<vComplexF, FundamentalRepresentation > StaggeredVec5dImplF;  \/\/ Float$/;"	t	namespace:Grid::QCD
StaggeredVec5dImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef StaggeredVec5dImpl<vComplex,  FundamentalRepresentation > StaggeredVec5dImplR;   \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
StandardCompressedFormat	lib/Eigen/src/SparseCore/SparseRef.h	/^  StandardCompressedFormat = 2 \/**< used by Ref<SparseMatrix> to specify whether the input storage must be in standard compressed form *\/$/;"	e	enum:Eigen::__anon531
Staple	lib/qcd/utils/WilsonLoops.h	/^  static void Staple(GaugeMat &staple, const GaugeLorentz &Umu, int mu) {$/;"	f	class:Grid::QCD::WilsonLoops
Staple	lib/qcd/utils/WilsonLoops.h	/^  static void Staple(GaugeMat &staple, const GaugeLorentz &Umu, int mu,$/;"	f	class:Grid::QCD::WilsonLoops
StapleLower	lib/qcd/utils/WilsonLoops.h	/^  static void StapleLower(GaugeMat &staple, const GaugeLorentz &Umu, int mu,$/;"	f	class:Grid::QCD::WilsonLoops
StapleMult	lib/qcd/utils/WilsonLoops.h	/^static void StapleMult(GaugeMat &staple, const GaugeLorentz &Umu, int mu) {$/;"	f	class:Grid::QCD::WilsonLoops
StapleUpper	lib/qcd/utils/WilsonLoops.h	/^  static void StapleUpper(GaugeMat &staple, const GaugeLorentz &Umu, int mu,$/;"	f	class:Grid::QCD::WilsonLoops
Start	lib/perfmon/PerfCount.h	/^  void Start(void)$/;"	f	class:Grid::PerformanceCounter
Start	lib/perfmon/Timer.h	/^  void     Start(void) { $/;"	f	class:Grid::GridStopWatch
StartIndex	lib/Eigen/src/Core/SolveTriangular.h	/^    StartIndex = IsLower ? 0         : DiagIndex+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon133
SteepestDescentGaugeFix	lib/qcd/utils/GaugeFix.h	/^  static void SteepestDescentGaugeFix(GaugeLorentz &Umu,Real & alpha,int maxiter,Real Omega_tol, Real Phi_tol,bool Fourier=false) {$/;"	f	class:FourierAcceleratedGaugeFixer
SteepestDescentStep	lib/qcd/utils/GaugeFix.h	/^  static Real SteepestDescentStep(std::vector<GaugeMat> &U,Real & alpha, GaugeMat & dmuAmu) {$/;"	f	class:FourierAcceleratedGaugeFixer
StemFunction	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase
Stencil	lib/algorithms/CoarsenedMatrix.h	/^    CartesianStencil<siteVector,siteVector> Stencil; $/;"	m	class:Grid::CoarsenedMatrix
Stencil	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  StencilImpl Stencil;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
Stencil	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    StencilImpl Stencil; $/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
Stencil	lib/qcd/action/fermion/WilsonFermion.h	/^  StencilImpl Stencil;$/;"	m	class:Grid::QCD::WilsonFermion
Stencil	lib/qcd/action/fermion/WilsonFermion5D.h	/^    StencilImpl Stencil; $/;"	m	class:Grid::QCD::WilsonFermion5D
Stencil	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    typedef CartesianStencil<vobj,vobj> Stencil;$/;"	t	class:Grid::ScalarInteractionAction
Stencil	lib/qcd/utils/CovariantLaplacian.h	/^  typedef CartesianStencil<vobj,vobj> Stencil;$/;"	t	class:Grid::QCD::LaplacianAdjointField
Stencil	tests/debug/test_Grid_jacobi.cc	/^  CartesianStencil *Stencil;$/;"	m	class:LinearOperatorJacobi	file:
StencilBarrier	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::StencilBarrier(void){};$/;"	f	class:Grid::CartesianCommunicator
StencilBarrier	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::StencilBarrier(void)$/;"	f	class:Grid::CartesianCommunicator
StencilBarrier	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::StencilBarrier(void) { }$/;"	f	class:Grid::CartesianCommunicator
StencilEntry	lib/stencil/Stencil.h	/^ struct StencilEntry { $/;"	s	namespace:Grid
StencilEven	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  StencilImpl StencilEven;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
StencilEven	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    StencilImpl StencilEven; $/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
StencilEven	lib/qcd/action/fermion/WilsonFermion.h	/^  StencilImpl StencilEven;$/;"	m	class:Grid::QCD::WilsonFermion
StencilEven	lib/qcd/action/fermion/WilsonFermion5D.h	/^    StencilImpl StencilEven; $/;"	m	class:Grid::QCD::WilsonFermion5D
StencilImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef CartesianStencil<SiteSpinor, SiteSpinor> StencilImpl;$/;"	t	class:Grid::QCD::StaggeredImpl
StencilImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef CartesianStencil<SiteSpinor, SiteSpinor> StencilImpl;$/;"	t	class:Grid::QCD::StaggeredVec5dImpl
StencilImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef WilsonStencil<SiteSpinor, SiteHalfSpinor> StencilImpl;$/;"	t	class:Grid::QCD::WilsonImpl
StencilImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  typedef WilsonStencil<SiteSpinor, SiteHalfSpinor> StencilImpl;$/;"	t	class:Grid::QCD::DomainWallVec5dImpl
StencilImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ typedef WilsonStencil<SiteSpinor, SiteHalfSpinor> StencilImpl;$/;"	t	class:Grid::QCD::GparityWilsonImpl
StencilOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  StencilImpl StencilOdd;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
StencilOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    StencilImpl StencilOdd; $/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
StencilOdd	lib/qcd/action/fermion/WilsonFermion.h	/^  StencilImpl StencilOdd;$/;"	m	class:Grid::QCD::WilsonFermion
StencilOdd	lib/qcd/action/fermion/WilsonFermion5D.h	/^    StencilImpl StencilOdd; $/;"	m	class:Grid::QCD::WilsonFermion5D
StencilSendToRecvFromBegin	lib/communicator/Communicator_base.cc	/^double CartesianCommunicator::StencilSendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
StencilSendToRecvFromBegin	lib/communicator/Communicator_mpi3.cc	/^double CartesianCommunicator::StencilSendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
StencilSendToRecvFromBegin	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::StencilSendToRecvFromBegin(std::vector<CommsRequest_t> &list,$/;"	f	class:Grid::CartesianCommunicator
StencilSendToRecvFromComplete	lib/communicator/Communicator_base.cc	/^void CartesianCommunicator::StencilSendToRecvFromComplete(std::vector<CommsRequest_t> &waitall)$/;"	f	class:Grid::CartesianCommunicator
StencilSendToRecvFromComplete	lib/communicator/Communicator_mpi3.cc	/^void CartesianCommunicator::StencilSendToRecvFromComplete(std::vector<CommsRequest_t> &waitall)$/;"	f	class:Grid::CartesianCommunicator
StencilSendToRecvFromComplete	lib/communicator/Communicator_mpi3_leader.cc	/^void CartesianCommunicator::StencilSendToRecvFromComplete(std::vector<CommsRequest_t> &list)$/;"	f	class:Grid::CartesianCommunicator
StepFunction	tests/debug/Test_cheby.cc	/^RealD StepFunction(RealD x){$/;"	f
StoD	lib/simd/Grid_avx.h	/^    static inline void StoD (__m256 s,__m256d &a,__m256d &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoD	lib/simd/Grid_avx512.h	/^    static inline void StoD (__m512 s,__m512d &a,__m512d &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoD	lib/simd/Grid_generic.h	/^    static inline void StoD (vecf s,vecd &a,vecd &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoD	lib/simd/Grid_neon.h	/^    static inline void StoD (float32x4_t s,float64x2_t &a,float64x2_t &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoD	lib/simd/Grid_qpx.h	/^    static inline void StoD (vector4float s, vector4double &a, vector4double &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoD	lib/simd/Grid_sse4.h	/^    static inline void StoD (__m128 s,__m128d &a,__m128d &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoH	lib/simd/Grid_avx.h	/^    static inline __m256i StoH (__m256 a,__m256 b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoH	lib/simd/Grid_avx512.h	/^    static inline __m512i StoH (__m512 a,__m512 b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoH	lib/simd/Grid_generic.h	/^    static inline vech StoH (const vecf &a,const vecf &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoH	lib/simd/Grid_neon.h	/^    static inline float16x8_t StoH (const float32x4_t &a,const float32x4_t &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoH	lib/simd/Grid_qpx.h	/^    static inline vech StoH (const vector4float &a, const vector4float &b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StoH	lib/simd/Grid_sse4.h	/^    static inline __m128i StoH (__m128 a,__m128 b) {$/;"	f	struct:Grid::Optimization::PrecisionChange
StochEmPar	extras/Hadrons/Modules/MGauge/StochEm.hpp	/^class StochEmPar: Serializable$/;"	c
StochEmPar	lib/Hadrons/Modules/MGauge/StochEm.hpp	/^class StochEmPar: Serializable$/;"	c
StochasticField	lib/qcd/action/gauge/Photon.h	/^  void Photon<Gimpl>::StochasticField(GaugeField &out, GridParallelRNG &rng)$/;"	f	class:Grid::QCD::Photon
StochasticField	lib/qcd/action/gauge/Photon.h	/^  void Photon<Gimpl>::StochasticField(GaugeField &out, GridParallelRNG &rng,$/;"	f	class:Grid::QCD::Photon
StochasticWeight	lib/qcd/action/gauge/Photon.h	/^  void Photon<Gimpl>::StochasticWeight(GaugeLinkField &weight)$/;"	f	class:Grid::QCD::Photon
Stop	lib/perfmon/PerfCount.h	/^  void Stop(void) {$/;"	f	class:Grid::PerformanceCounter
Stop	lib/perfmon/Timer.h	/^  void     Stop(void)  { $/;"	f	class:Grid::GridStopWatch
StopWatch	lib/log/Log.cc	/^GridStopWatch Logger::StopWatch;$/;"	m	class:Grid::Logger	file:
StopWatch	lib/log/Log.h	/^  static GridStopWatch StopWatch;$/;"	m	class:Grid::Logger
Storage	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,StorageIndex> Storage;$/;"	t	class:Eigen::SparseMatrix
Storage	lib/Eigen/src/SparseCore/SparseVector.h	/^    typedef internal::CompressedStorage<Scalar,StorageIndex> Storage;$/;"	t	class:Eigen::SparseVector
StorageBaseType	lib/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase
StorageBaseType	lib/Eigen/src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase
StorageBaseType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase
StorageIndex	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::LDLT
StorageIndex	lib/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::LLT
StorageIndex	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::CholmodBase
StorageIndex	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::TridiagonalMatrix
StorageIndex	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::BandMatrixBase
StorageIndex	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::BandMatrix
StorageIndex	lib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::BandMatrixWrapper
StorageIndex	lib/Eigen/src/Core/BandMatrix.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/Block.h	/^    typedef typename XprType::StorageIndex StorageIndex;$/;"	t	class:Eigen::BlockImpl
StorageIndex	lib/Eigen/src/Core/CwiseBinaryOp.h	/^                                      typename traits<Rhs>::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::traits<Arg1>::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::DenseBase
StorageIndex	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::DiagonalBase
StorageIndex	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageIndex StorageIndex;$/;"	t	class:Eigen::DiagonalMatrix
StorageIndex	lib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/Inverse.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	class:Eigen::Inverse
StorageIndex	lib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::MapBase
StorageIndex	lib/Eigen/src/Core/Matrix.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::MatrixBase
StorageIndex	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::Map
StorageIndex	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::StorageIndex StorageIndex;$/;"	t	class:Eigen::PermutationBase
StorageIndex	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::StorageIndex StorageIndex;$/;"	t	class:Eigen::PermutationMatrix
StorageIndex	lib/Eigen/src/Core/PermutationMatrix.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/Product.h	/^                                      typename RhsTraits::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SelfAdjointView
StorageIndex	lib/Eigen/src/Core/Solve.h	/^  typedef typename internal::traits<Solve>::StorageIndex StorageIndex;$/;"	t	class:Eigen::Solve
StorageIndex	lib/Eigen/src/Core/Solve.h	/^  typedef typename promote_index_type<typename Decomposition::StorageIndex, typename RhsType::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::Map
StorageIndex	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::Transpositions
StorageIndex	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::TranspositionsBase
StorageIndex	lib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::TranspositionsWrapper
StorageIndex	lib/Eigen/src/Core/Transpositions.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::TriangularBase
StorageIndex	lib/Eigen/src/Geometry/Transform.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	class:Eigen::Transform
StorageIndex	lib/Eigen/src/Geometry/Transform.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::StorageIndex StorageIndex;$/;"	t	class:Eigen::DiagonalPreconditioner
StorageIndex	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef typename PermutationType::StorageIndex StorageIndex; $/;"	t	class:Eigen::IncompleteCholesky
StorageIndex	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::IncompleteLUT
StorageIndex	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::IterativeSolverBase
StorageIndex	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::PastixBase
StorageIndex	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::PastixLU
StorageIndex	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::pastix_traits
StorageIndex	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::PardisoLDLT
StorageIndex	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::PardisoLLT
StorageIndex	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::StorageIndex StorageIndex;$/;"	t	class:Eigen::PardisoImpl
StorageIndex	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::StorageIndex StorageIndex;    $/;"	t	struct:Eigen::internal::pardiso_traits
StorageIndex	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::pardiso_traits
StorageIndex	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::ColPivHouseholderQR
StorageIndex	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
StorageIndex	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::FullPivHouseholderQR
StorageIndex	lib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::HouseholderQR
StorageIndex	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SuiteSparse_long StorageIndex ;$/;"	t	class:Eigen::SPQR
StorageIndex	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::SPQR_QProduct
StorageIndex	lib/Eigen/src/SVD/SVDBase.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SVDBase
StorageIndex	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialCholesky
StorageIndex	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialCholeskyBase
StorageIndex	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialLDLT
StorageIndex	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialLLT
StorageIndex	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::StorageIndex                       StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::StorageIndex                   StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::AmbiVector
StorageIndex	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::CompressedStorage
StorageIndex	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::MappedSparseMatrix
StorageIndex	lib/Eigen/src/SparseCore/SparseAssign.h	/^  typedef typename DstXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::Assignment
StorageIndex	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::unary_evaluator
StorageIndex	lib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::BlockImpl
StorageIndex	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::binary_evaluator
StorageIndex	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
StorageIndex	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename SparseXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
StorageIndex	lib/Eigen/src/SparseCore/SparseMap.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseMapBase
StorageIndex	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseMatrixBase
StorageIndex	lib/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeCleaned::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::permutation_matrix_product
StorageIndex	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseSelfAdjointView
StorageIndex	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
StorageIndex	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename DstXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::Assignment
StorageIndex	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::SparseTransposeImpl
StorageIndex	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::unary_evaluator
StorageIndex	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/SparseCore/SparseView.h	/^    typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::unary_evaluator
StorageIndex	lib/Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/SparseCore/TriangularSolver.h	/^                                      typename traits<Rhs>::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
StorageIndex	lib/Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseLU
StorageIndex	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  typedef typename IndexVector::Scalar StorageIndex; $/;"	t	struct:Eigen::internal::LU_GlobalLU_t
StorageIndex	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
StorageIndex	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename IndexVector::Scalar StorageIndex;$/;"	t	struct:Eigen::internal::column_dfs_traits
StorageIndex	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  typedef typename IndexVector::Scalar StorageIndex;$/;"	t	struct:Eigen::internal::panel_dfs_traits
StorageIndex	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseQR
StorageIndex	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	lib/Eigen/src/SparseQR/SparseQR.h	/^  typedef typename DstXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::Assignment
StorageIndex	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::SuperLU
StorageIndex	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SuperLUBase
StorageIndex	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::UmfPackLU
StorageKind	lib/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase
StorageKind	lib/Eigen/src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/CwiseBinaryOp.h	/^                                              BinaryOp>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::traits<Arg1>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase
StorageKind	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase
StorageKind	lib/Eigen/src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase
StorageKind	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix
StorageKind	lib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef DiagonalShape StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase
StorageKind	lib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase
StorageKind	lib/Eigen/src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase
StorageKind	lib/Eigen/src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase
StorageKind	lib/Eigen/src/Core/Product.h	/^                                                internal::product_type<Lhs,Rhs>::ret>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/Transpositions.h	/^  typedef TranspositionsStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase
StorageKind	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView
StorageKind	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularViewType>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularViewImpl
StorageKind	lib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Geometry/Transform.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/LU/FullPivLU.h	/^  typedef SolverStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef SolverStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase
StorageKind	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	lib/Eigen/src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageOptions	lib/Eigen/src/Core/util/Constants.h	/^enum StorageOptions {$/;"	g	namespace:Eigen
StorageOrder	lib/Eigen/src/Core/ProductEvaluators.h	/^    StorageOrder = int(Rhs::Flags) & RowMajorBit ? RowMajor : ColMajor$/;"	e	enum:Eigen::internal::product_evaluator::__anon180
StorageOrder	lib/Eigen/src/Core/ProductEvaluators.h	/^  enum { StorageOrder = int(Lhs::Flags) & RowMajorBit ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::product_evaluator::__anon181
StorageOrderMatch	lib/Eigen/src/Core/Ref.h	/^      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),$/;"	e	enum:Eigen::internal::traits::match::__anon150
StorageOrderMatch	lib/Eigen/src/SparseCore/SparseRef.h	/^      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),$/;"	e	enum:Eigen::internal::traits::match::__anon533
StorageOrdersAgree	lib/Eigen/src/Core/AssignEvaluator.h	/^    StorageOrdersAgree = (int(DstIsRowMajor) == int(SrcIsRowMajor)),$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon142
StorageOrdersAgree	lib/Eigen/src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
StorageOrdersAgree	lib/Eigen/src/Core/CoreEvaluators.h	/^    StorageOrdersAgree = (int(Arg1Flags)&RowMajorBit)==(int(Arg2Flags)&RowMajorBit) && (int(Arg1Flags)&RowMajorBit)==(int(Arg3Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon231
StorageOrdersAgree	lib/Eigen/src/Core/CoreEvaluators.h	/^    StorageOrdersAgree = (int(LhsFlags)&RowMajorBit)==(int(RhsFlags)&RowMajorBit),$/;"	e	enum:Eigen::internal::binary_evaluator::__anon232
StorageOrdersMatch	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon675
StorageOrdersMatch	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon676
StoutSmearing	lib/qcd/smearing/GaugeConfiguration.h	/^  Smear_Stout<Gimpl> StoutSmearing;$/;"	m	class:Grid::QCD::SmearedConfiguration
StreamPrecision	lib/Eigen/src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon162
StrictlyLower	lib/Eigen/src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::UpLoType
StrictlyUpper	lib/Eigen/src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::UpLoType
Stride	lib/Eigen/src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride
Stride	lib/Eigen/src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride
Stride	lib/Eigen/src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride
Stride	lib/Eigen/src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
StrideBase	lib/Eigen/src/Core/Ref.h	/^  typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;$/;"	t	class:Eigen::RefBase
StrideType	lib/Eigen/src/Core/Ref.h	/^  typedef _StrideType StrideType;$/;"	t	struct:Eigen::internal::traits
StrideType	lib/Eigen/src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::StrideType StrideType;$/;"	t	class:Eigen::RefBase
StridedAlignedMapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstAlignedMapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstMapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedMapType	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
Sub	lib/simd/Grid_avx.h	/^  struct Sub{$/;"	s	namespace:Grid::Optimization
Sub	lib/simd/Grid_avx512.h	/^  struct Sub{$/;"	s	namespace:Grid::Optimization
Sub	lib/simd/Grid_generic.h	/^  struct Sub{$/;"	s	namespace:Grid::Optimization
Sub	lib/simd/Grid_imci.h	/^  struct Sub{$/;"	s	namespace:Grid::Optimization
Sub	lib/simd/Grid_neon.h	/^  struct Sub{$/;"	s	namespace:Grid::Optimization
Sub	lib/simd/Grid_qpx.h	/^  struct Sub{$/;"	s	namespace:Grid::Optimization
Sub	lib/simd/Grid_sse4.h	/^  struct Sub{$/;"	s	namespace:Grid::Optimization
SubDiagonalReturnType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
SubDiagonalType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename TridiagonalizationType::SubDiagonalType SubDiagonalType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
SubDiagonalType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization
SubGroupHeatBath	lib/qcd/utils/SUn.h	/^  static void SubGroupHeatBath($/;"	f	class:Grid::QCD::SU
SubSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Sub         SubSIMD;$/;"	t	namespace:Grid
SubSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Sub         SubSIMD;$/;"	t	namespace:Grid
SubSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Sub         SubSIMD;$/;"	t	namespace:Grid
SubSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Sub         SubSIMD;$/;"	t	namespace:Grid
SubSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Sub         SubSIMD;$/;"	t	namespace:Grid
SubSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Sub         SubSIMD;$/;"	t	namespace:Grid
SubSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Sub         SubSIMD;$/;"	t	namespace:Grid
SubVector	lib/Eigen/src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp
Subs	lib/Eigen/src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
Subs	lib/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon388
Subs	lib/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon389
Success	lib/Eigen/src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
Sum	lib/simd/Grid_avx.h	/^  struct Sum{$/;"	s	namespace:Grid::Optimization
Sum	lib/simd/Grid_avx512.h	/^  struct Sum{$/;"	s	namespace:Grid::Optimization
Sum	lib/simd/Grid_generic.h	/^  struct Sum{$/;"	s	namespace:Grid::Optimization
Sum	lib/simd/Grid_imci.h	/^  struct Sum{$/;"	s	namespace:Grid::Optimization
Sum	lib/simd/Grid_neon.h	/^  struct Sum{$/;"	s	namespace:Grid::Optimization
Sum	lib/simd/Grid_qpx.h	/^  struct Sum{$/;"	s	namespace:Grid::Optimization
Sum	lib/simd/Grid_sse4.h	/^  struct Sum{$/;"	s	namespace:Grid::Optimization
SumArraySize	lib/threads/Threads.h	/^  static int SumArraySize(void) {return _threads;};$/;"	f	class:Grid::GridThread
SumReturnType	lib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_sum>::Type SumReturnType;$/;"	t	class:Eigen::VectorwiseOp
SumSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Sum         SumSIMD;$/;"	t	namespace:Grid
SumSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Sum         SumSIMD;$/;"	t	namespace:Grid
SumSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Sum         SumSIMD;$/;"	t	namespace:Grid
SumSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Sum         SumSIMD;$/;"	t	namespace:Grid
SumSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Sum         SumSIMD;$/;"	t	namespace:Grid
SumSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Sum         SumSIMD;$/;"	t	namespace:Grid
SumSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Sum         SumSIMD;$/;"	t	namespace:Grid
SuperDiagVectorType	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
SuperILU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU
SuperILU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU
SuperILU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU
SuperILU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU
SuperLU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU
SuperLU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    explicit SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU
SuperLU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLUBase	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
Supers	lib/Eigen/src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon385
Supers	lib/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon388
Supers	lib/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon389
SupportedAccessPatterns	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon513
SupportedAccessPatterns	lib/Eigen/src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon539
SwappedTraits	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<RhsScalar,LhsScalar,ConjugateRhs,ConjugateLhs> SwappedTraits;$/;"	t	struct:Eigen::internal::gebp_kernel
SymanzikGMod	lib/qcd/modules/Registration.h	/^typedef QCD::SymanzikGModule<ImplementationPolicy> SymanzikGMod;$/;"	t
SymanzikGModule	lib/qcd/modules/ActionModules.h	/^class SymanzikGModule: public ActionModule<SymanzikGaugeAction<Impl>, BetaGaugeActionParameters> {$/;"	c	namespace:Grid::QCD
SymanzikGaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      SymanzikGaugeAction(RealD beta) : RBCGaugeAction<Gimpl>(beta,-1.0\/12.0) {};$/;"	f	class:Grid::QCD::SymanzikGaugeAction
SymanzikGaugeAction	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^    class SymanzikGaugeAction : public RBCGaugeAction<Gimpl> {$/;"	c	namespace:Grid::QCD
SymanzikGaugeActionD	lib/qcd/action/gauge/Gauge.h	/^typedef SymanzikGaugeAction<PeriodicGimplD>        SymanzikGaugeActionD;$/;"	t	namespace:Grid::QCD
SymanzikGaugeActionF	lib/qcd/action/gauge/Gauge.h	/^typedef SymanzikGaugeAction<PeriodicGimplF>        SymanzikGaugeActionF;$/;"	t	namespace:Grid::QCD
SymanzikGaugeActionR	lib/qcd/action/gauge/Gauge.h	/^typedef SymanzikGaugeAction<PeriodicGimplR>        SymanzikGaugeActionR;$/;"	t	namespace:Grid::QCD
Symmetric	lib/Eigen/src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::UpLoType
Symmetric	lib/qcd/utils/SUnTwoIndex.h	/^enum TwoIndexSymmetry { Symmetric = 1, AntiSymmetric = -1 };$/;"	e	enum:Grid::QCD::TwoIndexSymmetry
T	lib/json/json.hpp	/^    static basic_json parse(T (&array)[N],$/;"	m	class:nlohmann::basic_json
T0	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	91;"	d	file:
T1	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	92;"	d	file:
T1	lib/simd/Intel512wilson.h	68;"	d
T2	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	93;"	d	file:
T2	lib/simd/Intel512wilson.h	69;"	d
T3	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	94;"	d	file:
T4	tests/qdpxx/Test_qdpxx_munprec.cc	/^  typedef LatticeFermion T4;$/;"	t	class:Chroma::ChromaWrapper	file:
T4	tests/qdpxx/Test_qdpxx_stag.cc	/^  typedef LatticeStaggeredFermion T4;$/;"	t	class:Chroma::ChromaWrapper	file:
T5	tests/qdpxx/Test_qdpxx_munprec.cc	/^  typedef multi1d<LatticeFermion> T5;$/;"	t	class:Chroma::ChromaWrapper	file:
TBaryon	extras/Hadrons/Modules/MContraction/Baryon.hpp	/^TBaryon<FImpl1, FImpl2, FImpl3>::TBaryon(const std::string name)$/;"	f	class:TBaryon
TBaryon	extras/Hadrons/Modules/MContraction/Baryon.hpp	/^class TBaryon: public Module<BaryonPar>$/;"	c
TBaryon	lib/Hadrons/Modules/MContraction/Baryon.hpp	/^TBaryon<FImpl1, FImpl2, FImpl3>::TBaryon(const std::string name)$/;"	f	class:TBaryon
TBaryon	lib/Hadrons/Modules/MContraction/Baryon.hpp	/^class TBaryon: public Module<BaryonPar>$/;"	c
TChargedProp	extras/Hadrons/Modules/MScalar/ChargedProp.cc	/^TChargedProp::TChargedProp(const std::string name)$/;"	f	class:TChargedProp
TChargedProp	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^class TChargedProp: public Module<ChargedPropPar>$/;"	c
TChargedProp	lib/Hadrons/Modules/MScalar/ChargedProp.cc	/^TChargedProp::TChargedProp(const std::string name)$/;"	f	class:TChargedProp
TChargedProp	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^class TChargedProp: public Module<ChargedPropPar>$/;"	c
TComplex	lib/qcd/QCD.h	/^    typedef iSinglet<Complex >         TComplex;     \/\/ FIXME This is painful. Tensor singlet complex type.$/;"	t	namespace:Grid::QCD
TComplexD	lib/qcd/QCD.h	/^    typedef iSinglet<ComplexD>         TComplexD;    \/\/ FIXME This is painful. Tensor singlet complex type.$/;"	t	namespace:Grid::QCD
TComplexF	lib/qcd/QCD.h	/^    typedef iSinglet<ComplexF>         TComplexF;    \/\/ FIXME This is painful. Tensor singlet complex type.$/;"	t	namespace:Grid::QCD
TDWF	extras/Hadrons/Modules/MAction/DWF.hpp	/^TDWF<FImpl>::TDWF(const std::string name)$/;"	f	class:TDWF
TDWF	extras/Hadrons/Modules/MAction/DWF.hpp	/^class TDWF: public Module<DWFPar>$/;"	c
TDWF	lib/Hadrons/Modules/MAction/DWF.hpp	/^TDWF<FImpl>::TDWF(const std::string name)$/;"	f	class:TDWF
TDWF	lib/Hadrons/Modules/MAction/DWF.hpp	/^class TDWF: public Module<DWFPar>$/;"	c
TDiscLoop	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^TDiscLoop<FImpl>::TDiscLoop(const std::string name)$/;"	f	class:TDiscLoop
TDiscLoop	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^class TDiscLoop: public Module<DiscLoopPar>$/;"	c
TDiscLoop	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^TDiscLoop<FImpl>::TDiscLoop(const std::string name)$/;"	f	class:TDiscLoop
TDiscLoop	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^class TDiscLoop: public Module<DiscLoopPar>$/;"	c
TEST_RNG_STANDALONE	tests/testu01/Test_smallcrush.cc	38;"	d	file:
TFreeProp	extras/Hadrons/Modules/MScalar/FreeProp.cc	/^TFreeProp::TFreeProp(const std::string name)$/;"	f	class:TFreeProp
TFreeProp	extras/Hadrons/Modules/MScalar/FreeProp.hpp	/^class TFreeProp: public Module<FreePropPar>$/;"	c
TFreeProp	lib/Hadrons/Modules/MScalar/FreeProp.cc	/^TFreeProp::TFreeProp(const std::string name)$/;"	f	class:TFreeProp
TFreeProp	lib/Hadrons/Modules/MScalar/FreeProp.hpp	/^class TFreeProp: public Module<FreePropPar>$/;"	c
TGamma3pt	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^TGamma3pt<FImpl1, FImpl2, FImpl3>::TGamma3pt(const std::string name)$/;"	f	class:TGamma3pt
TGamma3pt	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^class TGamma3pt: public Module<Gamma3ptPar>$/;"	c
TGamma3pt	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^TGamma3pt<FImpl1, FImpl2, FImpl3>::TGamma3pt(const std::string name)$/;"	f	class:TGamma3pt
TGamma3pt	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^class TGamma3pt: public Module<Gamma3ptPar>$/;"	c
TGaugeProp	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^TGaugeProp<FImpl>::TGaugeProp(const std::string name)$/;"	f	class:TGaugeProp
TGaugeProp	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^class TGaugeProp: public Module<GaugePropPar>$/;"	c
TGaugeProp	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^TGaugeProp<FImpl>::TGaugeProp(const std::string name)$/;"	f	class:TGaugeProp
TGaugeProp	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^class TGaugeProp: public Module<GaugePropPar>$/;"	c
THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	lib/Eigen/src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	lib/Eigen/src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	lib/Eigen/src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	lib/Eigen/src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIRD_PARTY_EIGEN3_EIGEN_SRC_CORE_ARCH_AVX512_MATHFUNCTIONS_H_	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	11;"	d
THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THIS_TYPE_IS_NOT_SUPPORTED	lib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_TYPE_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
THREE	lib/algorithms/approx/Zolotarev.cc	48;"	d	file:
TIMatrix	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnTwoIndexMatrix<Complex> TIMatrix;$/;"	t	class:Grid::QCD::SU_TwoIndex
TIMatrixD	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnTwoIndexMatrix<ComplexD> TIMatrixD;$/;"	t	class:Grid::QCD::SU_TwoIndex
TIMatrixF	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnTwoIndexMatrix<ComplexF> TIMatrixF;$/;"	t	class:Grid::QCD::SU_TwoIndex
TInteger	lib/qcd/QCD.h	/^    typedef iSinglet<Integer >         TInteger;$/;"	t	namespace:Grid::QCD
TLoad	extras/Hadrons/Modules/MGauge/Load.cc	/^TLoad::TLoad(const std::string name)$/;"	f	class:TLoad
TLoad	extras/Hadrons/Modules/MGauge/Load.hpp	/^class TLoad: public Module<LoadPar>$/;"	c
TLoad	lib/Hadrons/Modules/MGauge/Load.cc	/^TLoad::TLoad(const std::string name)$/;"	f	class:TLoad
TLoad	lib/Hadrons/Modules/MGauge/Load.hpp	/^class TLoad: public Module<LoadPar>$/;"	c
TMP	lib/simd/Intel512wilson.h	78;"	d
TM_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	158;"	d	file:
TM_PROJMEM	lib/simd/BGQQPX.h	379;"	d
TM_PROJMEM	lib/simd/IBM_qpx.h	424;"	d
TM_PROJMEM	lib/simd/Intel512wilson.h	299;"	d
TM_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	296;"	d	file:
TM_RECON_ACCUM	lib/simd/BGQQPX.h	522;"	d
TM_RECON_ACCUM	lib/simd/IBM_qpx.h	567;"	d
TM_RECON_ACCUM	lib/simd/Intel512wilson.h	523;"	d
TMeson	extras/Hadrons/Modules/MContraction/Meson.hpp	/^TMeson<FImpl1, FImpl2>::TMeson(const std::string name)$/;"	f	class:TMeson
TMeson	extras/Hadrons/Modules/MContraction/Meson.hpp	/^class TMeson: public Module<MesonPar>$/;"	c
TMeson	lib/Hadrons/Modules/MContraction/Meson.hpp	/^TMeson<FImpl1, FImpl2>::TMeson(const std::string name)$/;"	f	class:TMeson
TMeson	lib/Hadrons/Modules/MContraction/Meson.hpp	/^class TMeson: public Module<MesonPar>$/;"	c
TNoiseLoop	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^TNoiseLoop<FImpl>::TNoiseLoop(const std::string name)$/;"	f	class:TNoiseLoop
TNoiseLoop	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^class TNoiseLoop: public Module<NoiseLoopPar>$/;"	c
TNoiseLoop	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^TNoiseLoop<FImpl>::TNoiseLoop(const std::string name)$/;"	f	class:TNoiseLoop
TNoiseLoop	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^class TNoiseLoop: public Module<NoiseLoopPar>$/;"	c
TP_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	123;"	d	file:
TP_PROJMEM	lib/simd/BGQQPX.h	367;"	d
TP_PROJMEM	lib/simd/IBM_qpx.h	412;"	d
TP_PROJMEM	lib/simd/Intel512wilson.h	239;"	d
TP_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	282;"	d	file:
TP_RECON_ACCUM	lib/simd/BGQQPX.h	513;"	d
TP_RECON_ACCUM	lib/simd/IBM_qpx.h	558;"	d
TP_RECON_ACCUM	lib/simd/Intel512wilson.h	509;"	d
TPlainObjectType	lib/Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseMatrix<MatScalar,MatOptions,MatIndex> TPlainObjectType;$/;"	t	class:Eigen::Ref
TPlainObjectType	lib/Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseVector<MatScalar,MatOptions,MatIndex> TPlainObjectType;$/;"	t	class:Eigen::Ref
TPoint	extras/Hadrons/Modules/MSink/Point.hpp	/^TPoint<FImpl>::TPoint(const std::string name)$/;"	f	class:TPoint
TPoint	extras/Hadrons/Modules/MSink/Point.hpp	/^class TPoint: public Module<PointPar>$/;"	c
TPoint	extras/Hadrons/Modules/MSource/Point.hpp	/^TPoint<FImpl>::TPoint(const std::string name)$/;"	f	class:TPoint
TPoint	extras/Hadrons/Modules/MSource/Point.hpp	/^class TPoint: public Module<PointPar>$/;"	c
TPoint	lib/Hadrons/Modules/MSink/Point.hpp	/^TPoint<FImpl>::TPoint(const std::string name)$/;"	f	class:TPoint
TPoint	lib/Hadrons/Modules/MSink/Point.hpp	/^class TPoint: public Module<PointPar>$/;"	c
TPoint	lib/Hadrons/Modules/MSource/Point.hpp	/^TPoint<FImpl>::TPoint(const std::string name)$/;"	f	class:TPoint
TPoint	lib/Hadrons/Modules/MSource/Point.hpp	/^class TPoint: public Module<PointPar>$/;"	c
TRAP	lib/simd/Intel512common.h	157;"	d
TRBPrecCG	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^TRBPrecCG<FImpl>::TRBPrecCG(const std::string name)$/;"	f	class:TRBPrecCG
TRBPrecCG	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^class TRBPrecCG: public Module<RBPrecCGPar>$/;"	c
TRBPrecCG	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^TRBPrecCG<FImpl>::TRBPrecCG(const std::string name)$/;"	f	class:TRBPrecCG
TRBPrecCG	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^class TRBPrecCG: public Module<RBPrecCGPar>$/;"	c
TRandom	extras/Hadrons/Modules/MGauge/Random.cc	/^TRandom::TRandom(const std::string name)$/;"	f	class:TRandom
TRandom	extras/Hadrons/Modules/MGauge/Random.hpp	/^class TRandom: public Module<NoPar>$/;"	c
TRandom	lib/Hadrons/Modules/MGauge/Random.cc	/^TRandom::TRandom(const std::string name)$/;"	f	class:TRandom
TRandom	lib/Hadrons/Modules/MGauge/Random.hpp	/^class TRandom: public Module<NoPar>$/;"	c
TReal	lib/qcd/QCD.h	/^    typedef iSinglet<Real >            TReal;        \/\/ Shouldn't need these; can I make it work without?$/;"	t	namespace:Grid::QCD
TRealD	lib/qcd/QCD.h	/^    typedef iSinglet<RealD>            TRealD;       \/\/ Shouldn't need these; can I make it work without?$/;"	t	namespace:Grid::QCD
TRealF	lib/qcd/QCD.h	/^    typedef iSinglet<RealF>            TRealF;       \/\/ Shouldn't need these; can I make it work without?$/;"	t	namespace:Grid::QCD
TSeqGamma	extras/Hadrons/Modules/MSource/SeqGamma.hpp	/^TSeqGamma<FImpl>::TSeqGamma(const std::string name)$/;"	f	class:TSeqGamma
TSeqGamma	extras/Hadrons/Modules/MSource/SeqGamma.hpp	/^class TSeqGamma: public Module<SeqGammaPar>$/;"	c
TSeqGamma	lib/Hadrons/Modules/MSource/SeqGamma.hpp	/^TSeqGamma<FImpl>::TSeqGamma(const std::string name)$/;"	f	class:TSeqGamma
TSeqGamma	lib/Hadrons/Modules/MSource/SeqGamma.hpp	/^class TSeqGamma: public Module<SeqGammaPar>$/;"	c
TStochEm	extras/Hadrons/Modules/MGauge/StochEm.cc	/^TStochEm::TStochEm(const std::string name)$/;"	f	class:TStochEm
TStochEm	extras/Hadrons/Modules/MGauge/StochEm.hpp	/^class TStochEm: public Module<StochEmPar>$/;"	c
TStochEm	lib/Hadrons/Modules/MGauge/StochEm.cc	/^TStochEm::TStochEm(const std::string name)$/;"	f	class:TStochEm
TStochEm	lib/Hadrons/Modules/MGauge/StochEm.hpp	/^class TStochEm: public Module<StochEmPar>$/;"	c
TUnit	extras/Hadrons/Modules/MGauge/Unit.cc	/^TUnit::TUnit(const std::string name)$/;"	f	class:TUnit
TUnit	extras/Hadrons/Modules/MGauge/Unit.hpp	/^class TUnit: public Module<NoPar>$/;"	c
TUnit	lib/Hadrons/Modules/MGauge/Unit.cc	/^TUnit::TUnit(const std::string name)$/;"	f	class:TUnit
TUnit	lib/Hadrons/Modules/MGauge/Unit.hpp	/^class TUnit: public Module<NoPar>$/;"	c
TWO	lib/algorithms/approx/Zolotarev.cc	47;"	d	file:
TWO	lib/algorithms/approx/Zolotarev.cc	527;"	d	file:
TWO	lib/algorithms/approx/Zolotarev.cc	528;"	d	file:
TWall	extras/Hadrons/Modules/MSource/Wall.hpp	/^TWall<FImpl>::TWall(const std::string name)$/;"	f	class:TWall
TWall	extras/Hadrons/Modules/MSource/Wall.hpp	/^class TWall: public Module<WallPar>$/;"	c
TWall	lib/Hadrons/Modules/MSource/Wall.hpp	/^TWall<FImpl>::TWall(const std::string name)$/;"	f	class:TWall
TWall	lib/Hadrons/Modules/MSource/Wall.hpp	/^class TWall: public Module<WallPar>$/;"	c
TWeakHamiltonianEye	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^TWeakHamiltonianEye::TWeakHamiltonianEye(const std::string name)$/;"	f	class:TWeakHamiltonianEye
TWeakHamiltonianEye	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^TWeakHamiltonianEye::TWeakHamiltonianEye(const std::string name)$/;"	f	class:TWeakHamiltonianEye
TWeakHamiltonianNonEye	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^TWeakHamiltonianNonEye::TWeakHamiltonianNonEye(const std::string name)$/;"	f	class:TWeakHamiltonianNonEye
TWeakHamiltonianNonEye	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^TWeakHamiltonianNonEye::TWeakHamiltonianNonEye(const std::string name)$/;"	f	class:TWeakHamiltonianNonEye
TWeakNeutral4ptDisc	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^TWeakNeutral4ptDisc::TWeakNeutral4ptDisc(const std::string name)$/;"	f	class:TWeakNeutral4ptDisc
TWeakNeutral4ptDisc	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^TWeakNeutral4ptDisc::TWeakNeutral4ptDisc(const std::string name)$/;"	f	class:TWeakNeutral4ptDisc
TWilson	extras/Hadrons/Modules/MAction/Wilson.hpp	/^TWilson<FImpl>::TWilson(const std::string name)$/;"	f	class:TWilson
TWilson	extras/Hadrons/Modules/MAction/Wilson.hpp	/^class TWilson: public Module<WilsonPar>$/;"	c
TWilson	lib/Hadrons/Modules/MAction/Wilson.hpp	/^TWilson<FImpl>::TWilson(const std::string name)$/;"	f	class:TWilson
TWilson	lib/Hadrons/Modules/MAction/Wilson.hpp	/^class TWilson: public Module<WilsonPar>$/;"	c
TZ2	extras/Hadrons/Modules/MSource/Z2.hpp	/^TZ2<FImpl>::TZ2(const std::string name)$/;"	f	class:TZ2
TZ2	extras/Hadrons/Modules/MSource/Z2.hpp	/^class TZ2: public Module<Z2Par>$/;"	c
TZ2	lib/Hadrons/Modules/MSource/Z2.hpp	/^TZ2<FImpl>::TZ2(const std::string name)$/;"	f	class:TZ2
TZ2	lib/Hadrons/Modules/MSource/Z2.hpp	/^class TZ2: public Module<Z2Par>$/;"	c
Ta	lib/tensors/Tensor_Ta.h	/^  template<class vtype,int N> inline iMatrix<vtype,N> Ta(const iMatrix<vtype,N> &arg)$/;"	f	namespace:Grid
Ta	lib/tensors/Tensor_Ta.h	/^  template<class vtype,int N> inline iVector<vtype,N> Ta(const iVector<vtype,N>&r)$/;"	f	namespace:Grid
Ta	lib/tensors/Tensor_Ta.h	/^  template<class vtype> inline iScalar<vtype> Ta(const iScalar<vtype>&r)$/;"	f	namespace:Grid
TanReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_tan_op<Scalar>, const Derived> TanReturnType;$/;"	t
TanhReturnType	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_tanh_op<Scalar>, const Derived> TanhReturnType;$/;"	t
Target	lib/Eigen/src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
Tdir	lib/qcd/QCD.h	/^    static const int Tdir = 3;$/;"	m	namespace:Grid::QCD
TensorIndexRecursion	lib/tensors/Tensor_index.h	/^class TensorIndexRecursion {$/;"	c	namespace:Grid
TensorIndexRecursion	lib/tensors/Tensor_index.h	/^class TensorIndexRecursion<0> {$/;"	c	namespace:Grid
TensorLevel	lib/tensors/Tensor_class.h	/^  enum { TensorLevel = GridTypeMapper<vtype>::TensorLevel + 1 };$/;"	e	enum:Grid::iMatrix::__anon712
TensorLevel	lib/tensors/Tensor_class.h	/^  enum { TensorLevel = GridTypeMapper<vtype>::TensorLevel + 1 };$/;"	e	enum:Grid::iScalar::__anon710
TensorLevel	lib/tensors/Tensor_class.h	/^  enum { TensorLevel = GridTypeMapper<vtype>::TensorLevel + 1 };$/;"	e	enum:Grid::iVector::__anon711
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon697
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon698
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon699
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon700
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon701
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon702
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon703
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon704
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon705
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon706
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = 0 };$/;"	e	enum:Grid::GridTypeMapper::__anon707
TensorLevel	lib/tensors/Tensor_traits.h	/^    enum { TensorLevel = T::TensorLevel };$/;"	e	enum:Grid::GridTypeMapper::__anon696
TensorRemove	lib/tensors/Tensor_class.h	/^    -> decltype(TensorRemove(arg._internal)) {$/;"	f	namespace:Grid
TensorRemove	lib/tensors/Tensor_class.h	/^TensorRemove(T arg) {$/;"	f	namespace:Grid
TepidConfiguration	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline void TepidConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::QCD::GaugeImplTypes
TepidConfiguration	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void TepidConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::ScalarAdjMatrixImplTypes
TepidConfiguration	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void TepidConfiguration(GridParallelRNG &pRNG, Field &U) {$/;"	f	class:Grid::ScalarImplTypes
TepidConfiguration	lib/qcd/utils/SUn.h	/^  static void TepidConfiguration(GridParallelRNG &pRNG,GaugeField &out){$/;"	f	class:Grid::QCD::SU
TestCGinversions	tests/debug/Test_cayley_cg.cc	/^void  TestCGinversions(What & Ddwf, $/;"	f
TestCGinversions	tests/solver/Test_contfrac_cg.cc	/^void  TestCGinversions(What & Ddwf, $/;"	f
TestCGprec	tests/debug/Test_cayley_cg.cc	/^void  TestCGprec(What & Ddwf, $/;"	f
TestCGprec	tests/solver/Test_contfrac_cg.cc	/^void  TestCGprec(What & Ddwf, $/;"	f
TestCGschur	tests/debug/Test_cayley_cg.cc	/^void  TestCGschur(What & Ddwf, $/;"	f
TestCGschur	tests/solver/Test_contfrac_cg.cc	/^void  TestCGschur(What & Ddwf, $/;"	f
TestCGunprec	tests/debug/Test_cayley_cg.cc	/^void  TestCGunprec(What & Ddwf, $/;"	f
TestCGunprec	tests/solver/Test_contfrac_cg.cc	/^void  TestCGunprec(What & Ddwf, $/;"	f
TestMoo	tests/Test_cayley_even_odd_vec.cc	/^void  TestMoo(This & Dw, That &sDw)$/;"	f
TestRNG	tests/testu01/Test_smallcrush.cc	/^struct TestRNG { $/;"	s	file:
TestWhat	tests/Test_cayley_even_odd_vec.cc	/^void  TestWhat(What & Ddwf, $/;"	f
TestWhat	tests/core/Test_contfrac_even_odd.cc	/^void  TestWhat(What & Ddwf, $/;"	f
TestWhat	tests/debug/Test_cayley_even_odd.cc	/^void  TestWhat(What & Ddwf, $/;"	f
Tester	tests/Test_simd.cc	/^void Tester(const functor &func)$/;"	f
TextReader	lib/serialisation/TextIO.cc	/^TextReader::TextReader(const string &fileName) $/;"	f	class:TextReader
TextReader	lib/serialisation/TextIO.h	/^  class TextReader: public Reader<TextReader>$/;"	c	namespace:Grid
TextWriter	lib/serialisation/TextIO.cc	/^TextWriter::TextWriter(const string &fileName)$/;"	f	class:TextWriter
TextWriter	lib/serialisation/TextIO.h	/^  class TextWriter: public Writer<TextWriter>$/;"	c	namespace:Grid
TgtCoeffRatio	lib/Eigen/src/Core/GenericPacketMath.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon509
TgtCoeffRatio	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon301
TgtCoeffRatio	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon302
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon271
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon273
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon274
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon275
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon276
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon277
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon278
TgtCoeffRatio	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 2$/;"	e	enum:Eigen::internal::type_casting_traits::__anon272
TgtCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon341
TgtCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon342
TgtCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon343
TgtCoeffRatio	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 2$/;"	e	enum:Eigen::internal::type_casting_traits::__anon344
TheAction	lib/qcd/hmc/GenericHMCrunner.h	/^  ActionSet<Field, RepresentationsPolicy> TheAction;$/;"	m	class:Grid::QCD::HMCWrapperTemplate
TheIntegrator	lib/qcd/hmc/HMC.h	/^  IntegratorType &TheIntegrator;$/;"	m	class:Grid::QCD::HybridMonteCarlo
TheReader	lib/qcd/hmc/HMCRunnerModule.h	/^ 	typedef Reader<ReaderClass> TheReader; $/;"	t	class:Grid::HMCRunnerModuleFactory
TheReader	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^ 	typedef Reader<ReaderClass> TheReader; $/;"	t	class:Grid::HMC_CPModuleFactory
TheReader	lib/qcd/modules/ActionModules.h	/^  typedef Reader<ReaderClass> TheReader; $/;"	t	class:Grid::HMC_ActionModuleFactory
TheReader	lib/qcd/modules/FermionOperatorModules.h	/^  typedef Reader<ReaderClass> TheReader; $/;"	t	class:Grid::HMC_FermionOperatorModuleFactory
TheReader	lib/qcd/modules/ObservableModules.h	/^  typedef Reader<ReaderClass> TheReader; $/;"	t	class:Grid::HMC_ObservablesModuleFactory
TheReader	lib/qcd/modules/SolverModules.h	/^  typedef Reader<ReaderClass> TheReader; $/;"	t	class:Grid::HMC_SolverModuleFactory
ThenMatrixNested	lib/Eigen/src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits
ThinField	lib/qcd/smearing/GaugeConfiguration.h	/^  Field* ThinField;$/;"	m	class:Grid::QCD::NoSmearing
ThinLinks	lib/qcd/smearing/GaugeConfiguration.h	/^      ThinLinks; \/*!< @brief Pointer to the thin$/;"	m	class:Grid::QCD::SmearedConfiguration
ThinQRfact	lib/algorithms/iterative/BlockConjugateGradient.h	/^void ThinQRfact (Eigen::MatrixXcd &m_rr,$/;"	f	class:Grid::BlockConjugateGradient
ThisProcessorCoor	lib/communicator/Communicator_base.cc	/^const std::vector<int> & CartesianCommunicator::ThisProcessorCoor(void) { return _processor_coor; };$/;"	f	class:Grid::CartesianCommunicator
ThisRank	lib/communicator/Communicator_base.cc	/^int                      CartesianCommunicator::ThisRank(void)          { return _processor; };$/;"	f	class:Grid::CartesianCommunicator
ThreadBarrier	lib/threads/Threads.h	/^  static int  ThreadBarrier(void) {$/;"	f	class:Grid::GridThread
ThreadInterleave	lib/stencil/Lebesgue.cc	/^void LebesgueOrder::ThreadInterleave(void)$/;"	f	class:Grid::LebesgueOrder
ThreadSum	lib/threads/Threads.h	/^  template<class obj> static void ThreadSum( std::vector<obj> &sum_array,obj &val,int me){$/;"	f	class:Grid::GridThread
Through	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane
Through	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane
Through	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine
TimesI	lib/simd/Grid_avx.h	/^  struct TimesI{$/;"	s	namespace:Grid::Optimization
TimesI	lib/simd/Grid_avx512.h	/^  struct TimesI{$/;"	s	namespace:Grid::Optimization
TimesI	lib/simd/Grid_generic.h	/^  struct TimesI{$/;"	s	namespace:Grid::Optimization
TimesI	lib/simd/Grid_imci.h	/^  struct TimesI{$/;"	s	namespace:Grid::Optimization
TimesI	lib/simd/Grid_neon.h	/^  struct TimesI{$/;"	s	namespace:Grid::Optimization
TimesI	lib/simd/Grid_qpx.h	/^  struct TimesI{$/;"	s	namespace:Grid::Optimization
TimesI	lib/simd/Grid_sse4.h	/^  struct TimesI{$/;"	s	namespace:Grid::Optimization
TimesISIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::TimesI      TimesISIMD;$/;"	t	namespace:Grid
TimesISIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::TimesI      TimesISIMD;$/;"	t	namespace:Grid
TimesISIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::TimesI      TimesISIMD;$/;"	t	namespace:Grid
TimesISIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::TimesI      TimesISIMD;$/;"	t	namespace:Grid
TimesISIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::TimesI      TimesISIMD;$/;"	t	namespace:Grid
TimesISIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::TimesI      TimesISIMD;$/;"	t	namespace:Grid
TimesISIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::TimesI      TimesISIMD;$/;"	t	namespace:Grid
TimesMinusI	lib/simd/Grid_avx.h	/^  struct TimesMinusI{$/;"	s	namespace:Grid::Optimization
TimesMinusI	lib/simd/Grid_avx512.h	/^  struct TimesMinusI{$/;"	s	namespace:Grid::Optimization
TimesMinusI	lib/simd/Grid_generic.h	/^  struct TimesMinusI{$/;"	s	namespace:Grid::Optimization
TimesMinusI	lib/simd/Grid_imci.h	/^  struct TimesMinusI{$/;"	s	namespace:Grid::Optimization
TimesMinusI	lib/simd/Grid_neon.h	/^  struct TimesMinusI{$/;"	s	namespace:Grid::Optimization
TimesMinusI	lib/simd/Grid_qpx.h	/^  struct TimesMinusI{$/;"	s	namespace:Grid::Optimization
TimesMinusI	lib/simd/Grid_sse4.h	/^  struct TimesMinusI{$/;"	s	namespace:Grid::Optimization
TimesMinusISIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::TimesMinusI TimesMinusISIMD;$/;"	t	namespace:Grid
TimesMinusISIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::TimesMinusI TimesMinusISIMD;$/;"	t	namespace:Grid
TimesMinusISIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::TimesMinusI TimesMinusISIMD;$/;"	t	namespace:Grid
TimesMinusISIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::TimesMinusI TimesMinusISIMD;$/;"	t	namespace:Grid
TimesMinusISIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::TimesMinusI TimesMinusISIMD;$/;"	t	namespace:Grid
TimesMinusISIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::TimesMinusI TimesMinusISIMD;$/;"	t	namespace:Grid
TimesMinusISIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::TimesMinusI TimesMinusISIMD;$/;"	t	namespace:Grid
Timestamp	lib/log/Log.h	/^  static void Timestamp(int on) {timestamp = on;};$/;"	f	class:Grid::Logger
Tm	lib/qcd/LatticeTheories.h	/^    static const int Tm = 7;$/;"	m	struct:Grid::LatticeTheories::QCD
Tm	lib/qcd/QCD.h	/^    static const int Tm = 7;$/;"	m	namespace:Grid::QCD
TmpFlags	lib/Eigen/src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon607
TmpMatrixType	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, 0, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT
Tolerance	lib/algorithms/iterative/AdefGeneric.h	/^  RealD   Tolerance;$/;"	m	class:TwoLevelFlexiblePcg
Tolerance	lib/algorithms/iterative/BlockConjugateGradient.h	/^  RealD Tolerance;$/;"	m	class:Grid::BlockConjugateGradient
Tolerance	lib/algorithms/iterative/ConjugateGradient.h	/^  RealD Tolerance;$/;"	m	class:Grid::ConjugateGradient
Tolerance	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    RealD   Tolerance;$/;"	m	class:Grid::MixedPrecisionConjugateGradient
Tolerance	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^    RealD   Tolerance;$/;"	m	class:Grid::ConjugateGradientMultiShift
Tolerance	lib/algorithms/iterative/ConjugateResidual.h	/^    RealD   Tolerance;$/;"	m	class:Grid::ConjugateResidual
Tolerance	lib/algorithms/iterative/PrecConjugateResidual.h	/^    RealD   Tolerance;$/;"	m	class:Grid::PrecConjugateResidual
Tolerance	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    RealD   Tolerance;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
TopLeft	lib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopLeft	lib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftCeil	lib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftFloor	lib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRight	lib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopRight	lib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightCeil	lib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightFloor	lib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopologicalCharge	lib/qcd/observables/topological_charge.h	/^    TopologicalCharge(TopologyObsParameters P):Pars(P){$/;"	f	class:Grid::QCD::TopologicalCharge
TopologicalCharge	lib/qcd/observables/topological_charge.h	/^    TopologicalCharge(int interval = 1, bool do_smearing = false):$/;"	f	class:Grid::QCD::TopologicalCharge
TopologicalCharge	lib/qcd/observables/topological_charge.h	/^class TopologicalCharge : public HmcObservable<typename Impl::Field> {$/;"	c	namespace:Grid::QCD
TopologicalCharge	lib/qcd/utils/WilsonLoops.h	/^  static Real TopologicalCharge(GaugeLorentz &U){$/;"	f	class:Grid::QCD::WilsonLoops
TopologicalChargeMod	lib/qcd/modules/ObservableModules.h	/^  TopologicalChargeMod(TopologyObsParameters Par): ObsBase(Par){}$/;"	f	class:Grid::QCD::TopologicalChargeMod
TopologicalChargeMod	lib/qcd/modules/ObservableModules.h	/^class TopologicalChargeMod: public ObservableModule<TopologicalCharge<Impl>, TopologyObsParameters>{$/;"	c	namespace:Grid::QCD
TopologyObsParameters	lib/qcd/observables/topological_charge.h	/^      TopologyObsParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::QCD::TopologyObsParameters
TopologyObsParameters	lib/qcd/observables/topological_charge.h	/^    TopologyObsParameters(int interval = 1, bool smearing = false):$/;"	f	struct:Grid::QCD::TopologyObsParameters
TopologyObsParameters	lib/qcd/observables/topological_charge.h	/^struct TopologyObsParameters : Serializable {$/;"	s	namespace:Grid::QCD
TopologySmearingParameters	lib/qcd/observables/topological_charge.h	/^    TopologySmearingParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::QCD::TopologySmearingParameters
TopologySmearingParameters	lib/qcd/observables/topological_charge.h	/^    TopologySmearingParameters(int s = 0, float ss = 0.0f, int mi = 0, float mT = 0.0f):$/;"	f	struct:Grid::QCD::TopologySmearingParameters
TopologySmearingParameters	lib/qcd/observables/topological_charge.h	/^struct TopologySmearingParameters : Serializable {$/;"	s	namespace:Grid::QCD
TotalAlignedAllocatedBytes	lib/allocator/AlignedAllocator.cc	/^long int PointerCache::TotalAlignedAllocatedBytes = 0;$/;"	m	class:Grid::PointerCache	file:
TotalAlignedAllocatedBytes	lib/allocator/AlignedAllocator.h	/^    static long int TotalAlignedAllocatedBytes;$/;"	m	class:Grid::PointerCache
TotalFinalStepIterations	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    Integer TotalFinalStepIterations; \/\/Number of CG iterations in final patch-up step$/;"	m	class:Grid::MixedPrecisionConjugateGradient
TotalInnerIterations	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    Integer TotalInnerIterations; \/\/Number of inner CG iterations$/;"	m	class:Grid::MixedPrecisionConjugateGradient
TotalOuterIterations	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    Integer TotalOuterIterations; \/\/Number of restarts$/;"	m	class:Grid::MixedPrecisionConjugateGradient
Tp	lib/qcd/LatticeTheories.h	/^    static const int Tp = 3;$/;"	m	struct:Grid::LatticeTheories::QCD
Tp	lib/qcd/QCD.h	/^    static const int Tp = 3;$/;"	m	namespace:Grid::QCD
TrOptions	lib/Eigen/src/SVD/JacobiSVD.h	/^    TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(RowMajor))$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon617
TrOptions	lib/Eigen/src/SVD/JacobiSVD.h	/^    TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(RowMajor))$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon618
Trace	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^  typedef typename Impl::Simd::scalar_type Trace;$/;"	t	class:MagMeas	file:
Traits	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT
Traits	lib/Eigen/src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT
Traits	lib/Eigen/src/Core/BooleanRedux.h	/^  typedef typename Derived::ExpressionTraits Traits;$/;"	t	struct:Eigen::internal::all_unroller
Traits	lib/Eigen/src/Core/BooleanRedux.h	/^  typedef typename Derived::ExpressionTraits Traits;$/;"	t	struct:Eigen::internal::any_unroller
Traits	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase
Traits	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix
Traits	lib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper
Traits	lib/Eigen/src/Core/Ref.h	/^    typedef internal::traits<Ref> Traits;$/;"	t	class:Eigen::Ref
Traits	lib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase
Traits	lib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	lib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions
Traits	lib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper
Traits	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel
Traits	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space
Traits	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef gebp_traits<RhsScalar,LhsScalar> Traits;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
Traits	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Gemm::Traits Traits;$/;"	t	struct:Eigen::internal::gemm_functor
Traits	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
Traits	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel
Traits	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix
Traits	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl
Traits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky
Traits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT
Traits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT
Traits	lib/Eigen/src/SparseCore/SparseRef.h	/^    typedef internal::traits<Ref> Traits;$/;"	t	class:Eigen::Ref
TraitsBase	lib/Eigen/src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits
TraitsBase	lib/Eigen/src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> > TraitsBase;$/;"	t	struct:Eigen::internal::traits
TraitsBase	lib/Eigen/src/SparseCore/SparseMap.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits
TrajRange	extras/Hadrons/Application.hpp	/^    class TrajRange: Serializable$/;"	c	class:Application
TrajRange	lib/Hadrons/Application.hpp	/^    class TrajRange: Serializable$/;"	c	class:Application
TrajectoryComplete	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  void TrajectoryComplete(int traj, Field &U, GridSerialRNG &sRNG, GridParallelRNG &pRNG) {$/;"	f	class:Grid::QCD::BinaryHmcCheckpointer
TrajectoryComplete	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^  void TrajectoryComplete(int traj, GaugeField &U, GridSerialRNG &sRNG,$/;"	f	class:Grid::QCD::ILDGHmcCheckpointer
TrajectoryComplete	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^  void TrajectoryComplete(int traj, GaugeField &U, GridSerialRNG &sRNG,$/;"	f	class:Grid::QCD::NerscHmcCheckpointer
TrajectoryComplete	lib/qcd/observables/plaquette.h	/^  void TrajectoryComplete(int traj,$/;"	f	class:Grid::QCD::PlaquetteLogger
TrajectoryComplete	lib/qcd/observables/topological_charge.h	/^    void TrajectoryComplete(int traj,$/;"	f	class:Grid::QCD::TopologicalCharge
TrajectoryComplete	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^  void TrajectoryComplete(int traj,$/;"	f	class:MagMeas
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform()$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform
Transform	lib/Eigen/src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
TransformMatrix	lib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType TransformMatrix;$/;"	t	struct:Eigen::internal::transform_right_product_impl
TransformTimeDiagonalMode	lib/Eigen/src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon594
TransformTimeDiagonalReturnType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform
TransformTraits	lib/Eigen/src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
TransformType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::generic_product_impl
TransformType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
TransformType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
Translation	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC Translation() {}$/;"	f	class:Eigen::Translation
Translation	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation
Translation	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation
Translation	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation
Translation	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation
Translation	lib/Eigen/src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation2d	lib/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2f	lib/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation3d	lib/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3f	lib/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
TranslationPart	lib/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,!(internal::traits<MatrixType>::Flags & RowMajorBit)> TranslationPart;$/;"	t	class:Eigen::Transform
TranslationType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform
Transpose	lib/Eigen/src/Core/Transpose.h	/^    explicit inline Transpose(MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Transpose
Transpose	lib/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen
Transpose	lib/Eigen/src/Core/Transpositions.h	/^    explicit Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose
Transpose	lib/Eigen/src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
Transpose	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon363
Transpose	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon361
TransposeImpl	lib/Eigen/src/Core/Transpose.h	/^class TransposeImpl$/;"	c	namespace:Eigen
TransposeImpl	lib/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen
TransposeImpl	lib/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen
TransposeImpl_base	lib/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
TransposeImpl_base	lib/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
TransposeMode	lib/Eigen/src/Core/SelfAdjointView.h	/^      TransposeMode = ((Mode & Upper) ? Lower : 0) | ((Mode & Lower) ? Upper : 0)$/;"	e	enum:Eigen::SelfAdjointView::__anon218
TransposeMode	lib/Eigen/src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon21
TransposeReturnType	lib/Eigen/src/Core/DenseBase.h	/^    typedef Transpose<Derived> TransposeReturnType;$/;"	t	class:Eigen::DenseBase
TransposeReturnType	lib/Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<typename MatrixType::TransposeReturnType,TransposeMode> TransposeReturnType;$/;"	t	class:Eigen::SelfAdjointView
TransposeReturnType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<typename MatrixType::TransposeReturnType,TransposeMode> TransposeReturnType;$/;"	t	class:Eigen::TriangularView
TransposeReturnType	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Transpose<Derived> TransposeReturnType;$/;"	t	class:Eigen::SparseMatrixBase
TransposeTypeWithSameStorageOrder	lib/Eigen/src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
TransposedSparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix
TranspositionType	lib/Eigen/src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT
TranspositionType	lib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose
TranspositionType	lib/Eigen/src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU
Transpositions	lib/Eigen/src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::Transpositions
Transpositions	lib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions
Transpositions	lib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions
Transpositions	lib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions
Transpositions	lib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
Transpositions	lib/Eigen/src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex> >$/;"	c	namespace:Eigen
TranspositionsBase	lib/Eigen/src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
TranspositionsShape	lib/Eigen/src/Core/util/Constants.h	/^struct TranspositionsShape    { static std::string debugName() { return "TranspositionsShape"; } };$/;"	s	namespace:Eigen
TranspositionsStorage	lib/Eigen/src/Core/util/Constants.h	/^struct TranspositionsStorage {};$/;"	s	namespace:Eigen
TranspositionsWrapper	lib/Eigen/src/Core/Transpositions.h	/^    explicit inline TranspositionsWrapper(IndicesType& indices)$/;"	f	class:Eigen::TranspositionsWrapper
TranspositionsWrapper	lib/Eigen/src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen
Traversal	lib/Eigen/src/Core/AssignEvaluator.h	/^    Traversal = int(MayLinearVectorize) && (LinearPacketSize>InnerPacketSize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon143
Traversal	lib/Eigen/src/Core/Assign_MKL.h	/^      Traversal = MightLinearize ? LinearTraversal : DefaultTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon154
Traversal	lib/Eigen/src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon117
TraversalSize	lib/Eigen/src/Core/CoreEvaluators.h	/^    TraversalSize = Direction==int(Vertical) ? int(ArgType::RowsAtCompileTime) :  int(ArgType::ColsAtCompileTime)$/;"	e	enum:Eigen::internal::evaluator::__anon242
TraversalSize	lib/Eigen/src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? MatrixType::RowsAtCompileTime :  MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon156
TraversalType	lib/Eigen/src/Core/util/Constants.h	/^enum TraversalType {$/;"	g	namespace:Eigen
Triangular2Dense	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Triangular2Dense         {};$/;"	s	namespace:Eigen::internal
Triangular2Triangular	lib/Eigen/src/Core/TriangularMatrix.h	/^struct Triangular2Triangular    {};$/;"	s	namespace:Eigen::internal
TriangularBase	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase
TriangularBase	lib/Eigen/src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
TriangularShape	lib/Eigen/src/Core/util/Constants.h	/^struct TriangularShape        { static std::string debugName() { return "TriangularShape"; } };$/;"	s	namespace:Eigen
TriangularView	lib/Eigen/src/Core/TriangularMatrix.h	/^    explicit inline TriangularView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView
TriangularView	lib/Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen
TriangularViewImpl	lib/Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularViewImpl<_MatrixType,_Mode,Dense>$/;"	c	namespace:Eigen
TriangularViewImpl	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, unsigned int Mode> class TriangularViewImpl<MatrixType,Mode,Sparse>$/;"	c	namespace:Eigen
TriangularViewReturnType	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
TriangularViewType	lib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<_MatrixType, _Mode> TriangularViewType;$/;"	t	class:Eigen::TriangularViewImpl
TriangularViewType	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef TriangularView<MatrixType,Mode> TriangularViewType;$/;"	t	class:Eigen::TriangularViewImpl
TridiagonalMatrix	lib/Eigen/src/Core/BandMatrix.h	/^    explicit TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix
TridiagonalMatrix	lib/Eigen/src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal
Tridiagonalization	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    explicit Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    explicit Tridiagonalization(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
TridiagonalizationMatrixTReturnType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
TridiagonalizationMatrixTReturnType	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal
TridiagonalizationType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Triplet	lib/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet
Triplet	lib/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet(const StorageIndex& i, const StorageIndex& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet
Triplet	lib/Eigen/src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
TrivialMetric	lib/qcd/utils/Metric.h	/^class TrivialMetric : public Metric<Field>{$/;"	c	namespace:Grid::QCD
TrivialPrecon	lib/algorithms/Preconditioner.h	/^    TrivialPrecon(void){};$/;"	f	class:Grid::TrivialPrecon
TrivialPrecon	lib/algorithms/Preconditioner.h	/^  template<class Field> class TrivialPrecon :  public Preconditioner<Field> { $/;"	c	namespace:Grid
Two	lib/sitmo_rng/sitmo_prng_engine.hpp	/^        typedef char (&Two)[2];;$/;"	t	struct:sitmo::has_generate_template
TwoFlavourEOFModule	lib/qcd/modules/ActionModules.h	/^   TwoFlavourEOFModule(Reader<ReaderClass>& R): PseudoFermionModuleBase<Impl, TwoFlavourEvenOddPseudoFermionAction>(R) {$/;"	f	class:Grid::QCD::TwoFlavourEOFModule
TwoFlavourEOFModule	lib/qcd/modules/ActionModules.h	/^class TwoFlavourEOFModule: public PseudoFermionModuleBase<Impl, TwoFlavourEvenOddPseudoFermionAction>{$/;"	c	namespace:Grid::QCD
TwoFlavourEvenOddPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      TwoFlavourEvenOddPseudoFermionAction(FermionOperator<Impl> &Op,$/;"	f	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
TwoFlavourEvenOddPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^    class TwoFlavourEvenOddPseudoFermionAction$/;"	c	namespace:Grid::QCD
TwoFlavourEvenOddRatioPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      TwoFlavourEvenOddRatioPseudoFermionAction(FermionOperator<Impl>  &_NumOp, $/;"	f	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
TwoFlavourEvenOddRatioPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^    class TwoFlavourEvenOddRatioPseudoFermionAction : public Action<typename Impl::GaugeField> {$/;"	c	namespace:Grid::QCD
TwoFlavourFModule	lib/qcd/modules/ActionModules.h	/^   TwoFlavourFModule(Reader<ReaderClass>& R): Base(R) {$/;"	f	class:Grid::QCD::TwoFlavourFModule
TwoFlavourFModule	lib/qcd/modules/ActionModules.h	/^class TwoFlavourFModule: public PseudoFermionModuleBase<Impl, TwoFlavourPseudoFermionAction>{$/;"	c	namespace:Grid::QCD
TwoFlavourPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  TwoFlavourPseudoFermionAction(FermionOperator<Impl> &Op,$/;"	f	class:Grid::QCD::TwoFlavourPseudoFermionAction
TwoFlavourPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavour.h	/^class TwoFlavourPseudoFermionAction : public Action<typename Impl::GaugeField> {$/;"	c	namespace:Grid::QCD
TwoFlavourRatioEOFModule	lib/qcd/modules/ActionModules.h	/^   TwoFlavourRatioEOFModule(Reader<ReaderClass>& R): Base(R) {$/;"	f	class:Grid::QCD::TwoFlavourRatioEOFModule
TwoFlavourRatioEOFModule	lib/qcd/modules/ActionModules.h	/^class TwoFlavourRatioEOFModule: public PseudoFermionModuleBase<Impl, TwoFlavourEvenOddRatioPseudoFermionAction>{$/;"	c	namespace:Grid::QCD
TwoFlavourRatioFModule	lib/qcd/modules/ActionModules.h	/^   TwoFlavourRatioFModule(Reader<ReaderClass>& R): PseudoFermionModuleBase<Impl, TwoFlavourRatioPseudoFermionAction>(R) {$/;"	f	class:Grid::QCD::TwoFlavourRatioFModule
TwoFlavourRatioFModule	lib/qcd/modules/ActionModules.h	/^class TwoFlavourRatioFModule: public PseudoFermionModuleBase<Impl, TwoFlavourRatioPseudoFermionAction>{$/;"	c	namespace:Grid::QCD
TwoFlavourRatioPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      TwoFlavourRatioPseudoFermionAction(FermionOperator<Impl>  &_NumOp, $/;"	f	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
TwoFlavourRatioPseudoFermionAction	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^    class TwoFlavourRatioPseudoFermionAction : public Action<typename Impl::GaugeField> {$/;"	c	namespace:Grid::QCD
TwoIndexAntiSymmMatrices	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<Nc, AntiSymmetric> TwoIndexAntiSymmMatrices;$/;"	t	namespace:Grid::QCD
TwoIndexAntiSymmetricRepresentation	lib/qcd/representations/two_index.h	/^typedef TwoIndexRep<Nc, AntiSymmetric> TwoIndexAntiSymmetricRepresentation;$/;"	t	namespace:Grid::QCD
TwoIndexFermOpTemplateInstantiate	lib/qcd/action/fermion/FermionCore.h	71;"	d
TwoIndexLieAlgebraMatrix	lib/qcd/utils/SUnTwoIndex.h	/^  static void TwoIndexLieAlgebraMatrix($/;"	f	class:Grid::QCD::SU_TwoIndex
TwoIndexRep	lib/qcd/representations/two_index.h	/^  explicit TwoIndexRep(GridBase *grid) : U(grid) {}$/;"	f	class:Grid::QCD::TwoIndexRep
TwoIndexRep	lib/qcd/representations/two_index.h	/^class TwoIndexRep {$/;"	c	namespace:Grid::QCD
TwoIndexSymmMatrices	lib/qcd/utils/SUnTwoIndex.h	/^typedef SU_TwoIndex<Nc, Symmetric> TwoIndexSymmMatrices;$/;"	t	namespace:Grid::QCD
TwoIndexSymmetricRepresentation	lib/qcd/representations/two_index.h	/^typedef TwoIndexRep<Nc, Symmetric> TwoIndexSymmetricRepresentation;$/;"	t	namespace:Grid::QCD
TwoIndexSymmetry	lib/qcd/utils/SUnTwoIndex.h	/^enum TwoIndexSymmetry { Symmetric = 1, AntiSymmetric = -1 };$/;"	g	namespace:Grid::QCD
TwoLevelFlexiblePcg	lib/algorithms/iterative/AdefGeneric.h	/^  TwoLevelFlexiblePcg(RealD tol,$/;"	f	class:TwoLevelFlexiblePcg
TwoLevelFlexiblePcg	lib/algorithms/iterative/AdefGeneric.h	/^class TwoLevelFlexiblePcg : public LinearFunction<Field>$/;"	c
TwoLevelFlexiblePcgADef2	lib/algorithms/iterative/AdefGeneric.h	/^class TwoLevelFlexiblePcgADef2 : public TwoLevelFlexiblePcg<Field> {$/;"	c	class:TwoLevelFlexiblePcg
Type	lib/Eigen/src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
Type	lib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType
Type	lib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType
Type	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType
Type	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType
Type	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType
Type	lib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType
Type	lib/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType
Type	lib/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType
Type	lib/Eigen/src/Core/VectorwiseOp.h	/^                        isHorizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType
Type	lib/Eigen/src/Core/VectorwiseOp.h	/^                        isVertical   ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::OppositeExtendedType
Type	lib/Eigen/src/Core/VectorwiseOp.h	/^      typedef PartialReduxExpr<ExpressionType, internal::member_lpnorm<p,RealScalar>,Direction> Type;$/;"	t	struct:Eigen::VectorwiseOp::LpNormReturnType
Type	lib/Eigen/src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
Type	lib/Eigen/src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
Type	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    typedef ActualMatrixType Type;$/;"	t	struct:Eigen::internal::generic_matrix_wrapper::ConstSelfAdjointViewReturnType
Type	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    typedef typename ActualMatrixType::template ConstSelfAdjointViewReturnType<UpLo>::Type Type;$/;"	t	struct:Eigen::internal::generic_matrix_wrapper::ConstSelfAdjointViewReturnType
Type	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^                          > Type;$/;"	t	struct:Eigen::SparseMatrixBase::CwiseProductDenseReturnType
Type	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SparseSelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::SparseMatrixBase::ConstSelfAdjointViewReturnType
Type	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SparseSelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::SparseMatrixBase::SelfAdjointViewReturnType
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct ConstFixedBlockXpr { typedef Block<const Derived,Rows,Cols> Type; };$/;"	t	struct:ConstFixedBlockXpr
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct FixedBlockXpr { typedef Block<Derived,Rows,Cols> Type; };$/;"	t	struct:FixedBlockXpr
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:ConstFixedSegmentReturnType
Type	lib/Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:FixedSegmentReturnType
Type	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^template<class NewType> struct CastXpr { typedef typename internal::cast_return_type<Derived,const CwiseUnaryOp<internal::scalar_cast_op<Scalar, NewType>, const Derived> >::type Type; };$/;"	t	struct:CastXpr
TypeMapper	gcc-bug-report/broken.cc	/^template <class T> class TypeMapper {$/;"	c	file:
TypeMapper	gcc-bug-report/broken.cc	/^template<> class TypeMapper<ComplexD> {$/;"	c	file:
U	lib/algorithms/approx/Zolotarev.cc	/^static INTERNAL_PRECISION U, F, K;	\/* THREAD LOCAL *\/$/;"	m	namespace:Grid::Approx	file:
U	lib/qcd/representations/adjoint.h	/^  LatticeField U;$/;"	m	class:Grid::QCD::AdjointRep
U	lib/qcd/representations/two_index.h	/^  LatticeField U;$/;"	m	class:Grid::QCD::TwoIndexRep
U	lib/qcd/utils/CovariantLaplacian.h	/^  std::vector<GaugeLinkField> U;$/;"	m	class:Grid::QCD::LaplacianAdjointField
U	lib/qcd/utils/CovariantLaplacian.h	/^  std::vector<GaugeLinkField> U;$/;"	m	class:Grid::QCD::LaplacianAlgebraField
U	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^  typedef multi1d<LatticeColorMatrix> U;$/;"	t	class:Chroma::ChromaWrapper	file:
U	tests/qdpxx/Test_qdpxx_munprec.cc	/^  typedef multi1d<LatticeColorMatrix> U;$/;"	t	class:Chroma::ChromaWrapper	file:
U	tests/qdpxx/Test_qdpxx_stag.cc	/^  typedef multi1d<LatticeColorMatrix> U;$/;"	t	class:Chroma::ChromaWrapper	file:
U0	lib/simd/BGQQPX.h	105;"	d
U0	lib/simd/IBM_qpx.h	68;"	d
U1	lib/simd/BGQQPX.h	106;"	d
U1	lib/simd/IBM_qpx.h	69;"	d
U1WilsonLoops	lib/qcd/utils/WilsonLoops.h	/^typedef WilsonLoops<PeriodicGimplR> U1WilsonLoops;$/;"	t	namespace:Grid::QCD
U2	lib/simd/BGQQPX.h	107;"	d
U2	lib/simd/IBM_qpx.h	70;"	d
UCOL	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon662
UChi_00	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	52;"	d	file:
UChi_00	lib/simd/BGQQPX.h	97;"	d
UChi_00	lib/simd/IBM_qpx.h	60;"	d
UChi_00	lib/simd/Intel512wilson.h	58;"	d
UChi_01	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	53;"	d	file:
UChi_01	lib/simd/BGQQPX.h	98;"	d
UChi_01	lib/simd/IBM_qpx.h	61;"	d
UChi_01	lib/simd/Intel512wilson.h	59;"	d
UChi_02	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	54;"	d	file:
UChi_02	lib/simd/BGQQPX.h	99;"	d
UChi_02	lib/simd/IBM_qpx.h	62;"	d
UChi_02	lib/simd/Intel512wilson.h	60;"	d
UChi_10	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	55;"	d	file:
UChi_10	lib/simd/BGQQPX.h	101;"	d
UChi_10	lib/simd/IBM_qpx.h	64;"	d
UChi_10	lib/simd/Intel512wilson.h	62;"	d
UChi_11	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	56;"	d	file:
UChi_11	lib/simd/BGQQPX.h	102;"	d
UChi_11	lib/simd/IBM_qpx.h	65;"	d
UChi_11	lib/simd/Intel512wilson.h	63;"	d
UChi_12	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	57;"	d	file:
UChi_12	lib/simd/BGQQPX.h	103;"	d
UChi_12	lib/simd/IBM_qpx.h	66;"	d
UChi_12	lib/simd/Intel512wilson.h	64;"	d
UChi_20	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	58;"	d	file:
UChi_21	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	59;"	d	file:
UChi_22	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	60;"	d	file:
UChi_30	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	61;"	d	file:
UChi_31	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	62;"	d	file:
UChi_32	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	63;"	d	file:
UIntPtr	lib/Eigen/src/Core/util/Meta.h	/^typedef std::uintptr_t UIntPtr;$/;"	t	namespace:Eigen::internal
ULVL	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon662
UMatrixType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>          UMatrixType;$/;"	t	class:Eigen::SuperLU
UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	lib/Eigen/src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
UNARY	lib/tensors/Tensor_unary.h	149;"	d
UNARY	lib/tensors/Tensor_unary.h	34;"	d
UNLOCK_GAUGE	lib/simd/BGQQPX.h	138;"	d
UNLOCK_GAUGE	lib/simd/IBM_qpx.h	170;"	d
UNLOCK_GAUGE	lib/simd/Intel512wilson.h	102;"	d
UNROLL	lib/threads/Threads.h	36;"	d
USE_FP16	lib/simd/Grid_avx.h	464;"	d
USE_FP16	lib/simd/Grid_avx512.h	343;"	d
USE_FP16	lib/simd/Grid_qpx.h	377;"	d
USE_MPI_IO	lib/parallelIO/BinaryIO.h	33;"	d
USE_MPI_IO	lib/parallelIO/BinaryIO.h	35;"	d
USUB	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon662
USec	lib/algorithms/FFT.h	/^    double USec(void)   {return (double)usec;}    $/;"	f	class:Grid::FFT
UUUmu	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  DoubledGaugeField UUUmu;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
UUUmu	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    DoubledGaugeField UUUmu;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
UUUmuEven	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  DoubledGaugeField UUUmuEven;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
UUUmuEven	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    DoubledGaugeField UUUmuEven;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
UUUmuOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  DoubledGaugeField UUUmuOdd;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
UUUmuOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    DoubledGaugeField UUUmuOdd;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
Uadj	lib/qcd/utils/CovariantLaplacian.h	/^  std::vector<GaugeLinkField> Uadj;$/;"	m	class:Grid::QCD::LaplacianAdjointField
Ucur	lib/qcd/hmc/HMC.h	/^  Field &Ucur;$/;"	m	class:Grid::QCD::HybridMonteCarlo
Uint32Checksum	lib/parallelIO/BinaryIO.h	/^  template<class vobj> static inline void Uint32Checksum(Lattice<vobj> &lat,uint32_t &nersc_csum)$/;"	f	class:Grid::BinaryIO
Uir	lib/simd/Intel512wilson.h	66;"	d
UmfPackLU	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU()$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    explicit UmfPackLU(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : public SparseSolverBase<UmfPackLU<_MatrixType> >$/;"	c	namespace:Eigen
UmfpackControl	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Array<double, UMFPACK_CONTROL, 1> UmfpackControl;$/;"	t	class:Eigen::UmfPackLU
UmfpackMatrixRef	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Ref<const UmfpackMatrixType, StandardCompressedFormat> UmfpackMatrixRef;$/;"	t	class:Eigen::UmfPackLU
UmfpackMatrixType	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU
Umu	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  DoubledGaugeField Umu;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
Umu	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    DoubledGaugeField Umu;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
Umu	lib/qcd/action/fermion/WilsonFermion.h	/^  DoubledGaugeField Umu;$/;"	m	class:Grid::QCD::WilsonFermion
Umu	lib/qcd/action/fermion/WilsonFermion5D.h	/^    DoubledGaugeField Umu;$/;"	m	class:Grid::QCD::WilsonFermion5D
UmuEven	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  DoubledGaugeField UmuEven;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
UmuEven	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    DoubledGaugeField UmuEven;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
UmuEven	lib/qcd/action/fermion/WilsonFermion.h	/^  DoubledGaugeField UmuEven;$/;"	m	class:Grid::QCD::WilsonFermion
UmuEven	lib/qcd/action/fermion/WilsonFermion5D.h	/^    DoubledGaugeField UmuEven;$/;"	m	class:Grid::QCD::WilsonFermion5D
UmuOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  DoubledGaugeField UmuOdd;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
UmuOdd	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    DoubledGaugeField UmuOdd;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
UmuOdd	lib/qcd/action/fermion/WilsonFermion.h	/^  DoubledGaugeField UmuOdd;$/;"	m	class:Grid::QCD::WilsonFermion
UmuOdd	lib/qcd/action/fermion/WilsonFermion5D.h	/^    DoubledGaugeField UmuOdd;$/;"	m	class:Grid::QCD::WilsonFermion5D
Unaligned	lib/Eigen/src/Core/util/Constants.h	/^  Unaligned=0,        \/**< Data pointer has no specific alignment. *\/$/;"	e	enum:Eigen::AlignmentType
UniformScaling	lib/Eigen/src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	lib/Eigen/src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	lib/Eigen/src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling
UniformScaling	lib/Eigen/src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
Unit	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase
Unit	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index newSize, Index i)$/;"	f	class:Eigen::MatrixBase
UnitDiag	lib/Eigen/src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::UpLoType
UnitLower	lib/Eigen/src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::UpLoType
UnitRandom	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC Quaternion<Scalar,Options> Quaternion<Scalar,Options>::UnitRandom()$/;"	f	class:Eigen::Quaternion
UnitUpper	lib/Eigen/src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::UpLoType
UnitW	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase
UnitX	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase
UnitY	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase
UnitZ	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase
UniverseRank	lib/communicator/Communicator_mpi3_leader.cc	/^  static int UniverseRank;$/;"	m	class:Grid::MPIoffloadEngine	file:
UniverseRank	lib/communicator/Communicator_mpi3_leader.cc	/^int MPIoffloadEngine::UniverseRank;$/;"	m	class:Grid::MPIoffloadEngine	file:
UniverseRanks	lib/communicator/Communicator_mpi3_leader.cc	/^  static std::vector<std::vector<int> > UniverseRanks;$/;"	m	class:Grid::MPIoffloadEngine	file:
UniverseRanks	lib/communicator/Communicator_mpi3_leader.cc	/^std::vector<std::vector<int> > MPIoffloadEngine::UniverseRanks;$/;"	m	class:Grid::MPIoffloadEngine	file:
UniverseSize	lib/communicator/Communicator_mpi3_leader.cc	/^  static int UniverseSize;$/;"	m	class:Grid::MPIoffloadEngine	file:
UniverseSize	lib/communicator/Communicator_mpi3_leader.cc	/^int MPIoffloadEngine::UniverseSize;$/;"	m	class:Grid::MPIoffloadEngine	file:
Unroll	lib/Eigen/src/Core/ProductEvaluators.h	/^    Unroll = CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::internal::product_evaluator::__anon177
Unrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon145
Unrolling	lib/Eigen/src/Core/Redux.h	/^    Unrolling = Cost <= UnrollingLimit ? CompleteUnrolling : NoUnrolling$/;"	e	enum:Eigen::internal::redux_traits::__anon119
Unrolling	lib/Eigen/src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon132
UnrollingLimit	lib/Eigen/src/Core/AssignEvaluator.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * ActualPacketSize,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon144
UnrollingLimit	lib/Eigen/src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon118
UnrollingType	lib/Eigen/src/Core/util/Constants.h	/^enum UnrollingType {$/;"	g	namespace:Eigen
Unusable	lib/Eigen/src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable
Unusable	lib/Eigen/src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue
Unusable	lib/Eigen/src/Core/ReturnByValue.h	67;"	d
Unusable	lib/Eigen/src/Core/ReturnByValue.h	76;"	d
UpLo	lib/Eigen/src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon630
UpLo	lib/Eigen/src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon632
UpLo	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon13
UpLo	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon663
UpLo	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::IncompleteCholesky::__anon664
UpLo	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon650
UpLo	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon649
UpLo	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon656
UpLo	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon655
UpLo	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon640
UpLo	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon639
UpLo	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon638
UpLo	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon633
UpLo	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon635
UpLo	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon636
UpLo	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon637
UpLoType	lib/Eigen/src/Core/util/Constants.h	/^enum UpLoType {$/;"	g	namespace:Eigen
Upper	lib/Eigen/src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::UpLoType
UpperBidiagonalization	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    explicit UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
Uri	lib/simd/Intel512wilson.h	67;"	d
UseLebesgueOrder	lib/stencil/Lebesgue.cc	/^int LebesgueOrder::UseLebesgueOrder;$/;"	m	class:Grid::LebesgueOrder	file:
UseLebesgueOrder	lib/stencil/Lebesgue.h	/^    static int UseLebesgueOrder;$/;"	m	class:Grid::LebesgueOrder
UserCommunicatorToWorldRanks	lib/communicator/Communicator_mpi3_leader.cc	/^  static std::vector<int> UserCommunicatorToWorldRanks; $/;"	m	class:Grid::MPIoffloadEngine	file:
UserCommunicatorToWorldRanks	lib/communicator/Communicator_mpi3_leader.cc	/^std::vector<int>               MPIoffloadEngine::UserCommunicatorToWorldRanks; $/;"	m	class:Grid::MPIoffloadEngine	file:
VACCTIMESI	lib/simd/Intel512double.h	66;"	d
VACCTIMESI	lib/simd/Intel512double.h	70;"	d
VACCTIMESI	lib/simd/Intel512single.h	66;"	d
VACCTIMESI	lib/simd/Intel512single.h	70;"	d
VACCTIMESI0	lib/simd/Intel512double.h	67;"	d
VACCTIMESI0	lib/simd/Intel512double.h	71;"	d
VACCTIMESI0	lib/simd/Intel512single.h	67;"	d
VACCTIMESI0	lib/simd/Intel512single.h	71;"	d
VACCTIMESI0d	lib/simd/Intel512avx.h	188;"	d
VACCTIMESI0d	lib/simd/Intel512imci.h	101;"	d
VACCTIMESI0f	lib/simd/Intel512avx.h	184;"	d
VACCTIMESI0f	lib/simd/Intel512imci.h	97;"	d
VACCTIMESI1	lib/simd/Intel512double.h	68;"	d
VACCTIMESI1	lib/simd/Intel512double.h	72;"	d
VACCTIMESI1	lib/simd/Intel512single.h	68;"	d
VACCTIMESI1	lib/simd/Intel512single.h	72;"	d
VACCTIMESI1MEM	lib/simd/Intel512double.h	84;"	d
VACCTIMESI1MEM	lib/simd/Intel512double.h	86;"	d
VACCTIMESI1MEM	lib/simd/Intel512single.h	84;"	d
VACCTIMESI1MEM	lib/simd/Intel512single.h	86;"	d
VACCTIMESI1d	lib/simd/Intel512avx.h	189;"	d
VACCTIMESI1d	lib/simd/Intel512imci.h	102;"	d
VACCTIMESI1f	lib/simd/Intel512avx.h	185;"	d
VACCTIMESI1f	lib/simd/Intel512imci.h	98;"	d
VACCTIMESI2	lib/simd/Intel512double.h	69;"	d
VACCTIMESI2	lib/simd/Intel512double.h	73;"	d
VACCTIMESI2	lib/simd/Intel512single.h	69;"	d
VACCTIMESI2	lib/simd/Intel512single.h	73;"	d
VACCTIMESI2MEM	lib/simd/Intel512double.h	85;"	d
VACCTIMESI2MEM	lib/simd/Intel512double.h	87;"	d
VACCTIMESI2MEM	lib/simd/Intel512single.h	85;"	d
VACCTIMESI2MEM	lib/simd/Intel512single.h	87;"	d
VACCTIMESI2d	lib/simd/Intel512avx.h	190;"	d
VACCTIMESI2d	lib/simd/Intel512imci.h	103;"	d
VACCTIMESI2f	lib/simd/Intel512avx.h	186;"	d
VACCTIMESI2f	lib/simd/Intel512imci.h	99;"	d
VACCTIMESId	lib/simd/Intel512common.h	75;"	d
VACCTIMESIf	lib/simd/Intel512common.h	70;"	d
VACCTIMESMINUSI	lib/simd/Intel512double.h	75;"	d
VACCTIMESMINUSI	lib/simd/Intel512double.h	79;"	d
VACCTIMESMINUSI	lib/simd/Intel512single.h	75;"	d
VACCTIMESMINUSI	lib/simd/Intel512single.h	79;"	d
VACCTIMESMINUSI0	lib/simd/Intel512double.h	76;"	d
VACCTIMESMINUSI0	lib/simd/Intel512double.h	80;"	d
VACCTIMESMINUSI0	lib/simd/Intel512single.h	76;"	d
VACCTIMESMINUSI0	lib/simd/Intel512single.h	80;"	d
VACCTIMESMINUSI0d	lib/simd/Intel512avx.h	177;"	d
VACCTIMESMINUSI0d	lib/simd/Intel512imci.h	110;"	d
VACCTIMESMINUSI0f	lib/simd/Intel512avx.h	172;"	d
VACCTIMESMINUSI0f	lib/simd/Intel512imci.h	105;"	d
VACCTIMESMINUSI1	lib/simd/Intel512double.h	77;"	d
VACCTIMESMINUSI1	lib/simd/Intel512double.h	81;"	d
VACCTIMESMINUSI1	lib/simd/Intel512single.h	77;"	d
VACCTIMESMINUSI1	lib/simd/Intel512single.h	81;"	d
VACCTIMESMINUSI1MEM	lib/simd/Intel512double.h	89;"	d
VACCTIMESMINUSI1MEM	lib/simd/Intel512double.h	91;"	d
VACCTIMESMINUSI1MEM	lib/simd/Intel512single.h	89;"	d
VACCTIMESMINUSI1MEM	lib/simd/Intel512single.h	91;"	d
VACCTIMESMINUSI1d	lib/simd/Intel512avx.h	178;"	d
VACCTIMESMINUSI1d	lib/simd/Intel512imci.h	111;"	d
VACCTIMESMINUSI1f	lib/simd/Intel512avx.h	173;"	d
VACCTIMESMINUSI1f	lib/simd/Intel512imci.h	106;"	d
VACCTIMESMINUSI2	lib/simd/Intel512double.h	78;"	d
VACCTIMESMINUSI2	lib/simd/Intel512double.h	82;"	d
VACCTIMESMINUSI2	lib/simd/Intel512single.h	78;"	d
VACCTIMESMINUSI2	lib/simd/Intel512single.h	82;"	d
VACCTIMESMINUSI2MEM	lib/simd/Intel512double.h	90;"	d
VACCTIMESMINUSI2MEM	lib/simd/Intel512double.h	92;"	d
VACCTIMESMINUSI2MEM	lib/simd/Intel512single.h	90;"	d
VACCTIMESMINUSI2MEM	lib/simd/Intel512single.h	92;"	d
VACCTIMESMINUSI2d	lib/simd/Intel512avx.h	179;"	d
VACCTIMESMINUSI2d	lib/simd/Intel512imci.h	112;"	d
VACCTIMESMINUSI2f	lib/simd/Intel512avx.h	174;"	d
VACCTIMESMINUSI2f	lib/simd/Intel512imci.h	107;"	d
VACCTIMESMINUSId	lib/simd/Intel512common.h	85;"	d
VACCTIMESMINUSIf	lib/simd/Intel512common.h	80;"	d
VADD	lib/simd/BGQQPX.h	49;"	d
VADD	lib/simd/IBM_qpx.h	144;"	d
VADD	lib/simd/Intel512double.h	38;"	d
VADD	lib/simd/Intel512double.h	42;"	d
VADD	lib/simd/Intel512single.h	38;"	d
VADD	lib/simd/Intel512single.h	42;"	d
VADDMEM	lib/simd/Intel512double.h	104;"	d
VADDMEM	lib/simd/Intel512double.h	107;"	d
VADDMEM	lib/simd/Intel512single.h	104;"	d
VADDMEM	lib/simd/Intel512single.h	107;"	d
VADDMEMd	lib/simd/Intel512common.h	122;"	d
VADDMEMf	lib/simd/Intel512common.h	121;"	d
VADDd	lib/simd/Intel512common.h	116;"	d
VADDf	lib/simd/Intel512common.h	115;"	d
VADDi	lib/simd/IBM_qpx.h	132;"	d
VBCASTCDUP	lib/simd/Intel512avx.h	104;"	d
VBCASTCDUPf	lib/simd/Intel512avx.h	102;"	d
VBCASTIDUPd	lib/simd/Intel512avx.h	99;"	d
VBCASTIDUPf	lib/simd/Intel512avx.h	101;"	d
VBCASTRDUPd	lib/simd/Intel512avx.h	98;"	d
VBCASTRDUPf	lib/simd/Intel512avx.h	100;"	d
VBCASTZDUP	lib/simd/Intel512avx.h	105;"	d
VBCASTZDUPf	lib/simd/Intel512avx.h	103;"	d
VECTOR_FOR	lib/simd/Grid_generic_types.h	37;"	d
VECTOR_FOR	lib/simd/Grid_generic_types.h	41;"	d
VECTOR_FOR	lib/simd/Grid_generic_types.h	45;"	d
VECTOR_FOR	lib/simd/Grid_generic_types.h	49;"	d
VERSION	lib/algorithms/approx/Zolotarev.cc	2;"	d	file:
VEVICT	lib/simd/Intel512common.h	107;"	d
VIDUP	lib/simd/Intel512double.h	138;"	d
VIDUP	lib/simd/Intel512double.h	143;"	d
VIDUP	lib/simd/Intel512single.h	136;"	d
VIDUP	lib/simd/Intel512single.h	142;"	d
VIDUPd	lib/simd/Intel512avx.h	95;"	d
VIDUPf	lib/simd/Intel512avx.h	96;"	d
VLOAD	lib/simd/IBM_qpx_double.h	30;"	d
VLOAD	lib/simd/IBM_qpx_double.h	39;"	d
VLOAD	lib/simd/IBM_qpx_single.h	30;"	d
VLOAD	lib/simd/IBM_qpx_single.h	39;"	d
VLOAD	lib/simd/Intel512double.h	31;"	d
VLOAD	lib/simd/Intel512double.h	35;"	d
VLOAD	lib/simd/Intel512single.h	31;"	d
VLOAD	lib/simd/Intel512single.h	35;"	d
VLOADd	lib/simd/BGQQPX.h	37;"	d
VLOADd	lib/simd/IBM_qpx.h	121;"	d
VLOADd	lib/simd/Intel512common.h	113;"	d
VLOADf	lib/simd/BGQQPX.h	36;"	d
VLOADf	lib/simd/IBM_qpx.h	109;"	d
VLOADf	lib/simd/Intel512common.h	112;"	d
VLOADu	lib/simd/IBM_qpx_double.h	31;"	d
VLOADu	lib/simd/IBM_qpx_double.h	40;"	d
VLOADu	lib/simd/IBM_qpx_single.h	31;"	d
VLOADu	lib/simd/IBM_qpx_single.h	40;"	d
VLOADud	lib/simd/IBM_qpx.h	122;"	d
VLOADuf	lib/simd/IBM_qpx.h	110;"	d
VMADD	lib/simd/BGQQPX.h	53;"	d
VMADD	lib/simd/IBM_qpx.h	148;"	d
VMADD	lib/simd/Intel512double.h	41;"	d
VMADD	lib/simd/Intel512double.h	45;"	d
VMADD	lib/simd/Intel512single.h	41;"	d
VMADD	lib/simd/Intel512single.h	45;"	d
VMADDIDUPd	lib/simd/Intel512avx.h	121;"	d
VMADDIDUPf	lib/simd/Intel512avx.h	114;"	d
VMADDMEM	lib/simd/Intel512double.h	140;"	d
VMADDMEM	lib/simd/Intel512double.h	145;"	d
VMADDMEM	lib/simd/Intel512single.h	138;"	d
VMADDMEM	lib/simd/Intel512single.h	144;"	d
VMADDMEMd	lib/simd/Intel512common.h	137;"	d
VMADDMEMf	lib/simd/Intel512common.h	136;"	d
VMADDRDUP	lib/simd/Intel512double.h	147;"	d
VMADDRDUP	lib/simd/Intel512double.h	152;"	d
VMADDRDUP	lib/simd/Intel512single.h	147;"	d
VMADDRDUP	lib/simd/Intel512single.h	152;"	d
VMADDRDUPd	lib/simd/Intel512avx.h	120;"	d
VMADDRDUPf	lib/simd/Intel512avx.h	113;"	d
VMADDSUB	lib/simd/Intel512double.h	112;"	d
VMADDSUB	lib/simd/Intel512double.h	116;"	d
VMADDSUB	lib/simd/Intel512single.h	112;"	d
VMADDSUB	lib/simd/Intel512single.h	116;"	d
VMADDSUBIDUP	lib/simd/Intel512double.h	149;"	d
VMADDSUBIDUP	lib/simd/Intel512double.h	154;"	d
VMADDSUBIDUP	lib/simd/Intel512single.h	149;"	d
VMADDSUBIDUP	lib/simd/Intel512single.h	154;"	d
VMADDSUBIDUPd	lib/simd/Intel512avx.h	123;"	d
VMADDSUBIDUPf	lib/simd/Intel512avx.h	116;"	d
VMADDSUBMEM	lib/simd/Intel512double.h	139;"	d
VMADDSUBMEM	lib/simd/Intel512double.h	144;"	d
VMADDSUBMEM	lib/simd/Intel512single.h	137;"	d
VMADDSUBMEM	lib/simd/Intel512single.h	143;"	d
VMADDSUBMEMd	lib/simd/Intel512avx.h	110;"	d
VMADDSUBMEMf	lib/simd/Intel512avx.h	109;"	d
VMADDSUBRDUP	lib/simd/Intel512double.h	148;"	d
VMADDSUBRDUP	lib/simd/Intel512double.h	153;"	d
VMADDSUBRDUP	lib/simd/Intel512single.h	148;"	d
VMADDSUBRDUP	lib/simd/Intel512single.h	153;"	d
VMADDSUBRDUPd	lib/simd/Intel512avx.h	122;"	d
VMADDSUBRDUPf	lib/simd/Intel512avx.h	115;"	d
VMADDSUBd	lib/simd/Intel512avx.h	108;"	d
VMADDSUBf	lib/simd/Intel512avx.h	107;"	d
VMADD_II_MIR	lib/simd/BGQQPX.h	56;"	d
VMADD_II_MIR	lib/simd/IBM_qpx.h	151;"	d
VMADD_II_MIRi	lib/simd/IBM_qpx.h	139;"	d
VMADD_MII_IR	lib/simd/BGQQPX.h	55;"	d
VMADD_MII_IR	lib/simd/IBM_qpx.h	150;"	d
VMADD_MII_IRi	lib/simd/IBM_qpx.h	138;"	d
VMADD_RR_RI	lib/simd/BGQQPX.h	54;"	d
VMADD_RR_RI	lib/simd/IBM_qpx.h	149;"	d
VMADD_RR_RIi	lib/simd/IBM_qpx.h	137;"	d
VMADDd	lib/simd/Intel512common.h	131;"	d
VMADDf	lib/simd/Intel512common.h	130;"	d
VMADDi	lib/simd/IBM_qpx.h	136;"	d
VMOV	lib/simd/BGQQPX.h	47;"	d
VMOV	lib/simd/IBM_qpx.h	143;"	d
VMOV	lib/simd/Intel512double.h	30;"	d
VMOV	lib/simd/Intel512double.h	34;"	d
VMOV	lib/simd/Intel512single.h	30;"	d
VMOV	lib/simd/Intel512single.h	34;"	d
VMOVIDUP	lib/simd/Intel512double.h	110;"	d
VMOVIDUP	lib/simd/Intel512double.h	114;"	d
VMOVIDUP	lib/simd/Intel512single.h	110;"	d
VMOVIDUP	lib/simd/Intel512single.h	114;"	d
VMOVIDUPd	lib/simd/Intel512avx.h	89;"	d
VMOVIDUPf	lib/simd/Intel512avx.h	91;"	d
VMOVRDUP	lib/simd/Intel512double.h	111;"	d
VMOVRDUP	lib/simd/Intel512double.h	115;"	d
VMOVRDUP	lib/simd/Intel512single.h	111;"	d
VMOVRDUP	lib/simd/Intel512single.h	115;"	d
VMOVRDUPd	lib/simd/Intel512avx.h	88;"	d
VMOVRDUPf	lib/simd/Intel512avx.h	90;"	d
VMOVd	lib/simd/Intel512common.h	95;"	d
VMOVf	lib/simd/Intel512common.h	94;"	d
VMOVi	lib/simd/IBM_qpx.h	131;"	d
VMUL	lib/simd/BGQQPX.h	51;"	d
VMUL	lib/simd/IBM_qpx.h	146;"	d
VMUL	lib/simd/Intel512double.h	40;"	d
VMUL	lib/simd/Intel512double.h	44;"	d
VMUL	lib/simd/Intel512single.h	40;"	d
VMUL	lib/simd/Intel512single.h	44;"	d
VMULIDUP	lib/simd/Intel512double.h	151;"	d
VMULIDUP	lib/simd/Intel512double.h	156;"	d
VMULIDUP	lib/simd/Intel512single.h	151;"	d
VMULIDUP	lib/simd/Intel512single.h	156;"	d
VMULIDUPd	lib/simd/Intel512avx.h	125;"	d
VMULIDUPf	lib/simd/Intel512avx.h	118;"	d
VMULMEM	lib/simd/Intel512double.h	141;"	d
VMULMEM	lib/simd/Intel512double.h	146;"	d
VMULMEM	lib/simd/Intel512single.h	139;"	d
VMULMEM	lib/simd/Intel512single.h	145;"	d
VMULMEMd	lib/simd/Intel512common.h	134;"	d
VMULMEMf	lib/simd/Intel512common.h	133;"	d
VMULRDUP	lib/simd/Intel512double.h	150;"	d
VMULRDUP	lib/simd/Intel512double.h	155;"	d
VMULRDUP	lib/simd/Intel512single.h	150;"	d
VMULRDUP	lib/simd/Intel512single.h	155;"	d
VMULRDUPd	lib/simd/Intel512avx.h	124;"	d
VMULRDUPf	lib/simd/Intel512avx.h	117;"	d
VMUL_RR_RI	lib/simd/BGQQPX.h	52;"	d
VMUL_RR_RI	lib/simd/IBM_qpx.h	147;"	d
VMUL_RR_RIi	lib/simd/IBM_qpx.h	135;"	d
VMULd	lib/simd/Intel512common.h	128;"	d
VMULf	lib/simd/Intel512common.h	127;"	d
VMULi	lib/simd/IBM_qpx.h	134;"	d
VNEG	lib/simd/BGQQPX.h	46;"	d
VONE	lib/simd/BGQQPX.h	45;"	d
VONE	lib/simd/IBM_qpx.h	142;"	d
VONEi	lib/simd/IBM_qpx.h	130;"	d
VPERM	lib/simd/IBM_qpx.h	119;"	d
VPERM0	lib/simd/Intel512double.h	94;"	d
VPERM0	lib/simd/Intel512double.h	98;"	d
VPERM0	lib/simd/Intel512single.h	94;"	d
VPERM0	lib/simd/Intel512single.h	98;"	d
VPERM0d	lib/simd/Intel512avx.h	199;"	d
VPERM0d	lib/simd/Intel512imci.h	122;"	d
VPERM0f	lib/simd/Intel512avx.h	194;"	d
VPERM0f	lib/simd/Intel512imci.h	117;"	d
VPERM1	lib/simd/Intel512double.h	95;"	d
VPERM1	lib/simd/Intel512double.h	99;"	d
VPERM1	lib/simd/Intel512single.h	95;"	d
VPERM1	lib/simd/Intel512single.h	99;"	d
VPERM1d	lib/simd/Intel512avx.h	200;"	d
VPERM1d	lib/simd/Intel512imci.h	123;"	d
VPERM1f	lib/simd/Intel512avx.h	195;"	d
VPERM1f	lib/simd/Intel512imci.h	118;"	d
VPERM2	lib/simd/Intel512double.h	100;"	d
VPERM2	lib/simd/Intel512double.h	96;"	d
VPERM2	lib/simd/Intel512single.h	100;"	d
VPERM2	lib/simd/Intel512single.h	96;"	d
VPERM2d	lib/simd/Intel512avx.h	201;"	d
VPERM2d	lib/simd/Intel512imci.h	124;"	d
VPERM2f	lib/simd/Intel512avx.h	196;"	d
VPERM2f	lib/simd/Intel512imci.h	119;"	d
VPERM3	lib/simd/Intel512double.h	101;"	d
VPERM3	lib/simd/Intel512double.h	97;"	d
VPERM3	lib/simd/Intel512single.h	101;"	d
VPERM3	lib/simd/Intel512single.h	97;"	d
VPERM3d	lib/simd/Intel512avx.h	202;"	d
VPERM3d	lib/simd/Intel512imci.h	125;"	d
VPERM3f	lib/simd/Intel512avx.h	197;"	d
VPERM3f	lib/simd/Intel512imci.h	120;"	d
VPERMI	lib/simd/IBM_qpx.h	118;"	d
VPERMIi	lib/simd/IBM_qpx.h	116;"	d
VPERMi	lib/simd/IBM_qpx.h	117;"	d
VPREFETCH	lib/simd/Intel512common.h	105;"	d
VPREFETCH1	lib/simd/Intel512common.h	97;"	d
VPREFETCH2	lib/simd/Intel512common.h	98;"	d
VPREFETCHNTA	lib/simd/Intel512common.h	104;"	d
VPREFETCHW	lib/simd/Intel512common.h	100;"	d
VPREFETCHW	lib/simd/Intel512common.h	102;"	d
VPREFETCH_G1	lib/simd/Intel512wilson.h	559;"	d
VPREFETCH_G2	lib/simd/Intel512wilson.h	560;"	d
VPREFETCH_M1	lib/simd/Intel512wilson.h	547;"	d
VPREFETCH_M1	lib/simd/Intel512wilson.h	552;"	d
VPREFETCH_M2	lib/simd/Intel512wilson.h	548;"	d
VPREFETCH_M2	lib/simd/Intel512wilson.h	553;"	d
VPREFETCH_P1	lib/simd/Intel512wilson.h	545;"	d
VPREFETCH_P1	lib/simd/Intel512wilson.h	554;"	d
VPREFETCH_P2	lib/simd/Intel512wilson.h	546;"	d
VPREFETCH_P2	lib/simd/Intel512wilson.h	555;"	d
VRDUP	lib/simd/Intel512double.h	137;"	d
VRDUP	lib/simd/Intel512double.h	142;"	d
VRDUP	lib/simd/Intel512single.h	135;"	d
VRDUP	lib/simd/Intel512single.h	141;"	d
VRDUPd	lib/simd/Intel512avx.h	93;"	d
VRDUPf	lib/simd/Intel512avx.h	94;"	d
VSHUF	lib/simd/Intel512double.h	113;"	d
VSHUF	lib/simd/Intel512double.h	117;"	d
VSHUF	lib/simd/Intel512single.h	113;"	d
VSHUF	lib/simd/Intel512single.h	117;"	d
VSHUFMEM	lib/simd/Intel512double.h	103;"	d
VSHUFMEM	lib/simd/Intel512double.h	106;"	d
VSHUFMEM	lib/simd/Intel512single.h	103;"	d
VSHUFMEM	lib/simd/Intel512single.h	106;"	d
VSHUFMEMd	lib/simd/Intel512common.h	154;"	d
VSHUFMEMf	lib/simd/Intel512common.h	155;"	d
VSHUFd	lib/simd/Intel512common.h	152;"	d
VSHUFf	lib/simd/Intel512common.h	153;"	d
VSIZE	lib/simd/IBM_qpx_double.h	29;"	d
VSIZE	lib/simd/IBM_qpx_double.h	38;"	d
VSIZE	lib/simd/IBM_qpx_single.h	29;"	d
VSIZE	lib/simd/IBM_qpx_single.h	38;"	d
VSIZEd	lib/simd/IBM_qpx.h	126;"	d
VSIZEf	lib/simd/IBM_qpx.h	114;"	d
VSPLAT	lib/simd/IBM_qpx_double.h	32;"	d
VSPLAT	lib/simd/IBM_qpx_double.h	41;"	d
VSPLAT	lib/simd/IBM_qpx_single.h	32;"	d
VSPLAT	lib/simd/IBM_qpx_single.h	41;"	d
VSPLATd	lib/simd/BGQQPX.h	41;"	d
VSPLATd	lib/simd/IBM_qpx.h	125;"	d
VSPLATf	lib/simd/BGQQPX.h	40;"	d
VSPLATf	lib/simd/IBM_qpx.h	113;"	d
VSTORE	lib/simd/IBM_qpx_double.h	33;"	d
VSTORE	lib/simd/IBM_qpx_double.h	42;"	d
VSTORE	lib/simd/IBM_qpx_single.h	33;"	d
VSTORE	lib/simd/IBM_qpx_single.h	42;"	d
VSTORE	lib/simd/Intel512double.h	32;"	d
VSTORE	lib/simd/Intel512double.h	36;"	d
VSTORE	lib/simd/Intel512single.h	32;"	d
VSTORE	lib/simd/Intel512single.h	36;"	d
VSTOREd	lib/simd/BGQQPX.h	39;"	d
VSTOREd	lib/simd/IBM_qpx.h	123;"	d
VSTOREd	lib/simd/Intel512common.h	145;"	d
VSTOREd	lib/simd/Intel512common.h	148;"	d
VSTOREf	lib/simd/BGQQPX.h	38;"	d
VSTOREf	lib/simd/IBM_qpx.h	111;"	d
VSTOREf	lib/simd/Intel512common.h	144;"	d
VSTOREf	lib/simd/Intel512common.h	147;"	d
VSTOREu	lib/simd/IBM_qpx_double.h	34;"	d
VSTOREu	lib/simd/IBM_qpx_double.h	43;"	d
VSTOREu	lib/simd/IBM_qpx_single.h	34;"	d
VSTOREu	lib/simd/IBM_qpx_single.h	43;"	d
VSTOREud	lib/simd/IBM_qpx.h	124;"	d
VSTOREuf	lib/simd/IBM_qpx.h	112;"	d
VSUB	lib/simd/BGQQPX.h	50;"	d
VSUB	lib/simd/IBM_qpx.h	145;"	d
VSUB	lib/simd/Intel512double.h	39;"	d
VSUB	lib/simd/Intel512double.h	43;"	d
VSUB	lib/simd/Intel512single.h	39;"	d
VSUB	lib/simd/Intel512single.h	43;"	d
VSUBMEM	lib/simd/Intel512double.h	105;"	d
VSUBMEM	lib/simd/Intel512double.h	108;"	d
VSUBMEM	lib/simd/Intel512single.h	105;"	d
VSUBMEM	lib/simd/Intel512single.h	108;"	d
VSUBMEMd	lib/simd/Intel512common.h	125;"	d
VSUBMEMf	lib/simd/Intel512common.h	124;"	d
VSUBd	lib/simd/Intel512common.h	119;"	d
VSUBf	lib/simd/Intel512common.h	118;"	d
VSUBi	lib/simd/IBM_qpx.h	133;"	d
VSX	lib/Eigen/src/Core/util/Constants.h	/^    VSX = 0x3,$/;"	e	enum:Eigen::Architecture::Type
VTIMESI	lib/simd/Intel512double.h	48;"	d
VTIMESI	lib/simd/Intel512double.h	52;"	d
VTIMESI	lib/simd/Intel512single.h	48;"	d
VTIMESI	lib/simd/Intel512single.h	52;"	d
VTIMESI0	lib/simd/Intel512double.h	49;"	d
VTIMESI0	lib/simd/Intel512double.h	53;"	d
VTIMESI0	lib/simd/Intel512single.h	49;"	d
VTIMESI0	lib/simd/Intel512single.h	53;"	d
VTIMESI0d	lib/simd/Intel512avx.h	135;"	d
VTIMESI0d	lib/simd/Intel512imci.h	85;"	d
VTIMESI0f	lib/simd/Intel512avx.h	131;"	d
VTIMESI0f	lib/simd/Intel512imci.h	81;"	d
VTIMESI1	lib/simd/Intel512double.h	50;"	d
VTIMESI1	lib/simd/Intel512double.h	54;"	d
VTIMESI1	lib/simd/Intel512single.h	50;"	d
VTIMESI1	lib/simd/Intel512single.h	54;"	d
VTIMESI1d	lib/simd/Intel512avx.h	136;"	d
VTIMESI1d	lib/simd/Intel512imci.h	86;"	d
VTIMESI1f	lib/simd/Intel512avx.h	132;"	d
VTIMESI1f	lib/simd/Intel512imci.h	82;"	d
VTIMESI2	lib/simd/Intel512double.h	51;"	d
VTIMESI2	lib/simd/Intel512double.h	55;"	d
VTIMESI2	lib/simd/Intel512single.h	51;"	d
VTIMESI2	lib/simd/Intel512single.h	55;"	d
VTIMESI2d	lib/simd/Intel512avx.h	137;"	d
VTIMESI2d	lib/simd/Intel512imci.h	87;"	d
VTIMESI2f	lib/simd/Intel512avx.h	133;"	d
VTIMESI2f	lib/simd/Intel512imci.h	83;"	d
VTIMESId	lib/simd/Intel512common.h	55;"	d
VTIMESIf	lib/simd/Intel512common.h	50;"	d
VTIMESMINUSI	lib/simd/Intel512double.h	57;"	d
VTIMESMINUSI	lib/simd/Intel512double.h	61;"	d
VTIMESMINUSI	lib/simd/Intel512single.h	57;"	d
VTIMESMINUSI	lib/simd/Intel512single.h	61;"	d
VTIMESMINUSI0	lib/simd/Intel512double.h	58;"	d
VTIMESMINUSI0	lib/simd/Intel512double.h	62;"	d
VTIMESMINUSI0	lib/simd/Intel512single.h	58;"	d
VTIMESMINUSI0	lib/simd/Intel512single.h	62;"	d
VTIMESMINUSI0d	lib/simd/Intel512avx.h	143;"	d
VTIMESMINUSI0d	lib/simd/Intel512imci.h	93;"	d
VTIMESMINUSI0f	lib/simd/Intel512avx.h	139;"	d
VTIMESMINUSI0f	lib/simd/Intel512imci.h	89;"	d
VTIMESMINUSI1	lib/simd/Intel512double.h	59;"	d
VTIMESMINUSI1	lib/simd/Intel512double.h	63;"	d
VTIMESMINUSI1	lib/simd/Intel512single.h	59;"	d
VTIMESMINUSI1	lib/simd/Intel512single.h	63;"	d
VTIMESMINUSI1d	lib/simd/Intel512avx.h	144;"	d
VTIMESMINUSI1d	lib/simd/Intel512imci.h	94;"	d
VTIMESMINUSI1f	lib/simd/Intel512avx.h	140;"	d
VTIMESMINUSI1f	lib/simd/Intel512imci.h	90;"	d
VTIMESMINUSI2	lib/simd/Intel512double.h	60;"	d
VTIMESMINUSI2	lib/simd/Intel512double.h	64;"	d
VTIMESMINUSI2	lib/simd/Intel512single.h	60;"	d
VTIMESMINUSI2	lib/simd/Intel512single.h	64;"	d
VTIMESMINUSI2d	lib/simd/Intel512avx.h	145;"	d
VTIMESMINUSI2d	lib/simd/Intel512imci.h	95;"	d
VTIMESMINUSI2f	lib/simd/Intel512avx.h	141;"	d
VTIMESMINUSI2f	lib/simd/Intel512imci.h	91;"	d
VTIMESMINUSId	lib/simd/Intel512common.h	65;"	d
VTIMESMINUSIf	lib/simd/Intel512common.h	60;"	d
VZERO	lib/simd/BGQQPX.h	44;"	d
VZERO	lib/simd/IBM_qpx.h	141;"	d
VZERO	lib/simd/Intel512double.h	29;"	d
VZERO	lib/simd/Intel512double.h	33;"	d
VZERO	lib/simd/Intel512single.h	29;"	d
VZERO	lib/simd/Intel512single.h	33;"	d
VZEROd	lib/simd/Intel512common.h	48;"	d
VZEROf	lib/simd/Intel512common.h	47;"	d
VZEROi	lib/simd/IBM_qpx.h	129;"	d
Vector	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner
Vector	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT
Vector	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase
Vector	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase
Vector	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU
Vector2	lib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Vector2	lib/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D
Vector2s	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,1> Vector2s;$/;"	t	class:Eigen::RealQZ
Vector3	lib/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis
Vector3	lib/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase
Vector3s	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealQZ
Vector3s	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur
VectorBlock	lib/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock
VectorBlock	lib/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock
VectorBlock	lib/Eigen/src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen
VectorI	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::IncompleteLUT
VectorI	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::SimplicialCholeskyBase
VectorI	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView
VectorI	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
VectorIx	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef Matrix<StorageIndex,Dynamic, 1> VectorIx;$/;"	t	class:Eigen::IncompleteCholesky
VectorList	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef std::vector<std::list<StorageIndex> > VectorList; $/;"	t	class:Eigen::IncompleteCholesky
VectorMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef BlasVectorMapper<Scalar, Index> VectorMapper;$/;"	t	class:Eigen::internal::blas_data_mapper
VectorRx	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef Matrix<RealScalar,Dynamic,1> VectorRx;$/;"	t	class:Eigen::IncompleteCholesky
VectorSx	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorSx;$/;"	t	class:Eigen::IncompleteCholesky
VectorType	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> VectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver
VectorType	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition
VectorType	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
VectorType	lib/Eigen/src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox
VectorType	lib/Eigen/src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane
VectorType	lib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
VectorType	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine
VectorType	lib/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase
VectorType	lib/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform
VectorType	lib/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation
VectorType	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl
VectorType	lib/Eigen/src/SVD/BDCSVD.h	/^  typedef Matrix<RealScalar, Dynamic, 1> VectorType;$/;"	t	class:Eigen::BDCSVD
VectorType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky
VectorType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase
VectorType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT
VectorType	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT
VectorTypeSum	lib/Eigen/src/Geometry/AlignedBox.h	/^  typedef CwiseBinaryOp<internal::scalar_sum_op<Scalar>, const VectorType, const VectorType> VectorTypeSum;$/;"	t	class:Eigen::AlignedBox
Vectorizable	lib/Eigen/src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon507
Vectorizable	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
Vectorizable	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
Vectorizable	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
Vectorizable	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
Vectorizable	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
Vectorizable	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon353
Vectorizable	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
Vectorizable	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
Vectorizable	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
Vectorizable	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
Vectorizable	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
Vectorizable	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^    Vectorizable = packet_traits<std::complex<T>>::HasDiv$/;"	e	enum:Eigen::internal::scalar_quotient_op::__anon280
Vectorizable	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^    Vectorizable = packet_traits<std::complex<T>>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon279
Vectorizable	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
Vectorizable	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
Vectorizable	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
Vectorizable	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
Vectorizable	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
Vectorizable	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
Vectorizable	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon282
Vectorizable	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
Vectorizable	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
Vectorizable	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
Vectorizable	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
Vectorizable	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
Vectorizable	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon335
Vectorizable	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
Vectorizable	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
Vectorizable	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
Vectorizable	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
Vectorizable	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
Vectorizable	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon377
Vectorizable	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
Vectorizable	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
Vectorizable	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
Vectorizable	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
Vectorizable	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon371
Vectorizable	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon372
Vectorized	lib/Eigen/src/Core/AssignEvaluator.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon143
VectorizedCast	lib/Eigen/src/Core/GenericPacketMath.h	/^    VectorizedCast = 0,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon509
VectorizedCast	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^    VectorizedCast = 0,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon301
VectorizedCast	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^    VectorizedCast = 0,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon302
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon271
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon272
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon273
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon274
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon275
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon276
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon277
VectorizedCast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon278
VectorizedCast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon341
VectorizedCast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon342
VectorizedCast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon343
VectorizedCast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon344
VectorizedSize	lib/Eigen/src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon124
VectorwiseOp	lib/Eigen/src/Core/VectorwiseOp.h	/^    explicit inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp
VectorwiseOp	lib/Eigen/src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Vertical	lib/Eigen/src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
VerticalComm	lib/communicator/Communicator_mpi3_leader.cc	/^  static MPI_Comm VerticalComm;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalComm	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Comm MPIoffloadEngine::VerticalComm;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalRank	lib/communicator/Communicator_mpi3_leader.cc	/^  static int VerticalRank;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalRank	lib/communicator/Communicator_mpi3_leader.cc	/^int      MPIoffloadEngine::VerticalRank;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalShmBufs	lib/communicator/Communicator_mpi3_leader.cc	/^  static std::vector<void *> VerticalShmBufs;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalShmBufs	lib/communicator/Communicator_mpi3_leader.cc	/^std::vector<void *>            MPIoffloadEngine::VerticalShmBufs;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalSize	lib/communicator/Communicator_mpi3_leader.cc	/^  static int VerticalSize;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalSize	lib/communicator/Communicator_mpi3_leader.cc	/^int      MPIoffloadEngine::VerticalSize;$/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalWindow	lib/communicator/Communicator_mpi3_leader.cc	/^  static MPI_Win  VerticalWindow; $/;"	m	class:Grid::MPIoffloadEngine	file:
VerticalWindow	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Win  MPIoffloadEngine::VerticalWindow; $/;"	m	class:Grid::MPIoffloadEngine	file:
VirtualLocalDimensions	lib/cartesian/Cartesian_base.h	/^    inline const std::vector<int> &VirtualLocalDimensions(void) { return _ldimensions;};$/;"	f	class:Grid::GridBase
VmlSize	lib/Eigen/src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon153
Vset	lib/simd/Grid_avx.h	/^  struct Vset{$/;"	s	namespace:Grid::Optimization
Vset	lib/simd/Grid_avx512.h	/^  struct Vset{$/;"	s	namespace:Grid::Optimization
Vset	lib/simd/Grid_generic.h	/^  struct Vset{$/;"	s	namespace:Grid::Optimization
Vset	lib/simd/Grid_imci.h	/^  struct Vset{$/;"	s	namespace:Grid::Optimization
Vset	lib/simd/Grid_neon.h	/^  struct Vset{$/;"	s	namespace:Grid::Optimization
Vset	lib/simd/Grid_qpx.h	/^  struct Vset{$/;"	s	namespace:Grid::Optimization
Vset	lib/simd/Grid_sse4.h	/^  struct Vset{$/;"	s	namespace:Grid::Optimization
VsetSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Vset     VsetSIMD;$/;"	t	namespace:Grid
VsetSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Vset     VsetSIMD;$/;"	t	namespace:Grid
VsetSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Vset     VsetSIMD;$/;"	t	namespace:Grid
VsetSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Vset     VsetSIMD;$/;"	t	namespace:Grid
VsetSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Vset     VsetSIMD;$/;"	t	namespace:Grid
VsetSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Vset     VsetSIMD;$/;"	t	namespace:Grid
VsetSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Vset     VsetSIMD;$/;"	t	namespace:Grid
Vsplat	lib/simd/Grid_avx.h	/^ struct Vsplat{$/;"	s	namespace:Grid::Optimization
Vsplat	lib/simd/Grid_avx512.h	/^  struct Vsplat{$/;"	s	namespace:Grid::Optimization
Vsplat	lib/simd/Grid_generic.h	/^  struct Vsplat{$/;"	s	namespace:Grid::Optimization
Vsplat	lib/simd/Grid_imci.h	/^  struct Vsplat{$/;"	s	namespace:Grid::Optimization
Vsplat	lib/simd/Grid_neon.h	/^  struct Vsplat{$/;"	s	namespace:Grid::Optimization
Vsplat	lib/simd/Grid_qpx.h	/^  struct Vsplat{$/;"	s	namespace:Grid::Optimization
Vsplat	lib/simd/Grid_sse4.h	/^  struct Vsplat{$/;"	s	namespace:Grid::Optimization
VsplatSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Vsplat   VsplatSIMD;$/;"	t	namespace:Grid
VsplatSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Vsplat   VsplatSIMD;$/;"	t	namespace:Grid
VsplatSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Vsplat   VsplatSIMD;$/;"	t	namespace:Grid
VsplatSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Vsplat   VsplatSIMD;$/;"	t	namespace:Grid
VsplatSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Vsplat   VsplatSIMD;$/;"	t	namespace:Grid
VsplatSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Vsplat   VsplatSIMD;$/;"	t	namespace:Grid
VsplatSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Vsplat   VsplatSIMD;$/;"	t	namespace:Grid
Vstart	lib/algorithms/iterative/AdefGeneric.h	/^  virtual void Vstart(Field & in, Field & src, Field & r, Field & mp, Field & mmp, Field & tmp){$/;"	f	class:TwoLevelFlexiblePcg::TwoLevelFlexiblePcgADef2
Vstore	lib/simd/Grid_avx.h	/^  struct Vstore{$/;"	s	namespace:Grid::Optimization
Vstore	lib/simd/Grid_avx512.h	/^  struct Vstore{$/;"	s	namespace:Grid::Optimization
Vstore	lib/simd/Grid_generic.h	/^  struct Vstore{$/;"	s	namespace:Grid::Optimization
Vstore	lib/simd/Grid_imci.h	/^  struct Vstore{$/;"	s	namespace:Grid::Optimization
Vstore	lib/simd/Grid_neon.h	/^  struct Vstore{$/;"	s	namespace:Grid::Optimization
Vstore	lib/simd/Grid_qpx.h	/^  struct Vstore{$/;"	s	namespace:Grid::Optimization
Vstore	lib/simd/Grid_sse4.h	/^  struct Vstore{$/;"	s	namespace:Grid::Optimization
VstoreSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Vstore   VstoreSIMD;$/;"	t	namespace:Grid
VstoreSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Vstore   VstoreSIMD;$/;"	t	namespace:Grid
VstoreSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Vstore   VstoreSIMD;$/;"	t	namespace:Grid
VstoreSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Vstore   VstoreSIMD;$/;"	t	namespace:Grid
VstoreSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Vstore   VstoreSIMD;$/;"	t	namespace:Grid
VstoreSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Vstore   VstoreSIMD;$/;"	t	namespace:Grid
VstoreSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Vstore   VstoreSIMD;$/;"	t	namespace:Grid
Vstream	lib/simd/Grid_avx.h	/^  struct Vstream{$/;"	s	namespace:Grid::Optimization
Vstream	lib/simd/Grid_avx512.h	/^  struct Vstream{$/;"	s	namespace:Grid::Optimization
Vstream	lib/simd/Grid_generic.h	/^  struct Vstream{$/;"	s	namespace:Grid::Optimization
Vstream	lib/simd/Grid_imci.h	/^  struct Vstream{$/;"	s	namespace:Grid::Optimization
Vstream	lib/simd/Grid_neon.h	/^  struct Vstream{ \/\/ N:equivalents to _mm_stream_p* in NEON?$/;"	s	namespace:Grid::Optimization
Vstream	lib/simd/Grid_qpx.h	/^  struct Vstream{$/;"	s	namespace:Grid::Optimization
Vstream	lib/simd/Grid_sse4.h	/^  struct Vstream{$/;"	s	namespace:Grid::Optimization
VstreamSIMD	lib/simd/Grid_avx.h	/^  typedef Optimization::Vstream  VstreamSIMD;$/;"	t	namespace:Grid
VstreamSIMD	lib/simd/Grid_avx512.h	/^  typedef Optimization::Vstream  VstreamSIMD;$/;"	t	namespace:Grid
VstreamSIMD	lib/simd/Grid_generic.h	/^  typedef Optimization::Vstream  VstreamSIMD;$/;"	t	namespace:Grid
VstreamSIMD	lib/simd/Grid_imci.h	/^  typedef Optimization::Vstream  VstreamSIMD;$/;"	t	namespace:Grid
VstreamSIMD	lib/simd/Grid_neon.h	/^  typedef Optimization::Vstream  VstreamSIMD;$/;"	t	namespace:Grid
VstreamSIMD	lib/simd/Grid_qpx.h	/^typedef Optimization::Vstream  VstreamSIMD;$/;"	t	namespace:Grid
VstreamSIMD	lib/simd/Grid_sse4.h	/^  typedef Optimization::Vstream  VstreamSIMD;$/;"	t	namespace:Grid
W	lib/simd/Grid_generic_types.h	/^  template <> struct W<Integer> {$/;"	s	namespace:Grid::Optimization
W	lib/simd/Grid_generic_types.h	/^  template <> struct W<double> {$/;"	s	namespace:Grid::Optimization
W	lib/simd/Grid_generic_types.h	/^  template <> struct W<float> {$/;"	s	namespace:Grid::Optimization
W	lib/simd/Grid_generic_types.h	/^  template <> struct W<uint16_t> {$/;"	s	namespace:Grid::Optimization
WFParameters	tests/smearing/Test_WilsonFlow.cc	/^    WFParameters(Reader<ReaderClass>& Reader){$/;"	f	struct:Grid::WFParameters
WFParameters	tests/smearing/Test_WilsonFlow.cc	/^  struct WFParameters: Serializable {$/;"	s	namespace:Grid	file:
WILSONFLOW_H	lib/qcd/smearing/WilsonFlow.h	31;"	d
WORK	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	108;"	d
WORK	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	149;"	d
WORK	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	206;"	d
WORK	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	246;"	d
WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	lib/Eigen/src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
W_diag	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	/^    W_diag = 0,$/;"	e	enum:__anon6
W_diag	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	/^    W_diag = 0,$/;"	e	enum:__anon689
WaitAll	lib/communicator/Communicator_mpi3_leader.cc	/^  static void WaitAll() {$/;"	f	class:Grid::MPIoffloadEngine
WaitAll	lib/communicator/Communicator_mpi3_leader.cc	/^  void WaitAll() {$/;"	f	class:Grid::Slave
WaitForCommand	lib/communicator/Communicator_mpi3_leader.cc	/^  void WaitForCommand(void) { $/;"	f	class:Grid::Slave
WaitForComplete	lib/communicator/Communicator_mpi3_leader.cc	/^  void WaitForComplete(void) { $/;"	f	class:Grid::Slave
WakeUpCompute	lib/communicator/Communicator_mpi3_leader.cc	/^  void WakeUpCompute(void) { $/;"	f	class:Grid::Slave
WakeUpDMA	lib/communicator/Communicator_mpi3_leader.cc	/^  void WakeUpDMA(void) { $/;"	f	class:Grid::Slave
WallPar	extras/Hadrons/Modules/MSource/Wall.hpp	/^class WallPar: Serializable$/;"	c
WallPar	lib/Hadrons/Modules/MSource/Wall.hpp	/^class WallPar: Serializable$/;"	c
WeakHamiltonianPar	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^class WeakHamiltonianPar: Serializable$/;"	c
WeakHamiltonianPar	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^class WeakHamiltonianPar: Serializable$/;"	c
WilsonAdjFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonAdjImplD> WilsonAdjFermionD;$/;"	t	namespace:Grid::QCD
WilsonAdjFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonAdjImplF> WilsonAdjFermionF;$/;"	t	namespace:Grid::QCD
WilsonAdjFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonAdjImplR> WilsonAdjFermionR;$/;"	t	namespace:Grid::QCD
WilsonAdjImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexD, AdjointRepresentation, CoeffReal > WilsonAdjImplD;  \/\/ Double$/;"	t	namespace:Grid::QCD
WilsonAdjImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexF, AdjointRepresentation, CoeffReal > WilsonAdjImplF;  \/\/ Float$/;"	t	namespace:Grid::QCD
WilsonAdjImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplex,  AdjointRepresentation, CoeffReal > WilsonAdjImplR;   \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
WilsonCompressorTemplate	lib/qcd/action/fermion/WilsonCompressor.h	/^  WilsonCompressorTemplate(int _dag=0){$/;"	f	class:Grid::QCD::WilsonCompressorTemplate
WilsonCompressorTemplate	lib/qcd/action/fermion/WilsonCompressor.h	/^class WilsonCompressorTemplate< _HCspinor, _Hspinor, _Spinor, projector,$/;"	c	namespace:Grid::QCD
WilsonFermion	lib/qcd/action/fermion/WilsonFermion.cc	/^WilsonFermion<Impl>::WilsonFermion(GaugeField &_Umu, GridCartesian &Fgrid,$/;"	f	class:Grid::QCD::WilsonFermion
WilsonFermion	lib/qcd/action/fermion/WilsonFermion.h	/^class WilsonFermion : public WilsonKernels<Impl>, public WilsonFermionStatic {$/;"	c	namespace:Grid::QCD
WilsonFermion	tests/qdpxx/Test_qdpxx_munprec.cc	/^		 WilsonFermion, \/\/ Wilson$/;"	e	enum:ChromaAction	file:
WilsonFermion5D	lib/qcd/action/fermion/WilsonFermion5D.cc	/^WilsonFermion5D<Impl>::WilsonFermion5D(GaugeField &_Umu,$/;"	f	class:Grid::QCD::WilsonFermion5D
WilsonFermion5D	lib/qcd/action/fermion/WilsonFermion5D.h	/^    class WilsonFermion5D : public WilsonKernels<Impl>, public WilsonFermion5DStatic$/;"	c	namespace:Grid::QCD
WilsonFermion5DD	benchmarks/Benchmark_dwf.cc	/^typedef WilsonFermion5D<DomainWallVec5dImplD> WilsonFermion5DD;$/;"	t	file:
WilsonFermion5DD	tests/core/Test_dwf_rb5d.cc	/^typedef WilsonFermion5D<DomainWallVec5dImplD> WilsonFermion5DD;$/;"	t	file:
WilsonFermion5DF	benchmarks/Benchmark_dwf.cc	/^typedef WilsonFermion5D<DomainWallVec5dImplF> WilsonFermion5DF;$/;"	t	file:
WilsonFermion5DF	tests/core/Test_dwf_rb5d.cc	/^typedef WilsonFermion5D<DomainWallVec5dImplF> WilsonFermion5DF;$/;"	t	file:
WilsonFermion5DR	benchmarks/Benchmark_dwf.cc	/^typedef WilsonFermion5D<DomainWallVec5dImplR> WilsonFermion5DR;$/;"	t	file:
WilsonFermion5DR	tests/core/Test_dwf_rb5d.cc	/^typedef WilsonFermion5D<DomainWallVec5dImplR> WilsonFermion5DR;$/;"	t	file:
WilsonFermion5DStatic	lib/qcd/action/fermion/WilsonFermion5D.h	/^    class WilsonFermion5DStatic { $/;"	c	namespace:Grid::QCD
WilsonFermion5D_OKR	tests/core/Test_dwf_rb5d.cc	/^typedef WilsonFermion5D<WilsonImplR> WilsonFermion5D_OKR;$/;"	t	file:
WilsonFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonImplD> WilsonFermionD;$/;"	t	namespace:Grid::QCD
WilsonFermionD	lib/qcd/action/fermion/WilsonFermion.h	/^typedef WilsonFermion<WilsonImplD> WilsonFermionD;$/;"	t	namespace:Grid::QCD
WilsonFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonImplDF> WilsonFermionDF;$/;"	t	namespace:Grid::QCD
WilsonFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonImplF> WilsonFermionF;$/;"	t	namespace:Grid::QCD
WilsonFermionF	lib/qcd/action/fermion/WilsonFermion.h	/^typedef WilsonFermion<WilsonImplF> WilsonFermionF;$/;"	t	namespace:Grid::QCD
WilsonFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonImplFH> WilsonFermionFH;$/;"	t	namespace:Grid::QCD
WilsonFermionModule	lib/qcd/modules/FermionOperatorModules.h	/^class WilsonFermionModule: public FermionOperatorModule<WilsonFermion, FermionImpl, WilsonFermionParameters> {$/;"	c	namespace:Grid::QCD
WilsonFermionParameters	lib/qcd/modules/FermionOperatorModules.h	/^class WilsonFermionParameters : Serializable {$/;"	c	namespace:Grid::QCD
WilsonFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonImplR> WilsonFermionR;$/;"	t	namespace:Grid::QCD
WilsonFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonImplRL> WilsonFermionRL;$/;"	t	namespace:Grid::QCD
WilsonFermionStatic	lib/qcd/action/fermion/WilsonFermion.h	/^class WilsonFermionStatic {$/;"	c	namespace:Grid::QCD
WilsonFlow	lib/qcd/smearing/WilsonFlow.h	/^    explicit WilsonFlow(unsigned int Nstep, RealD epsilon, unsigned int interval = 1):$/;"	f	class:Grid::QCD::WilsonFlow
WilsonFlow	lib/qcd/smearing/WilsonFlow.h	/^class WilsonFlow: public Smear<Gimpl>{$/;"	c	namespace:Grid::QCD
WilsonGMod	lib/qcd/modules/Registration.h	/^typedef QCD::WilsonGModule<ImplementationPolicy> WilsonGMod;$/;"	t
WilsonGModule	lib/qcd/modules/ActionModules.h	/^class WilsonGModule: public ActionModule<WilsonGaugeAction<Impl>, BetaGaugeActionParameters> {$/;"	c	namespace:Grid::QCD
WilsonGaugeAction	lib/qcd/action/gauge/WilsonGaugeAction.h	/^  explicit WilsonGaugeAction(RealD beta_):beta(beta_){};$/;"	f	class:Grid::QCD::WilsonGaugeAction
WilsonGaugeAction	lib/qcd/action/gauge/WilsonGaugeAction.h	/^class WilsonGaugeAction : public Action<typename Gimpl::GaugeField> {$/;"	c	namespace:Grid::QCD
WilsonGaugeActionD	lib/qcd/action/gauge/Gauge.h	/^typedef WilsonGaugeAction<PeriodicGimplD>          WilsonGaugeActionD;$/;"	t	namespace:Grid::QCD
WilsonGaugeActionF	lib/qcd/action/gauge/Gauge.h	/^typedef WilsonGaugeAction<PeriodicGimplF>          WilsonGaugeActionF;$/;"	t	namespace:Grid::QCD
WilsonGaugeActionR	lib/qcd/action/gauge/Gauge.h	/^typedef WilsonGaugeAction<PeriodicGimplR>          WilsonGaugeActionR;$/;"	t	namespace:Grid::QCD
WilsonImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    WilsonImpl(const ImplParams &p = ImplParams()) : Params(p){$/;"	f	class:Grid::QCD::WilsonImpl
WilsonImpl	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  class WilsonImpl : public PeriodicGaugeImpl<GaugeImplTypes<S, Representation::Dimension > > {$/;"	c	namespace:Grid::QCD
WilsonImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexD, FundamentalRepresentation, CoeffReal > WilsonImplD;  \/\/ Double$/;"	t	namespace:Grid::QCD
WilsonImplDF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexD, FundamentalRepresentation, CoeffRealHalfComms > WilsonImplDF;  \/\/ Double$/;"	t	namespace:Grid::QCD
WilsonImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexF, FundamentalRepresentation, CoeffReal > WilsonImplF;  \/\/ Float$/;"	t	namespace:Grid::QCD
WilsonImplFH	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexF, FundamentalRepresentation, CoeffRealHalfComms > WilsonImplFH;  \/\/ Float$/;"	t	namespace:Grid::QCD
WilsonImplParams	lib/qcd/action/ActionParams.h	/^    WilsonImplParams() : overlapCommsCompute(false) {$/;"	f	struct:Grid::QCD::WilsonImplParams
WilsonImplParams	lib/qcd/action/ActionParams.h	/^    WilsonImplParams(const std::vector<Complex> phi)$/;"	f	struct:Grid::QCD::WilsonImplParams
WilsonImplParams	lib/qcd/action/ActionParams.h	/^  struct WilsonImplParams {$/;"	s	namespace:Grid::QCD
WilsonImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplex,  FundamentalRepresentation, CoeffReal > WilsonImplR;  \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
WilsonImplRL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplex,  FundamentalRepresentation, CoeffRealHalfComms > WilsonImplRL;  \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
WilsonKernels	lib/qcd/action/fermion/WilsonKernels.cc	/^WilsonKernels<Impl>::WilsonKernels(const ImplParams &p) : Base(p){};$/;"	f	class:Grid::QCD::WilsonKernels
WilsonKernels	lib/qcd/action/fermion/WilsonKernels.h	/^template<class Impl> class WilsonKernels : public FermionOperator<Impl> , public WilsonKernelsStatic { $/;"	c	namespace:Grid::QCD
WilsonKernelsStatic	lib/qcd/action/fermion/WilsonKernels.h	/^class WilsonKernelsStatic { $/;"	c	namespace:Grid::QCD
WilsonLoops	lib/qcd/utils/WilsonLoops.h	/^template <class Gimpl> class WilsonLoops : public Gimpl {$/;"	c	namespace:Grid::QCD
WilsonPar	extras/Hadrons/Modules/MAction/Wilson.hpp	/^class WilsonPar: Serializable$/;"	c
WilsonPar	lib/Hadrons/Modules/MAction/Wilson.hpp	/^class WilsonPar: Serializable$/;"	c
WilsonProjector	lib/qcd/action/fermion/WilsonCompressor.h	/^class WilsonProjector {$/;"	c	namespace:Grid::QCD
WilsonStencil	lib/qcd/action/fermion/WilsonCompressor.h	/^  WilsonStencil(GridBase *grid,$/;"	f	class:Grid::QCD::WilsonStencil
WilsonStencil	lib/qcd/action/fermion/WilsonCompressor.h	/^class WilsonStencil : public CartesianStencil<vobj,cobj> {$/;"	c	namespace:Grid::QCD
WilsonTMFermion	lib/qcd/action/fermion/WilsonTMFermion.h	/^      WilsonTMFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::WilsonTMFermion
WilsonTMFermion	lib/qcd/action/fermion/WilsonTMFermion.h	/^    class WilsonTMFermion : public WilsonFermion<Impl>$/;"	c	namespace:Grid::QCD
WilsonTMFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<WilsonImplD> WilsonTMFermionD;$/;"	t	namespace:Grid::QCD
WilsonTMFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<WilsonImplF> WilsonTMFermionF;$/;"	t	namespace:Grid::QCD
WilsonTMFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonTMFermion<WilsonImplR> WilsonTMFermionR;$/;"	t	namespace:Grid::QCD
WilsonTwoIndexSymmetricFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonTwoIndexSymmetricImplD> WilsonTwoIndexSymmetricFermionD;$/;"	t	namespace:Grid::QCD
WilsonTwoIndexSymmetricFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonTwoIndexSymmetricImplF> WilsonTwoIndexSymmetricFermionF;$/;"	t	namespace:Grid::QCD
WilsonTwoIndexSymmetricFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef WilsonFermion<WilsonTwoIndexSymmetricImplR> WilsonTwoIndexSymmetricFermionR;$/;"	t	namespace:Grid::QCD
WilsonTwoIndexSymmetricImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexD, TwoIndexSymmetricRepresentation, CoeffReal > WilsonTwoIndexSymmetricImplD;  \/\/ Double$/;"	t	namespace:Grid::QCD
WilsonTwoIndexSymmetricImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexF, TwoIndexSymmetricRepresentation, CoeffReal > WilsonTwoIndexSymmetricImplF;  \/\/ Float$/;"	t	namespace:Grid::QCD
WilsonTwoIndexSymmetricImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplex,  TwoIndexSymmetricRepresentation, CoeffReal > WilsonTwoIndexSymmetricImplR;   \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
WithFormat	lib/Eigen/src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat
WithFormat	lib/Eigen/src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
WorkMatrixType	lib/Eigen/src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD
WorkVectorType	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
WorkingRows	lib/Eigen/src/Geometry/Transform.h	/^    WorkingRows = EIGEN_PLAIN_ENUM_MIN(TransformMatrix::RowsAtCompileTime,HDim)$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon598
WorkspaceType	lib/Eigen/src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
WorldCoor	lib/communicator/Communicator_base.h	/^  std::vector<int> WorldCoor;$/;"	m	class:Grid::CartesianCommunicator
WorldDims	lib/communicator/Communicator_base.h	/^  std::vector<int>  WorldDims;$/;"	m	class:Grid::CartesianCommunicator
WorldGroup	lib/communicator/Communicator_mpi3_leader.cc	/^  static MPI_Group WorldGroup, CachedGroup;$/;"	m	class:Grid::MPIoffloadEngine	file:
WorldGroup	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Group MPIoffloadEngine::WorldGroup;$/;"	m	class:Grid::MPIoffloadEngine	file:
WorldRank	lib/communicator/Communicator_base.h	/^  static int WorldRank;$/;"	m	class:Grid::CartesianCommunicator
WorldRank	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::WorldRank;$/;"	m	class:Grid::CartesianCommunicator	file:
WorldSize	lib/communicator/Communicator_base.h	/^  static int WorldSize;$/;"	m	class:Grid::CartesianCommunicator
WorldSize	lib/communicator/Communicator_mpi3.cc	/^int CartesianCommunicator::WorldSize;$/;"	m	class:Grid::CartesianCommunicator	file:
WriteAccessors	lib/Eigen/src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
Writer	lib/serialisation/BaseIO.h	/^  Writer<T>::Writer(void)$/;"	f	class:Grid::Writer
Writer	lib/serialisation/BaseIO.h	/^  class Writer$/;"	c	namespace:Grid
XConnections	lib/communicator/Communicator_shmem.cc	/^static Vector< HandShake > XConnections;$/;"	m	namespace:Grid	file:
XM_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	134;"	d	file:
XM_PROJMEM	lib/simd/BGQQPX.h	291;"	d
XM_PROJMEM	lib/simd/IBM_qpx.h	337;"	d
XM_PROJMEM	lib/simd/Intel512wilson.h	252;"	d
XM_RECON	lib/qcd/action/fermion/WilsonKernelsHand.cc	198;"	d	file:
XM_RECON	lib/simd/BGQQPX.h	418;"	d
XM_RECON	lib/simd/IBM_qpx.h	463;"	d
XM_RECON	lib/simd/Intel512wilson.h	370;"	d
XM_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	212;"	d	file:
XM_RECON_ACCUM	lib/simd/BGQQPX.h	448;"	d
XM_RECON_ACCUM	lib/simd/IBM_qpx.h	493;"	d
XM_RECON_ACCUM	lib/simd/Intel512wilson.h	398;"	d
XP_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	99;"	d	file:
XP_PROJMEM	lib/simd/BGQQPX.h	278;"	d
XP_PROJMEM	lib/simd/IBM_qpx.h	324;"	d
XP_PROJMEM	lib/simd/Intel512wilson.h	190;"	d
XP_RECON	lib/qcd/action/fermion/WilsonKernelsHand.cc	170;"	d	file:
XP_RECON	lib/simd/BGQQPX.h	402;"	d
XP_RECON	lib/simd/IBM_qpx.h	447;"	d
XP_RECON	lib/simd/Intel512wilson.h	314;"	d
XP_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	184;"	d	file:
XP_RECON_ACCUM	lib/simd/BGQQPX.h	434;"	d
XP_RECON_ACCUM	lib/simd/IBM_qpx.h	479;"	d
XP_RECON_ACCUM	lib/simd/Intel512wilson.h	342;"	d
Xdir	lib/qcd/QCD.h	/^    static const int Xdir = 0;$/;"	m	namespace:Grid::QCD
Xm	lib/qcd/LatticeTheories.h	/^    static const int Xm = 4;$/;"	m	struct:Grid::LatticeTheories::QCD
Xm	lib/qcd/QCD.h	/^    static const int Xm = 4;$/;"	m	namespace:Grid::QCD
XmlReader	lib/serialisation/XmlIO.cc	/^XmlReader::XmlReader(const char *xmlstring,string toplev) : fileName_("")$/;"	f	class:XmlReader
XmlReader	lib/serialisation/XmlIO.cc	/^XmlReader::XmlReader(const string &fileName,string toplev) : fileName_(fileName)$/;"	f	class:XmlReader
XmlReader	lib/serialisation/XmlIO.h	/^  class XmlReader: public Reader<XmlReader>$/;"	c	namespace:Grid
XmlString	lib/serialisation/XmlIO.cc	/^std::string XmlWriter::XmlString(void)$/;"	f	class:XmlWriter
XmlWriter	lib/serialisation/XmlIO.cc	/^XmlWriter::XmlWriter(const string &fileName, string toplev) : fileName_(fileName)$/;"	f	class:XmlWriter
XmlWriter	lib/serialisation/XmlIO.h	/^  class XmlWriter: public Writer<XmlWriter>$/;"	c	namespace:Grid
Xp	lib/qcd/LatticeTheories.h	/^    static const int Xp = 0;$/;"	m	struct:Grid::LatticeTheories::QCD
Xp	lib/qcd/QCD.h	/^    static const int Xp = 0;$/;"	m	namespace:Grid::QCD
Xpr	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef CwiseBinaryOp<internal::scalar_sum_op<typename Lhs::Scalar,typename Rhs::Scalar>, const LinearProduct, const ConstantBlock> Xpr;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
Xpr	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef CwiseBinaryOp<internal::scalar_sum_op<typename Lhs::Scalar,typename Rhs::Scalar>, const LinearProduct, const ConstantBlock> Xpr;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
XprBase	lib/Eigen/src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename traits<DiagonalVectorType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/Product.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/LU/FullPivLU.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	lib/Eigen/src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef ArrayWrapper<TArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;$/;"	t	struct:Eigen::internal::block_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseNullaryOp<NullaryOp,PlainObjectType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;$/;"	t	struct:Eigen::internal::ternary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseUnaryView<UnaryOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Derived  XprType;$/;"	t	struct:Eigen::internal::mapbase_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Diagonal<ArgType, DiagIndex> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef EvalToTemp<ArgType>                   XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Map<PlainObjectType, MapOptions, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef MatrixWrapper<TArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef PartialReduxExpr<ArgType, MemberOp, Direction> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Ref<PlainObjectType, RefOptions, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Replicate<ArgType, RowFactor, ColFactor> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Reverse<ArgType, Direction> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef Transpose<ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/ProductEvaluators.h	/^                               const Product<Lhs, Rhs, DefaultProduct> > XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, LazyProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, Options> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, Options> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, ProductKind> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/Core/Redux.h	/^  typedef _XprType XprType;$/;"	t	class:Eigen::internal::redux_evaluator
XprType	lib/Eigen/src/Core/ReturnByValue.h	/^  typedef ReturnByValue<Derived> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType,Mode> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Homogeneous<ArgType,Direction> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Product<Lhs, Rhs, LazyProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^  typedef MappedSparseMatrix<_Scalar,_Options,_StorageIndex> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<ArgType,BlockRows,BlockCols,InnerPanel> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef Block<SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef Block<const SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<scalar_quotient_op<T1,T2>, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Product<Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef Product<Lhs, Rhs, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/SparseCore/SparseMap.h	/^  typedef Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/SparseCore/SparseMap.h	/^  typedef Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef Product<Lhs, Rhs, AliasFreeProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef SparseView<Product<Lhs, Rhs, Options> > XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Product<Lhs, RhsView, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Product<LhsView, Rhs, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef Transpose<ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef TriangularView<ArgType,Mode> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	lib/Eigen/src/SparseCore/SparseView.h	/^    typedef SparseView<ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprTypeIsRowMajor	lib/Eigen/src/Core/Block.h	/^      XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0$/;"	e	enum:Eigen::internal::BlockImpl_dense::__anon214
XprTypeIsRowMajor	lib/Eigen/src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon213
XprTypeNested	lib/Eigen/src/Core/Block.h	/^    typedef typename internal::ref_selector<XprType>::non_const_type XprTypeNested;$/;"	t	class:Eigen::internal::BlockImpl_dense
XprTypeNested	lib/Eigen/src/Core/Block.h	/^  typedef typename ref_selector<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XprTypeNested	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::ref_selector<XprType>::type XprTypeNested;$/;"	t	class:Eigen::CwiseUnaryOp
XprTypeNested	lib/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XprTypeNested	lib/Eigen/src/Core/Inverse.h	/^  typedef typename internal::ref_selector<XprType>::type      XprTypeNested;$/;"	t	class:Eigen::Inverse
XprTypeNestedCleaned	lib/Eigen/src/Core/Inverse.h	/^  typedef typename internal::remove_all<XprTypeNested>::type  XprTypeNestedCleaned;$/;"	t	class:Eigen::Inverse
YM_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	142;"	d	file:
YM_PROJMEM	lib/simd/BGQQPX.h	318;"	d
YM_PROJMEM	lib/simd/IBM_qpx.h	364;"	d
YM_PROJMEM	lib/simd/Intel512wilson.h	270;"	d
YM_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	240;"	d	file:
YM_RECON_ACCUM	lib/simd/BGQQPX.h	472;"	d
YM_RECON_ACCUM	lib/simd/IBM_qpx.h	517;"	d
YM_RECON_ACCUM	lib/simd/Intel512wilson.h	441;"	d
YOU_ALREADY_SPECIFIED_THIS_STRIDE	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_MADE_A_PROGRAMMING_MISTAKE	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	lib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon24
YP_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	107;"	d	file:
YP_PROJMEM	lib/simd/BGQQPX.h	306;"	d
YP_PROJMEM	lib/simd/IBM_qpx.h	352;"	d
YP_PROJMEM	lib/simd/Intel512wilson.h	209;"	d
YP_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	226;"	d	file:
YP_RECON_ACCUM	lib/simd/BGQQPX.h	464;"	d
YP_RECON_ACCUM	lib/simd/IBM_qpx.h	509;"	d
YP_RECON_ACCUM	lib/simd/Intel512wilson.h	427;"	d
Ydir	lib/qcd/QCD.h	/^    static const int Ydir = 1;$/;"	m	namespace:Grid::QCD
Ym	lib/qcd/LatticeTheories.h	/^    static const int Ym = 5;$/;"	m	struct:Grid::LatticeTheories::QCD
Ym	lib/qcd/QCD.h	/^    static const int Ym = 5;$/;"	m	namespace:Grid::QCD
Yp	lib/qcd/LatticeTheories.h	/^    static const int Yp = 1;$/;"	m	struct:Grid::LatticeTheories::QCD
Yp	lib/qcd/QCD.h	/^    static const int Yp = 1;$/;"	m	namespace:Grid::QCD
Z0	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	98;"	d	file:
Z0	lib/simd/Intel512wilson.h	71;"	d
Z00	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	96;"	d	file:
Z1	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	99;"	d	file:
Z1	lib/simd/Intel512wilson.h	72;"	d
Z10	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	97;"	d	file:
Z2	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	100;"	d	file:
Z2	lib/simd/Intel512wilson.h	73;"	d
Z2Par	extras/Hadrons/Modules/MSource/Z2.hpp	/^class Z2Par: Serializable$/;"	c
Z2Par	lib/Hadrons/Modules/MSource/Z2.hpp	/^class Z2Par: Serializable$/;"	c
Z3	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	102;"	d	file:
Z3	lib/simd/Intel512wilson.h	74;"	d
Z4	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	103;"	d	file:
Z4	lib/simd/Intel512wilson.h	75;"	d
Z5	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	104;"	d	file:
Z5	lib/simd/Intel512wilson.h	76;"	d
Z6	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	105;"	d	file:
Z6	lib/simd/Intel512wilson.h	890;"	d
ZDomainWallVec5dImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexD,Nc,CoeffComplex> ZDomainWallVec5dImplD; \/\/ Double$/;"	t	namespace:Grid::QCD
ZDomainWallVec5dImplDF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexD,Nc,CoeffComplexHalfComms> ZDomainWallVec5dImplDF; \/\/ Double$/;"	t	namespace:Grid::QCD
ZDomainWallVec5dImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexF,Nc,CoeffComplex> ZDomainWallVec5dImplF; \/\/ Float$/;"	t	namespace:Grid::QCD
ZDomainWallVec5dImplFH	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplexF,Nc,CoeffComplexHalfComms> ZDomainWallVec5dImplFH; \/\/ Float$/;"	t	namespace:Grid::QCD
ZDomainWallVec5dImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplex ,Nc,CoeffComplex> ZDomainWallVec5dImplR; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
ZDomainWallVec5dImplRL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef DomainWallVec5dImpl<vComplex ,Nc,CoeffComplexHalfComms> ZDomainWallVec5dImplRL; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
ZEND1	lib/simd/Intel512double.h	120;"	d
ZEND1	lib/simd/Intel512double.h	128;"	d
ZEND1	lib/simd/Intel512single.h	119;"	d
ZEND1	lib/simd/Intel512single.h	127;"	d
ZEND1d	lib/simd/Intel512avx.h	82;"	d
ZEND1d	lib/simd/Intel512imci.h	75;"	d
ZEND1f	lib/simd/Intel512avx.h	76;"	d
ZEND1f	lib/simd/Intel512imci.h	78;"	d
ZEND2	lib/simd/Intel512double.h	121;"	d
ZEND2	lib/simd/Intel512double.h	129;"	d
ZEND2	lib/simd/Intel512single.h	120;"	d
ZEND2	lib/simd/Intel512single.h	128;"	d
ZEND2d	lib/simd/Intel512avx.h	85;"	d
ZEND2d	lib/simd/Intel512imci.h	76;"	d
ZEND2f	lib/simd/Intel512avx.h	79;"	d
ZEND2f	lib/simd/Intel512imci.h	79;"	d
ZENDd	lib/simd/Intel512avx.h	45;"	d
ZENDd	lib/simd/Intel512imci.h	45;"	d
ZENDf	lib/simd/Intel512avx.h	44;"	d
ZENDf	lib/simd/Intel512imci.h	44;"	d
ZERO	lib/algorithms/approx/Zolotarev.cc	45;"	d	file:
ZERO	lib/algorithms/approx/Zolotarev.cc	523;"	d	file:
ZERO	lib/algorithms/approx/Zolotarev.cc	524;"	d	file:
ZERO_PSI	lib/simd/IBM_qpx.h	184;"	d
ZERO_PSI	lib/simd/Intel512wilson.h	112;"	d
ZERO_RESULT	lib/qcd/action/fermion/WilsonKernelsHand.cc	423;"	d	file:
ZGraph	lib/stencil/Lebesgue.cc	/^void LebesgueOrder::ZGraph(void) $/;"	f	class:Grid::LebesgueOrder
ZLOAD	lib/simd/Intel512double.h	122;"	d
ZLOAD	lib/simd/Intel512double.h	130;"	d
ZLOAD	lib/simd/Intel512single.h	121;"	d
ZLOAD	lib/simd/Intel512single.h	129;"	d
ZLOADd	lib/simd/Intel512avx.h	36;"	d
ZLOADd	lib/simd/Intel512common.h	140;"	d
ZLOADd	lib/simd/Intel512imci.h	36;"	d
ZLOADf	lib/simd/Intel512avx.h	35;"	d
ZLOADf	lib/simd/Intel512common.h	139;"	d
ZLOADf	lib/simd/Intel512imci.h	35;"	d
ZMADD	lib/simd/Intel512double.h	124;"	d
ZMADD	lib/simd/Intel512double.h	132;"	d
ZMADD	lib/simd/Intel512single.h	123;"	d
ZMADD	lib/simd/Intel512single.h	131;"	d
ZMADDMEM2SP	lib/simd/Intel512double.h	126;"	d
ZMADDMEM2SP	lib/simd/Intel512double.h	134;"	d
ZMADDMEM2SP	lib/simd/Intel512single.h	125;"	d
ZMADDMEM2SP	lib/simd/Intel512single.h	133;"	d
ZMADDMEM2SPd	lib/simd/Intel512avx.h	68;"	d
ZMADDMEM2SPd	lib/simd/Intel512imci.h	68;"	d
ZMADDMEM2SPf	lib/simd/Intel512avx.h	61;"	d
ZMADDMEM2SPf	lib/simd/Intel512imci.h	61;"	d
ZMADDd	lib/simd/Intel512avx.h	42;"	d
ZMADDd	lib/simd/Intel512imci.h	42;"	d
ZMADDf	lib/simd/Intel512avx.h	41;"	d
ZMADDf	lib/simd/Intel512imci.h	41;"	d
ZMUL	lib/simd/Intel512double.h	123;"	d
ZMUL	lib/simd/Intel512double.h	131;"	d
ZMUL	lib/simd/Intel512single.h	122;"	d
ZMUL	lib/simd/Intel512single.h	130;"	d
ZMULMEM2SP	lib/simd/Intel512double.h	125;"	d
ZMULMEM2SP	lib/simd/Intel512double.h	133;"	d
ZMULMEM2SP	lib/simd/Intel512single.h	124;"	d
ZMULMEM2SP	lib/simd/Intel512single.h	132;"	d
ZMULMEM2SPd	lib/simd/Intel512avx.h	54;"	d
ZMULMEM2SPd	lib/simd/Intel512imci.h	54;"	d
ZMULMEM2SPf	lib/simd/Intel512avx.h	47;"	d
ZMULMEM2SPf	lib/simd/Intel512imci.h	47;"	d
ZMULd	lib/simd/Intel512avx.h	39;"	d
ZMULd	lib/simd/Intel512imci.h	39;"	d
ZMULf	lib/simd/Intel512avx.h	38;"	d
ZMULf	lib/simd/Intel512imci.h	38;"	d
ZM_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	150;"	d	file:
ZM_PROJMEM	lib/simd/BGQQPX.h	349;"	d
ZM_PROJMEM	lib/simd/IBM_qpx.h	394;"	d
ZM_PROJMEM	lib/simd/Intel512wilson.h	281;"	d
ZM_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	268;"	d	file:
ZM_RECON_ACCUM	lib/simd/BGQQPX.h	497;"	d
ZM_RECON_ACCUM	lib/simd/IBM_qpx.h	542;"	d
ZM_RECON_ACCUM	lib/simd/Intel512wilson.h	482;"	d
ZMobiusFermion	lib/qcd/action/fermion/ZMobiusFermion.h	/^      ZMobiusFermion(GaugeField &_Umu,$/;"	f	class:Grid::QCD::ZMobiusFermion
ZMobiusFermion	lib/qcd/action/fermion/ZMobiusFermion.h	/^    class ZMobiusFermion : public CayleyFermion5D<Impl>$/;"	c	namespace:Grid::QCD
ZMobiusFermionD	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZWilsonImplD> ZMobiusFermionD;$/;"	t	namespace:Grid::QCD
ZMobiusFermionDF	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZWilsonImplDF> ZMobiusFermionDF;$/;"	t	namespace:Grid::QCD
ZMobiusFermionF	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZWilsonImplF> ZMobiusFermionF;$/;"	t	namespace:Grid::QCD
ZMobiusFermionFH	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZWilsonImplFH> ZMobiusFermionFH;$/;"	t	namespace:Grid::QCD
ZMobiusFermionR	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZWilsonImplR> ZMobiusFermionR;$/;"	t	namespace:Grid::QCD
ZMobiusFermionRL	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZWilsonImplRL> ZMobiusFermionRL;$/;"	t	namespace:Grid::QCD
ZMobiusFermionVec5dD	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZDomainWallVec5dImplD> ZMobiusFermionVec5dD;$/;"	t	namespace:Grid::QCD
ZMobiusFermionVec5dDF	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZDomainWallVec5dImplDF> ZMobiusFermionVec5dDF;$/;"	t	namespace:Grid::QCD
ZMobiusFermionVec5dF	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZDomainWallVec5dImplF> ZMobiusFermionVec5dF;$/;"	t	namespace:Grid::QCD
ZMobiusFermionVec5dFH	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZDomainWallVec5dImplFH> ZMobiusFermionVec5dFH;$/;"	t	namespace:Grid::QCD
ZMobiusFermionVec5dR	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZDomainWallVec5dImplR> ZMobiusFermionVec5dR;$/;"	t	namespace:Grid::QCD
ZMobiusFermionVec5dRL	lib/qcd/action/fermion/Fermion.h	/^typedef ZMobiusFermion<ZDomainWallVec5dImplRL> ZMobiusFermionVec5dRL;$/;"	t	namespace:Grid::QCD
ZMobiusVecFermionR	tests/Test_cayley_even_odd_vec.cc	/^typedef ZMobiusFermion<ZDomainWallVec5dImplR>                        ZMobiusVecFermionR;$/;"	t	file:
ZOLOTAREV_DATA	lib/algorithms/approx/Zolotarev.cc	31;"	d	file:
ZOLOTAREV_DATA	lib/algorithms/approx/Zolotarev.cc	32;"	d	file:
ZOLOTAREV_DATA	lib/algorithms/approx/Zolotarev.h	/^} ZOLOTAREV_DATA;$/;"	t	namespace:Grid::Approx	typeref:struct:Grid::Approx::__anon695
ZOLOTAREV_DATA	lib/algorithms/approx/Zolotarev.h	16;"	d
ZOLOTAREV_INTERNAL	lib/algorithms/approx/Zolotarev.cc	30;"	d	file:
ZOLOTAREV_INTERNAL	lib/algorithms/approx/Zolotarev.cc	36;"	d	file:
ZPRECISION	lib/algorithms/approx/Zolotarev.cc	33;"	d	file:
ZPRECISION	lib/algorithms/approx/Zolotarev.cc	34;"	d	file:
ZPRECISION	lib/algorithms/approx/Zolotarev.h	15;"	d
ZP_PROJ	lib/qcd/action/fermion/WilsonKernelsHand.cc	115;"	d	file:
ZP_PROJMEM	lib/simd/BGQQPX.h	336;"	d
ZP_PROJMEM	lib/simd/IBM_qpx.h	381;"	d
ZP_PROJMEM	lib/simd/Intel512wilson.h	220;"	d
ZP_RECON_ACCUM	lib/qcd/action/fermion/WilsonKernelsHand.cc	254;"	d	file:
ZP_RECON_ACCUM	lib/simd/BGQQPX.h	483;"	d
ZP_RECON_ACCUM	lib/simd/IBM_qpx.h	528;"	d
ZP_RECON_ACCUM	lib/simd/Intel512wilson.h	455;"	d
ZWilsonImplD	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexD, FundamentalRepresentation, CoeffComplex > ZWilsonImplD; \/\/ Double$/;"	t	namespace:Grid::QCD
ZWilsonImplDF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexD, FundamentalRepresentation, CoeffComplexHalfComms > ZWilsonImplDF; \/\/ Double$/;"	t	namespace:Grid::QCD
ZWilsonImplF	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexF, FundamentalRepresentation, CoeffComplex > ZWilsonImplF; \/\/ Float$/;"	t	namespace:Grid::QCD
ZWilsonImplFH	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplexF, FundamentalRepresentation, CoeffComplexHalfComms > ZWilsonImplFH; \/\/ Float$/;"	t	namespace:Grid::QCD
ZWilsonImplR	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplex,  FundamentalRepresentation, CoeffComplex > ZWilsonImplR; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
ZWilsonImplRL	lib/qcd/action/fermion/FermionOperatorImpl.h	/^typedef WilsonImpl<vComplex,  FundamentalRepresentation, CoeffComplexHalfComms > ZWilsonImplRL; \/\/ Real.. whichever prec$/;"	t	namespace:Grid::QCD
Zdir	lib/qcd/QCD.h	/^    static const int Zdir = 2;$/;"	m	namespace:Grid::QCD
Zero	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase
Zero	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Zero	lib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase
Zero	lib/simd/Simd.h	/^  class Zero{};$/;"	c	namespace:Grid
ZeroCounters	lib/qcd/action/fermion/WilsonFermion5D.cc	/^void WilsonFermion5D<Impl>::ZeroCounters(void) {$/;"	f	class:Grid::QCD::WilsonFermion5D
ZeroCounters	lib/stencil/Stencil.h	/^  void ZeroCounters(void) {$/;"	f	class:Grid::CartesianStencil
ZeroDiag	lib/Eigen/src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::UpLoType
ZeroSign	lib/Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Zm	lib/qcd/LatticeTheories.h	/^    static const int Zm = 6;$/;"	m	struct:Grid::LatticeTheories::QCD
Zm	lib/qcd/QCD.h	/^    static const int Zm = 6;$/;"	m	namespace:Grid::QCD
ZoloHiInv	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      RealD ZoloHiInv;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
Zp	lib/qcd/LatticeTheories.h	/^    static const int Zp = 2;$/;"	m	struct:Grid::LatticeTheories::QCD
Zp	lib/qcd/QCD.h	/^    static const int Zp = 2;$/;"	m	namespace:Grid::QCD
_Aggregates	tests/solver/Test_dwf_hdcr.cc	/^  Aggregates     & _Aggregates;$/;"	m	class:MultiGridPreconditioner	file:
_Arg1Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_reference<Arg1Nested>::type _Arg1Nested;$/;"	t	class:Eigen::CwiseTernaryOp
_Arg1Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_reference<Arg1Nested>::type _Arg1Nested;$/;"	t	struct:Eigen::internal::traits
_Arg2Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_reference<Arg2Nested>::type _Arg2Nested;$/;"	t	class:Eigen::CwiseTernaryOp
_Arg2Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_reference<Arg2Nested>::type _Arg2Nested;$/;"	t	struct:Eigen::internal::traits
_Arg3Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_reference<Arg3Nested>::type _Arg3Nested;$/;"	t	class:Eigen::CwiseTernaryOp
_Arg3Nested	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_reference<Arg3Nested>::type _Arg3Nested;$/;"	t	struct:Eigen::internal::traits
_CoarseOperator	tests/solver/Test_dwf_hdcr.cc	/^  CoarseOperator & _CoarseOperator;$/;"	m	class:MultiGridPreconditioner	file:
_CoarseSolver	lib/algorithms/iterative/AdefGeneric.h	/^  LinearFunction<CoarseField> *_CoarseSolver;$/;"	m	class:TwoLevelFlexiblePcg
_Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef ComplexD _Coeff_t;$/;"	t	struct:Grid::QCD::CoeffComplex
_Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef ComplexD _Coeff_t;$/;"	t	struct:Grid::QCD::CoeffComplexHalfComms
_Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef RealD  _Coeff_t ;$/;"	t	class:Grid::QCD::StaggeredImpl
_Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef RealD _Coeff_t;$/;"	t	struct:Grid::QCD::CoeffReal
_Coeff_t	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    typedef RealD _Coeff_t;$/;"	t	struct:Grid::QCD::CoeffRealHalfComms
_EIGEN_ACCUMULATE_PACKETS	lib/Eigen/src/Core/products/GeneralMatrixVector.h	100;"	d
_EIGEN_ACCUMULATE_PACKETS	lib/Eigen/src/Core/products/GeneralMatrixVector.h	321;"	d
_EIGEN_ACCUMULATE_PACKETS	lib/Eigen/src/Core/products/GeneralMatrixVector.h	377;"	d
_EIGEN_ACCUMULATE_PACKETS	lib/Eigen/src/Core/products/GeneralMatrixVector.h	612;"	d
_EIGEN_ALIGNED_PTR	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	93;"	d
_EIGEN_ALIGNED_PTR	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	103;"	d
_EIGEN_DECLARE_CONST_FAST_Packet2d	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	67;"	d
_EIGEN_DECLARE_CONST_FAST_Packet2l	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	70;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4f	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	44;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	47;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	64;"	d
_EIGEN_DECLARE_CONST_Packet16f	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	20;"	d
_EIGEN_DECLARE_CONST_Packet16f_FROM_INT	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	23;"	d
_EIGEN_DECLARE_CONST_Packet2d	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	56;"	d
_EIGEN_DECLARE_CONST_Packet2d	lib/Eigen/src/Core/arch/SSE/PacketMath.h	82;"	d
_EIGEN_DECLARE_CONST_Packet2d	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	76;"	d
_EIGEN_DECLARE_CONST_Packet2l	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	59;"	d
_EIGEN_DECLARE_CONST_Packet2l	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	79;"	d
_EIGEN_DECLARE_CONST_Packet4d	lib/Eigen/src/Core/arch/AVX/PacketMath.h	42;"	d
_EIGEN_DECLARE_CONST_Packet4f	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	50;"	d
_EIGEN_DECLARE_CONST_Packet4f	lib/Eigen/src/Core/arch/NEON/PacketMath.h	45;"	d
_EIGEN_DECLARE_CONST_Packet4f	lib/Eigen/src/Core/arch/SSE/PacketMath.h	79;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	62;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	lib/Eigen/src/Core/arch/NEON/PacketMath.h	48;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	lib/Eigen/src/Core/arch/SSE/PacketMath.h	85;"	d
_EIGEN_DECLARE_CONST_Packet4i	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	53;"	d
_EIGEN_DECLARE_CONST_Packet4i	lib/Eigen/src/Core/arch/NEON/PacketMath.h	51;"	d
_EIGEN_DECLARE_CONST_Packet4i	lib/Eigen/src/Core/arch/SSE/PacketMath.h	88;"	d
_EIGEN_DECLARE_CONST_Packet4i	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	73;"	d
_EIGEN_DECLARE_CONST_Packet8d	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	26;"	d
_EIGEN_DECLARE_CONST_Packet8d_FROM_INT64	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	29;"	d
_EIGEN_DECLARE_CONST_Packet8f	lib/Eigen/src/Core/arch/AVX/PacketMath.h	39;"	d
_EIGEN_DECLARE_CONST_Packet8f_FROM_INT	lib/Eigen/src/Core/arch/AVX/PacketMath.h	45;"	d
_EIGEN_DECLARE_CONST_Packet8i	lib/Eigen/src/Core/arch/AVX/PacketMath.h	48;"	d
_EIGEN_MASK_ALIGNMENT	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	88;"	d
_EIGEN_MASK_ALIGNMENT	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	90;"	d
_EIGEN_MASK_ALIGNMENT	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	101;"	d
_ExtractType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_ExtractType	lib/Eigen/src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_FineMatrix	tests/solver/Test_dwf_hdcr.cc	/^  Matrix         & _FineMatrix;$/;"	m	class:MultiGridPreconditioner	file:
_FineOperator	tests/solver/Test_dwf_hdcr.cc	/^  FineOperator   & _FineOperator;$/;"	m	class:MultiGridPreconditioner	file:
_FiveDimGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    GridBase *_FiveDimGrid;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
_FiveDimGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^    GridBase *_FiveDimGrid;$/;"	m	class:Grid::QCD::WilsonFermion5D
_FiveDimRedBlackGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    GridBase *_FiveDimRedBlackGrid;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
_FiveDimRedBlackGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^    GridBase *_FiveDimRedBlackGrid;$/;"	m	class:Grid::QCD::WilsonFermion5D
_FourDimGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    GridBase *_FourDimGrid;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
_FourDimGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^    GridBase *_FourDimGrid;$/;"	m	class:Grid::QCD::WilsonFermion5D
_FourDimRedBlackGrid	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    GridBase *_FourDimRedBlackGrid;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
_FourDimRedBlackGrid	lib/qcd/action/fermion/WilsonFermion5D.h	/^    GridBase *_FourDimRedBlackGrid;$/;"	m	class:Grid::QCD::WilsonFermion5D
_GRID_CSHIFT_COMMON_H_	lib/cshift/Cshift_common.h	29;"	d
_GRID_CSHIFT_H_	lib/cshift/Cshift.h	29;"	d
_GRID_CSHIFT_MPI_H_	lib/cshift/Cshift_mpi.h	30;"	d
_GRID_CSHIFT_NONE_H_	lib/cshift/Cshift_none.h	29;"	d
_GRID_FFT_H_	lib/algorithms/FFT.h	30;"	d
_GRID_MACRO_END_OF_ARGUMENTS_	lib/serialisation/MacroMagic.h	95;"	d
_GRID_MACRO_IF_0	lib/serialisation/MacroMagic.h	89;"	d
_GRID_MACRO_IF_0_ELSE	lib/serialisation/MacroMagic.h	92;"	d
_GRID_MACRO_IF_1	lib/serialisation/MacroMagic.h	88;"	d
_GRID_MACRO_IF_1_ELSE	lib/serialisation/MacroMagic.h	91;"	d
_GRID_MACRO_IF_ELSE	lib/serialisation/MacroMagic.h	86;"	d
_GRID_MACRO_MAP	lib/serialisation/MacroMagic.h	105;"	d
_GRID_MACRO_NOT_0	lib/serialisation/MacroMagic.h	81;"	d
_GRID_STAT_H	lib/perfmon/Stat.h	2;"	d
_HasDirectAccess	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon573
_HermitianRBSolver	lib/algorithms/iterative/SchurRedBlack.h	/^    OperatorFunction<Field> & _HermitianRBSolver;$/;"	m	class:Grid::SchurRedBlackDiagMooeeSolve
_HermitianSolver	lib/algorithms/iterative/NormalEquations.h	/^    OperatorFunction<Field> & _HermitianSolver;$/;"	m	class:Grid::NormalEquations
_Iter_cat	lib/pugixml/pugixml.cc	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_attribute_iterator&)$/;"	f	namespace:std
_Iter_cat	lib/pugixml/pugixml.cc	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_named_node_iterator&)$/;"	f	namespace:std
_Iter_cat	lib/pugixml/pugixml.cc	/^	PUGI__FN std::bidirectional_iterator_tag _Iter_cat(const pugi::xml_node_iterator&)$/;"	f	namespace:std
_KNIGHTS_LANDING_ROOTONLY	lib/perfmon/Stat.h	5;"	d
_LAPACKE_H_	lib/Eigen/src/misc/lapacke.h	37;"	d
_LebesgueReorder	lib/stencil/Lebesgue.h	/^    std::vector<IndexInteger> _LebesgueReorder;$/;"	m	class:Grid::LebesgueOrder
_Lhs	lib/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type
_LhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_LhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_LhsPacket	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_LinearAccessMask	lib/Eigen/src/Core/ProductEvaluators.h	/^    _LinearAccessMask = (MatrixType::RowsAtCompileTime==1 || MatrixType::ColsAtCompileTime==1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
_Linop	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  LinearOperatorBase<Field> &_Linop;$/;"	m	class:Grid::ImplicitlyRestartedLanczos
_MM_SELECT_EIGHT_TWO	lib/simd/Simd.h	47;"	d
_MM_SELECT_FOUR_FOUR	lib/simd/Simd.h	45;"	d
_MM_SELECT_FOUR_FOUR_STRING	lib/simd/Simd.h	46;"	d
_MM_SELECT_FOUR_TWO	lib/simd/Simd.h	48;"	d
_MM_SELECT_TWO_TWO	lib/simd/Simd.h	49;"	d
_Mat	lib/algorithms/LinearOperator.h	/^      Matrix &_Mat;$/;"	m	class:Grid::HermitianLinearOperator
_Mat	lib/algorithms/LinearOperator.h	/^      Matrix &_Mat;$/;"	m	class:Grid::MdagMLinearOperator
_Mat	lib/algorithms/LinearOperator.h	/^      Matrix &_Mat;$/;"	m	class:Grid::SchurDiagMooeeOperator
_Mat	lib/algorithms/LinearOperator.h	/^      Matrix &_Mat;$/;"	m	class:Grid::SchurDiagOneOperator
_Mat	lib/algorithms/LinearOperator.h	/^      Matrix &_Mat;$/;"	m	class:Grid::SchurDiagTwoOperator
_Mat	lib/algorithms/LinearOperator.h	/^      Matrix &_Mat;$/;"	m	class:Grid::ShiftedMdagMLinearOperator
_Mat	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    SchurDiagTwoOperator<Matrix, Field> _Mat;$/;"	m	class:Grid::SchurDiagTwoKappaOperator
_Mat	lib/qcd/action/fermion/g5HermitianLinop.h	/^  Matrix &_Mat;$/;"	m	class:Grid::QCD::Gamma5HermitianLinearOperator
_Mat	lib/qcd/action/fermion/g5HermitianLinop.h	/^  Matrix &_Mat;$/;"	m	class:Grid::QCD::Gamma5R5HermitianLinearOperator
_Matrix	lib/algorithms/iterative/NormalEquations.h	/^    SparseMatrixBase<Field> & _Matrix;$/;"	m	class:Grid::NormalEquations
_MatrixType	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase
_MatrixTypeNested	lib/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	lib/Eigen/src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	lib/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate
_MatrixTypeNested	lib/Eigen/src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	lib/Eigen/src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename SparseMatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
_MatrixTypeNested	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl
_MatrixTypeNested	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
_MatrixTypeNested	lib/Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView
_NBACKTRACE	lib/log/Log.h	149;"	d
_Nprocessors	lib/communicator/Communicator_base.h	/^  int              _Nprocessors;     \/\/ How many in all$/;"	m	class:Grid::CartesianCommunicator
_Options	lib/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Options = ((Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::sparse_eval::__anon519
_Options	lib/Eigen/src/SparseCore/SparseUtil.h	/^  enum { _Options = ((evaluator<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon520
_ResPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
_ResPacket	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_Rhs	lib/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type
_RhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_RhsNested	lib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsPacket	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_RhsPacket	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_S	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    KappaSimilarityTransform<Matrix, Field> _S;$/;"	m	class:Grid::SchurDiagTwoKappaOperator
_S	lib/qcd/hmc/integrators/Integrator.h	/^  struct _S {$/;"	s	class:Grid::QCD::Integrator
_SCHUR_DIAG_TWO_KAPPA_H	lib/qcd/action/fermion/SchurDiagTwoKappa.h	30;"	d
_STENCIL_SIMPLE_COMPRESSOR_H_	lib/stencil/SimpleCompressor.h	2;"	d
_SameTypes	lib/Eigen/src/Core/ProductEvaluators.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
_Scalar	lib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval
_Scalar	lib/Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type
_ScalarAccessOnDiag	lib/Eigen/src/Core/ProductEvaluators.h	/^    _ScalarAccessOnDiag =  !((int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
_Smoother	lib/algorithms/iterative/AdefGeneric.h	/^  OperatorFunction<Field>     *_Smoother,$/;"	m	class:TwoLevelFlexiblePcg
_SmootherMatrix	tests/solver/Test_dwf_hdcr.cc	/^  Matrix         & _SmootherMatrix;$/;"	m	class:MultiGridPreconditioner	file:
_SmootherOperator	tests/solver/Test_dwf_hdcr.cc	/^  FineOperator   & _SmootherOperator;$/;"	m	class:MultiGridPreconditioner	file:
_StorageIndex	lib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::StorageIndex _StorageIndex;$/;"	t	struct:Eigen::internal::sparse_eval
_StorageIndex	lib/Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::StorageIndex _StorageIndex;$/;"	t	struct:Eigen::internal::plain_matrix_type
_StorageOrder	lib/Eigen/src/Core/ProductEvaluators.h	/^    _StorageOrder = MatrixFlags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
_Vectorizable	lib/Eigen/src/Core/ProductEvaluators.h	/^    _Vectorizable = bool(int(MatrixFlags)&PacketAccessBit) && _SameTypes && (_ScalarAccessOnDiag || (bool(int(DiagFlags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon179
_XprTypeNested	lib/Eigen/src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
_XprTypeNested	lib/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
__DBL_EPSILON__	lib/Eigen/src/Core/util/Meta.h	170;"	d
__FLT_EPSILON__	lib/Eigen/src/Core/util/Meta.h	169;"	d
__PPC_CT	lib/simd/IBM_qpx.h	81;"	d
__SSC_MARK	lib/perfmon/PerfCount.h	70;"	d
__SSC_MARK	lib/perfmon/PerfCount.h	77;"	d
__SSC_START	lib/perfmon/PerfCount.h	72;"	d
__SSC_START	lib/perfmon/PerfCount.h	79;"	d
__SSC_STOP	lib/perfmon/PerfCount.h	71;"	d
__SSC_STOP	lib/perfmon/PerfCount.h	78;"	d
___PPC_RA	lib/simd/IBM_qpx.h	82;"	d
___PPC_RB	lib/simd/IBM_qpx.h	83;"	d
__half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^    typedef half_impl::__half __half;$/;"	t	struct:Eigen::half
__half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC __half() {}$/;"	f	struct:Eigen::half_impl::__half
__half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC __half(unsigned short raw) : x(raw) {}$/;"	f	struct:Eigen::half_impl::__half
__half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^struct __half {$/;"	s	namespace:Eigen::half_impl
__has_feature	lib/Eigen/src/Core/util/Macros.h	349;"	d
__iterator_category	lib/pugixml/pugixml.cc	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_attribute_iterator&)$/;"	f	namespace:std
__iterator_category	lib/pugixml/pugixml.cc	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_named_node_iterator&)$/;"	f	namespace:std
__iterator_category	lib/pugixml/pugixml.cc	/^	PUGI__FN std::bidirectional_iterator_tag __iterator_category(const pugi::xml_node_iterator&)$/;"	f	namespace:std
__ldg	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half __ldg(const Eigen::half* ptr) {$/;"	f
__shfl_xor	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ EIGEN_STRONG_INLINE Eigen::half __shfl_xor(Eigen::half var, int laneMask, int width=warpSize) {$/;"	f
_alloc	lib/pugixml/pugixml.cc	/^		xpath_allocator* _alloc;$/;"	m	struct:xpath_parser	file:
_around_the_world	lib/stencil/Stencil.h	/^   uint16_t _around_the_world; \/\/256 bits, 32 bytes, 1\/2 cacheline$/;"	m	struct:Grid::StencilEntry
_assign	lib/pugixml/pugixml.cc	/^	PUGI__FN void xpath_node_set::_assign(const_iterator begin_, const_iterator end_, type_t type_)$/;"	f	class:pugi::xpath_node_set
_assign	lib/pugixml/pugixml.cc	/^	PUGI__FN void xpath_variable_set::_assign(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set
_assignProduct	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularViewImpl<MatrixType,UpLo,Dense>::_assignProduct(const ProductType& prod, const Scalar& alpha, bool beta)$/;"	f	class:Eigen::TriangularViewImpl
_attr	lib/pugixml/pugixml.h	/^		xml_attribute_struct* _attr;$/;"	m	class:pugi::xml_attribute
_attribute	lib/pugixml/pugixml.h	/^		xml_attribute _attribute;$/;"	m	class:pugi::xpath_node
_axis	lib/pugixml/pugixml.cc	/^		char _axis;$/;"	m	class:xpath_ast_node	file:
_begin	lib/pugixml/pugixml.cc	/^		xpath_node* _begin;$/;"	m	class:xpath_node_set_raw	file:
_begin	lib/pugixml/pugixml.h	/^		It _begin, _end;$/;"	m	class:pugi::xml_object_range
_begin	lib/pugixml/pugixml.h	/^		xpath_node* _begin;$/;"	m	class:pugi::xpath_node_set
_bernoulli	lib/lattice/Lattice_rng.h	/^    std::vector<std::discrete_distribution<int32_t> >   _bernoulli;$/;"	m	class:Grid::GridRNGbase
_buffer	lib/pugixml/pugixml.cc	/^		const char_t* _buffer;$/;"	m	class:xpath_string	file:
_buffer	lib/pugixml/pugixml.h	/^		char_t* _buffer;$/;"	m	class:pugi::xml_document
_busy_size	lib/pugixml/pugixml.cc	/^		size_t _busy_size;$/;"	m	struct:xml_allocator	file:
_byte_offset	lib/stencil/Stencil.h	/^   uint64_t _byte_offset;$/;"	m	struct:Grid::StencilEntry
_capacity	lib/pugixml/pugixml.cc	/^		size_t _capacity;$/;"	m	class:compact_hash_table	file:
_cbgrid	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  GridBase *_cbgrid;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
_cbgrid	lib/qcd/action/fermion/WilsonFermion.h	/^  GridBase *_cbgrid;$/;"	m	class:Grid::QCD::WilsonFermion
_check_template_params	lib/Eigen/src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase
_check_template_params	lib/Eigen/src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion
_checker_board	lib/cartesian/Cartesian_red_black.h	/^    std::vector<int> _checker_board;$/;"	m	class:Grid::GridRedBlackCartesian
_checker_dim	lib/cartesian/Cartesian_red_black.h	/^    int              _checker_dim;$/;"	m	class:Grid::GridRedBlackCartesian
_checker_dim_mask	lib/cartesian/Cartesian_red_black.h	/^    std::vector<int> _checker_dim_mask;$/;"	m	class:Grid::GridRedBlackCartesian
_checkerboard	lib/stencil/Stencil.h	/^  int                               _checkerboard;$/;"	m	class:Grid::CartesianStencil
_clone	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable_set::_clone(xpath_variable* var, xpath_variable** out_result)$/;"	f	class:pugi::xpath_variable_set
_comm_buf_size	lib/stencil/Stencil.h	/^  std::vector<int>                  _comm_buf_size;$/;"	m	class:Grid::CartesianStencil
_compute	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition
_cores	lib/threads/Threads.h	/^  static int _cores;$/;"	m	class:Grid::GridThread
_cores	lib/util/Init.cc	/^int GridThread::_cores=1;$/;"	m	class:Grid::GridThread	file:
_count	lib/pugixml/pugixml.cc	/^		size_t _count;$/;"	m	class:compact_hash_table	file:
_cur	lib/pugixml/pugixml.cc	/^		const char_t* _cur;$/;"	m	class:xpath_lexer	file:
_cur_lexeme	lib/pugixml/pugixml.cc	/^		lexeme_t _cur_lexeme;$/;"	m	class:xpath_lexer	file:
_cur_lexeme_contents	lib/pugixml/pugixml.cc	/^		xpath_lexer_string _cur_lexeme_contents;$/;"	m	class:xpath_lexer	file:
_cur_lexeme_pos	lib/pugixml/pugixml.cc	/^		const char_t* _cur_lexeme_pos;$/;"	m	class:xpath_lexer	file:
_data	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Storage& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector
_data	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED const Storage& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector
_data	lib/pugixml/pugixml.cc	/^		uint16_t _data;$/;"	m	class:compact_pointer_parent	file:
_data	lib/pugixml/pugixml.cc	/^		unsigned char _data;$/;"	m	class:compact_pointer	file:
_data	lib/pugixml/pugixml.cc	/^		unsigned char _data;$/;"	m	class:compact_string	file:
_data	lib/pugixml/pugixml.cc	/^		} _data;$/;"	m	class:xpath_ast_node	typeref:union:xpath_ast_node::__anon686	file:
_data	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_struct* xml_text::_data() const$/;"	f	class:pugi::xml_text
_data	lib/pugixml/pugixml.h	/^		xpath_variable* _data[64];$/;"	m	class:pugi::xpath_variable_set
_data_new	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_struct* xml_text::_data_new()$/;"	f	class:pugi::xml_text
_depth	lib/pugixml/pugixml.h	/^		int _depth;$/;"	m	class:pugi::xml_tree_walker
_destroy	lib/pugixml/pugixml.cc	/^	PUGI__FN void xpath_variable_set::_destroy(xpath_variable* var)$/;"	f	class:pugi::xpath_variable_set
_directions	lib/stencil/Stencil.h	/^  std::vector<int>                  _directions;$/;"	m	class:Grid::CartesianStencil
_distances	lib/stencil/Stencil.h	/^  std::vector<int>                  _distances;$/;"	m	class:Grid::CartesianStencil
_end	lib/pugixml/pugixml.cc	/^		xpath_node* _end;$/;"	m	class:xpath_node_set_raw	file:
_end	lib/pugixml/pugixml.h	/^		It _begin, _end;$/;"	m	class:pugi::xml_object_range
_end	lib/pugixml/pugixml.h	/^		xpath_node* _end;$/;"	m	class:pugi::xpath_node_set
_entries	lib/stencil/Stencil.h	/^  Vector<StencilEntry>  _entries;$/;"	m	class:Grid::CartesianStencil
_eos	lib/pugixml/pugixml.cc	/^		xpath_node* _eos;$/;"	m	class:xpath_node_set_raw	file:
_error_handler	lib/pugixml/pugixml.cc	/^		jmp_buf _error_handler;$/;"	m	struct:xpath_parser	file:
_expression	lib/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
_expression	lib/Eigen/src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp
_fdimensions	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _fdimensions;\/\/ (full) Global dimensions of array prior to cb removal$/;"	m	class:Grid::GridBase
_find	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable* xpath_variable_set::_find(const char_t* name) const$/;"	f	class:pugi::xpath_variable_set
_flags	lib/pugixml/pugixml.cc	/^		unsigned char _flags;$/;"	m	class:compact_header	file:
_fsites	lib/cartesian/Cartesian_base.h	/^    int _fsites;                  \/\/ _isites*_osites = product(dimensions).$/;"	m	class:Grid::GridBase
_gaussian	lib/lattice/Lattice_rng.h	/^    std::vector<std::normal_distribution<RealD> >       _gaussian;$/;"	m	class:Grid::GridRNGbase
_gdimensions	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _gdimensions;\/\/ Global dimensions of array after cb removal$/;"	m	class:Grid::GridBase
_generators	lib/lattice/Lattice_rng.h	/^    std::vector<RngEngine>                             _generators;$/;"	m	class:Grid::GridRNGbase
_grid	lib/algorithms/CoarsenedMatrix.h	/^    GridBase *       _grid; $/;"	m	class:Grid::CoarsenedMatrix
_grid	lib/lattice/Lattice_base.h	/^    GridBase *_grid;$/;"	m	class:Grid::LatticeBase
_grid	lib/lattice/Lattice_rng.h	/^    GridBase *_grid;$/;"	m	class:Grid::GridParallelRNG
_grid	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  GridBase *_grid;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
_grid	lib/qcd/action/fermion/WilsonFermion.h	/^  GridBase *_grid;$/;"	m	class:Grid::QCD::WilsonFermion
_grid	lib/stencil/Stencil.h	/^  GridBase *                        _grid;$/;"	m	class:Grid::CartesianStencil
_grid	tests/debug/test_Grid_jacobi.cc	/^  GridBase *_grid;$/;"	m	class:LinearOperatorJacobi	file:
_grid	tests/testu01/Test_smallcrush.cc	/^  static GridBase *_grid;$/;"	m	struct:TestRNG	file:
_grid	tests/testu01/Test_smallcrush.cc	/^GridBase        *TestRNG::_grid;$/;"	m	class:TestRNG	file:
_gsites	lib/cartesian/Cartesian_base.h	/^    int _gsites;$/;"	m	class:Grid::GridBase
_hash	lib/pugixml/pugixml.cc	/^		compact_hash_table* _hash;$/;"	m	struct:xml_allocator	file:
_hyperthreads	lib/threads/Threads.h	/^  static int _hyperthreads;$/;"	m	class:Grid::GridThread
_hyperthreads	lib/util/Init.cc	/^int GridThread::_hyperthreads=1;$/;"	m	class:Grid::GridThread	file:
_impl	lib/pugixml/pugixml.h	/^		void* _impl;$/;"	m	class:pugi::xpath_query
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(Index size, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other){$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Derived& other){$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other){$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Index& val0,$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Scalar& val0,$/;"	f	class:Eigen::PlainObjectBase
_init1	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Scalar* data){$/;"	f	class:Eigen::PlainObjectBase
_init2	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_init2	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Index& val0, const Index& val1,$/;"	f	class:Eigen::PlainObjectBase
_init2	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const T0& val0, const T1& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_internal	lib/tensors/Tensor_class.h	/^  vtype _internal;$/;"	m	class:Grid::iScalar
_internal	lib/tensors/Tensor_class.h	/^  vtype _internal[N];$/;"	m	class:Grid::iVector
_internal	lib/tensors/Tensor_class.h	/^  vtype _internal[N][N];$/;"	m	class:Grid::iMatrix
_is_local	lib/stencil/Stencil.h	/^   uint16_t _is_local;$/;"	m	struct:Grid::StencilEntry
_isites	lib/cartesian/Cartesian_base.h	/^    int _isites;$/;"	m	class:Grid::GridBase
_istride	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _istride;    \/\/ Inner stride i.e. within simd lane$/;"	m	class:Grid::GridBase
_items	lib/pugixml/pugixml.cc	/^		item_t* _items;$/;"	m	class:compact_hash_table	file:
_json	lib/json/json.hpp	/^inline nlohmann::json operator "" _json(const char* s, std::size_t n)$/;"	f
_json_pointer	lib/json/json.hpp	/^inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)$/;"	f
_k	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    uint64_t _k[4];             \/\/ key$/;"	m	class:sitmo::prng_engine
_ldimensions	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _ldimensions;\/\/ local dimensions of array with processor images removed$/;"	m	class:Grid::GridBase
_left	lib/pugixml/pugixml.cc	/^		xpath_ast_node* _left;$/;"	m	class:xpath_ast_node	file:
_lend	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _lend  ;     \/\/ local end of array in gcoors   _processor_coor[d]*_ldimensions[d]+_ldimensions_[d]-1$/;"	m	class:Grid::GridBase
_length_heap	lib/pugixml/pugixml.cc	/^		size_t _length_heap;$/;"	m	class:xpath_string	file:
_lexer	lib/pugixml/pugixml.cc	/^		xpath_lexer _lexer;$/;"	m	struct:xpath_parser	file:
_lstart	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _lstart;     \/\/ local start of array in gcoors _processor_coor[d]*_ldimensions[d]$/;"	m	class:Grid::GridBase
_memory	lib/pugixml/pugixml.h	/^		char _memory[192];$/;"	m	class:pugi::xml_document
_mm256_alignr_epi32_grid	lib/simd/Grid_avx.h	565;"	d
_mm256_alignr_epi32_grid	lib/simd/Grid_avx.h	570;"	d
_mm256_alignr_epi64_grid	lib/simd/Grid_avx.h	566;"	d
_mm256_alignr_epi64_grid	lib/simd/Grid_avx.h	584;"	d
_mm256_set_m128i	lib/simd/Grid_avx.h	38;"	d
_move	lib/pugixml/pugixml.cc	/^	PUGI__FN void xpath_node_set::_move(xpath_node_set& rhs)$/;"	f	class:pugi::xpath_node_set
_my_alignr_epi32	lib/simd/Grid_sse4.h	332;"	d
_my_alignr_epi64	lib/simd/Grid_sse4.h	333;"	d
_name	lib/pugixml/pugixml.h	/^		const char_t* _name;$/;"	m	class:pugi::xml_named_node_iterator
_ndimension	lib/communicator/Communicator_base.h	/^  unsigned long _ndimension;$/;"	m	class:Grid::CartesianCommunicator
_next	lib/pugixml/pugixml.cc	/^		xpath_ast_node* _next;$/;"	m	class:xpath_ast_node	file:
_next	lib/pugixml/pugixml.h	/^		xpath_variable* _next;$/;"	m	class:pugi::xpath_variable
_node	lib/pugixml/pugixml.h	/^		xml_node _node;$/;"	m	class:pugi::xpath_node
_npoints	lib/stencil/Stencil.h	/^  int                               _npoints; \/\/ Move to template param?$/;"	m	class:Grid::CartesianStencil
_o	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    uint64_t _o[4];             \/\/ cipher output    4 * 64 bit = 256 bit output$/;"	m	class:sitmo::prng_engine
_o_counter	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    unsigned short _o_counter;  \/\/ output chunk counter, the 256 random bits in _o $/;"	m	class:sitmo::prng_engine
_odata	lib/lattice/Lattice_base.h	/^    Vector<vobj> _odata;$/;"	m	class:Grid::Lattice
_offset	lib/stencil/Stencil.h	/^   uint64_t _offset;$/;"	m	struct:Grid::StencilEntry
_osites	lib/cartesian/Cartesian_base.h	/^    int _osites;                  \/\/ _isites*_osites = product(dimensions).$/;"	m	class:Grid::GridBase
_ostride	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _ostride;    \/\/ Outer stride for each dimension$/;"	m	class:Grid::GridBase
_pad	lib/stencil/Stencil.h	/^   uint16_t _pad;$/;"	m	struct:Grid::StencilEntry
_page	lib/pugixml/pugixml.cc	/^		unsigned char _page;$/;"	m	class:compact_header	file:
_parent	lib/pugixml/pugixml.h	/^		xml_node _parent;$/;"	m	class:pugi::xml_attribute_iterator
_parent	lib/pugixml/pugixml.h	/^		xml_node _parent;$/;"	m	class:pugi::xml_named_node_iterator
_parent	lib/pugixml/pugixml.h	/^		xml_node _parent;$/;"	m	class:pugi::xml_node_iterator
_permute	lib/stencil/Stencil.h	/^   uint16_t _permute;$/;"	m	struct:Grid::StencilEntry
_permute_type	lib/stencil/Stencil.h	/^  std::vector<int>                  _permute_type;$/;"	m	class:Grid::CartesianStencil
_poly	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^    OperatorFunction<Field> &_poly;$/;"	m	class:Grid::ImplicitlyRestartedLanczos
_processor	lib/communicator/Communicator_base.h	/^  int              _processor;       \/\/ linear processor rank$/;"	m	class:Grid::CartesianCommunicator
_processor_coor	lib/communicator/Communicator_base.h	/^  std::vector<int> _processor_coor;  \/\/ linear processor coordinate$/;"	m	class:Grid::CartesianCommunicator
_processors	lib/communicator/Communicator_base.h	/^  std::vector<int> _processors;      \/\/ Which dimensions get relayed out over processors lanes.$/;"	m	class:Grid::CartesianCommunicator
_query	lib/pugixml/pugixml.cc	/^		const char_t* _query;$/;"	m	struct:xpath_parser	file:
_rdimensions	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _rdimensions;\/\/ Reduced local dimensions with simd lane images and processor images removed $/;"	m	class:Grid::GridBase
_refresh	lib/qcd/hmc/integrators/Integrator.h	/^  struct _refresh {$/;"	s	class:Grid::QCD::Integrator
_resize_to_match	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_result	lib/pugixml/pugixml.cc	/^		xpath_parse_result* _result;$/;"	m	struct:xpath_parser	file:
_result	lib/pugixml/pugixml.h	/^		xpath_parse_result _result;$/;"	m	class:pugi::xpath_exception
_result	lib/pugixml/pugixml.h	/^		xpath_parse_result _result;$/;"	m	class:pugi::xpath_query
_rettype	lib/pugixml/pugixml.cc	/^		char _rettype;$/;"	m	class:xpath_ast_node	file:
_right	lib/pugixml/pugixml.cc	/^		xpath_ast_node* _right;$/;"	m	class:xpath_ast_node	file:
_root	lib/pugixml/pugixml.cc	/^		xml_memory_page* _root;$/;"	m	struct:xml_allocator	file:
_root	lib/pugixml/pugixml.cc	/^		xpath_memory_block* _root;$/;"	m	class:xpath_allocator	file:
_root	lib/pugixml/pugixml.h	/^		xml_node_struct* _root;$/;"	m	class:pugi::xml_node
_root	lib/pugixml/pugixml.h	/^		xml_node_struct* _root;$/;"	m	class:pugi::xml_text
_root_size	lib/pugixml/pugixml.cc	/^		size_t _root_size;$/;"	m	class:xpath_allocator	file:
_s	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    uint64_t _s[4];             \/\/ state (counter)$/;"	m	class:sitmo::prng_engine
_scratch	lib/pugixml/pugixml.cc	/^		char_t _scratch[32];$/;"	m	struct:xpath_parser	file:
_set	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_set_noalias	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_shift	lib/algorithms/LinearOperator.h	/^      RealD _shift;$/;"	m	class:Grid::ShiftedMdagMLinearOperator
_simd_layout	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _simd_layout;\/\/ Which dimensions get relayed out over simd lanes.$/;"	m	class:Grid::GridBase
_slice_block	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _slice_block;\/\/ subslice information$/;"	m	class:Grid::GridBase
_slice_nblock	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _slice_nblock;$/;"	m	class:Grid::GridBase
_slice_stride	lib/cartesian/Cartesian_base.h	/^    std::vector<int> _slice_stride;$/;"	m	class:Grid::GridBase
_solve_impl	lib/Eigen/src/Cholesky/LDLT.h	/^void LDLT<_MatrixType,_UpLo>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::LDLT
_solve_impl	lib/Eigen/src/Cholesky/LLT.h	/^void LLT<_MatrixType,_UpLo>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::LLT
_solve_impl	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve_impl	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve_impl(const SparseMatrixBase<RhsDerived> &b, SparseMatrixBase<DestDerived> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve_impl	lib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void _solve_impl(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::TriangularViewImpl
_solve_impl	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner
_solve_impl	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solve_impl	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solve_impl	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void _solve_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteCholesky
_solve_impl	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT
_solve_impl	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_impl(const Rhs& b, SparseMatrixBase<DestDerived> &aDest) const$/;"	f	class:Eigen::IterativeSolverBase
_solve_impl	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const$/;"	f	class:Eigen::LeastSquaresConjugateGradient
_solve_impl	lib/Eigen/src/LU/FullPivLU.h	/^void FullPivLU<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::FullPivLU
_solve_impl	lib/Eigen/src/LU/PartialPivLU.h	/^    void _solve_impl(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::PartialPivLU
_solve_impl	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase
_solve_impl	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^void PardisoImpl<Derived>::_solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl
_solve_impl	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^void ColPivHouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::ColPivHouseholderQR
_solve_impl	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^void CompleteOrthogonalDecomposition<_MatrixType>::_solve_impl($/;"	f	class:Eigen::CompleteOrthogonalDecomposition
_solve_impl	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^void FullPivHouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::FullPivHouseholderQR
_solve_impl	lib/Eigen/src/QR/HouseholderQR.h	/^void HouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::HouseholderQR
_solve_impl	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SPQR
_solve_impl	lib/Eigen/src/SVD/SVDBase.h	/^void SVDBase<Derived>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::SVDBase
_solve_impl	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky
_solve_impl	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase
_solve_impl	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const SparseMatrixBase<Rhs> &b, SparseMatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky
_solve_impl	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const SparseMatrixBase<Rhs> &b, SparseMatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase
_solve_impl	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    void _solve_impl(const SparseMatrixBase<Rhs> &b, SparseMatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SparseSolverBase
_solve_impl	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE void _solve_impl(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::TriangularViewImpl
_solve_impl	lib/Eigen/src/SparseLU/SparseLU.h	/^    bool _solve_impl(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const$/;"	f	class:Eigen::SparseLU
_solve_impl	lib/Eigen/src/SparseQR/SparseQR.h	/^    bool _solve_impl(const MatrixBase<Rhs> &B, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SparseQR
_solve_impl	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU
_solve_impl	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU
_solve_impl	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU
_solve_impl_transposed	lib/Eigen/src/LU/FullPivLU.h	/^void FullPivLU<_MatrixType>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::FullPivLU
_solve_impl_transposed	lib/Eigen/src/LU/PartialPivLU.h	/^    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::PartialPivLU
_solve_with_guess_impl	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solve_with_guess_impl	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solve_with_guess_impl	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::LeastSquaresConjugateGradient
_sort	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^           SortEigen<Field> _sort;$/;"	m	class:Grid::ImplicitlyRestartedLanczos
_sort_matrix_Q	lib/Eigen/src/SparseQR/SparseQR.h	/^    inline void _sort_matrix_Q()$/;"	f	class:Eigen::SparseQR
_state	lib/pugixml/pugixml.cc	/^		xpath_allocator _state;$/;"	m	struct:xpath_allocator_capture	file:
_storage	lib/pugixml/pugixml.h	/^		xpath_node _storage;$/;"	m	class:pugi::xpath_node_set
_swap	lib/pugixml/pugixml.cc	/^	PUGI__FN void xpath_variable_set::_swap(xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set
_target	lib/pugixml/pugixml.cc	/^		xpath_allocator* _target;$/;"	m	struct:xpath_allocator_capture	file:
_test	lib/pugixml/pugixml.cc	/^		char _test;$/;"	m	class:xpath_ast_node	file:
_threads	lib/threads/Threads.h	/^  static int _threads;$/;"	m	class:Grid::GridThread
_threads	lib/util/Init.cc	/^int GridThread::_threads =1;$/;"	m	class:Grid::GridThread	file:
_time_counter	lib/lattice/Lattice_rng.h	/^    double _time_counter;$/;"	m	class:Grid::GridParallelRNG
_tmp	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  FermionField _tmp;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
_tmp	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      FermionField _tmp;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
_tmp	lib/qcd/action/fermion/WilsonFermion.h	/^  FermionField _tmp;$/;"	m	class:Grid::QCD::WilsonFermion
_tmp	lib/qcd/action/fermion/WilsonFermion5D.h	/^     FermionField _tmp;$/;"	m	class:Grid::QCD::WilsonFermion5D
_transformVector	lib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(const Vector3& v) const$/;"	f	class:Eigen::QuaternionBase
_transformVector	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase
_type	lib/pugixml/pugixml.cc	/^		char _type;$/;"	m	class:xpath_ast_node	file:
_type	lib/pugixml/pugixml.cc	/^		xpath_node_set::type_t _type;$/;"	m	class:xpath_node_set_raw	file:
_type	lib/pugixml/pugixml.h	/^		type_t _type;$/;"	m	class:pugi::xpath_node_set
_type	lib/pugixml/pugixml.h	/^		xpath_value_type _type;$/;"	m	class:pugi::xpath_variable
_uid	lib/lattice/Lattice_rng.h	/^    std::vector<std::uniform_int_distribution<uint32_t> > _uid;$/;"	m	class:Grid::GridRNGbase
_unified_buffer_size	lib/stencil/Stencil.h	/^  int _unified_buffer_size;$/;"	m	class:Grid::CartesianStencil
_uniform	lib/lattice/Lattice_rng.h	/^    std::vector<std::uniform_real_distribution<RealD> > _uniform;$/;"	m	class:Grid::GridRNGbase
_updateP	lib/qcd/hmc/integrators/Integrator.h	/^  struct _updateP {$/;"	s	class:Grid::QCD::Integrator
_uses_heap	lib/pugixml/pugixml.cc	/^		bool _uses_heap;$/;"	m	class:xpath_string	file:
_variables	lib/pugixml/pugixml.cc	/^		xpath_variable_set* _variables;$/;"	m	struct:xpath_parser	file:
_vol	lib/lattice/Lattice_rng.h	/^    unsigned int _vol;$/;"	m	class:Grid::GridParallelRNG
_wrap	lib/pugixml/pugixml.h	/^		mutable xml_attribute _wrap;$/;"	m	class:pugi::xml_attribute_iterator
_wrap	lib/pugixml/pugixml.h	/^		mutable xml_node _wrap;$/;"	m	class:pugi::xml_named_node_iterator
_wrap	lib/pugixml/pugixml.h	/^		mutable xml_node _wrap;$/;"	m	class:pugi::xml_node_iterator
a	lib/Eigen/src/Core/util/Meta.h	/^  struct no  {int a[2];};$/;"	m	struct:Eigen::internal::is_convertible_impl::no
a	lib/Eigen/src/Core/util/Meta.h	/^  struct yes {int a[1];};$/;"	m	struct:Eigen::internal::is_convertible_impl::yes
a	lib/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none
a	lib/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type
a	lib/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result
a	lib/Eigen/src/Core/util/Meta.h	/^struct meta_no  { char a[2]; };$/;"	m	struct:Eigen::internal::meta_no
a	lib/Eigen/src/Core/util/Meta.h	/^struct meta_yes { char a[1]; };$/;"	m	struct:Eigen::internal::meta_yes
a	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct no  {int a[2];};$/;"	m	struct:Eigen::internal::is_ref_compatible_impl::no
a	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct yes {int a[1];};$/;"	m	struct:Eigen::internal::is_ref_compatible_impl::yes
a	lib/Eigen/src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon615
a	lib/algorithms/approx/Remez.h	/^  bigfloat *a;$/;"	m	class:AlgRemez
a	lib/algorithms/approx/Zolotarev.h	/^  ZPRECISION *a,      \/* zeros of numerator, a[0 .. dn-1] *\/$/;"	m	struct:Grid::Approx::__anon695
a_length	lib/algorithms/approx/Remez.h	/^  int a_length;$/;"	m	class:AlgRemez
a_power	lib/algorithms/approx/Remez.h	/^  int *a_power;$/;"	m	class:AlgRemez
abs	lib/Eigen/src/Core/MathFunctions.h	/^double      abs(double      x) { return (fabs(x));  }$/;"	f	namespace:Eigen
abs	lib/Eigen/src/Core/MathFunctions.h	/^double abs(const double &x) { return ::fabs(x); }$/;"	f	namespace:Eigen::numext
abs	lib/Eigen/src/Core/MathFunctions.h	/^double abs(const std::complex<double>& x) {$/;"	f	namespace:Eigen::numext
abs	lib/Eigen/src/Core/MathFunctions.h	/^float       abs(float       x) { return (fabsf(x)); }$/;"	f	namespace:Eigen
abs	lib/Eigen/src/Core/MathFunctions.h	/^float abs(const float &x) { return ::fabsf(x); }$/;"	f	namespace:Eigen::numext
abs	lib/Eigen/src/Core/MathFunctions.h	/^float abs(const std::complex<float>& x) {$/;"	f	namespace:Eigen::numext
abs	lib/Eigen/src/Core/MathFunctions.h	/^long        abs(long        x) { return (labs(x));  }$/;"	f	namespace:Eigen
abs	lib/Eigen/src/Core/MathFunctions.h	/^long double abs(long double x) { return (fabsl(x)); }$/;"	f	namespace:Eigen
abs	lib/Eigen/src/Core/MathFunctions.h	/^typename NumTraits<T>::Real abs(const T &x) {$/;"	f	namespace:Eigen::numext
abs	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half abs(const half& a) {$/;"	f	namespace:Eigen::half_impl
abs	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs() const$/;"	f
abs	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> abs(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
abs2	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::numext
abs2	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs2() const$/;"	f
abs2_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
abs2_impl_default	lib/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl_default$/;"	s	namespace:Eigen::internal
abs2_impl_default	lib/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl_default<Scalar, true> \/\/ IsComplex$/;"	s	namespace:Eigen::internal
abs2_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
absDeterminant	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
absDeterminant	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^CompleteOrthogonalDecomposition<MatrixType>::absDeterminant() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
absDeterminant	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
absDeterminant	lib/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR
absDeterminant	lib/Eigen/src/SparseLU/SparseLU.h	/^    Scalar absDeterminant()$/;"	f	class:Eigen::SparseLU
absDiagIndex	lib/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
absDistance	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Scalar absDistance(const VectorType& p) const { return numext::abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane
abs_bf	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat abs_bf(const bigfloat& x){$/;"	f	class:bigfloat
abs_bf	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat abs_bf(const bigfloat& x){$/;"	f	class:bigfloat
abs_knowing_score	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar, typename=void> struct abs_knowing_score$/;"	s	namespace:Eigen::internal
abs_knowing_score	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct abs_knowing_score<Scalar, typename scalar_score_coeff_op<Scalar>::Score_is_abs>$/;"	s	namespace:Eigen::internal
ac_fn_c_find_uintX_t	configure	/^ac_fn_c_find_uintX_t ()$/;"	f
ac_fn_c_try_compile	configure	/^ac_fn_c_try_compile ()$/;"	f
ac_fn_cxx_check_decl	configure	/^ac_fn_cxx_check_decl ()$/;"	f
ac_fn_cxx_check_func	configure	/^ac_fn_cxx_check_func ()$/;"	f
ac_fn_cxx_check_header_compile	configure	/^ac_fn_cxx_check_header_compile ()$/;"	f
ac_fn_cxx_check_header_mongrel	configure	/^ac_fn_cxx_check_header_mongrel ()$/;"	f
ac_fn_cxx_check_type	configure	/^ac_fn_cxx_check_type ()$/;"	f
ac_fn_cxx_try_compile	configure	/^ac_fn_cxx_try_compile ()$/;"	f
ac_fn_cxx_try_cpp	configure	/^ac_fn_cxx_try_cpp ()$/;"	f
ac_fn_cxx_try_link	configure	/^ac_fn_cxx_try_link ()$/;"	f
ac_fn_cxx_try_run	configure	/^ac_fn_cxx_try_run ()$/;"	f
acc	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacketType& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const ResPacketHalf& c, const ResPacketHalf& alpha, ResPacketHalf& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits
acc	lib/simd/Grid_generic.h	428;"	d
acc	lib/simd/Grid_generic.h	497;"	d
accessors_level	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
accum	lib/perfmon/Stat.cc	/^void PmuStat::accum(int nthreads)$/;"	f	class:Grid::PmuStat
accumRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumRecon5m (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumRecon5m (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumRecon5m (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumRecon5m (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumRecon5p (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumRecon5p (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumRecon5p (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumRecon5p (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconTm (iVector<rtype,N> &hspin, const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconTm (iMatrix<rtype,N> &hspin, const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconTm (iScalar<rtype> &hspin, const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconTm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconTp (iVector<rtype,N> &hspin, const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconTp (iMatrix<rtype,N> &hspin, const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconTp (iScalar<rtype> &hspin, iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconTp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconXm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconXm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconXm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconXm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconXp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconXp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconXp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconXp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconYm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconYm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconYm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconYm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconYp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconYp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconYp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconYp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconZm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconZm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconZm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconZm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void accumReconZp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void accumReconZp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
accumReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void accumReconZp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
accumReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void accumReconZp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
accumulate	lib/serialisation/BaseIO.h	/^  void Flatten<V>::accumulate(const Element &e)$/;"	f	class:Grid::Flatten
accumulate	lib/serialisation/BaseIO.h	/^  void Flatten<V>::accumulate(const W &v)$/;"	f	class:Grid::Flatten
accumulateDim	lib/serialisation/BaseIO.h	/^  void Flatten<V>::accumulateDim(const Element &e) {};$/;"	f	class:Grid::Flatten
accumulateDim	lib/serialisation/BaseIO.h	/^  void Flatten<V>::accumulateDim(const W &v)$/;"	f	class:Grid::Flatten
accumulator	lib/perfmon/Timer.h	/^  GridUsecs accumulator;$/;"	m	class:Grid::GridStopWatch
acos	lib/Eigen/src/Core/MathFunctions.h	/^T acos(const T &x) {$/;"	f	namespace:Eigen::numext
acos	lib/Eigen/src/Core/MathFunctions.h	/^double acos(const double &x) { return ::acos(x); }$/;"	f	namespace:Eigen::numext
acos	lib/Eigen/src/Core/MathFunctions.h	/^float acos(const float &x) { return ::acosf(x); }$/;"	f	namespace:Eigen::numext
acos	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^acos() const$/;"	f
acos	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> acos(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(R& ){};$/;"	f	class:Grid::ActionModuleBase
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::OneFlavourEOFModule
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::OneFlavourFModule
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::OneFlavourRatioEOFModule
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::OneFlavourRatioFModule
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::TwoFlavourEOFModule
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::TwoFlavourFModule
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::TwoFlavourRatioEOFModule
acquireResource	lib/qcd/modules/ActionModules.h	/^  virtual void acquireResource(typename Base::Resource& GridMod){$/;"	f	class:Grid::QCD::TwoFlavourRatioFModule
action_collection	lib/qcd/action/ActionSet.h	/^  typedef typename AccessTypes<Action, Repr>::VectorCollection action_collection;$/;"	t	struct:Grid::QCD::ActionLevel
action_hirep_types	lib/qcd/action/ActionSet.h	/^  typedef typename  AccessTypes<Action, Repr>::FieldTypeCollection action_hirep_types;$/;"	t	struct:Grid::QCD::ActionLevel
action_name	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual std::string action_name(){return "DBW2GaugeAction";}$/;"	f	class:Grid::QCD::DBW2GaugeAction
action_name	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual std::string action_name(){return "IwasakiGaugeAction";}$/;"	f	class:Grid::QCD::IwasakiGaugeAction
action_name	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual std::string action_name(){return "PlaqPlusRectangleAction";}$/;"	f	class:Grid::QCD::PlaqPlusRectangleAction
action_name	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual std::string action_name(){return "RBCGaugeAction";}$/;"	f	class:Grid::QCD::RBCGaugeAction
action_name	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual std::string action_name(){return "SymanzikGaugeAction";}$/;"	f	class:Grid::QCD::SymanzikGaugeAction
action_name	lib/qcd/action/gauge/WilsonGaugeAction.h	/^  virtual std::string action_name() {return "WilsonGaugeAction";}$/;"	f	class:Grid::QCD::WilsonGaugeAction
action_name	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  virtual std::string action_name(){return "OneFlavourEvenOddRationalPseudoFermionAction";}$/;"	f	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
action_name	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      virtual std::string action_name(){return "OneFlavourEvenOddRatioRationalPseudoFermionAction";}$/;"	f	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
action_name	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      virtual std::string action_name(){return "OneFlavourRationalPseudoFermionAction";}$/;"	f	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
action_name	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      virtual std::string action_name(){return "OneFlavourRatioRationalPseudoFermionAction";}$/;"	f	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
action_name	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  virtual std::string action_name(){return "TwoFlavourPseudoFermionAction";}$/;"	f	class:Grid::QCD::TwoFlavourPseudoFermionAction
action_name	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      virtual std::string action_name(){return "TwoFlavourEvenOddPseudoFermionAction";}$/;"	f	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
action_name	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      virtual std::string action_name(){return "TwoFlavourEvenOddRatioPseudoFermionAction";}$/;"	f	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
action_name	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      virtual std::string action_name(){return "TwoFlavourRatioPseudoFermionAction";}$/;"	f	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
action_name	lib/qcd/action/scalar/ScalarAction.h	/^    virtual std::string action_name() {return "ScalarAction";}$/;"	f	class:Grid::ScalarAction
action_name	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    virtual std::string action_name() {return "ScalarAction";}$/;"	f	class:Grid::ScalarInteractionAction
actions	lib/qcd/action/ActionSet.h	/^  std::vector<ActPtr>& actions;$/;"	m	struct:Grid::QCD::ActionLevel
actions_hirep	lib/qcd/action/ActionSet.h	/^  action_collection actions_hirep;$/;"	m	struct:Grid::QCD::ActionLevel
active	lib/log/Log.h	/^  int active;$/;"	m	class:Grid::Logger
actual_alignment	lib/Eigen/src/Core/Matrix.h	/^      actual_alignment = ((_Options&DontAlign)==0) ? default_alignment : 0,$/;"	e	enum:Eigen::internal::traits::__anon171
add	benchmarks/simple_simd_test.cc	/^Grid::vRealD add(const Grid::vRealD &x, const Grid::vRealD &y)$/;"	f
add	lib/Eigen/src/Core/ProductEvaluators.h	/^  struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	s	struct:Eigen::internal::generic_product_impl
add	lib/lattice/Lattice_arith.h	/^    void add(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
add	lib/lattice/Lattice_arith.h	/^    void add(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const obj3 &rhs){$/;"	f	namespace:Grid
add	lib/lattice/Lattice_arith.h	/^    void add(Lattice<obj1> &ret,const obj2 &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
add	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable* xpath_variable_set::add(const char_t* name, xpath_value_type type)$/;"	f	class:pugi::xpath_variable_set
add	lib/simd/Grid_vector_types.h	/^  friend inline void add(Grid_simd *__restrict__ y,$/;"	f	class:Grid::Grid_simd
add	lib/simd/Simd.h	/^  inline void add (ComplexD * __restrict__ y,const ComplexD * __restrict__ l,const ComplexD *__restrict__ r){ *y = (*l) + (*r);}$/;"	f	namespace:Grid
add	lib/simd/Simd.h	/^  inline void add (ComplexF * __restrict__ y,const ComplexF * __restrict__ l,const ComplexF *__restrict__ r){ *y = (*l) + (*r); }$/;"	f	namespace:Grid
add	lib/simd/Simd.h	/^  inline void add (RealD * __restrict__ y,const RealD * __restrict__ l,const RealD *__restrict__ r){ *y = (*l) + (*r);}$/;"	f	namespace:Grid
add	lib/simd/Simd.h	/^  inline void add (RealF * __restrict__ y,const RealF * __restrict__ l,const RealF *__restrict__ r){ *y = (*l) + (*r); }$/;"	f	namespace:Grid
add	lib/tensors/Tensor_arith_add.h	/^  template<class vtype,class ltype,class rtype, int N> strong_inline  void add(iMatrix<vtype,N> * __restrict__ ret,$/;"	f	namespace:Grid
add	lib/tensors/Tensor_arith_add.h	/^  template<class vtype,class ltype,class rtype,int N> strong_inline void add(iVector<vtype,N> * __restrict__ ret,$/;"	f	namespace:Grid
add	lib/tensors/Tensor_arith_add.h	/^  template<class vtype,class ltype,class rtype> strong_inline void add(iScalar<vtype> * __restrict__ ret,$/;"	f	namespace:Grid
addEdge	extras/Hadrons/Graph.hpp	/^void Graph<T>::addEdge(const Edge &e)$/;"	f	class:Graph
addEdge	extras/Hadrons/Graph.hpp	/^void Graph<T>::addEdge(const T &start, const T &end)$/;"	f	class:Graph
addEdge	lib/Hadrons/Graph.hpp	/^void Graph<T>::addEdge(const Edge &e)$/;"	f	class:Graph
addEdge	lib/Hadrons/Graph.hpp	/^void Graph<T>::addEdge(const T &start, const T &end)$/;"	f	class:Graph
addObject	extras/Hadrons/Environment.cc	/^void Environment::addObject(const std::string name, const int moduleAddress)$/;"	f	class:Environment
addObject	lib/Hadrons/Environment.cc	/^void Environment::addObject(const std::string name, const int moduleAddress)$/;"	f	class:Environment
addOwnership	extras/Hadrons/Environment.cc	/^void Environment::addOwnership(const std::string owner,$/;"	f	class:Environment
addOwnership	extras/Hadrons/Environment.cc	/^void Environment::addOwnership(const unsigned int owner,$/;"	f	class:Environment
addOwnership	lib/Hadrons/Environment.cc	/^void Environment::addOwnership(const std::string owner,$/;"	f	class:Environment
addOwnership	lib/Hadrons/Environment.cc	/^void Environment::addOwnership(const unsigned int owner,$/;"	f	class:Environment
addTo	lib/Eigen/src/Core/EigenBase.h	/^  inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
addTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
addTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl_base
addTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static inline void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
addTo	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
addTo	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void addTo(Dest& dst, const ActualLhs& lhs, const Rhs& rhs, typename enable_if<is_same<typename evaluator_traits<Dest>::Shape,DenseShape>::value,int*>::type* = 0)$/;"	f	struct:Eigen::internal::generic_product_impl
addVertex	extras/Hadrons/Graph.hpp	/^void Graph<T>::addVertex(const T &value)$/;"	f	class:Graph
addVertex	lib/Hadrons/Graph.hpp	/^void Graph<T>::addVertex(const T &value)$/;"	f	class:Graph
add_assign_op	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar,typename SrcScalar> struct add_assign_op {$/;"	s	namespace:Eigen::internal
add_const	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
add_const	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type_if_arithmetic	lib/Eigen/src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
address	lib/allocator/AlignedAllocator.h	/^      void *address;$/;"	m	struct:Grid::PointerCache::__anon11
address	lib/allocator/AlignedAllocator.h	/^      void *address;$/;"	m	struct:Grid::PointerCache::__anon12
address	lib/allocator/AlignedAllocator.h	/^    pointer address(reference __x) const { return &__x; }$/;"	f	class:Grid::alignedAllocator
address	lib/allocator/AlignedAllocator.h	/^  pointer       address(reference __x)       const { return &__x; }$/;"	f	class:Grid::commAllocator
adds	lib/Eigen/src/Core/ProductEvaluators.h	/^    explicit adds(const Scalar& s) : m_scale(s) {}$/;"	f	struct:Eigen::internal::generic_product_impl::adds
adds	lib/Eigen/src/Core/ProductEvaluators.h	/^  struct adds {$/;"	s	struct:Eigen::internal::generic_product_impl
adj	lib/lattice/Lattice_reality.h	/^    template<class vobj> inline Lattice<vobj> adj(const Lattice<vobj> &lhs){$/;"	f	namespace:Grid
adj	lib/qcd/spin/Dirac.h	/^inline QCD::Gamma adj(const QCD::Gamma &g)$/;"	f	namespace:Grid
adj	lib/qcd/spin/Gamma.cc	/^const std::array<Gamma::Algebra, Gamma::nGamma> Gamma::adj = {{$/;"	m	class:Grid::QCD::Gamma	file:
adj	lib/qcd/spin/Gamma.h	/^    static const std::array<Algebra, nGamma>                     adj;$/;"	m	class:Grid::QCD::Gamma
adj	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> adj(const Grid_simd<S, V> &in) {$/;"	f	namespace:Grid
adj	lib/simd/Simd.h	/^  inline ComplexD adj(const ComplexD& r){ return(conjugate(r)); }$/;"	f	namespace:Grid
adj	lib/simd/Simd.h	/^  inline ComplexF adj(const ComplexF& r ){ return(conjugate(r)); }$/;"	f	namespace:Grid
adj	lib/simd/Simd.h	/^  inline RealD adj(const RealD  & r){ return r; }$/;"	f	namespace:Grid
adj	lib/simd/Simd.h	/^  inline RealF adj(const RealF  & r){ return r; }$/;"	f	namespace:Grid
adj	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iMatrix<vtype,N> adj(const iMatrix<vtype,N> &arg)$/;"	f	namespace:Grid
adj	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iVector<vtype,N> adj(const iVector<vtype,N>&r)$/;"	f	namespace:Grid
adj	lib/tensors/Tensor_reality.h	/^template<class vtype> inline iScalar<vtype> adj(const iScalar<vtype>&r)$/;"	f	namespace:Grid
adjoint	lib/Eigen/src/Cholesky/LDLT.h	/^    const LDLT& adjoint() const { return *this; };$/;"	f	class:Eigen::LDLT
adjoint	lib/Eigen/src/Cholesky/LLT.h	/^    const LLT& adjoint() const { return *this; };$/;"	f	class:Eigen::LLT
adjoint	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline const AdjointReturnType adjoint() const$/;"	f	class:Eigen::SelfAdjointView
adjoint	lib/Eigen/src/Core/SolverBase.h	/^    inline AdjointReturnType adjoint() const$/;"	f	class:Eigen::SolverBase
adjoint	lib/Eigen/src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase
adjoint	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline const AdjointReturnType adjoint() const$/;"	f	class:Eigen::TriangularView
adjoint	lib/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence
adjoint	lib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation
adjoint	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> adjoint() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType
adjoint	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return AdjointReturnType(transpose()); }$/;"	f	class:Eigen::SparseMatrixBase
adjoint	lib/Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> adjoint() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
adjointInPlace	lib/Eigen/src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase
aee	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> aee;    $/;"	m	class:Grid::QCD::CayleyFermion5D
aeo	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> aeo;    $/;"	m	class:Grid::QCD::CayleyFermion5D
affine	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
affine	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
ag5xpbg5y_ssp	lib/qcd/utils/LinalgUtils.h	/^void ag5xpbg5y_ssp(Lattice<vobj> &z,Coeff a,const Lattice<vobj> &x,Coeff b,const Lattice<vobj> &y,int s,int sp)$/;"	f	namespace:Grid::QCD
ag5xpby_ssp	lib/qcd/utils/LinalgUtils.h	/^void ag5xpby_ssp(Lattice<vobj> &z,Coeff a,const Lattice<vobj> &x,Coeff b,const Lattice<vobj> &y,int s,int sp)$/;"	f	namespace:Grid::QCD
aix_post_process_depfile	depcomp	/^aix_post_process_depfile ()$/;"	f
aligned	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC bool aligned(Index i) const {$/;"	f	class:Eigen::internal::BlasVectorMapper
alignedAllocator	lib/allocator/AlignedAllocator.h	/^    alignedAllocator() throw() {}$/;"	f	class:Grid::alignedAllocator
alignedAllocator	lib/allocator/AlignedAllocator.h	/^    alignedAllocator(const alignedAllocator &) throw() {}$/;"	f	class:Grid::alignedAllocator
alignedAllocator	lib/allocator/AlignedAllocator.h	/^    alignedAllocator(const alignedAllocator<_Tp1> &) throw() {}$/;"	f	class:Grid::alignedAllocator
alignedAllocator	lib/allocator/AlignedAllocator.h	/^  class alignedAllocator$/;"	c	namespace:Grid
aligned_allocator	lib/Eigen/src/Core/util/Memory.h	/^  aligned_allocator() : std::allocator<T>() {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	lib/Eigen/src/Core/util/Memory.h	/^  aligned_allocator(const aligned_allocator& other) : std::allocator<T>(other) {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	lib/Eigen/src/Core/util/Memory.h	/^  aligned_allocator(const aligned_allocator<U>& other) : std::allocator<T>(other) {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	lib/Eigen/src/Core/util/Memory.h	/^class aligned_allocator : public std::allocator<T>$/;"	c	namespace:Eigen
aligned_allocator_indirection	lib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	lib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	lib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	lib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	lib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	lib/Eigen/src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen
aligned_delete	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline void aligned_delete(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
aligned_free	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
aligned_malloc	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline void* aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal
aligned_new	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline T* aligned_new(std::size_t size)$/;"	f	namespace:Eigen::internal
aligned_realloc	lib/Eigen/src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
aligned_stack_memory_handler	lib/Eigen/src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, std::size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
aligned_stack_memory_handler	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler : noncopyable$/;"	c	namespace:Eigen::internal
alignment	lib/Eigen/src/Core/Redux.h	/^    alignment = Derived::Alignment$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon123
alignment	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon306
alignment	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon304
alignment	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon299
alignment	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon298
alignment	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon300
alignment	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon354
alignment	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon356
alignment	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 8, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon355
alignment	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon329
alignment	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon327
alignment	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon325
alignment	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon322
alignment	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon323
alignment	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon266
alignment	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon265
alignment	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon260
alignment	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon290
alignment	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon288
alignment	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon286
alignment	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon283
alignment	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon284
alignment	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon348
alignment	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon346
alignment	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon337
alignment	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon336
alignment	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon338
alignment	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon319
alignment	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon318
alignment	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon314
alignment	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon313
alignment	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon312
alignment	lib/pugixml/pugixml.cc	/^			double alignment;$/;"	m	union:xpath_memory_block::__anon685	file:
alignup	lib/stencil/Lebesgue.cc	/^LebesgueOrder::IndexInteger LebesgueOrder::alignup(IndexInteger n){$/;"	f	class:Grid::LebesgueOrder
all	lib/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase
all	lib/Eigen/src/Core/VectorwiseOp.h	/^    const AllReturnType all() const$/;"	f	class:Eigen::VectorwiseOp
allFinite	lib/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::allFinite() const$/;"	f	class:Eigen::DenseBase
allTopoSort	extras/Hadrons/Graph.hpp	/^std::vector<std::vector<T>> Graph<T>::allTopoSort(void)$/;"	f	class:Graph
allTopoSort	lib/Hadrons/Graph.hpp	/^std::vector<std::vector<T>> Graph<T>::allTopoSort(void)$/;"	f	class:Graph
all_unroller	lib/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
all_unroller	lib/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
all_unroller	lib/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
alloc	lib/algorithms/approx/Remez.h	/^  int alloc;$/;"	m	class:AlgRemez
alloc	lib/pugixml/pugixml.cc	/^		xml_allocator alloc;$/;"	m	struct:xml_parser	file:
alloc	lib/pugixml/pugixml.cc	/^		xpath_allocator alloc;$/;"	m	struct:xpath_query_impl	file:
alloc_node	lib/pugixml/pugixml.cc	/^		void* alloc_node()$/;"	f	struct:xpath_parser
alloc_state	lib/pugixml/pugixml.cc	/^		xml_allocator* alloc_state;$/;"	m	struct:xml_parser	file:
alloc_string	lib/pugixml/pugixml.cc	/^		const char_t* alloc_string(const xpath_lexer_string& value)$/;"	f	struct:xpath_parser
allocate	lib/Eigen/src/Core/util/Memory.h	/^  pointer allocate(size_type num, const void* \/*hint*\/ = 0)$/;"	f	class:Eigen::aligned_allocator
allocate	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::BDCSVD
allocate	lib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	lib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	lib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	lib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	lib/Eigen/src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
allocate	lib/Eigen/src/SVD/SVDBase.h	/^bool SVDBase<MatrixType>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::SVDBase
allocate	lib/algorithms/approx/Remez.cc	/^void AlgRemez::allocate(int num_degree, int den_degree)$/;"	f	class:AlgRemez
allocate	lib/allocator/AlignedAllocator.h	/^    pointer allocate(size_type __n, const void *_p = 0)$/;"	f	class:Grid::alignedAllocator
allocate	lib/allocator/AlignedAllocator.h	/^  pointer allocate(size_type __n, const void* _p= 0) $/;"	f	class:Grid::commAllocator
allocate	lib/allocator/AlignedAllocator.h	/^  pointer allocate(size_type __n, const void* _p= 0)$/;"	f	class:Grid::commAllocator
allocate	lib/pugixml/pugixml.cc	/^		static allocation_function allocate;$/;"	m	struct:xml_memory_management_function_storage	file:
allocate	lib/pugixml/pugixml.cc	/^		void* allocate(size_t size)$/;"	f	class:xpath_allocator
allocate	lib/pugixml/pugixml.cc	/^	template <typename T> allocation_function xml_memory_management_function_storage<T>::allocate = default_allocate;$/;"	m	class:xml_memory_management_function_storage	file:
allocateA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocate_attribute	lib/pugixml/pugixml.cc	/^	inline xml_attribute_struct* allocate_attribute(xml_allocator& alloc)$/;"	f
allocate_memory	lib/pugixml/pugixml.cc	/^		void* allocate_memory(size_t size, xml_memory_page*& out_page)$/;"	f	struct:xml_allocator
allocate_memory_oob	lib/pugixml/pugixml.cc	/^	PUGI__FN_NO_INLINE void* xml_allocator::allocate_memory_oob(size_t size, xml_memory_page*& out_page)$/;"	f	class:xml_allocator
allocate_node	lib/pugixml/pugixml.cc	/^	inline xml_node_struct* allocate_node(xml_allocator& alloc, xml_node_type type)$/;"	f
allocate_nothrow	lib/pugixml/pugixml.cc	/^		void* allocate_nothrow(size_t size)$/;"	f	class:xpath_allocator
allocate_object	lib/pugixml/pugixml.cc	/^		void* allocate_object(size_t size, xml_memory_page*& out_page)$/;"	f	struct:xml_allocator
allocate_page	lib/pugixml/pugixml.cc	/^		xml_memory_page* allocate_page(size_t data_size)$/;"	f	struct:xml_allocator
allocate_string	lib/pugixml/pugixml.cc	/^		char_t* allocate_string(size_t length)$/;"	f	struct:xml_allocator
allocatedSize	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage
allocated_size	lib/allocator/AlignedAllocator.h	/^    static size_t allocated_size(){$/;"	f	class:Grid::PointerCache
allocation_function	lib/pugixml/pugixml.h	/^	typedef void* (*allocation_function)(size_t size);$/;"	t	namespace:pugi
allocator	lib/pugixml/pugixml.cc	/^		xml_allocator* allocator;$/;"	m	struct:xml_memory_page	file:
allow_insert_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN bool allow_insert_attribute(xml_node_type parent)$/;"	f
allow_insert_child	lib/pugixml/pugixml.cc	/^	PUGI__FN bool allow_insert_child(xml_node_type parent, xml_node_type child)$/;"	f
allow_move	lib/pugixml/pugixml.cc	/^	PUGI__FN bool allow_move(xml_node parent, xml_node child)$/;"	f
alpha	lib/algorithms/approx/Chebyshev.h	/^    RealD alpha;$/;"	m	class:Grid::ChebyshevLanczos
alpha	lib/algorithms/approx/Zolotarev.h	/^    *alpha,	      \/* coefficients of partial fraction, alpha[0 .. da-1] *\/$/;"	m	struct:Grid::Approx::__anon695
alphas	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType alphas() const$/;"	f	class:Eigen::GeneralizedEigenSolver
always_void	lib/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
amax	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      RealD amax;$/;"	m	class:Grid::QCD::PartialFractionFermion5D
amd_flip	lib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal
amd_mark	lib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal
amd_marked	lib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal
amd_unflip	lib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal
analyzePattern	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
analyzePattern	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::DiagonalPreconditioner
analyzePattern	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
analyzePattern	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
analyzePattern	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::IncompleteCholesky
analyzePattern	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
analyzePattern	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
analyzePattern	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
analyzePattern	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
analyzePattern	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
analyzePattern	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
analyzePattern	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
analyzePattern	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
analyzePattern	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
analyzePattern	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
analyzePattern	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
analyzePattern	lib/Eigen/src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseLU
analyzePattern	lib/Eigen/src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
analyzePattern	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase
analyzePattern	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU
analyzePattern	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU
analyzePattern	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
analyzePattern_impl	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern_impl()$/;"	f	class:Eigen::UmfPackLU
analyzePattern_preordered	lib/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
anchor	lib/json/json.hpp	/^                : anchor(it)$/;"	f	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
anchor	lib/json/json.hpp	/^            IteratorType anchor;$/;"	m	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
angle	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angularDistance	lib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
any	lib/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase
any	lib/Eigen/src/Core/VectorwiseOp.h	/^    const AnyReturnType any() const$/;"	f	class:Eigen::VectorwiseOp
any	lib/pugixml/pugixml.cc	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer
any	lib/pugixml/pugixml.cc	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer
any	lib/pugixml/pugixml.cc	/^		static value_type any(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer
any_conversion	lib/Eigen/src/Core/util/Meta.h	/^  struct any_conversion$/;"	s	struct:Eigen::internal::is_convertible_impl
any_conversion	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct any_conversion$/;"	s	struct:Eigen::internal::is_ref_compatible_impl
any_unroller	lib/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
any_unroller	lib/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
any_unroller	lib/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
ap	lib/algorithms/approx/Zolotarev.h	/^    *ap,	      \/* poles (zeros of denominator), ap[0 .. dd-1] *\/$/;"	m	struct:Grid::Approx::__anon695
apend	lib/algorithms/approx/Remez.h	/^  bigfloat apstrt, apwidt, apend;$/;"	m	class:AlgRemez
append	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage
append	lib/pugixml/pugixml.cc	/^		void append(const xpath_node* begin_, const xpath_node* end_, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw
append	lib/pugixml/pugixml.cc	/^		void append(const xpath_string& o, xpath_allocator* alloc)$/;"	f	class:xpath_string
append_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::append_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node
append_attribute	lib/pugixml/pugixml.cc	/^	inline void append_attribute(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f
append_buffer	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_node::append_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_node
append_child	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::append_child(const char_t* name_)$/;"	f	class:pugi::xml_node
append_child	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::append_child(xml_node_type type_)$/;"	f	class:pugi::xml_node
append_copy	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::append_copy(const xml_attribute& proto)$/;"	f	class:pugi::xml_node
append_copy	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::append_copy(const xml_node& proto)$/;"	f	class:pugi::xml_node
append_move	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::append_move(const xml_node& moved)$/;"	f	class:pugi::xml_node
append_new_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN_NO_INLINE xml_attribute_struct* append_new_attribute(xml_node_struct* node, xml_allocator& alloc)$/;"	f
append_new_node	lib/pugixml/pugixml.cc	/^	PUGI__FN_NO_INLINE xml_node_struct* append_new_node(xml_node_struct* node, xml_allocator& alloc, xml_node_type type = node_element)$/;"	f
append_node	lib/pugixml/pugixml.cc	/^	inline void append_node(xml_node_struct* child, xml_node_struct* node)$/;"	f
apply	lib/qcd/action/ActionSet.h	/^  inline typename std::enable_if<I == std::tuple_size<action_collection>::value, void>::type apply(Callable, Repr& R,Args&...) const {}$/;"	f	struct:Grid::QCD::ActionLevel
apply	tests/Test_simd.cc	/^  template<class scal>   void apply(std::vector<scal> &r1,$/;"	f	class:funcExchange
apply	tests/Test_simd.cc	/^  template<class scal>   void apply(std::vector<scal> &rr,std::vector<scal> &in)  const { $/;"	f	class:funcPermute
apply	tests/Test_simd.cc	/^  template<class scal>   void apply(std::vector<scal> &rr,std::vector<scal> &in)  const { $/;"	f	class:funcRotate
applyHouseholderOnTheLeft	lib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase
applyHouseholderOnTheRight	lib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase
applyOnTheLeft	lib/Eigen/src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheLeft	lib/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	lib/Eigen/src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	lib/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyThisOnTheLeft	lib/Eigen/src/Core/EigenBase.h	/^  EIGEN_DEVICE_FUNC inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheLeft	lib/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheLeft	lib/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	lib/Eigen/src/Core/EigenBase.h	/^  EIGEN_DEVICE_FUNC inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheRight	lib/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	lib/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyTranspositionOnTheLeft	lib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
applyTranspositionOnTheRight	lib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
applyZAdjointOnTheLeftInPlace	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^void CompleteOrthogonalDecomposition<MatrixType>::applyZAdjointOnTheLeftInPlace($/;"	f	class:Eigen::CompleteOrthogonalDecomposition
apply_block_householder_on_the_left	lib/Eigen/src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs, bool forward)$/;"	f	namespace:Eigen::internal
apply_predicate	lib/pugixml/pugixml.cc	/^		void apply_predicate(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:
apply_predicate_boolean	lib/pugixml/pugixml.cc	/^		static void apply_predicate_boolean(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:
apply_predicate_number	lib/pugixml/pugixml.cc	/^		static void apply_predicate_number(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack, bool once)$/;"	f	class:xpath_ast_node	file:
apply_predicate_number_const	lib/pugixml/pugixml.cc	/^		static void apply_predicate_number_const(xpath_node_set_raw& ns, size_t first, xpath_ast_node* expr, const xpath_stack& stack)$/;"	f	class:xpath_ast_node	file:
apply_predicates	lib/pugixml/pugixml.cc	/^		void apply_predicates(xpath_node_set_raw& ns, size_t first, const xpath_stack& stack, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	file:
apply_rotation_in_the_plane	lib/Eigen/src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal
approx	lib/algorithms/approx/Chebyshev.h	/^    RealD approx(RealD x) \/\/ Convenience for plotting the approximation$/;"	f	class:Grid::Chebyshev
approx	lib/algorithms/approx/Chebyshev.h	/^    RealD approx(RealD xx) \/\/ Convenience for plotting the approximation$/;"	f	class:Grid::ChebyshevLanczos
approx	lib/algorithms/approx/MultiShiftFunction.cc	/^double MultiShiftFunction::approx(double x)$/;"	f	class:Grid::MultiShiftFunction
approx	lib/algorithms/approx/Remez.cc	/^bigfloat AlgRemez::approx(const bigfloat x) {$/;"	f	class:AlgRemez
apstrt	lib/algorithms/approx/Remez.h	/^  bigfloat apstrt, apwidt, apend;$/;"	m	class:AlgRemez
apwidt	lib/algorithms/approx/Remez.h	/^  bigfloat apstrt, apwidt, apend;$/;"	m	class:AlgRemez
arg	lib/Eigen/src/Core/CoreEvaluators.h	/^  const ArgType& arg() const$/;"	f	class:Eigen::internal::EvalToTemp
arg	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(arg, Scalar) arg(const Scalar& x)$/;"	f	namespace:Eigen::numext
arg	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^arg() const$/;"	f
arg1	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  const _Arg1Nested& arg1() const { return m_arg1; }$/;"	f	class:Eigen::CwiseTernaryOp
arg2	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  const _Arg2Nested& arg2() const { return m_arg2; }$/;"	f	class:Eigen::CwiseTernaryOp
arg3	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  const _Arg3Nested& arg3() const { return m_arg3; }$/;"	f	class:Eigen::CwiseTernaryOp
arg_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^  struct arg_default_impl$/;"	s	namespace:Eigen::internal
arg_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^  struct arg_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
arg_impl	lib/Eigen/src/Core/MathFunctions.h	/^  struct arg_impl {$/;"	s	namespace:Eigen::internal
arg_impl	lib/Eigen/src/Core/MathFunctions.h	/^  template<typename Scalar> struct arg_impl : arg_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
arg_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct arg_retval$/;"	s	namespace:Eigen::internal
array	lib/Eigen/src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase
array	lib/Eigen/src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase
array	lib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	lib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(32) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	lib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(64) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	lib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(8) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	lib/Eigen/src/Core/DenseStorage.h	/^  T array[1];$/;"	m	struct:Eigen::internal::plain_array
array	lib/Eigen/src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	lib/Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ArrayWrapper<Derived> array() { return ArrayWrapper<Derived>(derived()); }$/;"	f	class:Eigen::MatrixBase
array	lib/Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const ArrayWrapper<const Derived> array() const { return ArrayWrapper<const Derived>(derived()); }$/;"	f	class:Eigen::MatrixBase
array	lib/json/json.hpp	/^        array,           \/\/\/< array (ordered collection of values)$/;"	m	class:nlohmann::basic_json::value_t
array	lib/json/json.hpp	/^        array_t* array;$/;"	m	union:nlohmann::basic_json::json_value
array	lib/json/json.hpp	/^    static basic_json array(std::initializer_list<basic_json> init =$/;"	f	class:nlohmann::basic_json
array_end	lib/json/json.hpp	/^        array_end,$/;"	m	class:nlohmann::basic_json::parse_event_t
array_index	lib/json/json.hpp	/^            size_t array_index = 0;$/;"	m	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
array_iterator	lib/json/json.hpp	/^        typename array_t::iterator array_iterator;$/;"	m	struct:nlohmann::basic_json::internal_iterator
array_start	lib/json/json.hpp	/^        array_start,$/;"	m	class:nlohmann::basic_json::parse_event_t
as	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> as;    $/;"	m	class:Grid::QCD::CayleyFermion5D
as	lib/qcd/hmc/integrators/Integrator.h	/^  const ActionSet<Field, RepresentationPolicy> as;$/;"	m	class:Grid::QCD::Integrator
asDiagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase
asPermutation	lib/Eigen/src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase
asSluMatrix	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal
as_bool	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::as_bool(bool def) const$/;"	f	class:pugi::xml_attribute
as_bool	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::as_bool(bool def) const$/;"	f	class:pugi::xml_text
as_double	lib/pugixml/pugixml.cc	/^	PUGI__FN double xml_attribute::as_double(double def) const$/;"	f	class:pugi::xml_attribute
as_double	lib/pugixml/pugixml.cc	/^	PUGI__FN double xml_text::as_double(double def) const$/;"	f	class:pugi::xml_text
as_float	lib/pugixml/pugixml.cc	/^	PUGI__FN float xml_attribute::as_float(float def) const$/;"	f	class:pugi::xml_attribute
as_float	lib/pugixml/pugixml.cc	/^	PUGI__FN float xml_text::as_float(float def) const$/;"	f	class:pugi::xml_text
as_fn_append	configure	/^  as_fn_append ()$/;"	f
as_fn_arith	configure	/^  as_fn_arith ()$/;"	f
as_fn_error	configure	/^as_fn_error ()$/;"	f
as_fn_executable_p	configure	/^as_fn_executable_p ()$/;"	f
as_fn_exit	configure	/^as_fn_exit ()$/;"	f
as_fn_failure	configure	/^as_fn_failure () { as_fn_return 1; }$/;"	f
as_fn_mkdir_p	configure	/^as_fn_mkdir_p ()$/;"	f
as_fn_ret_failure	configure	/^as_fn_ret_failure () { return 1; }$/;"	f
as_fn_ret_success	configure	/^as_fn_ret_success () { return 0; }$/;"	f
as_fn_set_status	configure	/^as_fn_set_status ()$/;"	f
as_fn_success	configure	/^as_fn_success () { as_fn_return 0; }$/;"	f
as_fn_unset	configure	/^as_fn_unset ()$/;"	f
as_int	lib/pugixml/pugixml.cc	/^	PUGI__FN int xml_attribute::as_int(int def) const$/;"	f	class:pugi::xml_attribute
as_int	lib/pugixml/pugixml.cc	/^	PUGI__FN int xml_text::as_int(int def) const$/;"	f	class:pugi::xml_text
as_llong	lib/pugixml/pugixml.cc	/^	PUGI__FN long long xml_attribute::as_llong(long long def) const$/;"	f	class:pugi::xml_attribute
as_llong	lib/pugixml/pugixml.cc	/^	PUGI__FN long long xml_text::as_llong(long long def) const$/;"	f	class:pugi::xml_text
as_string	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_attribute::as_string(const char_t* def) const$/;"	f	class:pugi::xml_attribute
as_string	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_text::as_string(const char_t* def) const$/;"	f	class:pugi::xml_text
as_uint	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned int xml_attribute::as_uint(unsigned int def) const$/;"	f	class:pugi::xml_attribute
as_uint	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned int xml_text::as_uint(unsigned int def) const$/;"	f	class:pugi::xml_text
as_ullong	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned long long xml_attribute::as_ullong(unsigned long long def) const$/;"	f	class:pugi::xml_attribute
as_ullong	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned long long xml_text::as_ullong(unsigned long long def) const$/;"	f	class:pugi::xml_text
as_utf8	lib/pugixml/pugixml.cc	/^	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const std::basic_string<wchar_t>& str)$/;"	f	namespace:pugi
as_utf8	lib/pugixml/pugixml.cc	/^	PUGI__FN std::string PUGIXML_FUNCTION as_utf8(const wchar_t* str)$/;"	f	namespace:pugi
as_utf8_begin	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t as_utf8_begin(const wchar_t* str, size_t length)$/;"	f
as_utf8_end	lib/pugixml/pugixml.cc	/^	PUGI__FN void as_utf8_end(char* buffer, size_t size, const wchar_t* str, size_t length)$/;"	f
as_utf8_impl	lib/pugixml/pugixml.cc	/^	PUGI__FN std::string as_utf8_impl(const wchar_t* str, size_t length)$/;"	f
as_wide	lib/pugixml/pugixml.cc	/^	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const char* str)$/;"	f	namespace:pugi
as_wide	lib/pugixml/pugixml.cc	/^	PUGI__FN std::basic_string<wchar_t> PUGIXML_FUNCTION as_wide(const std::string& str)$/;"	f	namespace:pugi
as_wide_impl	lib/pugixml/pugixml.cc	/^	PUGI__FN std::basic_string<wchar_t> as_wide_impl(const char* str, size_t size)$/;"	f
asin	lib/Eigen/src/Core/MathFunctions.h	/^T asin(const T &x) {$/;"	f	namespace:Eigen::numext
asin	lib/Eigen/src/Core/MathFunctions.h	/^double asin(const double &x) { return ::asin(x); }$/;"	f	namespace:Eigen::numext
asin	lib/Eigen/src/Core/MathFunctions.h	/^float asin(const float &x) { return ::asinf(x); }$/;"	f	namespace:Eigen::numext
asin	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^asin() const$/;"	f
asin	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> asin(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
assert_invariant	lib/json/json.hpp	/^    void assert_invariant() const$/;"	f	class:nlohmann::basic_json
assignCoeff	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index index)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignCoeff	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignCoeff	lib/Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC void assignCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignCoeff	lib/Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC void assignCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignCoeff	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a *= b; }$/;"	f	struct:Eigen::internal::mul_assign_op
assignCoeff	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a += b; }$/;"	f	struct:Eigen::internal::add_assign_op
assignCoeff	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a -= b; }$/;"	f	struct:Eigen::internal::sub_assign_op
assignCoeff	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a = b; }$/;"	f	struct:Eigen::internal::assign_op
assignCoeff	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a \/= b; }$/;"	f	struct:Eigen::internal::div_assign_op
assignCoeff	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Scalar& a, const Scalar& b) const$/;"	f	struct:Eigen::internal::swap_assign_op
assignCoeffByOuterInner	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeffByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignDiagonalCoeff	lib/Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC void assignDiagonalCoeff(Index id)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignDiagonalCoeff	lib/Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC void assignDiagonalCoeff(Index id)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignOppositeCoeff	lib/Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC void assignOppositeCoeff(Index, Index)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignOppositeCoeff	lib/Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC void assignOppositeCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignPacket	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index index)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index row, Index col)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	lib/Eigen/src/Core/Swap.h	/^  void assignPacket(Index index)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	lib/Eigen/src/Core/Swap.h	/^  void assignPacket(Index row, Index col)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::add_assign_op
assignPacket	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::assign_op
assignPacket	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::div_assign_op
assignPacket	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::mul_assign_op
assignPacket	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::sub_assign_op
assignPacketByOuterInner	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacketByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacketByOuterInner	lib/Eigen/src/Core/Swap.h	/^  void assignPacketByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignProduct	lib/Eigen/src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase
assignTranspose	lib/Eigen/src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
assign_op	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar,typename SrcScalar> struct assign_op {$/;"	s	namespace:Eigen::internal
assign_op	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar> struct assign_op<DstScalar,void> {};$/;"	s	namespace:Eigen::internal
assign_sparse_to_sparse	lib/Eigen/src/SparseCore/SparseAssign.h	/^void assign_sparse_to_sparse(DstXprType &dst, const SrcXprType &src)$/;"	f	namespace:Eigen::internal
assignment_from_xpr_op_product	lib/Eigen/src/Core/ProductEvaluators.h	/^struct assignment_from_xpr_op_product$/;"	s	namespace:Eigen::internal
ast_filter	lib/pugixml/pugixml.cc	/^		ast_filter,						\/\/ select * from left where right$/;"	e	enum:ast_type_t	file:
ast_func_boolean	lib/pugixml/pugixml.cc	/^		ast_func_boolean,				\/\/ boolean(left)$/;"	e	enum:ast_type_t	file:
ast_func_ceiling	lib/pugixml/pugixml.cc	/^		ast_func_ceiling,				\/\/ ceiling(left)$/;"	e	enum:ast_type_t	file:
ast_func_concat	lib/pugixml/pugixml.cc	/^		ast_func_concat,				\/\/ concat(left, right, siblings)$/;"	e	enum:ast_type_t	file:
ast_func_contains	lib/pugixml/pugixml.cc	/^		ast_func_contains,				\/\/ contains(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_count	lib/pugixml/pugixml.cc	/^		ast_func_count,					\/\/ count(left)$/;"	e	enum:ast_type_t	file:
ast_func_false	lib/pugixml/pugixml.cc	/^		ast_func_false,					\/\/ false()$/;"	e	enum:ast_type_t	file:
ast_func_floor	lib/pugixml/pugixml.cc	/^		ast_func_floor,					\/\/ floor(left)$/;"	e	enum:ast_type_t	file:
ast_func_id	lib/pugixml/pugixml.cc	/^		ast_func_id,					\/\/ id(left)$/;"	e	enum:ast_type_t	file:
ast_func_lang	lib/pugixml/pugixml.cc	/^		ast_func_lang,					\/\/ lang(left)$/;"	e	enum:ast_type_t	file:
ast_func_last	lib/pugixml/pugixml.cc	/^		ast_func_last,					\/\/ last()$/;"	e	enum:ast_type_t	file:
ast_func_local_name_0	lib/pugixml/pugixml.cc	/^		ast_func_local_name_0,			\/\/ local-name()$/;"	e	enum:ast_type_t	file:
ast_func_local_name_1	lib/pugixml/pugixml.cc	/^		ast_func_local_name_1,			\/\/ local-name(left)$/;"	e	enum:ast_type_t	file:
ast_func_name_0	lib/pugixml/pugixml.cc	/^		ast_func_name_0,				\/\/ name()$/;"	e	enum:ast_type_t	file:
ast_func_name_1	lib/pugixml/pugixml.cc	/^		ast_func_name_1,				\/\/ name(left)$/;"	e	enum:ast_type_t	file:
ast_func_namespace_uri_0	lib/pugixml/pugixml.cc	/^		ast_func_namespace_uri_0,		\/\/ namespace-uri()$/;"	e	enum:ast_type_t	file:
ast_func_namespace_uri_1	lib/pugixml/pugixml.cc	/^		ast_func_namespace_uri_1,		\/\/ namespace-uri(left)$/;"	e	enum:ast_type_t	file:
ast_func_normalize_space_0	lib/pugixml/pugixml.cc	/^		ast_func_normalize_space_0,		\/\/ normalize-space()$/;"	e	enum:ast_type_t	file:
ast_func_normalize_space_1	lib/pugixml/pugixml.cc	/^		ast_func_normalize_space_1,		\/\/ normalize-space(left)$/;"	e	enum:ast_type_t	file:
ast_func_not	lib/pugixml/pugixml.cc	/^		ast_func_not,					\/\/ not(left)$/;"	e	enum:ast_type_t	file:
ast_func_number_0	lib/pugixml/pugixml.cc	/^		ast_func_number_0,				\/\/ number()$/;"	e	enum:ast_type_t	file:
ast_func_number_1	lib/pugixml/pugixml.cc	/^		ast_func_number_1,				\/\/ number(left)$/;"	e	enum:ast_type_t	file:
ast_func_position	lib/pugixml/pugixml.cc	/^		ast_func_position,				\/\/ position()$/;"	e	enum:ast_type_t	file:
ast_func_round	lib/pugixml/pugixml.cc	/^		ast_func_round,					\/\/ round(left)$/;"	e	enum:ast_type_t	file:
ast_func_starts_with	lib/pugixml/pugixml.cc	/^		ast_func_starts_with,			\/\/ starts_with(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_string_0	lib/pugixml/pugixml.cc	/^		ast_func_string_0,				\/\/ string()$/;"	e	enum:ast_type_t	file:
ast_func_string_1	lib/pugixml/pugixml.cc	/^		ast_func_string_1,				\/\/ string(left)$/;"	e	enum:ast_type_t	file:
ast_func_string_length_0	lib/pugixml/pugixml.cc	/^		ast_func_string_length_0,		\/\/ string-length()$/;"	e	enum:ast_type_t	file:
ast_func_string_length_1	lib/pugixml/pugixml.cc	/^		ast_func_string_length_1,		\/\/ string-length(left)$/;"	e	enum:ast_type_t	file:
ast_func_substring_2	lib/pugixml/pugixml.cc	/^		ast_func_substring_2,			\/\/ substring(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_substring_3	lib/pugixml/pugixml.cc	/^		ast_func_substring_3,			\/\/ substring(left, right, third)$/;"	e	enum:ast_type_t	file:
ast_func_substring_after	lib/pugixml/pugixml.cc	/^		ast_func_substring_after,		\/\/ substring-after(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_substring_before	lib/pugixml/pugixml.cc	/^		ast_func_substring_before,		\/\/ substring-before(left, right)$/;"	e	enum:ast_type_t	file:
ast_func_sum	lib/pugixml/pugixml.cc	/^		ast_func_sum,					\/\/ sum(left)$/;"	e	enum:ast_type_t	file:
ast_func_translate	lib/pugixml/pugixml.cc	/^		ast_func_translate,				\/\/ translate(left, right, third)$/;"	e	enum:ast_type_t	file:
ast_func_true	lib/pugixml/pugixml.cc	/^		ast_func_true,					\/\/ true()$/;"	e	enum:ast_type_t	file:
ast_number_constant	lib/pugixml/pugixml.cc	/^		ast_number_constant,			\/\/ number constant$/;"	e	enum:ast_type_t	file:
ast_op_add	lib/pugixml/pugixml.cc	/^		ast_op_add,						\/\/ left + right$/;"	e	enum:ast_type_t	file:
ast_op_and	lib/pugixml/pugixml.cc	/^		ast_op_and,						\/\/ left and right$/;"	e	enum:ast_type_t	file:
ast_op_divide	lib/pugixml/pugixml.cc	/^		ast_op_divide,					\/\/ left \/ right$/;"	e	enum:ast_type_t	file:
ast_op_equal	lib/pugixml/pugixml.cc	/^		ast_op_equal,					\/\/ left = right$/;"	e	enum:ast_type_t	file:
ast_op_greater	lib/pugixml/pugixml.cc	/^		ast_op_greater,					\/\/ left > right$/;"	e	enum:ast_type_t	file:
ast_op_greater_or_equal	lib/pugixml/pugixml.cc	/^		ast_op_greater_or_equal,		\/\/ left >= right$/;"	e	enum:ast_type_t	file:
ast_op_less	lib/pugixml/pugixml.cc	/^		ast_op_less,					\/\/ left < right$/;"	e	enum:ast_type_t	file:
ast_op_less_or_equal	lib/pugixml/pugixml.cc	/^		ast_op_less_or_equal,			\/\/ left <= right$/;"	e	enum:ast_type_t	file:
ast_op_mod	lib/pugixml/pugixml.cc	/^		ast_op_mod,						\/\/ left % right$/;"	e	enum:ast_type_t	file:
ast_op_multiply	lib/pugixml/pugixml.cc	/^		ast_op_multiply,				\/\/ left * right$/;"	e	enum:ast_type_t	file:
ast_op_negate	lib/pugixml/pugixml.cc	/^		ast_op_negate,					\/\/ left - right$/;"	e	enum:ast_type_t	file:
ast_op_not_equal	lib/pugixml/pugixml.cc	/^		ast_op_not_equal,				\/\/ left != right$/;"	e	enum:ast_type_t	file:
ast_op_or	lib/pugixml/pugixml.cc	/^		ast_op_or,						\/\/ left or right$/;"	e	enum:ast_type_t	file:
ast_op_subtract	lib/pugixml/pugixml.cc	/^		ast_op_subtract,				\/\/ left - right$/;"	e	enum:ast_type_t	file:
ast_op_union	lib/pugixml/pugixml.cc	/^		ast_op_union,					\/\/ left | right$/;"	e	enum:ast_type_t	file:
ast_opt_compare_attribute	lib/pugixml/pugixml.cc	/^		ast_opt_compare_attribute		\/\/ @name = 'string'$/;"	e	enum:ast_type_t	file:
ast_opt_translate_table	lib/pugixml/pugixml.cc	/^		ast_opt_translate_table,		\/\/ translate(left, right, third) where right\/third are constants$/;"	e	enum:ast_type_t	file:
ast_predicate	lib/pugixml/pugixml.cc	/^		ast_predicate,					\/\/ apply predicate to set; next points to next predicate$/;"	e	enum:ast_type_t	file:
ast_step	lib/pugixml/pugixml.cc	/^		ast_step,						\/\/ process set left with step$/;"	e	enum:ast_type_t	file:
ast_step_root	lib/pugixml/pugixml.cc	/^		ast_step_root,					\/\/ select root node$/;"	e	enum:ast_type_t	file:
ast_string_constant	lib/pugixml/pugixml.cc	/^		ast_string_constant,			\/\/ string constant$/;"	e	enum:ast_type_t	file:
ast_type_t	lib/pugixml/pugixml.cc	/^	enum ast_type_t$/;"	g	file:
ast_unknown	lib/pugixml/pugixml.cc	/^		ast_unknown,$/;"	e	enum:ast_type_t	file:
ast_variable	lib/pugixml/pugixml.cc	/^		ast_variable,					\/\/ variable$/;"	e	enum:ast_type_t	file:
asttype	lib/pugixml/pugixml.cc	/^			ast_type_t asttype;$/;"	m	struct:xpath_parser::binary_op_t	file:
at	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
at	lib/json/json.hpp	/^    const_reference at(const json_pointer& ptr) const$/;"	f	class:nlohmann::basic_json
at	lib/json/json.hpp	/^    const_reference at(const typename object_t::key_type& key) const$/;"	f	class:nlohmann::basic_json
at	lib/json/json.hpp	/^    const_reference at(size_type idx) const$/;"	f	class:nlohmann::basic_json
at	lib/json/json.hpp	/^    reference at(const json_pointer& ptr)$/;"	f	class:nlohmann::basic_json
at	lib/json/json.hpp	/^    reference at(const typename object_t::key_type& key)$/;"	f	class:nlohmann::basic_json
at	lib/json/json.hpp	/^    reference at(size_type idx)$/;"	f	class:nlohmann::basic_json
atInRange	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(Index start, Index end, Index key, const Scalar &defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
atWithInsertion	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, const Scalar& defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage
atan	lib/Eigen/src/Core/MathFunctions.h	/^T atan(const T &x) {$/;"	f	namespace:Eigen::numext
atan	lib/Eigen/src/Core/MathFunctions.h	/^double atan(const double &x) { return ::atan(x); }$/;"	f	namespace:Eigen::numext
atan	lib/Eigen/src/Core/MathFunctions.h	/^float atan(const float &x) { return ::atanf(x); }$/;"	f	namespace:Eigen::numext
atan	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^atan() const$/;"	f
attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_) const$/;"	f	class:pugi::xml_node
attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::attribute(const char_t* name_, xml_attribute& hint_) const$/;"	f	class:pugi::xml_node
attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xpath_node::attribute() const$/;"	f	class:pugi::xpath_node
attribute_iterator	lib/pugixml/pugixml.h	/^		typedef xml_attribute_iterator attribute_iterator;$/;"	t	class:pugi::xml_node
attributes	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_object_range<xml_attribute_iterator> xml_node::attributes() const$/;"	f	class:pugi::xml_node
attributes_begin	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node::attribute_iterator xml_node::attributes_begin() const$/;"	f	class:pugi::xml_node
attributes_end	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node::attribute_iterator xml_node::attributes_end() const$/;"	f	class:pugi::xml_node
auto_deleter	lib/pugixml/pugixml.cc	/^		auto_deleter(T* data_, D deleter_): data(data_), deleter(deleter_)$/;"	f	struct:auto_deleter
auto_deleter	lib/pugixml/pugixml.cc	/^	template <typename T, typename D = void(*)(T*)> struct auto_deleter$/;"	s	file:
avgPlaquette	extras/qed-fvol/WilsonLoops.h	/^  static Real avgPlaquette(const GaugeLorentz &Umu) {$/;"	f	class:NewWilsonLoops
avgPlaquette	lib/qcd/utils/WilsonLoops.h	/^  static RealD avgPlaquette(const GaugeLorentz &Umu) {$/;"	f	class:Grid::QCD::WilsonLoops
avgRectangle	lib/qcd/utils/WilsonLoops.h	/^  static RealD avgRectangle(const GaugeLorentz &Umu) {$/;"	f	class:Grid::QCD::WilsonLoops
avgSpatialWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static Real avgSpatialWilsonLoop(const GaugeLorentz &Umu,$/;"	f	class:NewWilsonLoops
avgTimelikeWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static Real avgTimelikeWilsonLoop(const GaugeLorentz &Umu,$/;"	f	class:NewWilsonLoops
avgWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static Real avgWilsonLoop(const GaugeLorentz &Umu,$/;"	f	class:NewWilsonLoops
axis	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	lib/pugixml/pugixml.cc	/^		static const axis_t axis;$/;"	m	struct:axis_to_type	file:
axis	lib/pugixml/pugixml.cc	/^	template <axis_t N> const axis_t axis_to_type<N>::axis = N;$/;"	m	class:axis_to_type	file:
axis_ancestor	lib/pugixml/pugixml.cc	/^		axis_ancestor,$/;"	e	enum:axis_t	file:
axis_ancestor_or_self	lib/pugixml/pugixml.cc	/^		axis_ancestor_or_self,$/;"	e	enum:axis_t	file:
axis_attribute	lib/pugixml/pugixml.cc	/^		axis_attribute,$/;"	e	enum:axis_t	file:
axis_child	lib/pugixml/pugixml.cc	/^		axis_child,$/;"	e	enum:axis_t	file:
axis_descendant	lib/pugixml/pugixml.cc	/^		axis_descendant,$/;"	e	enum:axis_t	file:
axis_descendant_or_self	lib/pugixml/pugixml.cc	/^		axis_descendant_or_self,$/;"	e	enum:axis_t	file:
axis_following	lib/pugixml/pugixml.cc	/^		axis_following,$/;"	e	enum:axis_t	file:
axis_following_sibling	lib/pugixml/pugixml.cc	/^		axis_following_sibling,$/;"	e	enum:axis_t	file:
axis_namespace	lib/pugixml/pugixml.cc	/^		axis_namespace,$/;"	e	enum:axis_t	file:
axis_parent	lib/pugixml/pugixml.cc	/^		axis_parent,$/;"	e	enum:axis_t	file:
axis_preceding	lib/pugixml/pugixml.cc	/^		axis_preceding,$/;"	e	enum:axis_t	file:
axis_preceding_sibling	lib/pugixml/pugixml.cc	/^		axis_preceding_sibling,$/;"	e	enum:axis_t	file:
axis_self	lib/pugixml/pugixml.cc	/^		axis_self$/;"	e	enum:axis_t	file:
axis_t	lib/pugixml/pugixml.cc	/^	enum axis_t$/;"	g	file:
axis_to_type	lib/pugixml/pugixml.cc	/^	template <axis_t N> struct axis_to_type$/;"	s	file:
axpbg5y_ssp	lib/qcd/utils/LinalgUtils.h	/^void axpbg5y_ssp(Lattice<vobj> &z,Coeff a,const Lattice<vobj> &x,Coeff b,const Lattice<vobj> &y,int s,int sp)$/;"	f	namespace:Grid::QCD
axpby	lib/lattice/Lattice_arith.h	/^  void axpby(Lattice<vobj> &ret,sobj a,sobj b,const Lattice<vobj> &x,const Lattice<vobj> &y){$/;"	f	namespace:Grid
axpby_norm	lib/lattice/Lattice_arith.h	/^  RealD axpby_norm(Lattice<vobj> &ret,sobj a,sobj b,const Lattice<vobj> &x,const Lattice<vobj> &y){$/;"	f	namespace:Grid
axpby_ssp	lib/qcd/utils/LinalgUtils.h	/^void axpby_ssp(Lattice<vobj> &z, Coeff a,const Lattice<vobj> &x,Coeff b,const Lattice<vobj> &y,int s,int sp)$/;"	f	namespace:Grid::QCD
axpby_ssp_pminus	lib/qcd/utils/LinalgUtils.h	/^void axpby_ssp_pminus(Lattice<vobj> &z,Coeff a,const Lattice<vobj> &x,Coeff b,const Lattice<vobj> &y,int s,int sp)$/;"	f	namespace:Grid::QCD
axpby_ssp_pplus	lib/qcd/utils/LinalgUtils.h	/^void axpby_ssp_pplus(Lattice<vobj> &z,Coeff a,const Lattice<vobj> &x,Coeff b,const Lattice<vobj> &y,int s,int sp)$/;"	f	namespace:Grid::QCD
axpibg5x	lib/qcd/utils/LinalgUtils.h	/^void axpibg5x(Lattice<vobj> &z,const Lattice<vobj> &x,Coeff a,Coeff b)$/;"	f	namespace:Grid::QCD
axpy	lib/lattice/Lattice_arith.h	/^  void axpy(Lattice<vobj> &ret,sobj a,const Lattice<vobj> &x,const Lattice<vobj> &y){$/;"	f	namespace:Grid
axpy_norm	lib/lattice/Lattice_arith.h	/^  RealD axpy_norm(Lattice<vobj> &ret,sobj a,const Lattice<vobj> &x,const Lattice<vobj> &y){$/;"	f	namespace:Grid
b	lib/Eigen/src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon615
b	tests/IO/Test_serialisation.cc	/^bool     b   = false;$/;"	v
back	lib/json/json.hpp	/^    const_reference back() const$/;"	f	class:nlohmann::basic_json
back	lib/json/json.hpp	/^    reference back()$/;"	f	class:nlohmann::basic_json
background	lib/log/Log.h	/^  std::string background() {return Painter.colour["NORMAL"];}$/;"	f	class:Grid::Logger
backward	lib/algorithms/FFT.h	/^    static const int backward=FFTW_BACKWARD;$/;"	m	class:Grid::FFT
base	lib/Eigen/src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	lib/Eigen/src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	lib/communicator/Communicator_mpi3_leader.cc	/^  uint64_t     base;$/;"	m	class:Grid::Slave	file:
base	lib/qcd/utils/SUnTwoIndex.h	/^  static void base(int Index, iSUnMatrix<cplx> &eij) {$/;"	f	class:Grid::QCD::SU_TwoIndex
baseDiagonal	lib/qcd/utils/SUnTwoIndex.h	/^  static void baseDiagonal(int Index, iSUnMatrix<cplx> &eij) {$/;"	f	class:Grid::QCD::SU_TwoIndex
baseOffDiagonal	lib/qcd/utils/SUnTwoIndex.h	/^  static void baseOffDiagonal(int i, int j, iSUnMatrix<cplx> &eij) {$/;"	f	class:Grid::QCD::SU_TwoIndex
base_iterator	lib/json/json.hpp	/^            : base_iterator(it)$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
basic_json	lib/json/json.hpp	/^        : basic_json(value_t::null)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(InputIT first, InputIT last)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const CompatibleArrayType& val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const CompatibleObjectType& val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const CompatibleStringType& val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const array_t& val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const basic_json& other)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const object_t& val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const string_t& val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const typename string_t::value_type* val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(const value_t value_type)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(size_type cnt, const basic_json& val)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    basic_json(std::initializer_list<basic_json> init,$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^    explicit basic_json(std::istream& i, const parser_callback_t cb = nullptr)$/;"	f	class:nlohmann::basic_json
basic_json	lib/json/json.hpp	/^class basic_json$/;"	c	namespace:nlohmann
bcopy	lib/threads/Threads.h	/^  static void bcopy(const void *src, void *dst, size_t len) {$/;"	f	class:Grid::GridThread
bdcSvd	lib/Eigen/src/SVD/BDCSVD.h	/^MatrixBase<Derived>::bdcSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase
be32toh_v	lib/parallelIO/BinaryIO.h	/^  static inline void be32toh_v(void *file_object,uint64_t bytes)$/;"	f	class:Grid::BinaryIO
be64toh_v	lib/parallelIO/BinaryIO.h	/^  static inline void be64toh_v(void *file_object,uint64_t bytes)$/;"	f	class:Grid::BinaryIO
bee	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> bee;    $/;"	m	class:Grid::QCD::CayleyFermion5D
begin	lib/lattice/Lattice_base.h	/^    int begin(void) { return 0;};$/;"	f	class:Grid::Lattice
begin	lib/perfmon/PerfCount.h	/^  uint64_t begin;$/;"	m	class:Grid::PerformanceCounter
begin	lib/pugixml/pugixml.cc	/^		const char_t* begin;$/;"	m	struct:xpath_lexer_string	file:
begin	lib/pugixml/pugixml.cc	/^		xpath_node* begin() const$/;"	f	class:xpath_node_set_raw
begin	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_string_to_number_scratch(char_t (&buffer)[32], const char_t* begin, const char_t* end, double* out_result)$/;"	v
begin	lib/pugixml/pugixml.cc	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
begin	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_tree_walker::begin(xml_node&)$/;"	f	class:pugi::xml_tree_walker
begin	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node::iterator xml_node::begin() const$/;"	f	class:pugi::xml_node
begin	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::const_iterator xpath_node_set::begin() const$/;"	f	class:pugi::xpath_node_set
begin	lib/pugixml/pugixml.h	/^		It begin() const { return _begin; }$/;"	f	class:pugi::xml_object_range
begin_array	lib/json/json.hpp	/^            begin_array,     \/\/\/< the character for array begin `[`$/;"	m	class:nlohmann::basic_json::lexer::token_type
begin_object	lib/json/json.hpp	/^            begin_object,    \/\/\/< the character for object begin `{`$/;"	m	class:nlohmann::basic_json::lexer::token_type
begin_value	lib/json/json.hpp	/^        static constexpr difference_type begin_value = 0;$/;"	m	class:nlohmann::basic_json::primitive_iterator_t
benchDw	benchmarks/Benchmark_dwf_sweep.cc	/^void benchDw(std::vector<int> & latt4, int Ls, int threads,int report )$/;"	f
bench_wilson	benchmarks/Benchmark_wilson_sweep.cc	/^void bench_wilson ($/;"	f
benchmarkCrossover	extras/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::benchmarkCrossover(const unsigned int nIt)$/;"	f	class:GeneticScheduler
benchmarkCrossover	lib/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::benchmarkCrossover(const unsigned int nIt)$/;"	f	class:GeneticScheduler
benchsDw	benchmarks/Benchmark_dwf_sweep.cc	/^void benchsDw(std::vector<int> & latt4, int Ls, int threads, int report )$/;"	f
beo	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> beo;    $/;"	m	class:Grid::QCD::CayleyFermion5D
bernoulli	lib/lattice/Lattice_rng.h	/^  template <class sobj> inline void bernoulli(GridSerialRNG &rng,sobj &l){ rng.fill(l,rng._bernoulli); }$/;"	f	namespace:Grid
bernoulli	lib/lattice/Lattice_rng.h	/^  template <class vobj> inline void bernoulli(GridParallelRNG &rng,Lattice<vobj> &l){ rng.fill(l,rng._bernoulli);}$/;"	f	namespace:Grid
beta	lib/algorithms/approx/Chebyshev.h	/^    RealD beta;$/;"	m	class:Grid::ChebyshevLanczos
beta	lib/algorithms/approx/Zolotarev.h	/^    *beta,	      \/* coefficients of continued fraction, beta[0 .. db-1] *\/$/;"	m	struct:Grid::Approx::__anon695
beta	lib/qcd/action/gauge/WilsonGaugeAction.h	/^  RealD beta;  $/;"	m	class:Grid::QCD::WilsonGaugeAction
beta	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^const double beta=2.6;$/;"	v
betas	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType betas() const$/;"	f	class:Eigen::GeneralizedEigenSolver
bgq_l1p_optimisation	lib/simd/l1p.h	/^inline void bgq_l1p_optimisation(int mode)$/;"	f	namespace:Grid
bicgstab	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
bidiagonal	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat() { mpf_init(x); }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat(const bigfloat& y) { mpf_init_set(x, y.x); }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat(const char *str) { mpf_init_set_str(x, (char*)str, 10); }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat(const double d) { mpf_init_set_d(x, d); }  $/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat(const float d) { mpf_init_set_d(x, (double)d); }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat(const int i) {mpf_init_set_si(x,(long)i);}$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat(const long i) { mpf_init_set_si(x, i); }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^  bigfloat(const unsigned long u) { mpf_init_set_ui(x, u); }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat.h	/^class bigfloat {$/;"	c
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat() { }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat(const bigfloat& y) { x=y.x; }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat(const char *str) { x=std::stod(std::string(str));}$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat(const double d) {  x=d;}$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat(const float d) { x=d;}$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat(const int i) { x=i;}$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat(const long i) { x=i; }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat(const unsigned long u) { x=u; }$/;"	f	class:bigfloat
bigfloat	lib/algorithms/approx/bigfloat_double.h	/^class bigfloat {$/;"	c
binary	lib/simd/Grid_vector_types.h	/^Out binary(Input1 src_1, Input2 src_2, Operation op) {$/;"	f	namespace:Grid
binaryExpr	lib/Eigen/src/plugins/CommonCwiseBinaryOps.h	/^binaryExpr(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const$/;"	f
binary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit binary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::binary_evaluator
binary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  explicit binary_evaluator(const XprType& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::binary_evaluator
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  explicit binary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::binary_evaluator
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs>, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs>, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs>, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs>, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_quotient_op<T1,T2>, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_op_base	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct binary_op_base$/;"	s	namespace:Eigen::internal
binary_op_t	lib/pugixml/pugixml.cc	/^			binary_op_t(): asttype(ast_unknown), rettype(xpath_type_none), precedence(0)$/;"	f	struct:xpath_parser::binary_op_t
binary_op_t	lib/pugixml/pugixml.cc	/^			binary_op_t(ast_type_t asttype_, xpath_value_type rettype_, int precedence_): asttype(asttype_), rettype(rettype_), precedence(precedence_)$/;"	f	struct:xpath_parser::binary_op_t
binary_op_t	lib/pugixml/pugixml.cc	/^		struct binary_op_t$/;"	s	struct:xpath_parser	file:
binary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	s	namespace:Eigen::internal
binary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
binary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
bind1st_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  bind1st_op(const first_argument_type &val) : m_value(val) {}$/;"	f	struct:Eigen::internal::bind1st_op
bind1st_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct bind1st_op : BinaryOp {$/;"	s	namespace:Eigen::internal
bind2nd_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  bind2nd_op(const second_argument_type &val) : m_value(val) {}$/;"	f	struct:Eigen::internal::bind2nd_op
bind2nd_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct bind2nd_op : BinaryOp {$/;"	s	namespace:Eigen::internal
blas_data_mapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper
blas_data_mapper	lib/Eigen/src/Core/util/BlasUtil.h	/^class blas_data_mapper {$/;"	c	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > >$/;"	s	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain1>,$/;"	s	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal
blas_traits	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
block	lib/Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr block(Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f
block	lib/Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr block(Index startRow, Index startCol, Index blockRows, Index blockCols) const$/;"	f
block	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol) const$/;"	f
block	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol,$/;"	f
block	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol)$/;"	f
block	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol,$/;"	f
block	lib/pugixml/pugixml.cc	/^		xpath_memory_block block;$/;"	m	struct:xpath_query_impl	file:
blockA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking
blockB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking
blockCols	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index blockCols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::BlockImpl
blockCols	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index blockCols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
blockCols	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index blockCols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::BlockImpl
blockDim	lib/algorithms/iterative/BlockConjugateGradient.h	/^  int blockDim ;$/;"	m	class:Grid::BlockConjugateGradient
blockInnerProduct	lib/lattice/Lattice_transfer.h	/^  inline void blockInnerProduct(Lattice<CComplex> &CoarseInner,$/;"	f	namespace:Grid
blockNormalise	lib/lattice/Lattice_transfer.h	/^inline void blockNormalise(Lattice<CComplex> &ip,Lattice<vobj> &fineX)$/;"	f	namespace:Grid
blockOrthogonalise	lib/lattice/Lattice_transfer.h	/^inline void blockOrthogonalise(Lattice<CComplex> &ip,std::vector<Lattice<vobj> > &Basis)$/;"	f	namespace:Grid
blockPick	lib/lattice/Lattice_transfer.h	/^inline void blockPick(GridBase *coarse,const Lattice<vobj> &unpicked,Lattice<vobj> &picked,std::vector<int> coor)$/;"	f	namespace:Grid
blockProject	lib/lattice/Lattice_transfer.h	/^inline void blockProject(Lattice<iVector<CComplex,nbasis > > &coarseData,$/;"	f	namespace:Grid
blockPromote	lib/lattice/Lattice_transfer.h	/^inline void blockPromote(const Lattice<iVector<CComplex,nbasis > > &coarseData,$/;"	f	namespace:Grid
blockRows	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index blockRows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::BlockImpl
blockRows	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index blockRows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
blockRows	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index blockRows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::BlockImpl
blockSum	lib/lattice/Lattice_transfer.h	/^inline void blockSum(Lattice<vobj> &coarseData,const Lattice<vobj> &fineData)$/;"	f	namespace:Grid
blockZAXPY	lib/lattice/Lattice_transfer.h	/^inline void blockZAXPY(Lattice<vobj> &fineZ,$/;"	f	namespace:Grid
block_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)$/;"	f	struct:Eigen::internal::block_evaluator
block_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, \/* HasDirectAccess *\/ true>$/;"	s	namespace:Eigen::internal
block_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, \/*HasDirectAccess*\/ false>$/;"	s	namespace:Eigen::internal
block_evaluator_type	lib/Eigen/src/Core/CoreEvaluators.h	/^  typedef block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel> block_evaluator_type;$/;"	t	struct:Eigen::internal::evaluator
blocked	lib/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
blocked	lib/Eigen/src/Cholesky/LLT.h	/^  static Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace
blocked_lu	lib/Eigen/src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl
blocks	lib/pugixml/pugixml.cc	/^		xpath_memory_block blocks[2];$/;"	m	struct:xpath_stack_data	file:
blueNorm	lib/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase
blueNorm	lib/Eigen/src/Core/VectorwiseOp.h	/^    const BlueNormReturnType blueNorm() const$/;"	f	class:Eigen::VectorwiseOp
blueNorm	lib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::SparseMatrixBase
blueNorm_impl	lib/Eigen/src/Core/StableNorm.h	/^blueNorm_impl(const EigenBase<Derived>& _vec)$/;"	f	namespace:Eigen::internal
boolean	lib/json/json.hpp	/^        boolean,         \/\/\/< boolean value$/;"	m	class:nlohmann::basic_json::value_t
boolean	lib/json/json.hpp	/^        boolean_t boolean;$/;"	m	union:nlohmann::basic_json::json_value
boolean	lib/json/json.hpp	/^        json_value(boolean_t v) noexcept : boolean(v) {}$/;"	f	union:nlohmann::basic_json::json_value
bottomLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr bottomLeftCorner(Index cRows, Index cCols)$/;"	f
bottomLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr bottomLeftCorner(Index cRows, Index cCols) const$/;"	f
bottomLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomLeftCorner() const$/;"	f
bottomLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomLeftCorner(Index cRows, Index cCols) const$/;"	f
bottomLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomLeftCorner()$/;"	f
bottomLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomLeftCorner(Index cRows, Index cCols)$/;"	f
bottomRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr bottomRightCorner(Index cRows, Index cCols)$/;"	f
bottomRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr bottomRightCorner(Index cRows, Index cCols) const$/;"	f
bottomRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomRightCorner() const$/;"	f
bottomRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomRightCorner(Index cRows, Index cCols) const$/;"	f
bottomRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomRightCorner()$/;"	f
bottomRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomRightCorner(Index cRows, Index cCols)$/;"	f
bottomRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr bottomRows(Index n) const$/;"	f
bottomRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr bottomRows(Index n)$/;"	f
bottomRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type bottomRows(Index n = N) const$/;"	f
bottomRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type bottomRows(Index n = N)$/;"	f
boundary_phases	lib/qcd/action/ActionParams.h	/^    std::vector<Complex> boundary_phases;$/;"	m	struct:Grid::QCD::WilsonImplParams
broadcastRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, DoublePacketType& b0, DoublePacketType& b1)$/;"	f	class:Eigen::internal::gebp_traits
broadcastRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, RhsPacket& b3)$/;"	f	class:Eigen::internal::gebp_traits
broadcastRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, RhsScalar& b0, RhsScalar& b1)$/;"	f	class:Eigen::internal::gebp_traits
broadcastRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, RhsPacket& b3)$/;"	f	class:Eigen::internal::gebp_traits
bruteforce_det3_helper	lib/Eigen/src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal
bruteforce_det4_helper	lib/Eigen/src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal
bs	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> bs;    \/\/ S dependent coeffs$/;"	m	class:Grid::QCD::CayleyFermion5D
buf	lib/communicator/Communicator_mpi3_leader.cc	/^  uint64_t buf;$/;"	m	struct:Grid::Descriptor	file:
bufcapacity	lib/pugixml/pugixml.cc	/^			bufcapacity = bufcapacitybytes \/ (sizeof(char_t) + 4)$/;"	e	enum:xml_buffered_writer::__anon683	file:
bufcapacitybytes	lib/pugixml/pugixml.cc	/^			bufcapacitybytes =$/;"	e	enum:xml_buffered_writer::__anon683	file:
buffer	lib/pugixml/pugixml.cc	/^		char_t buffer[bufcapacity];$/;"	m	class:xml_buffered_writer	file:
buffer	lib/pugixml/pugixml.cc	/^		char_t* buffer;$/;"	m	struct:xml_extra_buffer	file:
buffer	lib/pugixml/pugixml.cc	/^		const char_t* buffer;$/;"	m	struct:xml_document_struct	file:
buffer_size	lib/stencil/Stencil.h	/^    Integer buffer_size;$/;"	m	struct:Grid::CartesianStencil::Decompress
buffer_size	lib/stencil/Stencil.h	/^    Integer buffer_size;$/;"	m	struct:Grid::CartesianStencil::Merge
bufsize	lib/pugixml/pugixml.cc	/^		size_t bufsize;$/;"	m	class:xml_buffered_writer	file:
build_filenames	lib/qcd/hmc/checkpointers/BaseCheckpointer.h	/^  void build_filenames(int traj, CheckpointerParameters &Params,$/;"	f	class:Grid::QCD::BaseHmcCheckpointer
builder_	extras/Hadrons/Factory.hpp	/^    std::map<std::string, Func> builder_;$/;"	m	class:Factory
builder_	lib/Hadrons/Factory.hpp	/^    std::map<std::string, Func> builder_;$/;"	m	class:Factory
builder_	lib/qcd/modules/Factory.h	/^    std::map<std::string, Func> builder_;$/;"	m	class:Grid::Factory
busy_size	lib/pugixml/pugixml.cc	/^		size_t busy_size;$/;"	m	struct:xml_memory_page	file:
byte_reverse32	lib/parallelIO/BinaryIO.h	/^inline uint32_t byte_reverse32(uint32_t f) { $/;"	f	namespace:Grid
byte_reverse64	lib/parallelIO/BinaryIO.h	/^inline uint64_t byte_reverse64(uint64_t f) { $/;"	f	namespace:Grid
bytes	lib/allocator/AlignedAllocator.h	/^      size_t bytes;$/;"	m	struct:Grid::PointerCache::__anon11
bytes	lib/allocator/AlignedAllocator.h	/^      size_t bytes;$/;"	m	struct:Grid::PointerCache::__anon12
bytes	lib/communicator/Communicator_mpi3_leader.cc	/^  size_t bytes;$/;"	m	struct:Grid::Descriptor	file:
bytes	lib/stencil/Stencil.h	/^    Integer bytes;$/;"	m	struct:Grid::CartesianStencil::Packet
c	lib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	lib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	lib/simd/Grid_generic_types.h	/^    constexpr static unsigned int c = GEN_SIMD_WIDTH\/16u;$/;"	m	struct:Grid::Optimization::W
c	lib/simd/Grid_generic_types.h	/^    constexpr static unsigned int c = GEN_SIMD_WIDTH\/4u;$/;"	m	struct:Grid::Optimization::W
c	lib/simd/Grid_generic_types.h	/^    constexpr static unsigned int c = GEN_SIMD_WIDTH\/8u;$/;"	m	struct:Grid::Optimization::W
c1	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  RealD c1;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
c1	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    RealD c1;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
c1	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^const double c1=-0.331;$/;"	v
c2	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  RealD c2;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
c2	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    RealD c2;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
c_plaq	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      RealD c_plaq;$/;"	m	class:Grid::QCD::PlaqPlusRectangleAction
c_rect	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      RealD c_rect;$/;"	m	class:Grid::QCD::PlaqPlusRectangleAction
c_str	lib/pugixml/pugixml.cc	/^		const char_t* c_str() const$/;"	f	class:xpath_string
c_to_fortran_numbering	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
calc	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void calc(std::vector<RealD>& eval,  std::vector<Field>& evec, const Field& src, int& Nconv)$/;"	f	class:Grid::ImplicitlyRestartedLanczos
calc_chroma	tests/qdpxx/Test_qdpxx_munprec.cc	/^void calc_chroma(ChromaAction action,Grid::QCD::LatticeGaugeField & lat, Grid::QCD::LatticeFermion &src, Grid::QCD::LatticeFermion &res,int dag)$/;"	f
calc_chroma	tests/qdpxx/Test_qdpxx_stag.cc	/^void calc_chroma(GaugeField & lat, GaugeField &uthin, GaugeField &ufat, FermionField &src, FermionField &res,int dag)$/;"	f
calc_chroma_IW	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^double calc_chroma_IW(Grid::QCD::LatticeGaugeField & lat)$/;"	f
calc_chroma_p	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^double calc_chroma_p(Grid::QCD::LatticeGaugeField & lat)$/;"	f
calc_chroma_r	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^double calc_chroma_r(Grid::QCD::LatticeGaugeField & lat)$/;"	f
calc_grid	tests/qdpxx/Test_qdpxx_munprec.cc	/^void calc_grid(ChromaAction action,Grid::QCD::LatticeGaugeField & Umu, Grid::QCD::LatticeFermion &src, Grid::QCD::LatticeFermion &res,int dag)$/;"	f
calc_grid	tests/qdpxx/Test_qdpxx_stag.cc	/^void calc_grid(GaugeField & Uthin, GaugeField & Utriple, GaugeField & Ufat, FermionField &src, FermionField &res,int dag)$/;"	f
calc_grid_IW	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^double calc_grid_IW(Grid::QCD::LatticeGaugeField & Umu)$/;"	f
calc_grid_p	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^double calc_grid_p(Grid::QCD::LatticeGaugeField & Umu)$/;"	f
calc_grid_r	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^double calc_grid_r(Grid::QCD::LatticeGaugeField & Umu)$/;"	f
calc_grid_r_dir	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^double calc_grid_r_dir(Grid::QCD::LatticeGaugeField & Umu)$/;"	f
call_assignment	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if< evaluator_assume_aliasing<Src>::value, void*>::type = 0)$/;"	f	namespace:Eigen::internal
call_assignment	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if<!evaluator_assume_aliasing<Src>::value, void*>::type = 0)$/;"	f	namespace:Eigen::internal
call_assignment	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(NoAlias<Dst,StorageBase>& dst, const Src& src, const Func& func)$/;"	f	namespace:Eigen::internal
call_assignment	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(const Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias(Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias(Dst& dst, const Src& src, const Func& func)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias_no_transpose	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias_no_transpose	lib/Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src, const Func& func)$/;"	f	namespace:Eigen::internal
call_dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen::internal
call_dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src, const Functor &func)$/;"	f	namespace:Eigen::internal
call_triangular_assignment_loop	lib/Eigen/src/Core/TriangularMatrix.h	/^void call_triangular_assignment_loop(DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen::internal
call_triangular_assignment_loop	lib/Eigen/src/Core/TriangularMatrix.h	/^void call_triangular_assignment_loop(DstXprType& dst, const SrcXprType& src, const Functor &func)$/;"	f	namespace:Eigen::internal
callback	lib/json/json.hpp	/^        const parser_callback_t callback = nullptr;$/;"	m	class:nlohmann::basic_json::parser
calls	lib/stencil/Stencil.h	/^  double calls;$/;"	m	class:Grid::CartesianStencil
capacity	lib/pugixml/pugixml.cc	/^		size_t capacity;$/;"	m	struct:xpath_memory_block	file:
cast	lib/Eigen/src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal
cast	lib/Eigen/src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox
cast	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis
cast	lib/Eigen/src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane
cast	lib/Eigen/src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine
cast	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase
cast	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D
cast	lib/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling
cast	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform
cast	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation
cast	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^cast() const$/;"	f
cast_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
cast_to_pointer_type	lib/Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map
cb	lib/json/json.hpp	/^                            const parser_callback_t cb = nullptr)$/;"	m	class:nlohmann::basic_json
cc	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      std::vector<double> cc;;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
cc_d	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      std::vector<double> cc_d;;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
cd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    Packet1cd cd[2];$/;"	m	union:Eigen::internal::Packet2cf::__anon315
cee	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> cee;    $/;"	m	class:Grid::QCD::CayleyFermion5D
ceil	lib/Eigen/src/Core/MathFunctions.h	/^T (ceil)(const T& x)$/;"	f	namespace:Eigen::numext
ceil	lib/Eigen/src/Core/MathFunctions.h	/^double ceil(const double &x) { return ::ceil(x); }$/;"	f	namespace:Eigen::numext
ceil	lib/Eigen/src/Core/MathFunctions.h	/^float ceil(const float &x) { return ::ceilf(x); }$/;"	f	namespace:Eigen::numext
ceil	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half ceil(const half& a) {$/;"	f	namespace:Eigen::half_impl
ceil	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^ceil() const$/;"	f
ceilh	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half ceilh(const Eigen::half& a) {$/;"	f
center	lib/Eigen/src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox
ceo	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> ceo;    $/;"	m	class:Grid::QCD::CayleyFermion5D
char_t	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_string_to_number_scratch(char_t (&buffer)[32], const char_t* begin, const char_t* end, double* out_result)$/;"	v
char_t	lib/pugixml/pugixml.cc	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
char_t	lib/pugixml/pugixml.h	/^	typedef PUGIXML_CHAR char_t;$/;"	t	namespace:pugi
chartype_t	lib/pugixml/pugixml.cc	/^	enum chartype_t$/;"	g	file:
chartype_table	lib/pugixml/pugixml.cc	/^	static const unsigned char chartype_table[256] =$/;"	v	file:
chartypex_t	lib/pugixml/pugixml.cc	/^	enum chartypex_t$/;"	g	file:
chartypex_table	lib/pugixml/pugixml.cc	/^	static const unsigned char chartypex_table[256] =$/;"	v	file:
check	lib/qcd/hmc/HMC_GridModules.h	/^  void check(){$/;"	f	class:Grid::GridModuleParameters
checkAdj	tests/core/Test_gamma.cc	/^void checkAdj(const Gamma::Algebra a)$/;"	f
checkGamma	tests/core/Test_gamma.cc	/^void checkGamma(const Gamma::Algebra a, GridSerialRNG &rng)$/;"	f
checkGammaL	tests/core/Test_gamma.cc	/^void checkGammaL(const Gamma::Algebra a, GridSerialRNG &rng)$/;"	f
checkIndent	lib/serialisation/TextIO.cc	/^void TextReader::checkIndent(void)$/;"	f	class:TextReader
checkProd	tests/core/Test_gamma.cc	/^void checkProd(const Gamma::Algebra a, const Gamma::Algebra b)$/;"	f
checkProject	tests/core/Test_gamma.cc	/^void checkProject(GridSerialRNG &rng)$/;"	f
checkSanity	lib/Eigen/src/Core/MapBase.h	/^    void checkSanity(typename internal::enable_if<(internal::traits<T>::Alignment>0),void*>::type = 0) const$/;"	f	class:Eigen::MapBase
checkSanity	lib/Eigen/src/Core/MapBase.h	/^    void checkSanity(typename internal::enable_if<internal::traits<T>::Alignment==0,void*>::type = 0) const$/;"	f	class:Eigen::MapBase
checkTransposeAliasing_impl	lib/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
checkTransposeAliasing_impl	lib/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
check_DenseIndex_is_signed	lib/Eigen/src/Core/DenseBase.h	/^static inline void check_DenseIndex_is_signed() {$/;"	f	namespace:Eigen::internal
check_coordinates	lib/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	lib/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	lib/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_for_aliasing	lib/Eigen/src/Core/Transpose.h	/^void check_for_aliasing(const Dst &dst, const Src &src)$/;"	f	namespace:Eigen::internal
check_grid_p_staple	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^void check_grid_p_staple(Grid::QCD::LatticeGaugeField & Umu)$/;"	f
check_grid_r_staple	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^void check_grid_r_staple(Grid::QCD::LatticeGaugeField & Umu)$/;"	f
check_rows_cols_for_overflow	lib/Eigen/src/Core/PlainObjectBase.h	/^template<> struct check_rows_cols_for_overflow<Dynamic> {$/;"	s	namespace:Eigen::internal
check_rows_cols_for_overflow	lib/Eigen/src/Core/PlainObjectBase.h	/^template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {$/;"	s	namespace:Eigen::internal
check_size_for_overflow	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void check_size_for_overflow(std::size_t size)$/;"	f	namespace:Eigen::internal
check_static_allocation_size	lib/Eigen/src/Core/DenseStorage.h	/^void check_static_allocation_size()$/;"	f	namespace:Eigen::internal
check_string_to_number_format	lib/pugixml/pugixml.cc	/^	PUGI__FN bool check_string_to_number_format(const char_t* string)$/;"	f
check_template_parameters	lib/Eigen/src/Cholesky/LDLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LDLT
check_template_parameters	lib/Eigen/src/Cholesky/LLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LLT
check_template_parameters	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ComplexEigenSolver
check_template_parameters	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::EigenSolver
check_template_parameters	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::GeneralizedEigenSolver
check_template_parameters	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SelfAdjointEigenSolver
check_template_parameters	lib/Eigen/src/LU/FullPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivLU
check_template_parameters	lib/Eigen/src/LU/PartialPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::PartialPivLU
check_template_parameters	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ColPivHouseholderQR
check_template_parameters	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  static void check_template_parameters() {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
check_template_parameters	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivHouseholderQR
check_template_parameters	lib/Eigen/src/QR/HouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::HouseholderQR
check_template_parameters	lib/Eigen/src/SVD/SVDBase.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SVDBase
check_template_parameters	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix
check_template_parameters	lib/Eigen/src/SparseCore/SparseVector.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SparseVector
check_template_params	lib/Eigen/src/Geometry/Transform.h	/^    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform
check_that_malloc_is_allowed	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	lib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	lib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	lib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	lib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
checkerboard	lib/lattice/Lattice_base.h	/^    int checkerboard;$/;"	m	class:Grid::Lattice
chi	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  const RealD chi = 1.0 \/ 72.0;$/;"	m	class:Grid::QCD::ForceGradient
child	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::child(const char_t* name_) const$/;"	f	class:pugi::xml_node
child_value	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_node::child_value() const$/;"	f	class:pugi::xml_node
child_value	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_node::child_value(const char_t* name_) const$/;"	f	class:pugi::xml_node
children	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_object_range<xml_named_node_iterator> xml_node::children(const char_t* name_) const$/;"	f	class:pugi::xml_node
children	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_object_range<xml_node_iterator> xml_node::children() const$/;"	f	class:pugi::xml_node
cholmod	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase
cholmodCommon	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    cholmod_common *cholmodCommon() const { return &m_cc; }$/;"	f	class:Eigen::SPQR
cholmod_configure_matrix	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^template<> struct cholmod_configure_matrix<double> {$/;"	s	namespace:Eigen::internal
cholmod_configure_matrix	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^template<> struct cholmod_configure_matrix<std::complex<double> > {$/;"	s	namespace:Eigen::internal
cj	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
clamp	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
clean	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase
clean	lib/allocator/AlignedAllocator.h	/^    static void clean()$/;"	f	class:Grid::PointerCache
clear	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage
clear	lib/perfmon/Stat.cc	/^void PmuStat::clear(void)$/;"	f	class:Grid::PmuStat
clear	lib/pugixml/pugixml.cc	/^		void clear()$/;"	f	class:compact_hash_table
clearFactors	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase
clear_mark	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline  IndexType clear_mark  \/* return the new value for tag_mark *\/$/;"	f	namespace:internal
close	lib/parallelIO/IldgIO.h	/^   void close(void) {$/;"	f	class:Grid::QCD::GridLimeWriter
close	lib/parallelIO/IldgIO.h	/^   void close(void){$/;"	f	class:Grid::QCD::GridLimeReader
cmp_EQ	lib/Eigen/src/Core/util/Constants.h	/^  cmp_EQ = 0,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_GE	lib/Eigen/src/Core/util/Constants.h	/^  cmp_GE = 6$/;"	e	enum:Eigen::internal::ComparisonName
cmp_GT	lib/Eigen/src/Core/util/Constants.h	/^  cmp_GT = 5,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LE	lib/Eigen/src/Core/util/Constants.h	/^  cmp_LE = 2,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LT	lib/Eigen/src/Core/util/Constants.h	/^  cmp_LT = 1,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_NEQ	lib/Eigen/src/Core/util/Constants.h	/^  cmp_NEQ = 4,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_UNORD	lib/Eigen/src/Core/util/Constants.h	/^  cmp_UNORD = 3,$/;"	e	enum:Eigen::internal::ComparisonName
cmul	lib/simd/Grid_generic.h	155;"	d
cmul	lib/simd/Grid_generic.h	202;"	d
cname	lib/algorithms/approx/Remez.h	/^  char *cname;$/;"	m	class:AlgRemez
coarsegrid	lib/algorithms/iterative/AdefGeneric.h	/^  GridBase *coarsegrid;$/;"	m	class:TwoLevelFlexiblePcg
coeff	lib/Eigen/src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeff	lib/Eigen/src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::binary_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::ternary_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::unary_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::binary_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::ternary_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::unary_evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(IndexType index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(IndexType row, IndexType col) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  const Scalar coeff(Index i, Index j) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/Core/CoreEvaluators.h	/^  const Scalar coeff(Index index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	lib/Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index idx) const$/;"	f	class:Eigen::Diagonal
coeff	lib/Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeff	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	lib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase
coeff	lib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
coeff	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue
coeff	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
coeff	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeff	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
coeff	lib/Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC Scalar coeff(Index i) const$/;"	f	class:Eigen::ProductImpl
coeff	lib/Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::ProductImpl
coeff	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
coeff	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index idx) const$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
coeff	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
coeff	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC const CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::product_evaluator
coeff	lib/Eigen/src/Core/Redux.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::internal::redux_evaluator
coeff	lib/Eigen/src/Core/Redux.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::internal::redux_evaluator
coeff	lib/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	lib/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	lib/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select
coeff	lib/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select
coeff	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView
coeff	lib/Eigen/src/Core/Transpositions.h	/^    inline const StorageIndex& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase
coeff	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase
coeff	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularViewImpl
coeff	lib/Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::internal::visitor_evaluator
coeff	lib/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_StorageIndex>::coeff(Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeff	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index index) const$/;"	f	class:Eigen::BlockImpl
coeff	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index index) const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
coeff	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::BlockImpl
coeff	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
coeff	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  const Scalar& coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
coeff	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMapBase
coeff	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix
coeff	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const$/;"	f	class:Eigen::SparseVector
coeff	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector
coeffByOuterInner	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
coeffByOuterInner	lib/Eigen/src/Core/Redux.h	/^  CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::internal::redux_evaluator
coeffRef	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	lib/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	lib/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	lib/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	lib/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::unary_evaluator
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::unary_evaluator
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	lib/Eigen/src/Core/CoreEvaluators.h	/^  typename XprType::Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::unary_evaluator
coeffRef	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	lib/Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index idx)$/;"	f	class:Eigen::Diagonal
coeffRef	lib/Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index row, Index)$/;"	f	class:Eigen::Diagonal
coeffRef	lib/Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index idx) const$/;"	f	class:Eigen::Diagonal
coeffRef	lib/Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeffRef	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	lib/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase
coeffRef	lib/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase
coeffRef	lib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase
coeffRef	lib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
coeffRef	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue
coeffRef	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue
coeffRef	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	lib/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	lib/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView
coeffRef	lib/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	lib/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	lib/Eigen/src/Core/Transpositions.h	/^    inline StorageIndex& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase
coeffRef	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase
coeffRef	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularViewImpl
coeffRef	lib/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_StorageIndex>::coeffRef(Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeffRef	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::BlockImpl
coeffRef	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::BlockImpl
coeffRef	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
coeffRef	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMapBase
coeffRef	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
coeffRef	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector
coeffRef	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector
coeffRefByOuterInner	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase
coeffSeparator	lib/Eigen/src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat
coeff_visitor	lib/Eigen/src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
coeffs	lib/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	lib/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	lib/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	lib/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	lib/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper
coeffs	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map
coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
coeffs	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    Map<Array<Scalar,Dynamic,1> > coeffs() { eigen_assert(isCompressed()); return Array<Scalar,Dynamic,1>::Map(valuePtr(),nonZeros()); }$/;"	f	class:Eigen::SparseCompressedBase
coeffs	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const Map<const Array<Scalar,Dynamic,1> > coeffs() const { eigen_assert(isCompressed()); return Array<Scalar,Dynamic,1>::Map(valuePtr(),nonZeros()); }$/;"	f	class:Eigen::SparseCompressedBase
cofactor_3x3	lib/Eigen/src/LU/InverseImpl.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal
cofactor_4x4	lib/Eigen/src/LU/InverseImpl.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal
col	lib/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
col	lib/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon215
col	lib/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon216
col	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index col() const             { return m_iter.col(); }$/;"	f	class:Eigen::InnerIterator
col	lib/Eigen/src/Core/CoreIterators.h	/^  inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::internal::inner_iterator_selector
col	lib/Eigen/src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ DstXprType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_loop::__anon23
col	lib/Eigen/src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon221
col	lib/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
col	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Index col()    const { return EvalIterator::col()   - m_block.startCol(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
col	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Index col()    const { return IsRowMajor ? index() : 0; }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
col	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
col	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
col	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return IsRowMajor ? m_id : m_lhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return IsRowMajor ? m_id : m_rhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index col()   const { return NeedToTranspose ? LhsIterator::index() : m_outer; }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index col() const    { return SparseXprType::IsRowMajor ? m_sparseIter.index() : m_sparseIter.outer(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseTranspose.h	/^      Index col() const { return EvalIterator::row(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
col	lib/Eigen/src/SparseCore/SparseUtil.h	/^  const StorageIndex& col() const { return m_col; }$/;"	f	class:Eigen::Triplet
col	lib/Eigen/src/SparseCore/SparseView.h	/^        inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
col	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
col	lib/Eigen/src/plugins/BlockMethods.h	/^inline ColXpr col(Index i)$/;"	f
col	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColXpr col(Index i) const$/;"	f
colIndexByOuterInner	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
colIndexByOuterInner	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
colIndexPtr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* colIndexPtr()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colIndexPtr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* colIndexPtr() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colOffset	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value() > 0 ? m_index.value() : 0; }$/;"	f	struct:Eigen::internal::evaluator
colOffset	lib/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	class:Eigen::Diagonal
colPivHouseholderQr	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
colStride	lib/Eigen/src/Core/CoreEvaluators.h	/^  inline Index colStride() const { return XprType::IsRowMajor ? m_innerStride.value() : m_outerStride.value(); }$/;"	f	struct:Eigen::internal::mapbase_evaluator
colStride	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase
colToSup	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* colToSup()  { return m_col_to_sup; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colToSup	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* colToSup() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colamd	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static bool colamd(IndexType n_row, IndexType n_col, IndexType Alen, IndexType *A, IndexType *p, double knobs[COLAMD_KNOBS], IndexType stats[COLAMD_STATS])$/;"	f	namespace:internal
colamd_c	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline IndexType colamd_c(IndexType n_col) $/;"	f	namespace:internal
colamd_col	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^struct colamd_col$/;"	s	namespace:internal
colamd_r	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline IndexType  colamd_r(IndexType n_row)$/;"	f	namespace:internal
colamd_recommended	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline IndexType colamd_recommended ( IndexType nnz, IndexType n_row, IndexType n_col)$/;"	f	namespace:internal
colamd_set_defaults	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline void colamd_set_defaults(double knobs[COLAMD_KNOBS])$/;"	f	namespace:internal
colblk	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index colblk; \/\/ The minimum column dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues
coletree	lib/Eigen/src/SparseCore/SparseColEtree.h	/^int coletree(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::StorageIndex *perm=0)$/;"	f	namespace:Eigen::internal
collapseDuplicates	lib/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_StorageIndex>::collapseDuplicates(DupFunctor dup_func)$/;"	f	class:Eigen::SparseMatrix
colour	lib/log/Log.h	/^  std::map<std::string, std::string> colour;$/;"	m	class:Grid::Colours
colour	lib/log/Log.h	/^  std::string colour() {return Painter.colour[COLOUR];}$/;"	f	class:Grid::Logger
cols	lib/Eigen/src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT
cols	lib/Eigen/src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT
cols	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline StorageIndex cols() const { return internal::convert_index<StorageIndex, Index>(m_cholmodFactor->n); }$/;"	f	class:Eigen::CholmodBase
cols	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper
cols	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper
cols	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index cols() const        { return m_dstExpr.cols(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
cols	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix
cols	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
cols	lib/Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense
cols	lib/Eigen/src/Core/CoreEvaluators.h	/^  Index cols() const $/;"	f	class:Eigen::internal::EvalToTemp
cols	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp
cols	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
cols	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseTernaryOp
cols	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp
cols	lib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView
cols	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index cols() const {return m_cols;}$/;"	f	class:Eigen::DenseStorage
cols	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage
cols	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	lib/Eigen/src/Core/Diagonal.h	/^    inline Index cols() const { return 1; }$/;"	f	class:Eigen::Diagonal
cols	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
cols	lib/Eigen/src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase
cols	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess
cols	lib/Eigen/src/Core/Inverse.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::Inverse
cols	lib/Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase
cols	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue
cols	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline Index cols() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
cols	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase
cols	lib/Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::Product
cols	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::internal::redux_evaluator
cols	lib/Eigen/src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate
cols	lib/Eigen/src/Core/ReturnByValue.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue
cols	lib/Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse
cols	lib/Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select
cols	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView
cols	lib/Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::Solve
cols	lib/Eigen/src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
cols	lib/Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose
cols	lib/Eigen/src/Core/Transpositions.h	/^    Index cols() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
cols	lib/Eigen/src/Core/Transpositions.h	/^    Index cols() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
cols	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase
cols	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView
cols	lib/Eigen/src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr
cols	lib/Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::internal::visitor_evaluator
cols	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
cols	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
cols	lib/Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
cols	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
cols	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
cols	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transform
cols	lib/Eigen/src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence
cols	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
cols	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    Index cols() const { return m_L.cols(); }$/;"	f	class:Eigen::IncompleteCholesky
cols	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT
cols	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return matrix().cols(); }$/;"	f	class:Eigen::IterativeSolverBase
cols	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SolveWithGuess
cols	lib/Eigen/src/LU/FullPivLU.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU
cols	lib/Eigen/src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU
cols	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase
cols	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
cols	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR
cols	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index cols() const { return m_cpqr.cols(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
cols	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR
cols	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
cols	lib/Eigen/src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR
cols	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index cols() const { return m_cR->ncol; }$/;"	f	class:Eigen::SPQR
cols	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct
cols	lib/Eigen/src/SVD/SVDBase.h	/^  inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::SVDBase
cols	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
cols	lib/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::BlockImpl
cols	lib/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
cols	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::BlockImpl
cols	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMapBase
cols	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
cols	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase
cols	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView
cols	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
cols	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector
cols	lib/Eigen/src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView
cols	lib/Eigen/src/SparseLU/SparseLU.h	/^    inline Index cols() const { return m_mat.cols(); }$/;"	f	class:Eigen::SparseLU
cols	lib/Eigen/src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
cols	lib/Eigen/src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
cols	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index cols() { return m_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
cols	lib/Eigen/src/SparseQR/SparseQR.h	/^    inline Index cols() const { return m_pmat.cols();}$/;"	f	class:Eigen::SparseQR
cols	lib/Eigen/src/SparseQR/SparseQR.h	/^  inline Index cols() const { return (std::min)(m_qr.rows(),m_qr.cols()); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
cols	lib/Eigen/src/SparseQR/SparseQR.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct
cols	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase
cols	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return mp_matrix.cols(); }$/;"	f	class:Eigen::UmfPackLU
cols	lib/Eigen/src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base
cols	lib/Eigen/src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base
colsPermutation	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR
colsPermutation	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const PermutationType& colsPermutation() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
colsPermutation	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR
colsPermutation	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    PermutationType colsPermutation() const$/;"	f	class:Eigen::SPQR
colsPermutation	lib/Eigen/src/SparseLU/SparseLU.h	/^    inline const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseLU
colsPermutation	lib/Eigen/src/SparseQR/SparseQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseQR
cols_select	lib/Eigen/src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon186
column_bmod	lib/Eigen/src/SparseLU/SparseLU_column_bmod.h	/^Index SparseLUImpl<Scalar,StorageIndex>::column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv,$/;"	f	class:Eigen::internal::SparseLUImpl
column_dfs	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^Index SparseLUImpl<Scalar,StorageIndex>::column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg,$/;"	f	class:Eigen::internal::SparseLUImpl
column_dfs_traits	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  column_dfs_traits(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, StorageIndex>::GlobalLU_t& glu, SparseLUImpl<Scalar, StorageIndex>& luImpl)$/;"	f	struct:Eigen::internal::column_dfs_traits
column_dfs_traits	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^struct column_dfs_traits : no_assignment_operator$/;"	s	namespace:Eigen::internal
colwise	lib/Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC inline ConstColwiseReturnType colwise() const {$/;"	f	class:Eigen::DenseBase
colwise	lib/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase
commAllocator	lib/allocator/AlignedAllocator.h	/^  commAllocator() throw() { }$/;"	f	class:Grid::commAllocator
commAllocator	lib/allocator/AlignedAllocator.h	/^  commAllocator(const commAllocator&) throw() { }$/;"	f	class:Grid::commAllocator
commAllocator	lib/allocator/AlignedAllocator.h	/^  template<typename _Tp1> commAllocator(const commAllocator<_Tp1>&) throw() { }$/;"	f	class:Grid::commAllocator
commAllocator	lib/allocator/AlignedAllocator.h	/^class commAllocator {$/;"	c	namespace:Grid
comm_buf	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    std::vector<SiteHalfSpinor,alignedAllocator<SiteHalfSpinor> >  comm_buf;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
comm_buf	lib/qcd/action/fermion/WilsonFermion5D.h	/^    std::vector<SiteHalfSpinor,alignedAllocator<SiteHalfSpinor> >  comm_buf;$/;"	m	class:Grid::QCD::WilsonFermion5D
comm_buf	tests/debug/test_Grid_jacobi.cc	/^  std::vector<vobj,alignedAllocator<vobj> >  comm_buf;$/;"	m	class:LinearOperatorJacobi	file:
command	lib/communicator/Communicator_mpi3_leader.cc	/^  int command;$/;"	m	struct:Grid::Descriptor	file:
comms_bytes	lib/stencil/Stencil.h	/^  double comms_bytes;$/;"	m	class:Grid::CartesianStencil
commtime	lib/stencil/Stencil.h	/^  double commtime;$/;"	m	class:Grid::CartesianStencil
communicator	lib/communicator/Communicator_base.h	/^         MPI_Comm communicator;$/;"	m	class:Grid::CartesianCommunicator
communicator_cached	lib/communicator/Communicator_mpi3_leader.cc	/^  static MPI_Comm communicator_cached;$/;"	m	class:Grid::MPIoffloadEngine	file:
communicator_cached	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Comm  MPIoffloadEngine::communicator_cached;$/;"	m	class:Grid::MPIoffloadEngine	file:
communicator_universe	lib/communicator/Communicator_mpi3_leader.cc	/^  static MPI_Comm communicator_universe;$/;"	m	class:Grid::MPIoffloadEngine	file:
communicator_universe	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Comm  MPIoffloadEngine::communicator_universe;$/;"	m	class:Grid::MPIoffloadEngine	file:
communicator_world	lib/communicator/Communicator_base.h	/^  static MPI_Comm communicator_world;$/;"	m	class:Grid::CartesianCommunicator
communicator_world	lib/communicator/Communicator_mpi.cc	/^MPI_Comm CartesianCommunicator::communicator_world;$/;"	m	class:Grid::CartesianCommunicator	file:
communicator_world	lib/communicator/Communicator_mpi3.cc	/^MPI_Comm CartesianCommunicator::communicator_world;$/;"	m	class:Grid::CartesianCommunicator	file:
communicator_world	lib/communicator/Communicator_mpi3_leader.cc	/^MPI_Comm CartesianCommunicator::communicator_world;$/;"	m	class:Grid::CartesianCommunicator	file:
compact_alignment	lib/pugixml/pugixml.cc	/^	static const uintptr_t compact_alignment = 1 << compact_alignment_log2;$/;"	v	file:
compact_alignment_log2	lib/pugixml/pugixml.cc	/^	static const uintptr_t compact_alignment_log2 = 2;$/;"	v	file:
compact_get_page	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_memory_page* compact_get_page(const void* object, int header_offset)$/;"	f
compact_get_value	lib/pugixml/pugixml.cc	/^	template <int header_offset, typename T> PUGI__FN_NO_INLINE T* compact_get_value(const void* object)$/;"	f
compact_hash_table	lib/pugixml/pugixml.cc	/^		compact_hash_table(): _items(0), _capacity(0), _count(0)$/;"	f	class:compact_hash_table
compact_hash_table	lib/pugixml/pugixml.cc	/^	class compact_hash_table$/;"	c	file:
compact_header	lib/pugixml/pugixml.cc	/^		compact_header(xml_memory_page* page, unsigned int flags)$/;"	f	class:compact_header
compact_header	lib/pugixml/pugixml.cc	/^	class compact_header$/;"	c	file:
compact_page_marker	lib/pugixml/pugixml.cc	/^		uint32_t* compact_page_marker;$/;"	m	struct:xml_memory_page	file:
compact_pointer	lib/pugixml/pugixml.cc	/^		compact_pointer(): _data(0)$/;"	f	class:compact_pointer
compact_pointer	lib/pugixml/pugixml.cc	/^	template <typename T, int header_offset, int start = -126> class compact_pointer$/;"	c	file:
compact_pointer_parent	lib/pugixml/pugixml.cc	/^		compact_pointer_parent(): _data(0)$/;"	f	class:compact_pointer_parent
compact_pointer_parent	lib/pugixml/pugixml.cc	/^	template <typename T, int header_offset> class compact_pointer_parent$/;"	c	file:
compact_set_value	lib/pugixml/pugixml.cc	/^	template <int header_offset, typename T> PUGI__FN_NO_INLINE void compact_set_value(const void* object, T* value)$/;"	f
compact_shared_parent	lib/pugixml/pugixml.cc	/^		void* compact_shared_parent;$/;"	m	struct:xml_memory_page	file:
compact_string	lib/pugixml/pugixml.cc	/^		compact_string(): _data(0)$/;"	f	class:compact_string
compact_string	lib/pugixml/pugixml.cc	/^	template <int header_offset, int base_offset> class compact_string$/;"	c	file:
compact_string_base	lib/pugixml/pugixml.cc	/^		char_t* compact_string_base;$/;"	m	struct:xml_memory_page	file:
compare_eq	lib/pugixml/pugixml.cc	/^		template <class Comp> static bool compare_eq(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)$/;"	f	class:xpath_ast_node	file:
compare_rel	lib/pugixml/pugixml.cc	/^		template <class Comp> static bool compare_rel(xpath_ast_node* lhs, xpath_ast_node* rhs, const xpath_context& c, const xpath_stack& stack, const Comp& comp)$/;"	f	class:xpath_ast_node	file:
completeOrthogonalDecomposition	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^MatrixBase<Derived>::completeOrthogonalDecomposition() const {$/;"	f	class:Eigen::MatrixBase
complex_schur_reduce_to_hessenberg	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
complex_schur_reduce_to_hessenberg	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
compressor	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    SimpleCompressor<vobj> compressor;$/;"	m	class:Grid::ScalarInteractionAction
compressor	lib/qcd/utils/CovariantLaplacian.h	/^  SimpleCompressor<vobj> compressor;$/;"	m	class:Grid::QCD::LaplacianAdjointField
compute	lib/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const EigenBase<InputType>& a)$/;"	f	class:Eigen::LDLT
compute	lib/Eigen/src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const EigenBase<InputType>& a)$/;"	f	class:Eigen::LLT
compute	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
compute	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
compute	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur
compute	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver
compute	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^GeneralizedEigenSolver<MatrixType>::compute(const MatrixType& A, const MatrixType& B, bool computeEigenvectors)$/;"	f	class:Eigen::GeneralizedEigenSolver
compute	lib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
compute	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
compute	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    RealQZ<MatrixType>& RealQZ<MatrixType>::compute(const MatrixType& A_in, const MatrixType& B_in, bool computeQZ)$/;"	f	class:Eigen::RealQZ
compute	lib/Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur
compute	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const EigenBase<InputType>& a_matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::Tridiagonalization
compute	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
compute	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
compute	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
compute	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void compute(const MatrixType& mat)$/;"	f	class:Eigen::IncompleteCholesky
compute	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
compute	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
compute	lib/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::FullPivLU
compute	lib/Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::PartialPivLU
compute	lib/Eigen/src/LU/PartialPivLU.h	/^void PartialPivLU<MatrixType>::compute()$/;"	f	class:Eigen::PartialPivLU
compute	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
compute	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
compute	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
compute	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
compute	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
compute	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
compute	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
compute	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
compute	lib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::HouseholderQR
compute	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void compute(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR
compute	lib/Eigen/src/SVD/BDCSVD.h	/^  BDCSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::BDCSVD
compute	lib/Eigen/src/SVD/BDCSVD.h	/^BDCSVD<MatrixType>& BDCSVD<MatrixType>::compute(const MatrixType& matrix, unsigned int computationOptions) $/;"	f	class:Eigen::BDCSVD
compute	lib/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD
compute	lib/Eigen/src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
compute	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
compute	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
compute	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
compute	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
compute	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
compute	lib/Eigen/src/SparseLU/SparseLU.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
compute	lib/Eigen/src/SparseQR/SparseQR.h	/^    void compute(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
compute	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase
compute	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
computeDirect	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
computeFromHessenberg	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)$/;"	f	class:Eigen::ComplexSchur
computeFromHessenberg	lib/Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU)$/;"	f	class:Eigen::RealSchur
computeFromTridiagonal	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeFromTridiagonal(const RealVectorType& diag, const SubDiagonalType& subdiag , int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
computeFromTridiagonal_impl	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^ComputationInfo computeFromTridiagonal_impl(DiagType& diag, SubDiagType& subdiag, const Index maxIterations, bool computeEigenvectors, MatrixType& eivec)$/;"	f	namespace:Eigen::internal
computeInPlace	lib/Eigen/src/LU/FullPivLU.h	/^void FullPivLU<MatrixType>::computeInPlace()$/;"	f	class:Eigen::FullPivLU
computeInPlace	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^void ColPivHouseholderQR<MatrixType>::computeInPlace()$/;"	f	class:Eigen::ColPivHouseholderQR
computeInPlace	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^void CompleteOrthogonalDecomposition<MatrixType>::computeInPlace()$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
computeInPlace	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^void FullPivHouseholderQR<MatrixType>::computeInPlace()$/;"	f	class:Eigen::FullPivHouseholderQR
computeInPlace	lib/Eigen/src/QR/HouseholderQR.h	/^void HouseholderQR<MatrixType>::computeInPlace()$/;"	f	class:Eigen::HouseholderQR
computeInverseAndDetWithCheck	lib/Eigen/src/LU/InverseImpl.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase
computeInverseWithCheck	lib/Eigen/src/LU/InverseImpl.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase
computeNormOfT	lib/Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur
computeNorms	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::computeNorms()$/;"	f	class:Eigen::RealQZ
computeProductBlockingSizes	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(Index& k, Index& m, Index& n, Index num_threads = 1)$/;"	f	namespace:Eigen::internal
computeProductBlockingSizes	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(Index& k, Index& m, Index& n, Index num_threads = 1)$/;"	f	namespace:Eigen::internal
computeRoots	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
computeRotationScaling	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform
computeSVDofM	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::computeSVDofM(Index firstCol, Index n, MatrixXr& U, VectorType& singVals, MatrixXr& V)$/;"	f	class:Eigen::BDCSVD
computeScalingRotation	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform
computeShift	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur
computeShift	lib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur
computeSingVals	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::computeSingVals(const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm,$/;"	f	class:Eigen::BDCSVD
computeSingVecs	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::computeSingVecs$/;"	f	class:Eigen::BDCSVD
computeU	lib/Eigen/src/SVD/SVDBase.h	/^  inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::SVDBase
computeUnblocked	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::computeUnblocked(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
computeV	lib/Eigen/src/SVD/SVDBase.h	/^  inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::SVDBase
compute_inverse	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
compute_inverse	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_size2_helper	lib/Eigen/src/LU/InverseImpl.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size3_helper	lib/Eigen/src/LU/InverseImpl.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size4	lib/Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
compute_inverse_size4	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_inverse_size4	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
conditionMatrix	lib/Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select
conditional	lib/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
conditional	lib/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
conditional_aligned_delete	lib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_delete(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_delete_auto	lib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_delete_auto(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	lib/Eigen/src/Core/util/Memory.h	/^template<> EIGEN_DEVICE_FUNC inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	lib/Eigen/src/Core/util/Memory.h	/^template<bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	lib/Eigen/src/Core/util/Memory.h	/^template<> EIGEN_DEVICE_FUNC inline void* conditional_aligned_malloc<false>(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	lib/Eigen/src/Core/util/Memory.h	/^template<bool Align> EIGEN_DEVICE_FUNC inline void* conditional_aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new	lib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_new(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new_auto	lib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_new_auto(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	lib/Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, std::size_t new_size, std::size_t)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	lib/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new	lib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_realloc_new(T* pts, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new_auto	lib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
config	lib/perfmon/PerfCount.h	/^    uint64_t config;$/;"	m	struct:Grid::PerformanceCounter::__anon691
configLoop	extras/Hadrons/Application.cc	/^void Application::configLoop(void)$/;"	f	class:Application
configLoop	lib/Hadrons/Application.cc	/^void Application::configLoop(void)$/;"	f	class:Application
conformable	lib/lattice/Lattice_base.h	/^void inline conformable(GridBase *lhs,GridBase *rhs)$/;"	f	namespace:Grid
conformable	lib/lattice/Lattice_conformable.h	/^    template<class obj1,class obj2> void conformable(const Lattice<obj1> &lhs,const Lattice<obj2> &rhs)$/;"	f	namespace:Grid
conj	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::numext
conj	lib/simd/Grid_generic.h	219;"	d
conj	lib/simd/Grid_generic.h	238;"	d
conj_expr_if	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet2cd, Packet2cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet2cd, Packet2cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet2cd, Packet2cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet2cd, Packet4d, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4cf, Packet4cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4cf, Packet4cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4cf, Packet4cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4cf, Packet8f, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4d, Packet2cd, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet8f, Packet4cf, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/util/BlasUtil.h	/^struct conj_helper$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
conj_if	lib/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
conj_if	lib/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
conj_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
conj_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct conj_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
conj_prod	lib/Eigen/src/Core/Dot.h	/^  typedef scalar_conj_product_op<typename traits<T>::Scalar,typename traits<U>::Scalar> conj_prod;$/;"	t	struct:Eigen::internal::dot_nocheck
conj_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
conjugate	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline const ConjugateReturnType conjugate() const$/;"	f	class:Eigen::SelfAdjointView
conjugate	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline const ConjugateReturnType conjugate() const$/;"	f	class:Eigen::TriangularView
conjugate	lib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase
conjugate	lib/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence
conjugate	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^conjugate() const$/;"	f
conjugate	lib/lattice/Lattice_reality.h	/^    template<class vobj> inline Lattice<vobj> conjugate(const Lattice<vobj> &lhs){$/;"	f	namespace:Grid
conjugate	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> conjugate(const Grid_simd<S, V> &in) {$/;"	f	namespace:Grid
conjugate	lib/simd/Simd.h	/^  inline ComplexD conjugate(const ComplexD& r){ return(conj(r)); }$/;"	f	namespace:Grid
conjugate	lib/simd/Simd.h	/^  inline ComplexF conjugate(const ComplexF& r ){ return(conj(r)); }$/;"	f	namespace:Grid
conjugate	lib/simd/Simd.h	/^  inline RealD conjugate(const RealD  & r){ return r; }$/;"	f	namespace:Grid
conjugate	lib/simd/Simd.h	/^  inline RealF conjugate(const RealF  & r){ return r; }$/;"	f	namespace:Grid
conjugate	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iMatrix<vtype,N> conjugate(const iMatrix<vtype,N>&r)$/;"	f	namespace:Grid
conjugate	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iVector<vtype,N> conjugate(const iVector<vtype,N>&r)$/;"	f	namespace:Grid
conjugate	lib/tensors/Tensor_reality.h	/^template<class vtype> inline iScalar<vtype> conjugate(const iScalar<vtype>&r)$/;"	f	namespace:Grid
conjugate_gradient	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
conservativeResize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index size, Index, Index cols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}$/;"	f	class:Eigen::DenseStorage
conservativeResize	lib/Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(Index size, Index rows, Index cols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	lib/Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(Index size, Index rows, Index)$/;"	f	class:Eigen::DenseStorage
conservativeResize	lib/Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(Index, Index, Index cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void conservativeResize(Index rows, Index cols) $/;"	f	class:Eigen::SparseMatrix
conservativeResize	lib/Eigen/src/SparseCore/SparseVector.h	/^    void conservativeResize(Index newSize)$/;"	f	class:Eigen::SparseVector
conservativeResizeLike	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
conservative_resize_like_impl	lib/Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl$/;"	s	namespace:Eigen::internal
conservative_resize_like_impl	lib/Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_impl	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, bool sortedInsertion = false)$/;"	f	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
const_blas_data_mapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_ALWAYS_INLINE const_blas_data_mapper(const Scalar *data, Index stride) : blas_data_mapper<const Scalar, Index, StorageOrder>(data, stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper
const_blas_data_mapper	lib/Eigen/src/Core/util/BlasUtil.h	/^class const_blas_data_mapper : public blas_data_mapper<const Scalar, Index, StorageOrder> {$/;"	c	namespace:Eigen::internal
const_cast_derived	lib/Eigen/src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase
const_cast_derived	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase
const_derived	lib/Eigen/src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase
const_iterator	lib/pugixml/pugixml.h	/^		typedef It const_iterator;$/;"	t	class:pugi::xml_object_range
const_iterator	lib/pugixml/pugixml.h	/^		typedef const xpath_node* const_iterator;$/;"	t	class:pugi::xpath_node_set
const_pointer	lib/Eigen/src/Core/util/Memory.h	/^  typedef const T*        const_pointer;$/;"	t	class:Eigen::aligned_allocator
const_pointer	lib/Eigen/src/StlSupport/details.h	/^    typedef const T*        const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
const_pointer	lib/allocator/AlignedAllocator.h	/^    typedef const _Tp *const_pointer;$/;"	t	class:Grid::alignedAllocator
const_pointer	lib/allocator/AlignedAllocator.h	/^  typedef const _Tp* const_pointer;$/;"	t	class:Grid::commAllocator
const_reference	lib/Eigen/src/Core/util/Memory.h	/^  typedef const T&        const_reference;$/;"	t	class:Eigen::aligned_allocator
const_reference	lib/Eigen/src/StlSupport/details.h	/^    typedef const T&        const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection
const_reference	lib/allocator/AlignedAllocator.h	/^    typedef const _Tp &const_reference;$/;"	t	class:Grid::alignedAllocator
const_reference	lib/allocator/AlignedAllocator.h	/^  typedef const _Tp& const_reference;$/;"	t	class:Grid::commAllocator
construct	lib/Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC void construct(const Expression& expr, internal::false_type)$/;"	f	class:Eigen::Ref
construct	lib/Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC void construct(const Expression& expr,internal::true_type)$/;"	f	class:Eigen::Ref
construct	lib/Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC void construct(Expression& expr)$/;"	f	class:Eigen::RefBase
construct	lib/Eigen/src/SparseCore/SparseRef.h	/^    void construct(const Expression& expr, internal::false_type)$/;"	f	class:Eigen::Ref
construct	lib/Eigen/src/SparseCore/SparseRef.h	/^    void construct(const Expression& expr,internal::true_type)$/;"	f	class:Eigen::Ref
construct	lib/Eigen/src/SparseCore/SparseRef.h	/^  void construct(Expression& expr)$/;"	f	class:Eigen::internal::SparseRefBase
construct	lib/allocator/AlignedAllocator.h	/^    void construct(pointer __p){};$/;"	f	class:Grid::alignedAllocator
construct	lib/allocator/AlignedAllocator.h	/^    void construct(pointer __p, const _Tp &__val){$/;"	f	class:Grid::alignedAllocator
construct	lib/allocator/AlignedAllocator.h	/^  void construct(pointer __p) { };$/;"	f	class:Grid::commAllocator
construct	lib/allocator/AlignedAllocator.h	/^  void construct(pointer __p, const _Tp& __val) { };$/;"	f	class:Grid::commAllocator
construct	lib/pugixml/pugixml.cc	/^		static xml_memory_page* construct(void* memory)$/;"	f	struct:xml_memory_page
construct_contfrac	lib/algorithms/approx/Zolotarev.cc	/^static void construct_contfrac(izd *z){$/;"	f	namespace:Grid::Approx
construct_elements_of_array	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline T* construct_elements_of_array(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
construct_partfrac	lib/algorithms/approx/Zolotarev.cc	/^static void construct_partfrac(izd *z) {$/;"	f	namespace:Grid::Approx
constructor_without_unaligned_array_assert	lib/Eigen/src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
container	lib/json/json.hpp	/^        typename IteratorType::reference container;$/;"	m	class:nlohmann::basic_json::iteration_proxy
contains	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
contains	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool contains(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox
contents	lib/pugixml/pugixml.cc	/^		const xpath_lexer_string& contents() const$/;"	f	class:xpath_lexer
contfrac_A	lib/algorithms/approx/Zolotarev.cc	/^static INTERNAL_PRECISION *contfrac_A(INTERNAL_PRECISION *beta,$/;"	f	namespace:Grid::Approx
contfrac_B	lib/algorithms/approx/Zolotarev.cc	/^static INTERNAL_PRECISION *contfrac_B(INTERNAL_PRECISION *beta,$/;"	f	namespace:Grid::Approx
conv_t	lib/simd/Grid_vector_types.h	/^  } conv_t;$/;"	t	class:Grid::Grid_simd	typeref:union:Grid::Grid_simd::conv_t_union
conv_t_union	lib/simd/Grid_vector_types.h	/^    conv_t_union(){};$/;"	f	union:Grid::Grid_simd::conv_t_union
conv_t_union	lib/simd/Grid_vector_types.h	/^  typedef union conv_t_union {$/;"	u	class:Grid::Grid_simd
convert_buffer	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_buffer(char_t*& out_buffer, size_t& out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)$/;"	f
convert_buffer_endian_swap	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_buffer_endian_swap(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)$/;"	f
convert_buffer_latin1	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_buffer_latin1(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size)$/;"	f
convert_buffer_latin1	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_buffer_latin1(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)$/;"	f
convert_buffer_output	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t convert_buffer_output(char_t* \/* r_char *\/, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)$/;"	f
convert_buffer_output	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t convert_buffer_output(char_t* r_char, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)$/;"	f
convert_buffer_utf16	lib/pugixml/pugixml.cc	/^	template <typename opt_swap> PUGI__FN bool convert_buffer_utf16(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)$/;"	f
convert_buffer_utf32	lib/pugixml/pugixml.cc	/^	template <typename opt_swap> PUGI__FN bool convert_buffer_utf32(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)$/;"	f
convert_buffer_utf8	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_buffer_utf8(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size)$/;"	f
convert_index	lib/Eigen/src/Core/util/XprHelper.h	/^inline IndexDest convert_index(const IndexSrc& idx) {$/;"	f	namespace:Eigen::internal
convert_index	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex convert_index(Index idx)$/;"	f	class:Eigen::internal::AmbiVector
convert_index	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    static inline StorageIndex convert_index(const Index idx) {$/;"	f	class:Eigen::SparseMatrixBase
convert_number_to_boolean	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_number_to_boolean(double value)$/;"	f
convert_number_to_mantissa_exponent	lib/pugixml/pugixml.cc	/^	PUGI__FN void convert_number_to_mantissa_exponent(double value, char* buffer, size_t buffer_size, char** out_mantissa, int* out_exponent)$/;"	f
convert_number_to_string	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_string convert_number_to_string(double value, xpath_allocator* alloc)$/;"	f
convert_number_to_string_special	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* convert_number_to_string_special(double value)$/;"	f
convert_path_heap	lib/pugixml/pugixml.cc	/^	PUGI__FN char* convert_path_heap(const wchar_t* str)$/;"	f
convert_string_to_number	lib/pugixml/pugixml.cc	/^	PUGI__FN double convert_string_to_number(const char_t* string)$/;"	f
convert_utf_endian_swap	lib/pugixml/pugixml.cc	/^	template <typename T> PUGI__FN void convert_utf_endian_swap(T* result, const T* data, size_t length)$/;"	f
convert_wchar_endian_swap	lib/pugixml/pugixml.cc	/^	PUGI__FN void convert_wchar_endian_swap(wchar_t* result, const wchar_t* data, size_t length)$/;"	f
copyCoeff	lib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase
copyUV	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::copyUV(const HouseholderU &householderU, const HouseholderV &householderV, const NaiveU &naiveU, const NaiveV &naiveV)$/;"	f	class:Eigen::BDCSVD
copy_backwards	lib/pugixml/pugixml.cc	/^	template <typename I> void copy_backwards(I begin, I end, I target)$/;"	f
copy_bool	lib/Eigen/src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal
copy_to_ucol	lib/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^Index SparseLUImpl<Scalar,StorageIndex>::copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep,$/;"	f	class:Eigen::internal::SparseLUImpl
copy_using_evaluator_DefaultTraversal_CompleteUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_DefaultTraversal_CompleteUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_DefaultTraversal_InnerUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_DefaultTraversal_InnerUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_LinearTraversal_CompleteUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_LinearTraversal_CompleteUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_CompleteUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_CompleteUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_CompleteUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_InnerUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_InnerUnrolling	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_InnerUnrolling<Kernel, Stop, Stop, SrcAlignment, DstAlignment>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_traits	lib/Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_traits$/;"	s	namespace:Eigen::internal
copy_xpath_variable	lib/pugixml/pugixml.cc	/^	PUGI__FN bool copy_xpath_variable(xpath_variable* lhs, const xpath_variable* rhs)$/;"	f
corner	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox
cos	lib/Eigen/src/Core/MathFunctions.h	/^T cos(const T &x) {$/;"	f	namespace:Eigen::numext
cos	lib/Eigen/src/Core/MathFunctions.h	/^double cos(const double &x) { return ::cos(x); }$/;"	f	namespace:Eigen::numext
cos	lib/Eigen/src/Core/MathFunctions.h	/^float cos(const float &x) { return ::cosf(x); }$/;"	f	namespace:Eigen::numext
cos	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half cos(const half& a) {$/;"	f	namespace:Eigen::half_impl
cos	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cos() const$/;"	f
cos	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> cos(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
cosh	lib/Eigen/src/Core/MathFunctions.h	/^T cosh(const T &x) {$/;"	f	namespace:Eigen::numext
cosh	lib/Eigen/src/Core/MathFunctions.h	/^double cosh(const double &x) { return ::cosh(x); }$/;"	f	namespace:Eigen::numext
cosh	lib/Eigen/src/Core/MathFunctions.h	/^float cosh(const float &x) { return ::coshf(x); }$/;"	f	namespace:Eigen::numext
cosh	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cosh() const$/;"	f
count	lib/Eigen/src/Core/BooleanRedux.h	/^inline Eigen::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase
count	lib/Eigen/src/Core/VectorwiseOp.h	/^    const CountReturnType count() const$/;"	f	class:Eigen::VectorwiseOp
count	lib/json/json.hpp	/^    size_type count(typename object_t::key_type key) const$/;"	f	class:nlohmann::basic_json
count	lib/perfmon/PerfCount.h	/^  long long count;$/;"	m	class:Grid::PerformanceCounter
count	lib/perfmon/Stat.h	/^    uint64_t count;     \/\/ number of invocations$/;"	m	class:Grid::PmuStat
counter	lib/pugixml/pugixml.cc	/^		typedef utf16_counter counter;$/;"	t	struct:wchar_selector	file:
counter	lib/pugixml/pugixml.cc	/^		typedef utf32_counter counter;$/;"	t	struct:wchar_selector	file:
counters	lib/perfmon/Stat.h	/^    uint64_t counters[8][256];$/;"	m	class:Grid::PmuStat
countnz	lib/Eigen/src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,StorageIndex>::countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
cp_string	lib/qcd/modules/Modules.cc	/^char cp_string[]         = "CheckPointer";$/;"	m	namespace:Grid	file:
cpuid_is_vendor	lib/Eigen/src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const int vendor[3])$/;"	f	namespace:Eigen::internal
create	extras/Hadrons/Factory.hpp	/^std::unique_ptr<T> Factory<T>::create(const std::string type,$/;"	f	class:Factory
create	lib/Hadrons/Factory.hpp	/^std::unique_ptr<T> Factory<T>::create(const std::string type,$/;"	f	class:Factory
create	lib/json/json.hpp	/^    static T* create(Args&& ... args)$/;"	f	class:nlohmann::basic_json
create	lib/pugixml/pugixml.cc	/^		static xml_stream_chunk* create()$/;"	f	struct:xml_stream_chunk
create	lib/pugixml/pugixml.cc	/^		static xpath_query_impl* create()$/;"	f	struct:xpath_query_impl
create	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_document::create()$/;"	f	class:pugi::xml_document
create	lib/qcd/modules/Factory.h	/^std::unique_ptr<T> Factory<T, CreatorInput>::create(const std::string type,$/;"	f	class:Grid::Factory
createGrid	extras/Hadrons/Environment.cc	/^void Environment::createGrid(const unsigned int Ls)$/;"	f	class:Environment
createGrid	lib/Hadrons/Environment.cc	/^void Environment::createGrid(const unsigned int Ls)$/;"	f	class:Environment
createLattice	extras/Hadrons/Environment.hpp	/^T * Environment::createLattice(const std::string name)$/;"	f	class:Environment
createLattice	extras/Hadrons/Environment.hpp	/^T * Environment::createLattice(const unsigned int address)$/;"	f	class:Environment
createLattice	lib/Hadrons/Environment.hpp	/^T * Environment::createLattice(const std::string name)$/;"	f	class:Environment
createLattice	lib/Hadrons/Environment.hpp	/^T * Environment::createLattice(const unsigned int address)$/;"	f	class:Environment
createLimeRecordHeader	lib/parallelIO/IldgIO.h	/^  int createLimeRecordHeader(std::string message, int MB, int ME, size_t PayloadSize)$/;"	f	class:Grid::QCD::GridLimeWriter
createModule	extras/Hadrons/Application.hpp	/^void Application::createModule(const std::string name)$/;"	f	class:Application
createModule	extras/Hadrons/Application.hpp	/^void Application::createModule(const std::string name,$/;"	f	class:Application
createModule	extras/Hadrons/Environment.cc	/^void Environment::createModule(const std::string name, const std::string type,$/;"	f	class:Environment
createModule	extras/Hadrons/Environment.hpp	/^void Environment::createModule(const std::string name)$/;"	f	class:Environment
createModule	extras/Hadrons/Environment.hpp	/^void Environment::createModule(const std::string name,$/;"	f	class:Environment
createModule	lib/Hadrons/Application.hpp	/^void Application::createModule(const std::string name)$/;"	f	class:Application
createModule	lib/Hadrons/Application.hpp	/^void Application::createModule(const std::string name,$/;"	f	class:Application
createModule	lib/Hadrons/Environment.cc	/^void Environment::createModule(const std::string name, const std::string type,$/;"	f	class:Environment
createModule	lib/Hadrons/Environment.hpp	/^void Environment::createModule(const std::string name)$/;"	f	class:Environment
createModule	lib/Hadrons/Environment.hpp	/^void Environment::createModule(const std::string name,$/;"	f	class:Environment
createTestAlgebra	tests/core/Test_gamma.cc	/^void createTestAlgebra(void)$/;"	f
cross	lib/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross	lib/Eigen/src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
cross3	lib/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross3_impl	lib/Eigen/src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
cross3_impl	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
cross_product_return_type	lib/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase
crossover	extras/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::crossover(Gene &c1, Gene &c2, const Gene &p1,$/;"	f	class:GeneticScheduler
crossover	lib/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::crossover(Gene &c1, Gene &c2, const Gene &p1,$/;"	f	class:GeneticScheduler
cs	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> cs;    $/;"	m	class:Grid::QCD::CayleyFermion5D
cs_tdfs	lib/Eigen/src/OrderingMethods/Amd.h	/^StorageIndex cs_tdfs(StorageIndex j, StorageIndex k, StorageIndex *head, const StorageIndex *next, StorageIndex *post, StorageIndex *stack)$/;"	f	namespace:Eigen::internal
cs_wclear	lib/Eigen/src/OrderingMethods/Amd.h	/^static StorageIndex cs_wclear (StorageIndex mark, StorageIndex lemax, StorageIndex *w, StorageIndex n)$/;"	f	namespace:Eigen::internal
csv	lib/algorithms/approx/Chebyshev.h	/^    void csv(std::ostream &out){$/;"	f	class:Grid::Chebyshev
csv	lib/algorithms/approx/Chebyshev.h	/^    void csv(std::ostream &out){$/;"	f	class:Grid::ChebyshevLanczos
csv	lib/algorithms/approx/MultiShiftFunction.cc	/^void MultiShiftFunction::csv(std::ostream &out)$/;"	f	class:Grid::MultiShiftFunction
csv	lib/algorithms/approx/Remez.cc	/^void AlgRemez::csv(std::ostream & os)$/;"	f	class:AlgRemez
ct_parse_attr	lib/pugixml/pugixml.cc	/^		ct_parse_attr = 2,		\/\/ \\0, &, \\r, ', "$/;"	e	enum:chartype_t	file:
ct_parse_attr_ws	lib/pugixml/pugixml.cc	/^		ct_parse_attr_ws = 4,	\/\/ \\0, &, \\r, ', ", \\n, tab$/;"	e	enum:chartype_t	file:
ct_parse_cdata	lib/pugixml/pugixml.cc	/^		ct_parse_cdata = 16,	\/\/ \\0, ], >, \\r$/;"	e	enum:chartype_t	file:
ct_parse_comment	lib/pugixml/pugixml.cc	/^		ct_parse_comment = 32,	\/\/ \\0, -, >, \\r$/;"	e	enum:chartype_t	file:
ct_parse_pcdata	lib/pugixml/pugixml.cc	/^		ct_parse_pcdata = 1,	\/\/ \\0, &, \\r, <$/;"	e	enum:chartype_t	file:
ct_space	lib/pugixml/pugixml.cc	/^		ct_space = 8,			\/\/ \\r, \\n, space, tab$/;"	e	enum:chartype_t	file:
ct_start_symbol	lib/pugixml/pugixml.cc	/^		ct_start_symbol = 128	\/\/ Any symbol > 127, a-z, A-Z, _, :$/;"	e	enum:chartype_t	file:
ct_symbol	lib/pugixml/pugixml.cc	/^		ct_symbol = 64,			\/\/ Any symbol > 127, a-z, A-Z, 0-9, _, :, -, .$/;"	e	enum:chartype_t	file:
ctrs	lib/perfmon/Stat.h	/^struct ctrs$/;"	s	namespace:Grid
ctx_digit	lib/pugixml/pugixml.cc	/^		ctx_digit = 8,			  \/\/ 0-9$/;"	e	enum:chartypex_t	file:
ctx_special_attr	lib/pugixml/pugixml.cc	/^		ctx_special_attr = 2,     \/\/ Any symbol >= 0 and < 32 (except \\t), &, <, >, "$/;"	e	enum:chartypex_t	file:
ctx_special_pcdata	lib/pugixml/pugixml.cc	/^		ctx_special_pcdata = 1,   \/\/ Any symbol >= 0 and < 32 (except \\t, \\r, \\n), &, <, >$/;"	e	enum:chartypex_t	file:
ctx_start_symbol	lib/pugixml/pugixml.cc	/^		ctx_start_symbol = 4,	  \/\/ Any symbol > 127, a-z, A-Z, _$/;"	e	enum:chartypex_t	file:
ctx_symbol	lib/pugixml/pugixml.cc	/^		ctx_symbol = 16			  \/\/ Any symbol > 127, a-z, A-Z, 0-9, _, -, .$/;"	e	enum:chartypex_t	file:
cube	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cube() const$/;"	f
current	lib/pugixml/pugixml.cc	/^		lexeme_t current() const$/;"	f	class:xpath_lexer
current_pos	lib/pugixml/pugixml.cc	/^		const char_t* current_pos() const$/;"	f	class:xpath_lexer
cwiseAbs	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs() const { return CwiseAbsReturnType(derived()); }$/;"	f
cwiseAbs2	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs2() const { return CwiseAbs2ReturnType(derived()); }$/;"	f
cwiseEqual	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseEqual	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const Scalar& s) const$/;"	f
cwiseInverse	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseInverse() const { return CwiseInverseReturnType(derived()); }$/;"	f
cwiseMax	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMax	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const Scalar &other) const$/;"	f
cwiseMin	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMin	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const Scalar &other) const$/;"	f
cwiseNotEqual	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseNotEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseProduct	lib/Eigen/src/Core/MatrixBase.h	/^    cwiseProduct(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
cwiseProduct	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
cwiseProduct	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseProduct(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseQuotient	lib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseQuotient(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseSign	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSign() const { return CwiseSignReturnType(derived()); }$/;"	f
cwiseSqrt	lib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSqrt() const { return CwiseSqrtReturnType(derived()); }$/;"	f
cyc	lib/perfmon/Stat.h	/^    uint64_t inst, ref, cyc;   \/\/ fixed counters$/;"	m	class:Grid::PmuStat
cyclecount	lib/perfmon/PerfCount.h	/^inline uint64_t cyclecount(void){ $/;"	f	namespace:Grid
cyclefd	lib/perfmon/PerfCount.h	/^  int cyclefd;$/;"	m	class:Grid::PerformanceCounter
cycles	lib/perfmon/PerfCount.h	/^  long long cycles;$/;"	m	class:Grid::PerformanceCounter
d	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  double    d[2];$/;"	m	union:Eigen::internal::__anon308
d	lib/algorithms/approx/Remez.h	/^  int n, d;$/;"	m	class:AlgRemez
d	tests/IO/Test_serialisation.cc	/^double   d   = 2*M_PI;$/;"	v
da	lib/algorithms/approx/Zolotarev.h	/^    dn, dd, da, db,   \/* number of elements of a, ap, alpha, and beta *\/$/;"	m	struct:Grid::Approx::__anon695
dag	lib/qcd/action/fermion/WilsonCompressor.h	/^  int mu,dag;  $/;"	m	class:Grid::QCD::WilsonCompressorTemplate
data	gcc-bug-report/broken.cc	/^  std::vector<obj> data;$/;"	m	class:Container	file:
data	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper
data	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper
data	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper
data	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper
data	lib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline Scalar* data() { return &(this->coeffRef(0)); }$/;"	f	class:Eigen::CwiseUnaryViewImpl
data	lib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return &(this->coeff(0)); }$/;"	f	class:Eigen::CwiseUnaryViewImpl
data	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage
data	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage
data	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	lib/Eigen/src/Core/Diagonal.h	/^    inline ScalarWithConstIfNotLvalue* data() { return &(m_matrix.coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	lib/Eigen/src/Core/Diagonal.h	/^    inline const Scalar* data() const { return &(m_matrix.coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	lib/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	lib/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	lib/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	lib/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() {$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	lib/Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase
data	lib/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase
data	lib/Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase
data	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase
data	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase
data	lib/Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	lib/Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::internal::blas_data_mapper
data	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseVector
data	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseVector
data	lib/pugixml/pugixml.cc	/^			char data[xpath_memory_page_size];$/;"	m	union:xpath_memory_block::__anon685	file:
data	lib/pugixml/pugixml.cc	/^		T data[xml_memory_page_size \/ sizeof(T)];$/;"	m	struct:xml_stream_chunk	file:
data	lib/pugixml/pugixml.cc	/^		T* data;$/;"	m	struct:auto_deleter	file:
data	lib/pugixml/pugixml.cc	/^		char_t* data(xpath_allocator* alloc)$/;"	f	class:xpath_string
data	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_text::data() const$/;"	f	class:pugi::xml_text
dataSetThres_	lib/serialisation/Hdf5IO.h	/^    unsigned int             dataSetThres_;$/;"	m	class:Grid::Hdf5Reader
data_char	lib/pugixml/pugixml.cc	/^			char_t data_char[bufcapacity];$/;"	m	union:xml_buffered_writer::__anon684	file:
data_u16	lib/pugixml/pugixml.cc	/^			uint16_t data_u16[2 * bufcapacity];$/;"	m	union:xml_buffered_writer::__anon684	file:
data_u32	lib/pugixml/pugixml.cc	/^			uint32_t data_u32[bufcapacity];$/;"	m	union:xml_buffered_writer::__anon684	file:
data_u8	lib/pugixml/pugixml.cc	/^			uint8_t data_u8[4 * bufcapacity];$/;"	m	union:xml_buffered_writer::__anon684	file:
db	lib/algorithms/approx/Zolotarev.h	/^    dn, dd, da, db,   \/* number of elements of a, ap, alpha, and beta *\/$/;"	m	struct:Grid::Approx::__anon695
dcomplex	lib/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
dd	lib/algorithms/approx/Zolotarev.h	/^    dn, dd, da, db,   \/* number of elements of a, ap, alpha, and beta *\/$/;"	m	struct:Grid::Approx::__anon695
deallocate	lib/Eigen/src/Core/util/Memory.h	/^  void deallocate(pointer p, size_type \/*num*\/)$/;"	f	class:Eigen::aligned_allocator
deallocate	lib/allocator/AlignedAllocator.h	/^    void deallocate(pointer __p, size_type __n)$/;"	f	class:Grid::alignedAllocator
deallocate	lib/allocator/AlignedAllocator.h	/^  void deallocate(pointer __p, size_type) { $/;"	f	class:Grid::commAllocator
deallocate	lib/pugixml/pugixml.cc	/^		static deallocation_function deallocate;$/;"	m	struct:xml_memory_management_function_storage	file:
deallocate	lib/pugixml/pugixml.cc	/^	template <typename T> deallocation_function xml_memory_management_function_storage<T>::deallocate = default_deallocate;$/;"	m	class:xml_memory_management_function_storage	file:
deallocate_memory	lib/pugixml/pugixml.cc	/^		void deallocate_memory(void* ptr, size_t size, xml_memory_page* page)$/;"	f	struct:xml_allocator
deallocate_page	lib/pugixml/pugixml.cc	/^		static void deallocate_page(xml_memory_page* page)$/;"	f	struct:xml_allocator
deallocate_string	lib/pugixml/pugixml.cc	/^		void deallocate_string(char_t* string)$/;"	f	struct:xml_allocator
deallocation_function	lib/pugixml/pugixml.h	/^	typedef void (*deallocation_function)(void* ptr);$/;"	t	namespace:pugi
debug	lib/Eigen/src/Core/AssignEvaluator.h	/^  static void debug()$/;"	f	struct:Eigen::internal::copy_using_evaluator_traits
debug	lib/Eigen/src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type
debug	lib/Eigen/src/Core/Redux.h	/^  static void debug()$/;"	f	struct:Eigen::internal::redux_traits
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct BandShape              { static std::string debugName() { return "BandShape"; } };$/;"	f	struct:Eigen::BandShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct DenseShape             { static std::string debugName() { return "DenseShape"; } };$/;"	f	struct:Eigen::DenseShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct DiagonalShape          { static std::string debugName() { return "DiagonalShape"; } };$/;"	f	struct:Eigen::DiagonalShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct HomogeneousShape       { static std::string debugName() { return "HomogeneousShape"; } };$/;"	f	struct:Eigen::HomogeneousShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct PermutationShape       { static std::string debugName() { return "PermutationShape"; } };$/;"	f	struct:Eigen::PermutationShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct SelfAdjointShape       { static std::string debugName() { return "SelfAdjointShape"; } };$/;"	f	struct:Eigen::SelfAdjointShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct SolverShape            { static std::string debugName() { return "SolverShape"; } };$/;"	f	struct:Eigen::SolverShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct SparseShape            { static std::string debugName() { return "SparseShape"; } };$/;"	f	struct:Eigen::SparseShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct TranspositionsShape    { static std::string debugName() { return "TranspositionsShape"; } };$/;"	f	struct:Eigen::TranspositionsShape
debugName	lib/Eigen/src/Core/util/Constants.h	/^struct TriangularShape        { static std::string debugName() { return "TriangularShape"; } };$/;"	f	struct:Eigen::TriangularShape
debugName	lib/Eigen/src/SparseCore/SparseUtil.h	/^struct SparseSelfAdjointShape { static std::string debugName() { return "SparseSelfAdjointShape"; } };$/;"	f	struct:Eigen::internal::SparseSelfAdjointShape
debugName	lib/Eigen/src/SparseCore/SparseUtil.h	/^struct SparseTriangularShape  { static std::string debugName() { return "SparseTriangularShape"; } };$/;"	f	struct:Eigen::internal::SparseTriangularShape
dec	lib/Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC const Decomposition& dec() const { return m_dec; }$/;"	f	class:Eigen::Solve
dec	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC const Decomposition& dec()   const { return m_dec; }$/;"	f	class:Eigen::SolveWithGuess
dec	lib/Eigen/src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base
dec	lib/Eigen/src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base
decltype	lib/lattice/Lattice_ET.h	/^    -> decltype(expr.first.func(eval(ss, std::get<0>(expr.second)))) {$/;"	f	namespace:Grid
decltype	lib/lattice/Lattice_ET.h	/^    -> decltype(expr.first.func(eval(ss, std::get<0>(expr.second)),$/;"	f	namespace:Grid
decltype	lib/lattice/Lattice_reduction.h	/^      ->typename decltype(expr.first.func(eval(0,std::get<0>(expr.second)),eval(0,std::get<1>(expr.second))))::scalar_object$/;"	f	namespace:Grid
decltype	lib/lattice/Lattice_reduction.h	/^  ->typename decltype(expr.first.func(eval(0,std::get<0>(expr.second))))::scalar_object$/;"	f	namespace:Grid
decltype	lib/lattice/Lattice_reduction.h	/^  ->typename decltype(expr.first.func(eval(0,std::get<0>(expr.second)),$/;"	f	namespace:Grid
decode_latin1_block	lib/pugixml/pugixml.cc	/^		static inline typename Traits::value_type decode_latin1_block(const uint8_t* data, size_t size, typename Traits::value_type result)$/;"	f	struct:utf_decoder
decode_utf16_block	lib/pugixml/pugixml.cc	/^		static inline typename Traits::value_type decode_utf16_block(const uint16_t* data, size_t size, typename Traits::value_type result)$/;"	f	struct:utf_decoder
decode_utf32_block	lib/pugixml/pugixml.cc	/^		static inline typename Traits::value_type decode_utf32_block(const uint32_t* data, size_t size, typename Traits::value_type result)$/;"	f	struct:utf_decoder
decode_utf8_block	lib/pugixml/pugixml.cc	/^		static inline typename Traits::value_type decode_utf8_block(const uint8_t* data, size_t size, typename Traits::value_type result)$/;"	f	struct:utf_decoder
decode_wchar_block	lib/pugixml/pugixml.cc	/^		static inline typename Traits::value_type decode_wchar_block(const wchar_t* data, size_t size, typename Traits::value_type result)$/;"	f	struct:utf_decoder
decode_wchar_block_impl	lib/pugixml/pugixml.cc	/^		static inline typename Traits::value_type decode_wchar_block_impl(const uint16_t* data, size_t size, typename Traits::value_type result)$/;"	f	struct:utf_decoder
decode_wchar_block_impl	lib/pugixml/pugixml.cc	/^		static inline typename Traits::value_type decode_wchar_block_impl(const uint32_t* data, size_t size, typename Traits::value_type result)$/;"	f	struct:utf_decoder
decompresstime	lib/stencil/Stencil.h	/^  double decompresstime;$/;"	m	class:Grid::CartesianStencil
decrement_size	lib/Eigen/src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
dee	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> dee;    $/;"	m	class:Grid::QCD::CayleyFermion5D
defaultL1CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL1CacheSize = 16*1024;$/;"	m	namespace:Eigen::internal
defaultL1CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL1CacheSize = 32*1024;$/;"	m	namespace:Eigen::internal
defaultL2CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL2CacheSize = 256*1024;$/;"	m	namespace:Eigen::internal
defaultL2CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL2CacheSize = 512*1024;$/;"	m	namespace:Eigen::internal
defaultL3CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL3CacheSize = 2*1024*1024;$/;"	m	namespace:Eigen::internal
defaultL3CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL3CacheSize = 512*1024;$/;"	m	namespace:Eigen::internal
default_alignment	lib/Eigen/src/Core/Matrix.h	/^      default_alignment = compute_default_alignment<_Scalar,max_size>::value,$/;"	e	enum:Eigen::internal::traits::__anon171
default_allocate	lib/pugixml/pugixml.cc	/^	PUGI__FN void* default_allocate(size_t size)$/;"	f
default_deallocate	lib/pugixml/pugixml.cc	/^	PUGI__FN void default_deallocate(void* ptr)$/;"	f
default_digits10_impl	lib/Eigen/src/Core/NumTraits.h	/^struct default_digits10_impl$/;"	s	namespace:Eigen::internal
default_digits10_impl	lib/Eigen/src/Core/NumTraits.h	/^struct default_digits10_impl<T,false,false> \/\/ Floating point$/;"	s	namespace:Eigen::internal
default_digits10_impl	lib/Eigen/src/Core/NumTraits.h	/^struct default_digits10_impl<T,false,true> \/\/ Integer$/;"	s	namespace:Eigen::internal
default_mr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    default_mr = (EIGEN_PLAIN_ENUM_MIN(16,NumberOfRegisters)\/2\/nr)*LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
default_packet_traits	lib/Eigen/src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
default_prunning_func	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    default_prunning_func(const Scalar& ref, const RealScalar& eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
default_prunning_func	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix
deflation	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::deflation(Index firstCol, Index lastCol, Index k, Index firstRowW, Index firstColW, Index shift)$/;"	f	class:Eigen::BDCSVD
deflation43	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::deflation43(Index firstCol, Index shift, Index i, Index size)$/;"	f	class:Eigen::BDCSVD
deflation44	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::deflation44(Index firstColu , Index firstColm, Index firstRowW, Index firstColW, Index i, Index j, Index size)$/;"	f	class:Eigen::BDCSVD
deg_denom	lib/algorithms/approx/Zolotarev.h	/^    deg_denom;	      \/* degree of denominator *\/$/;"	m	struct:Grid::Approx::__anon695
deg_num	lib/algorithms/approx/Zolotarev.h	/^    deg_num,	      \/* degree of numerator = deg_denom +\/- 1 *\/$/;"	m	struct:Grid::Approx::__anon695
degree	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType degree ;  \/* number of principal & non-principal columns in row *\/$/;"	m	union:internal::Colamd_Row::__anon627
degree_next	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType degree_next ; \/* next column, if col is in a degree list *\/$/;"	m	union:internal::colamd_col::__anon626
delete_comma	lib/serialisation/JSON_IO.cc	/^void JSONWriter::delete_comma()$/;"	f	class:JSONWriter
delete_xpath_variable	lib/pugixml/pugixml.cc	/^	PUGI__FN void delete_xpath_variable(xpath_value_type type, xpath_variable* var)$/;"	f
delete_xpath_variable	lib/pugixml/pugixml.cc	/^	template <typename T> PUGI__FN void delete_xpath_variable(T* var)$/;"	f
deleter	lib/pugixml/pugixml.cc	/^		D deleter;$/;"	m	struct:auto_deleter	file:
delta	lib/algorithms/approx/Remez.h	/^  bigfloat delta, spread, tolerance;$/;"	m	class:AlgRemez
delta	lib/qcd/utils/SUnTwoIndex.h	/^inline Real delta(int a, int b) { return (a == b) ? 1.0 : 0.0; }$/;"	f	namespace:Grid::QCD
demangle	lib/log/Log.cc	/^  std::string demangle(const char* name) {$/;"	f	namespace:Grid
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, DefaultTraversal, InnerUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, InnerUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, InnerUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_product_base	lib/Eigen/src/Core/Product.h	/^class dense_product_base$/;"	c	namespace:Eigen::internal
dense_product_base	lib/Eigen/src/Core/Product.h	/^class dense_product_base<Lhs, Rhs, Option, InnerProduct>$/;"	c	namespace:Eigen::internal
dense_xpr_base_dispatcher	lib/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::doxygen
dense_xpr_base_dispatcher	lib/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::doxygen
depth	lib/json/json.hpp	/^        int depth = 0;$/;"	m	class:nlohmann::basic_json::parser
depth	lib/pugixml/pugixml.cc	/^	PUGI__FN int xml_tree_walker::depth() const$/;"	f	class:pugi::xml_tree_walker
depthFirstSearch	extras/Hadrons/Graph.hpp	/^void Graph<T>::depthFirstSearch(const T &root)$/;"	f	class:Graph
depthFirstSearch	extras/Hadrons/Graph.hpp	/^void Graph<T>::depthFirstSearch(void)$/;"	f	class:Graph
depthFirstSearch	lib/Hadrons/Graph.hpp	/^void Graph<T>::depthFirstSearch(const T &root)$/;"	f	class:Graph
depthFirstSearch	lib/Hadrons/Graph.hpp	/^void Graph<T>::depthFirstSearch(void)$/;"	f	class:Graph
depth_select	lib/Eigen/src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon186
deque	lib/Eigen/src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
deque_base	lib/Eigen/src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque
deriv	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual void deriv(const GaugeField &Umu,GaugeField & dSdU) {$/;"	f	class:Grid::QCD::PlaqPlusRectangleAction
deriv	lib/qcd/action/gauge/WilsonGaugeAction.h	/^  virtual void deriv(const GaugeField &U, GaugeField &dSdU) {$/;"	f	class:Grid::QCD::WilsonGaugeAction
deriv	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  virtual void deriv(const GaugeField &U, GaugeField &dSdU) {$/;"	f	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
deriv	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      virtual void deriv(const GaugeField &U,GaugeField & dSdU) {$/;"	f	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
deriv	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      virtual void deriv(const GaugeField &U,GaugeField & dSdU) {$/;"	f	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
deriv	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      virtual void deriv(const GaugeField &U,GaugeField & dSdU) {$/;"	f	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
deriv	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  virtual void deriv(const GaugeField &U, GaugeField &dSdU) {$/;"	f	class:Grid::QCD::TwoFlavourPseudoFermionAction
deriv	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      virtual void deriv(const GaugeField &U,GaugeField & dSdU) {$/;"	f	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
deriv	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      virtual void deriv(const GaugeField &U,GaugeField & dSdU) {$/;"	f	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
deriv	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      virtual void deriv(const GaugeField &U,GaugeField & dSdU) {$/;"	f	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
deriv	lib/qcd/action/scalar/ScalarAction.h	/^    virtual void deriv(const Field &p,$/;"	f	class:Grid::ScalarAction
deriv	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    virtual void deriv(const Field &p, Field &force) {$/;"	f	class:Grid::ScalarInteractionAction
derivative	lib/qcd/smearing/APEsmearing.h	/^	  			void derivative(GaugeField& SigmaTerm,$/;"	f	class:Grid::QCD::Smear_APE
derivative	lib/qcd/smearing/StoutSmearing.h	/^  void derivative(GaugeField& SigmaTerm, const GaugeField& iLambda,$/;"	f	class:Grid::QCD::Smear_Stout
derivative	lib/qcd/smearing/WilsonFlow.h	/^    virtual void derivative(GaugeField&, const GaugeField&, const GaugeField&) const {$/;"	f	class:Grid::QCD::WilsonFlow
derived	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	lib/Eigen/src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	lib/Eigen/src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	lib/Eigen/src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	lib/Eigen/src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	lib/Eigen/src/SVD/SVDBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SVDBase
derived	lib/Eigen/src/SVD/SVDBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SVDBase
derived	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseSolverBase
derived	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseSolverBase
description	lib/pugixml/pugixml.cc	/^	PUGI__FN const char* xml_parse_result::description() const$/;"	f	class:pugi::xml_parse_result
description	lib/pugixml/pugixml.cc	/^	PUGI__FN const char* xpath_parse_result::description() const$/;"	f	class:pugi::xpath_parse_result
dest	lib/communicator/Communicator_mpi3_leader.cc	/^  int dest;$/;"	m	struct:Grid::Descriptor	file:
destroy	lib/allocator/AlignedAllocator.h	/^    void destroy(pointer __p){__p->~_Tp(); };$/;"	f	class:Grid::alignedAllocator
destroy	lib/allocator/AlignedAllocator.h	/^  void destroy(pointer __p) { };$/;"	f	class:Grid::commAllocator
destroy	lib/pugixml/pugixml.cc	/^		static void destroy(xml_stream_chunk* chunk)$/;"	f	struct:xml_stream_chunk
destroy	lib/pugixml/pugixml.cc	/^		static void destroy(xpath_query_impl* impl)$/;"	f	struct:xpath_query_impl
destroy	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_document::destroy()$/;"	f	class:pugi::xml_document
destroy_attribute	lib/pugixml/pugixml.cc	/^	inline void destroy_attribute(xml_attribute_struct* a, xml_allocator& alloc)$/;"	f
destroy_node	lib/pugixml/pugixml.cc	/^	inline void destroy_node(xml_node_struct* n, xml_allocator& alloc)$/;"	f
destruct_elements_of_array	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline void destruct_elements_of_array(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
detect_super_cols	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static void detect_super_cols$/;"	f	namespace:internal
determinant	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Scalar determinant() const$/;"	f	class:Eigen::CholmodBase
determinant	lib/Eigen/src/Core/PermutationMatrix.h	/^    Index determinant() const$/;"	f	class:Eigen::PermutationBase
determinant	lib/Eigen/src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView
determinant	lib/Eigen/src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase
determinant	lib/Eigen/src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU
determinant	lib/Eigen/src/LU/PartialPivLU.h	/^typename PartialPivLU<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU
determinant	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky
determinant	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT
determinant	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT
determinant	lib/Eigen/src/SparseLU/SparseLU.h	/^    Scalar determinant()$/;"	f	class:Eigen::SparseLU
determinant	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU
determinant	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU
determinant_impl	lib/Eigen/src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
determinant_impl	lib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
determinant_impl	lib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
determinant_impl	lib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
determinant_impl	lib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
device	lib/Eigen/src/Core/util/Meta.h	/^namespace device {$/;"	n	namespace:Eigen::internal
devnull	lib/log/Log.h	/^  static std::ostream devnull;$/;"	m	class:Grid::Logger
dfs_kernel	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,StorageIndex>::dfs_kernel(const StorageIndex jj, IndexVector& perm_r,$/;"	f	class:Eigen::internal::SparseLUImpl
diagonal	lib/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	lib/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	lib/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	lib/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	lib/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	lib/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	lib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::MatrixBase
diagonal	lib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::MatrixBase
diagonal	lib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::MatrixBase
diagonal	lib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::MatrixBase
diagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper
diagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	lib/Eigen/src/Core/SelfAdjointView.h	/^    typename MatrixType::ConstDiagonalReturnType diagonal() const$/;"	f	class:Eigen::SelfAdjointView
diagonal	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization
diagonal	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline CwiseBinaryOp< internal::scalar_difference_op<Scalar,Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox
diagonal	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    DiagonalReturnType diagonal() { return DiagonalReturnType(*this); }$/;"	f	class:Eigen::SparseMatrix
diagonal	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    const ConstDiagonalReturnType diagonal() const { return ConstDiagonalReturnType(*this); }$/;"	f	class:Eigen::SparseMatrix
diagonalLength	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonalSize	lib/Eigen/src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (numext::mini)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase
diagonal_product_evaluator_base	lib/Eigen/src/Core/ProductEvaluators.h	/^  diagonal_product_evaluator_base(const MatrixType &mat, const DiagonalType &diag)$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
diagonal_product_evaluator_base	lib/Eigen/src/Core/ProductEvaluators.h	/^struct diagonal_product_evaluator_base$/;"	s	namespace:Eigen::internal
diagonalisation	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  IRLdiagonalisation diagonalisation;$/;"	m	class:Grid::ImplicitlyRestartedLanczos
diagonalize	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void diagonalize(std::vector<RealD>& lmd, std::vector<RealD>& lme, $/;"	f	class:Grid::ImplicitlyRestartedLanczos
diagonalize_Eigen	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void diagonalize_Eigen(std::vector<RealD>& lmd, std::vector<RealD>& lme, $/;"	f	class:Grid::ImplicitlyRestartedLanczos
diagonalize_QR	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void diagonalize_QR(std::vector<RealD>& lmd, std::vector<RealD>& lme, $/;"	f	class:Grid::ImplicitlyRestartedLanczos
diagonalize_lapack	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^void diagonalize_lapack(std::vector<RealD>& lmd,$/;"	f	class:Grid::ImplicitlyRestartedLanczos
diff	lib/json/json.hpp	/^    static basic_json diff(const basic_json& source,$/;"	f	class:nlohmann::basic_json
difference_type	lib/Eigen/src/Core/util/Memory.h	/^  typedef std::ptrdiff_t  difference_type;$/;"	t	class:Eigen::aligned_allocator
difference_type	lib/Eigen/src/StlSupport/details.h	/^    typedef std::ptrdiff_t  difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection
difference_type	lib/allocator/AlignedAllocator.h	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:Grid::alignedAllocator
difference_type	lib/allocator/AlignedAllocator.h	/^  typedef std::ptrdiff_t  difference_type;$/;"	t	class:Grid::commAllocator
difference_type	lib/pugixml/pugixml.h	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_attribute_iterator
difference_type	lib/pugixml/pugixml.h	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_named_node_iterator
difference_type	lib/pugixml/pugixml.h	/^		typedef ptrdiff_t difference_type;$/;"	t	class:pugi::xml_node_iterator
digamma	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^digamma() const$/;"	f
dim	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size() : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox
dim	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane
dim	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine
dim_	extras/Hadrons/Environment.hpp	/^    std::vector<int>                       dim_;$/;"	m	class:Environment
dim_	lib/Hadrons/Environment.hpp	/^    std::vector<int>                       dim_;$/;"	m	class:Environment
dim_	lib/serialisation/BaseIO.h	/^    std::vector<size_t>        dim_;$/;"	m	class:Grid::Reconstruct
dim_	lib/serialisation/BaseIO.h	/^    std::vector<size_t>  dim_;$/;"	m	class:Grid::Flatten
dimensionOfKernel	lib/Eigen/src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU
dimensionOfKernel	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR
dimensionOfKernel	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index dimensionOfKernel() const { return m_cpqr.dimensionOfKernel(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
dimensionOfKernel	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR
dimensions	lib/algorithms/FFT.h	/^    std::vector<int> dimensions;$/;"	m	class:Grid::FFT
dirPlaquette	extras/qed-fvol/WilsonLoops.h	/^  static void dirPlaquette(GaugeMat &plaq, const std::vector<GaugeMat> &U,$/;"	f	class:NewWilsonLoops
dirPlaquette	lib/qcd/utils/WilsonLoops.h	/^  static void dirPlaquette(GaugeMat &plaq, const std::vector<GaugeMat> &U,$/;"	f	class:Grid::QCD::WilsonLoops
dirRectangle	lib/qcd/utils/WilsonLoops.h	/^  static void dirRectangle(GaugeMat &rect, const std::vector<GaugeMat> &U,$/;"	f	class:Grid::QCD::WilsonLoops
direct_selfadjoint_eigenvalues	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
direction	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
directions	lib/algorithms/CoarsenedMatrix.h	/^    std::vector<int> directions   ;$/;"	m	class:Grid::Geometry
directions	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  static const std::vector<int> directions;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermionStatic
directions	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      static const std::vector<int> directions;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5DStatic
directions	lib/qcd/action/fermion/WilsonFermion.h	/^  static const std::vector<int> directions;$/;"	m	class:Grid::QCD::WilsonFermionStatic
directions	lib/qcd/action/fermion/WilsonFermion5D.h	/^      static const std::vector<int> directions;$/;"	m	class:Grid::QCD::WilsonFermion5DStatic
directions	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    std::vector<int> directions;\/\/    = {0,1,2,3,0,1,2,3};  \/\/ forcing 4 dimensions$/;"	m	class:Grid::ScalarInteractionAction
directions	lib/qcd/utils/CovariantLaplacian.h	/^  std::vector<int> directions    = {0,1,2,3,0,1,2,3};  \/\/ forcing 4 dimensions$/;"	m	class:Grid::QCD::LaplacianAdjointField
discard	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void discard(uint64_t z)$/;"	f	class:sitmo::prng_engine
displacements	lib/algorithms/CoarsenedMatrix.h	/^    std::vector<int> displacements;$/;"	m	class:Grid::Geometry
displacements	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  static const std::vector<int> displacements;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermionStatic
displacements	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      static const std::vector<int> displacements;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5DStatic
displacements	lib/qcd/action/fermion/WilsonFermion.h	/^  static const std::vector<int> displacements;$/;"	m	class:Grid::QCD::WilsonFermionStatic
displacements	lib/qcd/action/fermion/WilsonFermion5D.h	/^      static const std::vector<int> displacements;$/;"	m	class:Grid::QCD::WilsonFermion5DStatic
displacements	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    std::vector<int> displacements;\/\/  = {1,1,1,1, -1,-1,-1,-1};$/;"	m	class:Grid::ScalarInteractionAction
displacements	lib/qcd/utils/CovariantLaplacian.h	/^  std::vector<int> displacements = {1,1,1,1, -1,-1,-1,-1};$/;"	m	class:Grid::QCD::LaplacianAdjointField
distance	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC RealScalar distance(const VectorType& p) const { EIGEN_USING_STD_MATH(sqrt) return sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine
div	lib/lattice/Lattice_unary.h	/^  template<class obj> Lattice<obj> div(const Lattice<obj> &rhs,Integer y){$/;"	f	namespace:Grid
div	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> div(const Grid_simd<S, V> &r, Integer y) {$/;"	f	namespace:Grid
div_assign_op	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar, typename SrcScalar=DstScalar> struct div_assign_op {$/;"	s	namespace:Eigen::internal
div_ceil	lib/Eigen/src/Core/util/Meta.h	/^T div_ceil(const T &a, const T &b)$/;"	f	namespace:numext
divide	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::divide (Index firstCol, Index lastCol, Index firstRowW, Index firstColW, Index shift)$/;"	f	class:Eigen::BDCSVD
dn	lib/algorithms/approx/Zolotarev.h	/^    dn, dd, da, db,   \/* number of elements of a, ap, alpha, and beta *\/$/;"	m	struct:Grid::Approx::__anon695
doComputeEigenvectors	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(RealScalar matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver
doComputeEigenvectors	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver
doCrossover	extras/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::doCrossover(void)$/;"	f	class:GeneticScheduler
doCrossover	lib/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::doCrossover(void)$/;"	f	class:GeneticScheduler
doMutation	extras/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::doMutation(void)$/;"	f	class:GeneticScheduler
doMutation	lib/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::doMutation(void)$/;"	f	class:GeneticScheduler
do_pop	lib/serialisation/JSON_IO.h	/^    std::vector<bool>   do_pop;$/;"	m	class:Grid::JSONReader
doc_	lib/serialisation/XmlIO.h	/^    pugi::xml_document doc_;$/;"	m	class:Grid::XmlReader
doc_	lib/serialisation/XmlIO.h	/^    pugi::xml_document doc_;$/;"	m	class:Grid::XmlWriter
document_buffer_order	lib/pugixml/pugixml.cc	/^	PUGI__FN const void* document_buffer_order(const xpath_node& xnode)$/;"	f
document_element	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_document::document_element() const$/;"	f	class:pugi::xml_document
document_order_comparator	lib/pugixml/pugixml.cc	/^	struct document_order_comparator$/;"	s	file:
dot	lib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
dot	lib/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_DEVICE_FUNC inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase
dot	lib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot	lib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot_nocheck	lib/Eigen/src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
dot_nocheck	lib/Eigen/src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
doxygen	lib/Eigen/src/Core/PlainObjectBase.h	/^namespace doxygen {$/;"	n	namespace:Eigen
dparm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<double,DPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase
dparm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase
dryRun	extras/Hadrons/Environment.cc	/^void Environment::dryRun(const bool isDry)$/;"	f	class:Environment
dryRun	lib/Hadrons/Environment.cc	/^void Environment::dryRun(const bool isDry)$/;"	f	class:Environment
dstDataPtr	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC const Scalar* dstDataPtr() const$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
dstEvaluator	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC DstEvaluatorType& dstEvaluator() { return m_dst; }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
dummy_node_set	lib/pugixml/pugixml.cc	/^	static const xpath_node_set dummy_node_set;$/;"	v	file:
dummy_precision	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half dummy_precision() { return Eigen::half(1e-2f); }$/;"	f	struct:Eigen::NumTraits
dump	lib/json/json.hpp	/^    string_t dump(const int indent = -1) const$/;"	f	class:nlohmann::basic_json
dumpMemory	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::CholmodBase
dumpMemory	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase
dumpMemory	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::SuperLUBase
dump_meta_data	lib/parallelIO/MetaData.h	137;"	d
duplicate_comparator	lib/pugixml/pugixml.cc	/^	struct duplicate_comparator$/;"	s	file:
duplicate_string	lib/pugixml/pugixml.cc	/^		static char_t* duplicate_string(const char_t* string, size_t length, xpath_allocator* alloc)$/;"	f	class:xpath_string	file:
dw_diag	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      RealD dw_diag;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
dw_diag	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      RealD dw_diag;$/;"	m	class:Grid::QCD::PartialFractionFermion5D
e	lib/qcd/hmc/HMCRunnerModule.h	/^  HMCRunnerModuleFactory(const HMCRunnerModuleFactory& e) = delete;$/;"	m	class:Grid::HMCRunnerModuleFactory
e	lib/qcd/hmc/HMCRunnerModule.h	/^  void operator=(const HMCRunnerModuleFactory& e) = delete;$/;"	m	class:Grid::HMCRunnerModuleFactory
e	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  HMC_CPModuleFactory(const HMC_CPModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_CPModuleFactory
e	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  void operator=(const HMC_CPModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_CPModuleFactory
e	lib/qcd/modules/ActionModules.h	/^  HMC_ActionModuleFactory(const HMC_ActionModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_ActionModuleFactory
e	lib/qcd/modules/ActionModules.h	/^  void operator=(const HMC_ActionModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_ActionModuleFactory
e	lib/qcd/modules/FermionOperatorModules.h	/^  HMC_FermionOperatorModuleFactory(const HMC_FermionOperatorModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_FermionOperatorModuleFactory
e	lib/qcd/modules/FermionOperatorModules.h	/^  void operator=(const HMC_FermionOperatorModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_FermionOperatorModuleFactory
e	lib/qcd/modules/ObservableModules.h	/^  HMC_ObservablesModuleFactory(const HMC_ObservablesModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_ObservablesModuleFactory
e	lib/qcd/modules/ObservableModules.h	/^  void operator=(const HMC_ObservablesModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_ObservablesModuleFactory
e	lib/qcd/modules/SolverModules.h	/^  HMC_SolverModuleFactory(const HMC_SolverModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_SolverModuleFactory
e	lib/qcd/modules/SolverModules.h	/^  void operator=(const HMC_SolverModuleFactory& e) = delete;$/;"	m	class:Grid::HMC_SolverModuleFactory
edc_hite	lib/perfmon/Stat.h	/^  int edc_hite[NEDC];$/;"	m	struct:Grid::knl_gbl_
edc_hitm	lib/perfmon/Stat.h	/^  int edc_hitm[NEDC];$/;"	m	struct:Grid::knl_gbl_
edc_misse	lib/perfmon/Stat.h	/^  int edc_misse[NEDC];$/;"	m	struct:Grid::knl_gbl_
edc_missm	lib/perfmon/Stat.h	/^  int edc_missm[NEDC];$/;"	m	struct:Grid::knl_gbl_
edc_rd	lib/perfmon/Stat.h	/^  int edc_rd[NEDC];$/;"	m	struct:Grid::knl_gbl_
edc_wr	lib/perfmon/Stat.h	/^  int edc_wr[NEDC];$/;"	m	struct:Grid::knl_gbl_
edchite	lib/perfmon/Stat.h	/^    uint64_t edchite[NEDC];$/;"	m	struct:Grid::ctrs
edchitm	lib/perfmon/Stat.h	/^    uint64_t edchitm[NEDC];$/;"	m	struct:Grid::ctrs
edcmisse	lib/perfmon/Stat.h	/^    uint64_t edcmisse[NEDC];$/;"	m	struct:Grid::ctrs
edcmissm	lib/perfmon/Stat.h	/^    uint64_t edcmissm[NEDC];$/;"	m	struct:Grid::ctrs
edcrd	lib/perfmon/Stat.h	/^    uint64_t edcrd[NEDC]; $/;"	m	struct:Grid::ctrs
edcwr	lib/perfmon/Stat.h	/^    uint64_t edcwr[NEDC];$/;"	m	struct:Grid::ctrs
edgeSet_	extras/Hadrons/Graph.hpp	/^    std::set<Edge>     edgeSet_;$/;"	m	class:Graph
edgeSet_	lib/Hadrons/Graph.hpp	/^    std::set<Edge>     edgeSet_;$/;"	m	class:Graph
ei_declare_aligned_stack_constructed_variable	lib/Eigen/src/Core/util/Memory.h	634;"	d
eigen_assert	lib/Eigen/src/Core/util/Macros.h	577;"	d
eigen_internal_assert	lib/Eigen/src/Core/util/Macros.h	581;"	d
eigen_packet_wrapper	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE eigen_packet_wrapper() {}$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
eigen_packet_wrapper	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE eigen_packet_wrapper(const T &v) : m_val(v) {}$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
eigen_packet_wrapper	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct eigen_packet_wrapper$/;"	s	namespace:Eigen::internal
eigen_pastix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_plain_assert	lib/Eigen/src/Core/util/Macros.h	539;"	d
eigen_plain_assert	lib/Eigen/src/Core/util/Macros.h	547;"	d
eigen_unaligned_array_assert_workaround_gcc47	lib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }$/;"	f	namespace:Eigen::internal
eigenvalues	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvalues	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver
eigenvalues	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvalueType eigenvalues() const$/;"	f	class:Eigen::GeneralizedEigenSolver
eigenvalues	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase
eigenvalues	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView
eigenvalues	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
eigenvalues_selector	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
eigenvalues_selector	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
eigenvectors	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvectors	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver
eigenvectors	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvectorsType eigenvectors() const {$/;"	f	class:Eigen::GeneralizedEigenSolver
eigenvectors	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const EigenvectorsType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
elapsed	lib/perfmon/PerfCount.h	/^  unsigned long long elapsed;$/;"	m	class:Grid::PerformanceCounter
element	lib/serialisation/BaseIO.h	/^  struct element$/;"	s	namespace:Grid
element	lib/serialisation/BaseIO.h	/^  struct element<std::vector<T>>$/;"	s	namespace:Grid
element	lib/tensors/Tensor_class.h	/^  typedef vtype element;$/;"	t	class:Grid::iMatrix
element	lib/tensors/Tensor_class.h	/^  typedef vtype element;$/;"	t	class:Grid::iScalar
element	lib/tensors/Tensor_class.h	/^  typedef vtype element;$/;"	t	class:Grid::iVector
elseMatrix	lib/Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select
emplace	lib/json/json.hpp	/^    std::pair<iterator, bool> emplace(Args&& ... args)$/;"	f	class:nlohmann::basic_json
emplace_back	lib/json/json.hpp	/^    void emplace_back(Args&& ... args)$/;"	f	class:nlohmann::basic_json
empty	lib/pugixml/pugixml.cc	/^		bool empty() const$/;"	f	class:xpath_node_set_raw
empty	lib/pugixml/pugixml.cc	/^		bool empty() const$/;"	f	class:xpath_string
empty	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::empty() const$/;"	f	class:pugi::xml_attribute
empty	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::empty() const$/;"	f	class:pugi::xml_node
empty	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::empty() const$/;"	f	class:pugi::xml_text
empty	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_node_set::empty() const$/;"	f	class:pugi::xpath_node_set
emptyIdxLU	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^enum {emptyIdxLU = -1};$/;"	e	enum:Eigen::internal::__anon659
enable_if	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
enable_if_ref	lib/Eigen/src/LU/PartialPivLU.h	/^struct enable_if_ref<Ref<T>,Derived> {$/;"	s	namespace:Eigen::internal
encoding	lib/pugixml/pugixml.cc	/^		xml_encoding encoding;$/;"	m	class:xml_buffered_writer	file:
encoding	lib/pugixml/pugixml.h	/^		xml_encoding encoding;$/;"	m	struct:pugi::xml_parse_result
encoding_auto	lib/pugixml/pugixml.h	/^		encoding_auto,		\/\/ Auto-detect input encoding using BOM or < \/ <? detection; use UTF8 if BOM is not found$/;"	e	enum:pugi::xml_encoding
encoding_latin1	lib/pugixml/pugixml.h	/^		encoding_latin1$/;"	e	enum:pugi::xml_encoding
encoding_utf16	lib/pugixml/pugixml.h	/^		encoding_utf16,		\/\/ UTF16 with native endianness$/;"	e	enum:pugi::xml_encoding
encoding_utf16_be	lib/pugixml/pugixml.h	/^		encoding_utf16_be,	\/\/ Big-endian UTF16$/;"	e	enum:pugi::xml_encoding
encoding_utf16_le	lib/pugixml/pugixml.h	/^		encoding_utf16_le,	\/\/ Little-endian UTF16$/;"	e	enum:pugi::xml_encoding
encoding_utf32	lib/pugixml/pugixml.h	/^		encoding_utf32,		\/\/ UTF32 with native endianness$/;"	e	enum:pugi::xml_encoding
encoding_utf32_be	lib/pugixml/pugixml.h	/^		encoding_utf32_be,	\/\/ Big-endian UTF32$/;"	e	enum:pugi::xml_encoding
encoding_utf32_le	lib/pugixml/pugixml.h	/^		encoding_utf32_le,	\/\/ Little-endian UTF32$/;"	e	enum:pugi::xml_encoding
encoding_utf8	lib/pugixml/pugixml.h	/^		encoding_utf8,		\/\/ UTF8 encoding$/;"	e	enum:pugi::xml_encoding
encoding_wchar	lib/pugixml/pugixml.h	/^		encoding_wchar,		\/\/ The same encoding wchar_t has (either UTF16 or UTF32)$/;"	e	enum:pugi::xml_encoding
encrypt_counter	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void encrypt_counter()$/;"	f	class:sitmo::prng_engine
end	lib/lattice/Lattice_base.h	/^    int end(void)   { return _odata.size(); }$/;"	f	class:Grid::Lattice
end	lib/pugixml/pugixml.cc	/^		char_t* end;$/;"	m	struct:gap	file:
end	lib/pugixml/pugixml.cc	/^		const char_t* end;$/;"	m	struct:xpath_lexer_string	file:
end	lib/pugixml/pugixml.cc	/^		xpath_node* end() const$/;"	f	class:xpath_node_set_raw
end	lib/pugixml/pugixml.cc	/^	PUGI__FN bool convert_string_to_number_scratch(char_t (&buffer)[32], const char_t* begin, const char_t* end, double* out_result)$/;"	v
end	lib/pugixml/pugixml.cc	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
end	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_tree_walker::end(xml_node&)$/;"	f	class:pugi::xml_tree_walker
end	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node::iterator xml_node::end() const$/;"	f	class:pugi::xml_node
end	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::const_iterator xpath_node_set::end() const$/;"	f	class:pugi::xpath_node_set
end	lib/pugixml/pugixml.h	/^		It end() const { return _end; }$/;"	f	class:pugi::xml_object_range
endFill	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector
end_array	lib/json/json.hpp	/^            end_array,       \/\/\/< the character for array end `]`$/;"	m	class:nlohmann::basic_json::lexer::token_type
end_object	lib/json/json.hpp	/^            end_object,      \/\/\/< the character for object end `}`$/;"	m	class:nlohmann::basic_json::lexer::token_type
end_value	lib/json/json.hpp	/^        static constexpr difference_type end_value = begin_value + 1;$/;"	m	class:nlohmann::basic_json::primitive_iterator_t
endian_swap	lib/pugixml/pugixml.cc	/^	inline uint16_t endian_swap(uint16_t value)$/;"	f
endian_swap	lib/pugixml/pugixml.cc	/^	inline uint32_t endian_swap(uint32_t value)$/;"	f
energyDensityPlaquette	lib/qcd/smearing/WilsonFlow.h	/^RealD WilsonFlow<Gimpl>::energyDensityPlaquette(const GaugeField& U) const {$/;"	f	class:Grid::QCD::WilsonFlow
energyDensityPlaquette	lib/qcd/smearing/WilsonFlow.h	/^RealD WilsonFlow<Gimpl>::energyDensityPlaquette(unsigned int step, const GaugeField& U) const {$/;"	f	class:Grid::QCD::WilsonFlow
enter	lib/perfmon/Stat.cc	/^void PmuStat::enter(int t)$/;"	f	class:Grid::PmuStat
env	extras/Hadrons/Application.cc	/^Environment & Application::env(void) const$/;"	f	class:Application
env	extras/Hadrons/Module.cc	/^Environment & ModuleBase::env(void) const$/;"	f	class:ModuleBase
env	lib/Hadrons/Application.cc	/^Environment & Application::env(void) const$/;"	f	class:Application
env	lib/Hadrons/Module.cc	/^Environment & ModuleBase::env(void) const$/;"	f	class:ModuleBase
env_	extras/Hadrons/Module.hpp	/^    Environment &env_;$/;"	m	class:ModuleBase
env_	lib/Hadrons/Module.hpp	/^    Environment &env_;$/;"	m	class:ModuleBase
epsilon	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half epsilon() {$/;"	f	struct:Eigen::NumTraits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static T epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static double epsilon() { return __DBL_EPSILON__; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static float epsilon() { return __FLT_EPSILON__; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static int epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static long long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned int epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned long long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
epsilon	lib/Eigen/src/SparseCore/SparseView.h	/^  RealScalar epsilon() const { return m_epsilon; }$/;"	f	class:Eigen::SparseView
epsilon	lib/algorithms/approx/Zolotarev.h	/^    epsilon;	      \/* minimum x value, epsilon < |x| < 1 *\/$/;"	m	struct:Grid::Approx::__anon695
epsilon	lib/qcd/smearing/WilsonFlow.h	/^    mutable RealD epsilon, taus;$/;"	m	class:Grid::QCD::WilsonFlow
equal_to	lib/pugixml/pugixml.cc	/^	struct equal_to$/;"	s	file:
equations	lib/algorithms/approx/Remez.cc	/^void AlgRemez::equations(void) {$/;"	f	class:AlgRemez
erase	lib/json/json.hpp	/^    IteratorType erase(IteratorType first, IteratorType last)$/;"	f	class:nlohmann::basic_json
erase	lib/json/json.hpp	/^    IteratorType erase(IteratorType pos)$/;"	f	class:nlohmann::basic_json
erase	lib/json/json.hpp	/^    size_type erase(const typename object_t::key_type& key)$/;"	f	class:nlohmann::basic_json
erase	lib/json/json.hpp	/^    void erase(const size_type idx)$/;"	f	class:nlohmann::basic_json
eresid	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  RealD eresid;$/;"	m	class:Grid::ImplicitlyRestartedLanczos
erf	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^erf() const$/;"	f
erfc	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^erfc() const$/;"	f
err	benchmarks/Benchmark_comms.cc	/^  double err;$/;"	m	struct:time_statistics	file:
error	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase
error	lib/pugixml/pugixml.h	/^		const char* error;$/;"	m	struct:pugi::xpath_parse_result
error_handler	lib/pugixml/pugixml.cc	/^		jmp_buf error_handler;$/;"	m	struct:xpath_stack_data	file:
error_handler	lib/pugixml/pugixml.cc	/^		jmp_buf* error_handler;$/;"	m	class:xpath_allocator	file:
error_offset	lib/pugixml/pugixml.cc	/^		char_t* error_offset;$/;"	m	struct:xml_parser	file:
error_status	lib/pugixml/pugixml.cc	/^		xml_parse_status error_status;$/;"	m	struct:xml_parser	file:
escape	lib/json/json.hpp	/^        static std::string escape(std::string s)$/;"	f	class:nlohmann::basic_json::json_pointer
essentialVector	lib/Eigen/src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence
essentialVector	lib/Eigen/src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etree_find	lib/Eigen/src/SparseCore/SparseColEtree.h	/^Index etree_find (Index i, IndexVector& pp)$/;"	f	namespace:Eigen::internal
eulerAngles	lib/Eigen/src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase
eval	lib/Eigen/src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase
eval	lib/Eigen/src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return derived(); }$/;"	f	class:Eigen::InverseImpl
eval	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase
eval	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal
eval	lib/lattice/Lattice_ET.h	/^inline const lobj &eval(const unsigned int ss, const Lattice<lobj> &arg) {$/;"	f	namespace:Grid
eval	lib/lattice/Lattice_ET.h	/^inline sobj eval(const unsigned int ss, const sobj &arg)$/;"	f	namespace:Grid
evalTo	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper
evalTo	lib/Eigen/src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase
evalTo	lib/Eigen/src/Core/DenseBase.h	/^    inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase
evalTo	lib/Eigen/src/Core/EigenBase.h	/^  inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
evalTo	lib/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::InverseImpl
evalTo	lib/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl_base
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static inline void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Inverse<Lhs>& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Inverse<Rhs>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Transpose<Rhs>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Transpose<Lhs>& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue
evalTo	lib/Eigen/src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval
evalTo	lib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
evalTo	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
evalTo	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
evalTo	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void evalTo(Dest& dst, const Homogeneous<LhsArg,Horizontal>& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void evalTo(Dest& dst, const Lhs& lhs, const Homogeneous<RhsArg,Vertical>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void evalTo(Dest& dst, const TransformType& lhs, const Homogeneous<RhsArg,Vertical>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Geometry/Homogeneous.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Homogeneous<RhsArg,Vertical>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> EIGEN_DEVICE_FUNC void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
evalTo	lib/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> EIGEN_DEVICE_FUNC void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
evalTo	lib/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	lib/Eigen/src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	lib/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval
evalTo	lib/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval
evalTo	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  void evalTo(ResType& res) const$/;"	f	struct:Eigen::SPQR_QProduct
evalTo	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, DenseShape)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, SparseShape)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	lib/Eigen/src/SparseQR/SparseQR.h	/^  void evalTo(DesType& res) const$/;"	f	struct:Eigen::SparseQR_QProduct
evalTo	lib/Eigen/src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base
evalTo	lib/Eigen/src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base
evalToLazy	lib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
eval_boolean	lib/pugixml/pugixml.cc	/^		bool eval_boolean(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node
eval_node_set	lib/pugixml/pugixml.cc	/^		xpath_node_set_raw eval_node_set(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node
eval_number	lib/pugixml/pugixml.cc	/^		double eval_number(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node
eval_once	lib/pugixml/pugixml.cc	/^		static bool eval_once(xpath_node_set::type_t type, nodeset_eval_t eval)$/;"	f	class:xpath_ast_node	file:
eval_string	lib/pugixml/pugixml.cc	/^		xpath_string eval_string(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node
eval_string_concat	lib/pugixml/pugixml.cc	/^		xpath_string eval_string_concat(const xpath_context& c, const xpath_stack& stack)$/;"	f	class:xpath_ast_node
evaluateApprox	lib/algorithms/approx/Remez.cc	/^double AlgRemez::evaluateApprox(double x) {$/;"	f	class:AlgRemez
evaluateFunc	lib/algorithms/approx/Remez.cc	/^double AlgRemez::evaluateFunc(double x) {$/;"	f	class:AlgRemez
evaluateInverseApprox	lib/algorithms/approx/Remez.cc	/^double AlgRemez::evaluateInverseApprox(double x) {$/;"	f	class:AlgRemez
evaluateInverseFunc	lib/algorithms/approx/Remez.cc	/^double AlgRemez::evaluateInverseFunc(double x) {$/;"	f	class:AlgRemez
evaluateProductBlockingSizesHeuristic	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void evaluateProductBlockingSizesHeuristic(Index& k, Index& m, Index& n, Index num_threads = 1)$/;"	f	namespace:Eigen::internal
evaluate_boolean	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_query::evaluate_boolean(const xpath_node& n) const$/;"	f	class:pugi::xpath_query
evaluate_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node xpath_query::evaluate_node(const xpath_node& n) const$/;"	f	class:pugi::xpath_query
evaluate_node_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set xpath_query::evaluate_node_set(const xpath_node& n) const$/;"	f	class:pugi::xpath_query
evaluate_node_set_prepare	lib/pugixml/pugixml.cc	/^	PUGI__FN impl::xpath_ast_node* evaluate_node_set_prepare(xpath_query_impl* impl)$/;"	f
evaluate_number	lib/pugixml/pugixml.cc	/^	PUGI__FN double xpath_query::evaluate_number(const xpath_node& n) const$/;"	f	class:pugi::xpath_query
evaluate_string	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t xpath_query::evaluate_string(char_t* buffer, size_t capacity, const xpath_node& n) const$/;"	f	class:pugi::xpath_query
evaluate_string	lib/pugixml/pugixml.cc	/^	PUGI__FN string_t xpath_query::evaluate_string(const xpath_node& n) const$/;"	f	class:pugi::xpath_query
evaluate_string_impl	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_string evaluate_string_impl(xpath_query_impl* impl, const xpath_node& n, xpath_stack_data& sd)$/;"	f
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC evaluator() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC evaluator()$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC evaluator(const ArgType& arg)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const PlainObjectType& m)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const T& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& block) : block_evaluator_type(block)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& diagonal)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& map)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& n)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& ref)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& select)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  explicit evaluator(const T& xpr) : evaluator<T>(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator : public unary_evaluator<T>$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Diagonal<ArgType, DiagIndex> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<EvalToTemp<ArgType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<PartialReduxExpr<ArgType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<PlainObjectBase<Derived> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Ref<PlainObjectType, RefOptions, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<const T>$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct evaluator<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct evaluator<Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> > $/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct evaluator<Product<Lhs, Rhs, Options> > $/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/ReturnByValue.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/ReturnByValue.h	/^struct evaluator<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const SolveType& solve)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/Core/Solve.h	/^struct evaluator<Solve<Decomposition,RhsType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  evaluator(const SolveType& solve)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^struct evaluator<SolveWithGuess<Decomposition,RhsType, GuessType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^  explicit evaluator(const XprType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct evaluator<MappedSparseMatrix<_Scalar,_Options,_StorageIndex> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  evaluator() : m_matrix(0), m_zero(0)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  explicit evaluator(const Derived &mat) : m_matrix(&mat), m_zero(0)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^struct evaluator<SparseCompressedBase<Derived> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseMap.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseMap.h	/^  explicit evaluator(const XprType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseMap.h	/^struct evaluator<Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseMap.h	/^struct evaluator<Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseMatrix.h	/^  explicit evaluator(const SparseMatrixType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseMatrix.h	/^struct evaluator<SparseMatrix<_Scalar,_Options,_StorageIndex> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseRef.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseRef.h	/^  explicit evaluator(const XprType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	lib/Eigen/src/SparseCore/SparseVector.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseVector.h	/^  explicit evaluator(const SparseVectorType &mat) : m_matrix(&mat)$/;"	f	struct:Eigen::internal::evaluator
evaluator	lib/Eigen/src/SparseCore/SparseVector.h	/^struct evaluator<SparseVector<_Scalar,_Options,_Index> >$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_assume_aliasing {$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	lib/Eigen/src/Core/ProductEvaluators.h	/^struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	lib/Eigen/src/Core/ProductEvaluators.h	/^struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_sum_op<typename OtherXpr::Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, const OtherXpr,$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	lib/Eigen/src/Core/ProductEvaluators.h	/^struct evaluator_assume_aliasing<Product<Lhs, Rhs, DefaultProduct> > {$/;"	s	namespace:Eigen::internal
evaluator_base	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_base : public noncopyable$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/Core/BandMatrix.h	/^struct evaluator_traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/Core/BandMatrix.h	/^struct evaluator_traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_traits : public evaluator_traits_base<T>$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/Core/SelfAdjointView.h	/^struct evaluator_traits<SelfAdjointView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/Core/TriangularMatrix.h	/^struct evaluator_traits<TriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/Geometry/Homogeneous.h	/^struct evaluator_traits<Homogeneous<ArgType,Direction> >$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/Householder/HouseholderSequence.h	/^struct evaluator_traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct evaluator_traits<SparseSelfAdjointView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
evaluator_traits	lib/Eigen/src/SparseQR/SparseQR.h	/^struct evaluator_traits<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
evaluator_traits_base	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_traits_base$/;"	s	namespace:Eigen::internal
evaluator_wrapper_base	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator_wrapper_base(const ArgType& arg) : m_argImpl(arg) {}$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
evaluator_wrapper_base	lib/Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_wrapper_base$/;"	s	namespace:Eigen::internal
evidence	lib/log/Log.h	/^  std::string evidence() {return Painter.colour["YELLOW"];}$/;"	f	class:Grid::Logger
evolve	lib/qcd/hmc/HMC.h	/^  void evolve(void) {$/;"	f	class:Grid::QCD::HybridMonteCarlo
evolve_hmc_step	lib/qcd/hmc/HMC.h	/^  RealD evolve_hmc_step(Field &U) {$/;"	f	class:Grid::QCD::HybridMonteCarlo
evolve_step	lib/qcd/smearing/WilsonFlow.h	/^void WilsonFlow<Gimpl>::evolve_step(typename Gimpl::GaugeField &U) const{$/;"	f	class:Grid::QCD::WilsonFlow
evolve_step_adaptive	lib/qcd/smearing/WilsonFlow.h	/^void WilsonFlow<Gimpl>::evolve_step_adaptive(typename Gimpl::GaugeField &U, RealD maxTau) {$/;"	f	class:Grid::QCD::WilsonFlow
exchange	lib/simd/Grid_vector_types.h	/^  friend inline void exchange(Grid_simd &out1,Grid_simd &out2,Grid_simd in1,Grid_simd in2,int n)$/;"	f	class:Grid::Grid_simd
exchange	lib/tensors/Tensor_class.h	/^  friend strong_inline void exchange(iMatrix<vtype,N> &out1,iMatrix<vtype,N> &out2,$/;"	f	class:Grid::iMatrix
exchange	lib/tensors/Tensor_class.h	/^  friend strong_inline void exchange(iScalar<vtype> &out1,iScalar<vtype> &out2,$/;"	f	class:Grid::iScalar
exchange	lib/tensors/Tensor_class.h	/^  friend strong_inline void exchange(iVector<vtype,N> &out1,iVector<vtype,N> &out2,$/;"	f	class:Grid::iVector
execute	extras/Hadrons/Modules/MAction/DWF.hpp	/^void TDWF<FImpl>::execute(void)$/;"	f	class:TDWF
execute	extras/Hadrons/Modules/MAction/Wilson.hpp	/^void TWilson<FImpl>::execute()$/;"	f	class:TWilson
execute	extras/Hadrons/Modules/MContraction/Baryon.hpp	/^void TBaryon<FImpl1, FImpl2, FImpl3>::execute(void)$/;"	f	class:TBaryon
execute	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^void TDiscLoop<FImpl>::execute(void)$/;"	f	class:TDiscLoop
execute	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^void TGamma3pt<FImpl1, FImpl2, FImpl3>::execute(void)$/;"	f	class:TGamma3pt
execute	extras/Hadrons/Modules/MContraction/Meson.hpp	/^void TMeson<FImpl1, FImpl2>::execute(void)$/;"	f	class:TMeson
execute	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^void TWeakHamiltonianEye::execute(void)$/;"	f	class:TWeakHamiltonianEye
execute	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^void TWeakHamiltonianNonEye::execute(void)$/;"	f	class:TWeakHamiltonianNonEye
execute	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^void TWeakNeutral4ptDisc::execute(void)$/;"	f	class:TWeakNeutral4ptDisc
execute	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^void TGaugeProp<FImpl>::execute(void)$/;"	f	class:TGaugeProp
execute	extras/Hadrons/Modules/MGauge/Load.cc	/^void TLoad::execute(void)$/;"	f	class:TLoad
execute	extras/Hadrons/Modules/MGauge/Random.cc	/^void TRandom::execute(void)$/;"	f	class:TRandom
execute	extras/Hadrons/Modules/MGauge/StochEm.cc	/^void TStochEm::execute(void)$/;"	f	class:TStochEm
execute	extras/Hadrons/Modules/MGauge/Unit.cc	/^void TUnit::execute(void)$/;"	f	class:TUnit
execute	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^void TNoiseLoop<FImpl>::execute(void)$/;"	f	class:TNoiseLoop
execute	extras/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::execute(void)$/;"	f	class:TChargedProp
execute	extras/Hadrons/Modules/MScalar/FreeProp.cc	/^void TFreeProp::execute(void)$/;"	f	class:TFreeProp
execute	extras/Hadrons/Modules/MSink/Point.hpp	/^void TPoint<FImpl>::execute(void)$/;"	f	class:TPoint
execute	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^void TRBPrecCG<FImpl>::execute(void)$/;"	f	class:TRBPrecCG
execute	extras/Hadrons/Modules/MSource/Point.hpp	/^void TPoint<FImpl>::execute(void)$/;"	f	class:TPoint
execute	extras/Hadrons/Modules/MSource/SeqGamma.hpp	/^void TSeqGamma<FImpl>::execute(void)$/;"	f	class:TSeqGamma
execute	extras/Hadrons/Modules/MSource/Wall.hpp	/^void TWall<FImpl>::execute(void)$/;"	f	class:TWall
execute	extras/Hadrons/Modules/MSource/Z2.hpp	/^void TZ2<FImpl>::execute(void)$/;"	f	class:TZ2
execute	lib/Hadrons/Modules/MAction/DWF.hpp	/^void TDWF<FImpl>::execute(void)$/;"	f	class:TDWF
execute	lib/Hadrons/Modules/MAction/Wilson.hpp	/^void TWilson<FImpl>::execute()$/;"	f	class:TWilson
execute	lib/Hadrons/Modules/MContraction/Baryon.hpp	/^void TBaryon<FImpl1, FImpl2, FImpl3>::execute(void)$/;"	f	class:TBaryon
execute	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^void TDiscLoop<FImpl>::execute(void)$/;"	f	class:TDiscLoop
execute	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^void TGamma3pt<FImpl1, FImpl2, FImpl3>::execute(void)$/;"	f	class:TGamma3pt
execute	lib/Hadrons/Modules/MContraction/Meson.hpp	/^void TMeson<FImpl1, FImpl2>::execute(void)$/;"	f	class:TMeson
execute	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^void TWeakHamiltonianEye::execute(void)$/;"	f	class:TWeakHamiltonianEye
execute	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^void TWeakHamiltonianNonEye::execute(void)$/;"	f	class:TWeakHamiltonianNonEye
execute	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^void TWeakNeutral4ptDisc::execute(void)$/;"	f	class:TWeakNeutral4ptDisc
execute	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^void TGaugeProp<FImpl>::execute(void)$/;"	f	class:TGaugeProp
execute	lib/Hadrons/Modules/MGauge/Load.cc	/^void TLoad::execute(void)$/;"	f	class:TLoad
execute	lib/Hadrons/Modules/MGauge/Random.cc	/^void TRandom::execute(void)$/;"	f	class:TRandom
execute	lib/Hadrons/Modules/MGauge/StochEm.cc	/^void TStochEm::execute(void)$/;"	f	class:TStochEm
execute	lib/Hadrons/Modules/MGauge/Unit.cc	/^void TUnit::execute(void)$/;"	f	class:TUnit
execute	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^void TNoiseLoop<FImpl>::execute(void)$/;"	f	class:TNoiseLoop
execute	lib/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::execute(void)$/;"	f	class:TChargedProp
execute	lib/Hadrons/Modules/MScalar/FreeProp.cc	/^void TFreeProp::execute(void)$/;"	f	class:TFreeProp
execute	lib/Hadrons/Modules/MSink/Point.hpp	/^void TPoint<FImpl>::execute(void)$/;"	f	class:TPoint
execute	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^void TRBPrecCG<FImpl>::execute(void)$/;"	f	class:TRBPrecCG
execute	lib/Hadrons/Modules/MSource/Point.hpp	/^void TPoint<FImpl>::execute(void)$/;"	f	class:TPoint
execute	lib/Hadrons/Modules/MSource/SeqGamma.hpp	/^void TSeqGamma<FImpl>::execute(void)$/;"	f	class:TSeqGamma
execute	lib/Hadrons/Modules/MSource/Wall.hpp	/^void TWall<FImpl>::execute(void)$/;"	f	class:TWall
execute	lib/Hadrons/Modules/MSource/Z2.hpp	/^void TZ2<FImpl>::execute(void)$/;"	f	class:TZ2
executeProgram	extras/Hadrons/Environment.cc	/^Environment::Size Environment::executeProgram(const std::vector<std::string> &p)$/;"	f	class:Environment
executeProgram	extras/Hadrons/Environment.cc	/^Environment::executeProgram(const std::vector<unsigned int> &p)$/;"	f	class:Environment
executeProgram	lib/Hadrons/Environment.cc	/^Environment::Size Environment::executeProgram(const std::vector<std::string> &p)$/;"	f	class:Environment
executeProgram	lib/Hadrons/Environment.cc	/^Environment::executeProgram(const std::vector<unsigned int> &p)$/;"	f	class:Environment
exit	lib/perfmon/Stat.cc	/^void PmuStat::exit(int t)$/;"	f	class:Grid::PmuStat
exp	lib/Eigen/src/Core/MathFunctions.h	/^T exp(const T &x) {$/;"	f	namespace:Eigen::numext
exp	lib/Eigen/src/Core/MathFunctions.h	/^double exp(const double &x) { return ::exp(x); }$/;"	f	namespace:Eigen::numext
exp	lib/Eigen/src/Core/MathFunctions.h	/^float exp(const float &x) { return ::expf(x); }$/;"	f	namespace:Eigen::numext
exp	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half exp(const half& a) {$/;"	f	namespace:Eigen::half_impl
exp	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^exp() const$/;"	f
exp	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> exp(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
expMat	lib/lattice/Lattice_unary.h	/^  template<class obj> Lattice<obj> expMat(const Lattice<obj> &rhs, RealD alpha, Integer Nexp = DEFAULT_MAT_EXP){$/;"	f	namespace:Grid
exp_bf	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat exp_bf(const bigfloat& a) {$/;"	f	class:bigfloat
exp_bf	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat exp_bf(const bigfloat& a) {$/;"	f	class:bigfloat
expand	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^Index  SparseLUImpl<Scalar,StorageIndex>::expand(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions) $/;"	f	class:Eigen::internal::SparseLUImpl
expect	lib/json/json.hpp	/^        void expect(typename lexer::token_type t) const$/;"	f	class:nlohmann::basic_json::parser
exph	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half exph(const Eigen::half& a) {$/;"	f
exponentiate_iQ	lib/qcd/smearing/StoutSmearing.h	/^  void exponentiate_iQ(GaugeLinkField& e_iQ, const GaugeLinkField& iQ) const {$/;"	f	class:Grid::QCD::Smear_Stout
expression	lib/Eigen/src/Core/NoAlias.h	/^    ExpressionType& expression() const$/;"	f	class:Eigen::NoAlias
extend	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
extend	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& extend(const MatrixBase<Derived>& p)$/;"	f	class:Eigen::AlignedBox
extendedTo	lib/Eigen/src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
extendedToOpposite	lib/Eigen/src/Core/VectorwiseOp.h	/^    extendedToOpposite(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
exteriorDistance	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
exteriorDistance	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox
extra_buffers	lib/pugixml/pugixml.cc	/^		xml_extra_buffer* extra_buffers;$/;"	m	struct:xml_document_struct	file:
extract	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.lhs()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.rhs()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return ExtractType(Base::extract(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits
extract	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits
extract	lib/tensors/Tensor_extract_merge.h	/^inline void extract(typename std::enable_if<!isGridTensor<vsimd>::value, const vsimd >::type  &y,std::vector<scalar> &extracted){$/;"	f	namespace:Grid
extract	lib/tensors/Tensor_extract_merge.h	/^inline void extract(typename std::enable_if<!isGridTensor<vsimd>::value, const vsimd >::type * y, $/;"	f	namespace:Grid
extract	lib/tensors/Tensor_extract_merge.h	/^template<class vobj> inline void extract(const vobj &vec,std::vector<typename vobj::scalar_object> &extracted)$/;"	f	namespace:Grid
extract	lib/tensors/Tensor_extract_merge.h	/^void extract(const vobj &vec,std::vector<typename vobj::scalar_object *> &extracted, int offset)$/;"	f	namespace:Grid
extract1	lib/tensors/Tensor_extract_merge.h	/^void extract1(const vobj &vec,std::vector<sobj*> &extracted, int offset)$/;"	f	namespace:Grid
extractData	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase
extractData	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU
extractScalarFactor	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	lib/Eigen/src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits
extract_data	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal
extract_data_selector	lib/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
extract_data_selector	lib/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
extract_kernel	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline bool extract_kernel(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
f	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  float f;$/;"	m	union:Eigen::half_impl::FP32
f	lib/simd/Grid_avx.h	/^    __m256 f;$/;"	m	union:Grid::Optimization::uconv
f	lib/simd/Grid_avx.h	/^    double f[4];$/;"	m	union:Grid::Optimization::u256d
f	lib/simd/Grid_avx.h	/^    float f[8];$/;"	m	union:Grid::Optimization::u256f
f	lib/simd/Grid_avx512.h	/^    double f[8];$/;"	m	union:Grid::Optimization::u512d
f	lib/simd/Grid_avx512.h	/^    float f[16];$/;"	m	union:Grid::Optimization::u512f
f	lib/simd/Grid_neon.h	/^    double f[2];$/;"	m	union:Grid::Optimization::u128d
f	lib/simd/Grid_neon.h	/^    float f[4];$/;"	m	union:Grid::Optimization::u128f
f	lib/simd/Grid_neon.h	/^    float32x4_t f;$/;"	m	union:Grid::Optimization::uconv
f	lib/simd/Grid_neon.h	/^    uint16_t f[8];$/;"	m	union:Grid::Optimization::u128h
f	lib/simd/Grid_sse4.h	/^    __m128 f;$/;"	m	union:Grid::Optimization::uconv
f	lib/simd/Grid_sse4.h	/^    double f[2];$/;"	m	union:Grid::Optimization::u128d
f	lib/simd/Grid_sse4.h	/^    float f;$/;"	m	union:Grid::Optimization::FP32
f	lib/simd/Grid_sse4.h	/^    float f[4];$/;"	m	union:Grid::Optimization::u128f
f	tests/IO/Test_serialisation.cc	/^float    f   = M_PI;$/;"	v
fabsh	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half fabsh(const Eigen::half& a) {$/;"	f
face_table	lib/stencil/Stencil.h	/^  std::vector<std::vector<std::pair<int,int> > > face_table ;$/;"	m	class:Grid::CartesianStencil
face_table_computed	lib/stencil/Stencil.h	/^  int face_table_computed;$/;"	m	class:Grid::CartesianStencil
factor	lib/Eigen/src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	lib/Eigen/src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	lib/qcd/utils/CovariantLaplacian.h	/^  RealD factor;$/;"	m	class:Grid::QCD::LaplacianAdjointField
factorize	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
factorize	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
factorize	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
factorize	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
factorize	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^void IncompleteCholesky<Scalar,_UpLo, OrderingType>::factorize(const _MatrixType& mat)$/;"	f	class:Eigen::IncompleteCholesky
factorize	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
factorize	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
factorize	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
factorize	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
factorize	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
factorize	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
factorize	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
factorize	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
factorize	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase
factorize	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
factorize	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
factorize	lib/Eigen/src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::factorize(const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
factorize	lib/Eigen/src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::factorize(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
factorize	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU
factorize	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU
factorize	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
factorize_impl	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize_impl()$/;"	f	class:Eigen::UmfPackLU
factorize_preordered	lib/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
false_type	lib/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
fd	lib/perfmon/PerfCount.h	/^  int fd;$/;"	m	class:Grid::PerformanceCounter
feenableexcept	lib/util/Init.cc	/^feenableexcept (unsigned int excepts)$/;"	f	file:
fermionop_string	lib/qcd/modules/Modules.cc	/^char fermionop_string[]  = "FermionOperator";$/;"	m	namespace:Grid	file:
fftw_destroy_plan	lib/algorithms/FFT.h	/^    inline static void fftw_destroy_plan(const FFTW_plan p) {$/;"	f	struct:Grid::FFTW
fftw_execute_dft	lib/algorithms/FFT.h	/^    inline static void fftw_execute_dft(const FFTW_plan p,FFTW_scalar *in,FFTW_scalar *out) {$/;"	f	struct:Grid::FFTW
fftw_flops	lib/algorithms/FFT.h	/^    static void fftw_flops(const FFTW_plan p,double *add, double *mul, double *fmas){$/;"	f	struct:Grid::FFTW
fftw_plan_many_dft	lib/algorithms/FFT.h	/^    static FFTW_plan fftw_plan_many_dft(int rank, const int *n,int howmany,$/;"	f	struct:Grid::FFTW
file	lib/pugixml/pugixml.h	/^		void* file;$/;"	m	class:pugi::xml_writer_file
fileName_	lib/serialisation/Hdf5IO.h	/^    std::string              fileName_;$/;"	m	class:Grid::Hdf5Reader
fileName_	lib/serialisation/Hdf5IO.h	/^    std::string              fileName_;$/;"	m	class:Grid::Hdf5Writer
fileName_	lib/serialisation/JSON_IO.h	/^    std::string         fileName_;$/;"	m	class:Grid::JSONReader
fileName_	lib/serialisation/JSON_IO.h	/^    std::string         fileName_;$/;"	m	class:Grid::JSONWriter
fileName_	lib/serialisation/XmlIO.h	/^    std::string        fileName_;$/;"	m	class:Grid::XmlReader
fileName_	lib/serialisation/XmlIO.h	/^    std::string        fileName_;$/;"	m	class:Grid::XmlWriter
file_	lib/serialisation/BinaryIO.h	/^    std::ifstream file_;$/;"	m	class:Grid::BinaryReader
file_	lib/serialisation/BinaryIO.h	/^    std::ofstream file_;$/;"	m	class:Grid::BinaryWriter
file_	lib/serialisation/Hdf5IO.h	/^    H5NS::H5File             file_;$/;"	m	class:Grid::Hdf5Reader
file_	lib/serialisation/Hdf5IO.h	/^    H5NS::H5File             file_;$/;"	m	class:Grid::Hdf5Writer
file_	lib/serialisation/TextIO.h	/^    std::ifstream file_;$/;"	m	class:Grid::TextReader
file_	lib/serialisation/TextIO.h	/^    std::ofstream file_;$/;"	m	class:Grid::TextWriter
filename	lib/parallelIO/IldgIO.h	/^   std::string filename;$/;"	m	class:Grid::QCD::GridLimeReader
filename	lib/parallelIO/IldgIO.h	/^   std::string filename;$/;"	m	class:Grid::QCD::GridLimeWriter
fill	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& val)$/;"	f	class:Eigen::DenseBase
fill	lib/Eigen/src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularViewImpl
fill	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector
fill	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(ComplexD &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(ComplexF &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(RealD &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(RealF &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(vComplexD &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(vComplexF &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(vRealD &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class distribution>  inline void fill(vRealF &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class sobj,class distribution> inline void fill(sobj &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridSerialRNG
fill	lib/lattice/Lattice_rng.h	/^    template <class vobj,class distribution> inline void fill(Lattice<vobj> &l,std::vector<distribution> &dist){$/;"	f	class:Grid::GridParallelRNG
fill	lib/serialisation/BaseIO.h	/^  void Reconstruct<V>::fill(W &v)$/;"	f	class:Grid::Reconstruct
fill	lib/serialisation/BaseIO.h	/^  void Reconstruct<V>::fill(std::vector<Element> &v)$/;"	f	class:Grid::Reconstruct
fillScalar	lib/lattice/Lattice_rng.h	/^  void fillScalar(ComplexD &s,distribution &dist,generator &gen)$/;"	f	namespace:Grid
fillScalar	lib/lattice/Lattice_rng.h	/^  void fillScalar(ComplexF &s,distribution &dist, generator &gen)$/;"	f	namespace:Grid
fillScalar	lib/lattice/Lattice_rng.h	/^  void fillScalar(scalar &s,distribution &dist,generator & gen)$/;"	f	namespace:Grid
fill_ActionsLevel	lib/qcd/hmc/HMCResourceManager.h	/^  void fill_ActionsLevel(ReaderClass &Read){$/;"	f	class:Grid::QCD::HMCResourceManager
fill_line_buffer	lib/json/json.hpp	/^        void fill_line_buffer(size_t n = 0)$/;"	f	class:nlohmann::basic_json::lexer
fill_smearedSet	lib/qcd/smearing/GaugeConfiguration.h	/^  void fill_smearedSet(GaugeField& U) {$/;"	f	class:Grid::QCD::SmearedConfiguration
fillfactor	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index fillfactor; \/\/ The estimated fills factors for L and U, compared with A$/;"	m	struct:Eigen::internal::perfvalues
fillrand	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector
fillrand	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector
finalize	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix
finalize	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector
find	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  Index find(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
find	lib/json/json.hpp	/^    const_iterator find(typename object_t::key_type key) const$/;"	f	class:nlohmann::basic_json
find	lib/json/json.hpp	/^    iterator find(typename object_t::key_type key)$/;"	f	class:nlohmann::basic_json
find	lib/pugixml/pugixml.cc	/^		void** find(const void* key)$/;"	f	class:compact_hash_table
findSmallDiagEntry	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    inline Index RealQZ<MatrixType>::findSmallDiagEntry(Index f, Index l)$/;"	f	class:Eigen::RealQZ
findSmallSubdiagEntry	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    inline Index RealQZ<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealQZ
findSmallSubdiagEntry	lib/Eigen/src/Eigenvalues/RealSchur.h	/^inline Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealSchur
find_attribute	lib/pugixml/pugixml.h	/^		template <typename Predicate> xml_attribute find_attribute(Predicate pred) const$/;"	f	class:pugi::xml_node
find_char	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* find_char(const char_t* s, char_t c)$/;"	f
find_child	lib/pugixml/pugixml.h	/^		template <typename Predicate> xml_node find_child(Predicate pred) const$/;"	f	class:pugi::xml_node
find_child_by_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const$/;"	f	class:pugi::xml_node
find_child_by_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::find_child_by_attribute(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const$/;"	f	class:pugi::xml_node
find_node	lib/pugixml/pugixml.h	/^		template <typename Predicate> xml_node find_node(Predicate pred) const$/;"	f	class:pugi::xml_node
find_ordering	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static IndexType find_ordering \/* return the number of garbage collections *\/$/;"	f	namespace:internal
find_substring	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* find_substring(const char_t* s, const char_t* p)$/;"	f
finished	lib/Eigen/src/Core/CommaInitializer.h	/^  inline XprType& finished() {$/;"	f	struct:Eigen::CommaInitializer
first	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  Packet first;$/;"	m	struct:Eigen::internal::DoublePacket
first	lib/pugixml/pugixml.cc	/^		xpath_node first() const$/;"	f	class:xpath_node_set_raw
first	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node xpath_node_set::first() const$/;"	f	class:pugi::xpath_node_set
firstAligned	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC Index firstAligned(Index size) const {$/;"	f	class:Eigen::internal::blas_data_mapper
first_aligned	lib/Eigen/src/Core/DenseCoeffsBase.h	/^static inline Index first_aligned(const DenseBase<Derived>& m)$/;"	f	namespace:Eigen::internal
first_aligned	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal
first_aligned_impl	lib/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
first_aligned_impl	lib/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Alignment, Derived, false>$/;"	s	namespace:Eigen::internal
first_argument_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef Arg1 first_argument_type;$/;"	t	struct:Eigen::internal::binary_op_base
first_argument_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::first_argument_type  first_argument_type;$/;"	t	struct:Eigen::internal::bind1st_op
first_argument_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::first_argument_type  first_argument_type;$/;"	t	struct:Eigen::internal::bind2nd_op
first_attribute	lib/pugixml/pugixml.cc	/^		impl::compact_pointer<xml_attribute_struct, 11, 0> first_attribute;$/;"	m	struct:pugi::xml_node_struct	file:
first_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::first_attribute() const$/;"	f	class:pugi::xml_node
first_child	lib/pugixml/pugixml.cc	/^		impl::compact_pointer<xml_node_struct, 8, 0> first_child;$/;"	m	struct:pugi::xml_node_struct	file:
first_child	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::first_child() const$/;"	f	class:pugi::xml_node
first_column	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType first_column ;\/* first column in row (used in garbage collection) *\/$/;"	m	union:internal::Colamd_Row::__anon628
first_default_aligned	lib/Eigen/src/Core/DenseCoeffsBase.h	/^static inline Index first_default_aligned(const DenseBase<Derived>& m)$/;"	f	namespace:Eigen::internal
first_default_aligned	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline Index first_default_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal
first_element_by_path	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::first_element_by_path(const char_t* path_, char_t delimiter) const$/;"	f	class:pugi::xml_node
first_multiple	lib/Eigen/src/Core/util/Memory.h	/^inline Index first_multiple(Index size, Index base)$/;"	f	namespace:Eigen::internal
fixupL	lib/Eigen/src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,StorageIndex>::fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
flagged	lib/Eigen/src/Core/DenseBase.h	/^    const Derived& flagged() const$/;"	f	class:Eigen::DenseBase
flags	lib/Eigen/src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat
flatVector_	lib/serialisation/BaseIO.h	/^    const std::vector<Element> &flatVector_;$/;"	m	class:Grid::Reconstruct
flatVector_	lib/serialisation/BaseIO.h	/^    std::vector<Element> flatVector_;$/;"	m	class:Grid::Flatten
flatten	lib/json/json.hpp	/^        static void flatten(const std::string& reference_string,$/;"	f	class:nlohmann::basic_json::json_pointer
flatten	lib/json/json.hpp	/^    basic_json flatten() const$/;"	f	class:nlohmann::basic_json
float_to_half_rtne	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half float_to_half_rtne(float ff) {$/;"	f	namespace:Eigen::half_impl
floor	lib/Eigen/src/Core/MathFunctions.h	/^T (floor)(const T& x)$/;"	f	namespace:Eigen::numext
floor	lib/Eigen/src/Core/MathFunctions.h	/^double floor(const double &x) { return ::floor(x); }$/;"	f	namespace:Eigen::numext
floor	lib/Eigen/src/Core/MathFunctions.h	/^float floor(const float &x) { return ::floorf(x); }$/;"	f	namespace:Eigen::numext
floor	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half floor(const half& a) {$/;"	f	namespace:Eigen::half_impl
floor	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^floor() const$/;"	f
floorh	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half floorh(const Eigen::half& a) {$/;"	f
flops	lib/algorithms/FFT.h	/^    double flops;$/;"	m	class:Grid::FFT
flops_call	lib/algorithms/FFT.h	/^    double flops_call;$/;"	m	class:Grid::FFT
flush	lib/pugixml/pugixml.cc	/^		char_t* flush(char_t* s)$/;"	f	struct:gap
flush	lib/pugixml/pugixml.cc	/^		size_t flush()$/;"	f	class:xml_buffered_writer
flush	lib/pugixml/pugixml.cc	/^		void flush(const char_t* data, size_t size)$/;"	f	class:xml_buffered_writer
fmod	lib/Eigen/src/Core/MathFunctions.h	/^T fmod(const T& a, const T& b) {$/;"	f	namespace:Eigen::numext
fmod	lib/Eigen/src/Core/MathFunctions.h	/^double fmod(const double& a, const double& b) {$/;"	f	namespace:Eigen::numext
fmod	lib/Eigen/src/Core/MathFunctions.h	/^float fmod(const float& a, const float& b) {$/;"	f	namespace:Eigen::numext
fobj_stype	lib/parallelIO/MetaData.h	/^  typedef typename getPrecision<fobj>::real_scalar_type fobj_stype;$/;"	t	struct:Grid::QCD::BinarySimpleMunger
fobj_stype	lib/parallelIO/MetaData.h	/^  typedef typename getPrecision<fobj>::real_scalar_type fobj_stype;$/;"	t	struct:Grid::QCD::BinarySimpleUnmunger
fop_denominator_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::operator_type fop_denominator_mod;$/;"	m	class:Grid::QCD::OneFlavourRatioEOFModule
fop_denominator_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::operator_type fop_denominator_mod;$/;"	m	class:Grid::QCD::OneFlavourRatioFModule
fop_denominator_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::operator_type fop_denominator_mod;$/;"	m	class:Grid::QCD::TwoFlavourRatioEOFModule
fop_denominator_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::operator_type fop_denominator_mod;$/;"	m	class:Grid::QCD::TwoFlavourRatioFModule
forceAlignedAccess	lib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	lib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	lib/Eigen/src/Core/MatrixBase.h	/^    inline Derived& forceAlignedAccess() { return derived(); }$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	lib/Eigen/src/Core/MatrixBase.h	/^    inline const Derived& forceAlignedAccess() const { return derived(); }$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	lib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	lib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	lib/Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline Derived& forceAlignedAccessIf() { return derived(); }$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	lib/Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline const Derived& forceAlignedAccessIf() const { return derived(); }$/;"	f	class:Eigen::MatrixBase
format	lib/Eigen/src/Core/DenseBase.h	/^    inline const WithFormat<Derived> format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase
format_default	lib/pugixml/pugixml.h	/^	const unsigned int format_default = format_indent;$/;"	m	namespace:pugi
format_indent	lib/pugixml/pugixml.h	/^	const unsigned int format_indent = 0x01;$/;"	m	namespace:pugi
format_indent_attributes	lib/pugixml/pugixml.h	/^	const unsigned int format_indent_attributes = 0x40;$/;"	m	namespace:pugi
format_no_declaration	lib/pugixml/pugixml.h	/^	const unsigned int format_no_declaration = 0x08;$/;"	m	namespace:pugi
format_no_escapes	lib/pugixml/pugixml.h	/^	const unsigned int format_no_escapes = 0x10;$/;"	m	namespace:pugi
format_raw	lib/pugixml/pugixml.h	/^	const unsigned int format_raw = 0x04;$/;"	m	namespace:pugi
format_save_file_text	lib/pugixml/pugixml.h	/^	const unsigned int format_save_file_text = 0x20;$/;"	m	namespace:pugi
format_write_bom	lib/pugixml/pugixml.h	/^	const unsigned int format_write_bom = 0x02;$/;"	m	namespace:pugi
fortran_to_c_numbering	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
forward	lib/algorithms/FFT.h	/^    static const int forward=FFTW_FORWARD;$/;"	m	class:Grid::FFT
foundRoots	lib/algorithms/approx/Remez.h	/^  int foundRoots;$/;"	m	class:AlgRemez
freeAll	extras/Hadrons/Environment.cc	/^void Environment::freeAll(void)$/;"	f	class:Environment
freeAll	lib/Hadrons/Environment.cc	/^void Environment::freeAll(void)$/;"	f	class:Environment
freeMomPropName_	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::string                freeMomPropName_, GFSrcName_;$/;"	m	class:TChargedProp
freeMomPropName_	extras/Hadrons/Modules/MScalar/FreeProp.hpp	/^    std::string freeMomPropName_;$/;"	m	class:TFreeProp
freeMomPropName_	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::string                freeMomPropName_, GFSrcName_;$/;"	m	class:TChargedProp
freeMomPropName_	lib/Hadrons/Modules/MScalar/FreeProp.hpp	/^    std::string freeMomPropName_;$/;"	m	class:TFreeProp
freeMomProp_	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    ScalarField                *freeMomProp_, *GFSrc_;$/;"	m	class:TChargedProp
freeMomProp_	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    ScalarField                *freeMomProp_, *GFSrc_;$/;"	m	class:TChargedProp
freeObject	extras/Hadrons/Environment.cc	/^bool Environment::freeObject(const std::string name)$/;"	f	class:Environment
freeObject	extras/Hadrons/Environment.cc	/^bool Environment::freeObject(const unsigned int address)$/;"	f	class:Environment
freeObject	lib/Hadrons/Environment.cc	/^bool Environment::freeObject(const std::string name)$/;"	f	class:Environment
freeObject	lib/Hadrons/Environment.cc	/^bool Environment::freeObject(const unsigned int address)$/;"	f	class:Environment
freed_size	lib/pugixml/pugixml.cc	/^		size_t freed_size;$/;"	m	struct:xml_memory_page	file:
fromPositionOrientationScale	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform
fromRotationMatrix	lib/Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
fromRotationMatrix	lib/Eigen/src/Geometry/Rotation2D.h	/^EIGEN_DEVICE_FUNC Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D
fromString	lib/serialisation/BaseIO.h	/^  void Reader<T>::fromString(U &output, const std::string &s)$/;"	f	class:Grid::Reader
from_const	lib/pugixml/pugixml.cc	/^		static xpath_string from_const(const char_t* str)$/;"	f	class:xpath_string
from_heap	lib/pugixml/pugixml.cc	/^		static xpath_string from_heap(const char_t* begin, const char_t* end, xpath_allocator* alloc)$/;"	f	class:xpath_string
from_heap_preallocated	lib/pugixml/pugixml.cc	/^		static xpath_string from_heap_preallocated(const char_t* begin, const char_t* end)$/;"	f	class:xpath_string
from_rank	lib/stencil/Stencil.h	/^    Integer from_rank;$/;"	m	struct:Grid::CartesianStencil::Packet
front	lib/json/json.hpp	/^    const_reference front() const$/;"	f	class:nlohmann::basic_json
front	lib/json/json.hpp	/^    reference front()$/;"	f	class:nlohmann::basic_json
fullPivHouseholderQr	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
fullPivLu	lib/Eigen/src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase
full_size	lib/pugixml/pugixml.cc	/^		uint16_t full_size; \/\/ 0 if string occupies whole page$/;"	m	struct:xml_memory_string_header	file:
func	lib/algorithms/approx/Remez.cc	/^bigfloat AlgRemez::func(const bigfloat x) {$/;"	f	class:AlgRemez
funcAdj	tests/Test_simd.cc	/^  funcAdj() {};$/;"	f	class:funcAdj
funcAdj	tests/Test_simd.cc	/^class funcAdj {$/;"	c	file:
funcConj	tests/Test_simd.cc	/^  funcConj() {};$/;"	f	class:funcConj
funcConj	tests/Test_simd.cc	/^class funcConj {$/;"	c	file:
funcDivide	tests/Test_simd.cc	/^  funcDivide() {};$/;"	f	class:funcDivide
funcDivide	tests/Test_simd.cc	/^class funcDivide {$/;"	c	file:
funcExchange	tests/Test_simd.cc	/^  funcExchange(int _n) { n=_n;};$/;"	f	class:funcExchange
funcExchange	tests/Test_simd.cc	/^class funcExchange {$/;"	c	file:
funcImag	tests/Test_simd.cc	/^  funcImag() {};$/;"	f	class:funcImag
funcImag	tests/Test_simd.cc	/^class funcImag {$/;"	c	file:
funcInnerProduct	tests/Test_simd.cc	/^  funcInnerProduct() {};$/;"	f	class:funcInnerProduct
funcInnerProduct	tests/Test_simd.cc	/^class funcInnerProduct {$/;"	c	file:
funcMinus	tests/Test_simd.cc	/^  funcMinus() {};$/;"	f	class:funcMinus
funcMinus	tests/Test_simd.cc	/^class funcMinus {$/;"	c	file:
funcPermute	tests/Test_simd.cc	/^  funcPermute(int _n) { n=_n;};$/;"	f	class:funcPermute
funcPermute	tests/Test_simd.cc	/^class funcPermute {$/;"	c	file:
funcPlus	tests/Test_simd.cc	/^  funcPlus() {};$/;"	f	class:funcPlus
funcPlus	tests/Test_simd.cc	/^class funcPlus {$/;"	c	file:
funcReal	tests/Test_simd.cc	/^  funcReal() {};$/;"	f	class:funcReal
funcReal	tests/Test_simd.cc	/^class funcReal {$/;"	c	file:
funcReduce	tests/Test_simd.cc	/^  funcReduce() {};$/;"	f	class:funcReduce
funcReduce	tests/Test_simd.cc	/^class funcReduce {$/;"	c	file:
funcRotate	tests/Test_simd.cc	/^  funcRotate(int _n) { n=_n;};$/;"	f	class:funcRotate
funcRotate	tests/Test_simd.cc	/^class funcRotate {$/;"	c	file:
funcTimes	tests/Test_simd.cc	/^  funcTimes() {};$/;"	f	class:funcTimes
funcTimes	tests/Test_simd.cc	/^class funcTimes {$/;"	c	file:
funcTimesI	tests/Test_simd.cc	/^  funcTimesI() {};$/;"	f	class:funcTimesI
funcTimesI	tests/Test_simd.cc	/^class funcTimesI {$/;"	c	file:
funcTimesMinusI	tests/Test_simd.cc	/^  funcTimesMinusI() {};$/;"	f	class:funcTimesMinusI
funcTimesMinusI	tests/Test_simd.cc	/^class funcTimesMinusI {$/;"	c	file:
func_	extras/Hadrons/GeneticScheduler.hpp	/^    const ObjFunc            &func_;$/;"	m	class:GeneticScheduler
func_	lib/Hadrons/GeneticScheduler.hpp	/^    const ObjFunc            &func_;$/;"	m	class:GeneticScheduler
func_xi0	lib/qcd/smearing/StoutSmearing.h	/^  LatticeComplex func_xi0(const LatticeComplex& w) const {$/;"	f	class:Grid::QCD::Smear_Stout
func_xi1	lib/qcd/smearing/StoutSmearing.h	/^  LatticeComplex func_xi1(const LatticeComplex& w) const {$/;"	f	class:Grid::QCD::Smear_Stout
functor	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp
functor	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp
functor	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  const TernaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseTernaryOp
functor	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp
functor	lib/Eigen/src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView
functor	lib/Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp& functor() const { return m_functor; }$/;"	f	class:Eigen::PartialReduxExpr
functor_has_linear_access	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = !has_binary_operator<Functor>::value }; };$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct functor_traits<scalar_cast_op<Eigen::half, float> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct functor_traits<scalar_cast_op<float, Eigen::half> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct functor_traits<scalar_cast_op<int, Eigen::half> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<add_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<div_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<mul_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<sub_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<swap_assign_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_cmp_op<LhsScalar,RhsScalar, cmp> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_difference_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_hypot_op<Scalar,Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_max_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_min_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_pow_op<Scalar,Exponent> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_quotient_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_sum_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct functor_traits<scalar_boolean_xor_op> {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct functor_traits<bind1st_op<BinaryOp> > : functor_traits<BinaryOp> {};$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct functor_traits<bind2nd_op<BinaryOp> > : functor_traits<BinaryOp> {};$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^template <typename Scalar, typename PacketType> struct functor_traits< linspaced_op<Scalar,PacketType> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_arg_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_atan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_boolean_not_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_ceil_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cosh_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_exp_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_floor_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_isfinite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_isinf_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_isnan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_log10_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_log1p_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_log_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_round_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_rsqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_score_coeff_op<Scalar> > : functor_traits<scalar_abs_op<Scalar> > {};$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sign_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sinh_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_tanh_op<Scalar> > {$/;"	s	namespace:Eigen::internal
g	lib/qcd/spin/Gamma.h	/^    Algebra                                                      g;$/;"	m	class:Grid::QCD::Gamma
g5	lib/qcd/action/fermion/g5HermitianLinop.h	/^  Gamma g5;$/;"	m	class:Grid::QCD::Gamma5HermitianLinearOperator
gSites	lib/cartesian/Cartesian_base.h	/^    inline int gSites(void) const { return _isites*_osites*_Nprocessors; }; $/;"	f	class:Grid::GridBase
gamma	lib/algorithms/approx/Zolotarev.h	/^    *gamma,	      \/* zeros of numerator of T in Cayley form *\/$/;"	m	struct:Grid::Approx::__anon695
gamma	lib/qcd/spin/Dirac.h	/^  Gamma gamma;$/;"	m	class:Grid::QCD::GammaL
gap	lib/pugixml/pugixml.cc	/^		gap(): end(0), size(0)$/;"	f	struct:gap
gap	lib/pugixml/pugixml.cc	/^	struct gap$/;"	s	file:
garbage_collection	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static IndexType garbage_collection  \/* returns the new value of pfree *\/$/;"	f	namespace:internal
gatherPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE SubPacket gatherPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
gathermtime	lib/stencil/Stencil.h	/^  double gathermtime;$/;"	m	class:Grid::CartesianStencil
gathertime	lib/stencil/Stencil.h	/^  double gathertime;$/;"	m	class:Grid::CartesianStencil
gauge_	lib/qcd/action/gauge/Photon.h	/^    Gauge    gauge_;$/;"	m	class:Grid::QCD::Photon
gauge_string	lib/qcd/modules/Modules.cc	/^char gauge_string[]      = "gauge";$/;"	m	namespace:Grid	file:
gaussian	lib/lattice/Lattice_rng.h	/^  template <class sobj> inline void gaussian(GridSerialRNG &rng,sobj &l) { rng.fill(l,rng._gaussian ); }$/;"	f	namespace:Grid
gaussian	lib/lattice/Lattice_rng.h	/^  template <class vobj> inline void gaussian(GridParallelRNG &rng,Lattice<vobj> &l) { rng.fill(l,rng._gaussian); }$/;"	f	namespace:Grid
gbl	lib/perfmon/Stat.cc	/^struct knl_gbl_ PmuStat::gbl;$/;"	m	class:Grid::PmuStat	typeref:struct:Grid::PmuStat::	file:
gbl	lib/perfmon/Stat.h	/^    static struct knl_gbl_ gbl;$/;"	m	class:Grid::PmuStat	typeref:struct:Grid::PmuStat::knl_gbl_
gebp_kernel	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
gebp_madd	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal
gebp_madd_selector	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
gebp_madd_selector	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
gebp_traits	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
gebp_traits	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
gebp_traits	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
gebp_traits	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
gemm_blocking_space	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(Index \/*rows*\/, Index \/*cols*\/, Index \/*depth*\/, Index \/*num_threads*\/, bool \/*full_rows = false*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(Index rows, Index cols, Index depth, Index num_threads, bool l3_blocking)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal
gemm_blocking_space	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true \/* == FiniteAtCompileTime *\/>$/;"	c	namespace:Eigen::internal
gemm_functor	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha, BlockingType& blocking)$/;"	f	struct:Eigen::internal::gemm_functor
gemm_functor	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs<Scalar, Index, DataMapper, Pack1, Pack2, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs<Scalar, Index, DataMapper, Pack1, Pack2, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, DataMapper, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, DataMapper, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	lib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_dense_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	lib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	lib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	lib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
gen_	extras/Hadrons/GeneticScheduler.hpp	/^    std::mt19937             gen_;$/;"	m	class:GeneticScheduler
gen_	lib/Hadrons/GeneticScheduler.hpp	/^    std::mt19937             gen_;$/;"	m	class:GeneticScheduler
gen_nan	lib/pugixml/pugixml.cc	/^	PUGI__FN double gen_nan()$/;"	f
general_det3_helper	lib/Eigen/src/LU/InverseImpl.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal
general_matrix_matrix_product	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_product	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_rankupdate	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,LhsMapper,ColMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,LhsMapper,RowMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_product_to_triangular_selector	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,false>$/;"	s	namespace:Eigen
general_product_to_triangular_selector	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,true>$/;"	s	namespace:Eigen
generateApprox	lib/algorithms/approx/Remez.cc	/^double AlgRemez::generateApprox(int degree, unsigned long pnum, $/;"	f	class:AlgRemez
generateApprox	lib/algorithms/approx/Remez.cc	/^double AlgRemez::generateApprox(int num_degree, int den_degree, $/;"	f	class:AlgRemez
generate_momenta	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline void generate_momenta(Field &P, GridParallelRNG &pRNG) {$/;"	f	class:Grid::QCD::GaugeImplTypes
generate_momenta	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void generate_momenta(Field& P, GridParallelRNG& pRNG) {$/;"	f	class:Grid::ScalarAdjMatrixImplTypes
generate_momenta	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void generate_momenta(Field& P, GridParallelRNG& pRNG){$/;"	f	class:Grid::ScalarImplTypes
generator	lib/qcd/utils/SUn.h	/^  static void generator(int lieIndex, iSUnMatrix<cplx> &ta) {$/;"	f	class:Grid::QCD::SU
generator	lib/qcd/utils/SUnAdjoint.h	/^  static void generator(int Index, iSUnAdjointMatrix<cplx> &iAdjTa) {$/;"	f	class:Grid::QCD::SU_Adjoint
generator	lib/qcd/utils/SUnTwoIndex.h	/^  static void generator(int Index, iSUnTwoIndexMatrix<cplx> &i2indTa) {$/;"	f	class:Grid::QCD::SU_TwoIndex
generatorDiagonal	lib/qcd/utils/SUn.h	/^  static void generatorDiagonal(int diagIndex, iSUnMatrix<cplx> &ta) {$/;"	f	class:Grid::QCD::SU
generatorSigmaX	lib/qcd/utils/SUn.h	/^  static void generatorSigmaX(int su2Index, iSUnMatrix<cplx> &ta) {$/;"	f	class:Grid::QCD::SU
generatorSigmaY	lib/qcd/utils/SUn.h	/^  static void generatorSigmaY(int su2Index, iSUnMatrix<cplx> &ta) {$/;"	f	class:Grid::QCD::SU
generator_idx	lib/lattice/Lattice_rng.h	/^    int generator_idx(int os,int is) {$/;"	f	class:Grid::GridParallelRNG
generic_dense_assignment_kernel	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC generic_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
generic_dense_assignment_kernel	lib/Eigen/src/Core/AssignEvaluator.h	/^class generic_dense_assignment_kernel$/;"	c	namespace:Eigen::internal
generic_dense_assignment_kernel	lib/Eigen/src/Core/Swap.h	/^  EIGEN_DEVICE_FUNC generic_dense_assignment_kernel(DstEvaluatorTypeT &dst, const SrcEvaluatorTypeT &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
generic_dense_assignment_kernel	lib/Eigen/src/Core/Swap.h	/^class generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, swap_assign_op<typename DstEvaluatorTypeT::Scalar>, Specialized>$/;"	c	namespace:Eigen::internal
generic_fast_tanh_float	lib/Eigen/src/Core/MathFunctionsImpl.h	/^T generic_fast_tanh_float(const T& a_x)$/;"	f	namespace:Eigen::internal
generic_matrix_wrapper	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  generic_matrix_wrapper()$/;"	f	class:Eigen::internal::generic_matrix_wrapper
generic_matrix_wrapper	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  generic_matrix_wrapper(const InputType &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
generic_matrix_wrapper	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  generic_matrix_wrapper(const MatrixType &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
generic_matrix_wrapper	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class generic_matrix_wrapper<MatrixType,false>$/;"	c	namespace:Eigen::internal
generic_matrix_wrapper	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class generic_matrix_wrapper<MatrixType,true>$/;"	c	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Inverse<Lhs>, Rhs, PermutationShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Inverse<Rhs>, MatrixShape, PermutationShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, MatrixShape, PermutationShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, MatrixShape, TranspositionsShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, PermutationShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, TranspositionsShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Transpose<Rhs>, MatrixShape, TranspositionsShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> $/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,InnerProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,OuterProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,SelfAdjointShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,TriangularShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,SelfAdjointShape,DenseShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,TriangularShape,DenseShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Transpose<Lhs>, Rhs, TranspositionsShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemmProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Homogeneous<LhsArg,Horizontal>, Rhs, HomogeneousShape, DenseShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Lhs, Homogeneous<RhsArg,Vertical>, DenseShape, HomogeneousShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Lhs, Homogeneous<RhsArg,Vertical>, TriangularShape, HomogeneousShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Transform<Scalar,Dim,Mode,Options>, Homogeneous<RhsArg,Vertical>, DenseShape, HomogeneousShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, DenseShape, SparseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, DenseShape, SparseTriangularShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseShape, DenseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseTriangularShape, DenseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseShape, SparseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseShape, SparseTriangularShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseTriangularShape, SparseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct generic_product_impl<Lhs, RhsView, DenseShape, SparseSelfAdjointShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct generic_product_impl<LhsView, Rhs, SparseSelfAdjointShape, DenseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl_base	lib/Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl_base$/;"	s	namespace:Eigen::internal
generic_xpr_base	lib/Eigen/src/Core/SolverBase.h	/^struct generic_xpr_base<Derived, MatrixXpr, SolverStorage>$/;"	s	namespace:Eigen::internal
generic_xpr_base	lib/Eigen/src/SparseCore/SparseUtil.h	/^struct generic_xpr_base<Derived, MatrixXpr, Sparse>$/;"	s	namespace:Eigen::internal
geom	lib/algorithms/CoarsenedMatrix.h	/^    Geometry         geom;$/;"	m	class:Grid::CoarsenedMatrix
get	extras/Hadrons/Environment.hpp	/^T & Holder<T>::get(void) const$/;"	f	class:Holder
get	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar get(const RhsEval &rhs, Index outer, Dense = Dense()) const$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
get	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar get(const RhsEval &rhs, Index outer, Sparse = Sparse())$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
get	lib/Hadrons/Environment.hpp	/^T & Holder<T>::get(void) const$/;"	f	class:Holder
get	lib/json/json.hpp	/^    ValueType get() const$/;"	f	class:nlohmann::basic_json
get	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_text::get() const$/;"	f	class:pugi::xml_text
get	lib/pugixml/pugixml.cc	/^	PUGI__FN const xpath_variable* xpath_variable_set::get(const char_t* name) const$/;"	f	class:pugi::xpath_variable_set
get	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable* xpath_variable_set::get(const char_t* name)$/;"	f	class:pugi::xpath_variable_set
get4dRng	extras/Hadrons/Environment.cc	/^GridParallelRNG * Environment::get4dRng(void) const$/;"	f	class:Environment
get4dRng	lib/Hadrons/Environment.cc	/^GridParallelRNG * Environment::get4dRng(void) const$/;"	f	class:Environment
getAdjacentVertices	extras/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getAdjacentVertices(const T &value) const$/;"	f	class:Graph
getAdjacentVertices	lib/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getAdjacentVertices(const T &value) const$/;"	f	class:Graph
getBounds	lib/algorithms/approx/Remez.h	/^  void getBounds(double &lower, double &upper) { $/;"	f	class:AlgRemez
getBuilderList	extras/Hadrons/Factory.hpp	/^std::vector<std::string> Factory<T>::getBuilderList(void) const$/;"	f	class:Factory
getBuilderList	lib/Hadrons/Factory.hpp	/^std::vector<std::string> Factory<T>::getBuilderList(void) const$/;"	f	class:Factory
getBuilderList	lib/qcd/modules/Factory.h	/^std::vector<std::string> Factory<T, CreatorInput>::getBuilderList(void) const$/;"	f	class:Grid::Factory
getChildren	extras/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getChildren(const T &value) const$/;"	f	class:Graph
getChildren	lib/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getChildren(const T &value) const$/;"	f	class:Graph
getConnectedComponents	extras/Hadrons/Graph.hpp	/^std::vector<Graph<T>> Graph<T>::getConnectedComponents(void) const$/;"	f	class:Graph
getConnectedComponents	lib/Hadrons/Graph.hpp	/^std::vector<Graph<T>> Graph<T>::getConnectedComponents(void) const$/;"	f	class:Graph
getDefaultPrecision	lib/algorithms/approx/bigfloat.h	/^  unsigned long getDefaultPrecision(void) const { return mpf_get_default_prec(); }$/;"	f	class:bigfloat
getDefaultPrecision	lib/algorithms/approx/bigfloat_double.h	/^  unsigned long getDefaultPrecision(void) const { return 64; }$/;"	f	class:bigfloat
getDegree	lib/algorithms/approx/Remez.h	/^  int getDegree(void){ $/;"	f	class:AlgRemez
getDim	extras/Hadrons/Environment.cc	/^int Environment::getDim(const unsigned int mu) const$/;"	f	class:Environment
getDim	extras/Hadrons/Environment.cc	/^std::vector<int> Environment::getDim(void) const$/;"	f	class:Environment
getDim	lib/Hadrons/Environment.cc	/^int Environment::getDim(const unsigned int mu) const$/;"	f	class:Environment
getDim	lib/Hadrons/Environment.cc	/^std::vector<int> Environment::getDim(void) const$/;"	f	class:Environment
getDim	lib/serialisation/BaseIO.h	/^  const std::vector<size_t> & Flatten<V>::getDim(void)$/;"	f	class:Grid::Flatten
getDim	lib/serialisation/BaseIO.h	/^  const std::vector<size_t> & Reconstruct<V>::getDim(void)$/;"	f	class:Grid::Reconstruct
getDimensions	lib/parallelIO/IldgIOtypes.h	/^  std::vector<int> getDimensions(void) { $/;"	f	struct:Grid::scidacFile
getErr	lib/algorithms/approx/Remez.cc	/^bigfloat AlgRemez::getErr(bigfloat x, int *sign) {$/;"	f	class:AlgRemez
getFermionOperator	lib/qcd/modules/ActionModules.h	/^  void getFermionOperator(Reader<ReaderClass>& Reader, operator_type &fo, std::string section_name){$/;"	f	class:Grid::QCD::PseudoFermionModuleBase
getFirstMarked	extras/Hadrons/Graph.hpp	/^const T * Graph<T>::getFirstMarked(const bool isMarked) const$/;"	f	class:Graph
getFirstMarked	lib/Hadrons/Graph.hpp	/^const T * Graph<T>::getFirstMarked(const bool isMarked) const$/;"	f	class:Graph
getFirstUnmarked	extras/Hadrons/Graph.hpp	/^const T * Graph<T>::getFirstUnmarked(void) const$/;"	f	class:Graph
getFirstUnmarked	lib/Hadrons/Graph.hpp	/^const T * Graph<T>::getFirstUnmarked(void) const$/;"	f	class:Graph
getFlatVector	lib/serialisation/BaseIO.h	/^  Flatten<V>::getFlatVector(void)$/;"	f	class:Grid::Flatten
getFlatVector	lib/serialisation/BaseIO.h	/^  Reconstruct<V>::getFlatVector(void)$/;"	f	class:Grid::Reconstruct
getFormatString	lib/parallelIO/MetaData.h	/^  template<class vobj> static std::string getFormatString (void)$/;"	f	namespace:Grid
getGrid	extras/Hadrons/Environment.cc	/^GridCartesian * Environment::getGrid(const unsigned int Ls) const$/;"	f	class:Environment
getGrid	lib/Hadrons/Environment.cc	/^GridCartesian * Environment::getGrid(const unsigned int Ls) const$/;"	f	class:Environment
getIPFE	lib/algorithms/approx/Remez.cc	/^int AlgRemez::getIPFE(double *Res, double *Pole, double *Norm) {$/;"	f	class:AlgRemez
getInput	extras/Hadrons/Modules/MAction/DWF.hpp	/^std::vector<std::string> TDWF<FImpl>::getInput(void)$/;"	f	class:TDWF
getInput	extras/Hadrons/Modules/MAction/Wilson.hpp	/^std::vector<std::string> TWilson<FImpl>::getInput(void)$/;"	f	class:TWilson
getInput	extras/Hadrons/Modules/MContraction/Baryon.hpp	/^std::vector<std::string> TBaryon<FImpl1, FImpl2, FImpl3>::getInput(void)$/;"	f	class:TBaryon
getInput	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^std::vector<std::string> TDiscLoop<FImpl>::getInput(void)$/;"	f	class:TDiscLoop
getInput	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^std::vector<std::string> TGamma3pt<FImpl1, FImpl2, FImpl3>::getInput(void)$/;"	f	class:TGamma3pt
getInput	extras/Hadrons/Modules/MContraction/Meson.hpp	/^std::vector<std::string> TMeson<FImpl1, FImpl2>::getInput(void)$/;"	f	class:TMeson
getInput	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^std::vector<std::string> TWeakHamiltonianEye::getInput(void)$/;"	f	class:TWeakHamiltonianEye
getInput	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^std::vector<std::string> TWeakHamiltonianNonEye::getInput(void)$/;"	f	class:TWeakHamiltonianNonEye
getInput	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^std::vector<std::string> TWeakNeutral4ptDisc::getInput(void)$/;"	f	class:TWeakNeutral4ptDisc
getInput	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^std::vector<std::string> TGaugeProp<FImpl>::getInput(void)$/;"	f	class:TGaugeProp
getInput	extras/Hadrons/Modules/MGauge/Load.cc	/^std::vector<std::string> TLoad::getInput(void)$/;"	f	class:TLoad
getInput	extras/Hadrons/Modules/MGauge/Random.cc	/^std::vector<std::string> TRandom::getInput(void)$/;"	f	class:TRandom
getInput	extras/Hadrons/Modules/MGauge/StochEm.cc	/^std::vector<std::string> TStochEm::getInput(void)$/;"	f	class:TStochEm
getInput	extras/Hadrons/Modules/MGauge/Unit.cc	/^std::vector<std::string> TUnit::getInput(void)$/;"	f	class:TUnit
getInput	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^std::vector<std::string> TNoiseLoop<FImpl>::getInput(void)$/;"	f	class:TNoiseLoop
getInput	extras/Hadrons/Modules/MScalar/ChargedProp.cc	/^std::vector<std::string> TChargedProp::getInput(void)$/;"	f	class:TChargedProp
getInput	extras/Hadrons/Modules/MScalar/FreeProp.cc	/^std::vector<std::string> TFreeProp::getInput(void)$/;"	f	class:TFreeProp
getInput	extras/Hadrons/Modules/MSink/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getInput(void)$/;"	f	class:TPoint
getInput	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^std::vector<std::string> TRBPrecCG<FImpl>::getInput(void)$/;"	f	class:TRBPrecCG
getInput	extras/Hadrons/Modules/MSource/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getInput(void)$/;"	f	class:TPoint
getInput	extras/Hadrons/Modules/MSource/SeqGamma.hpp	/^std::vector<std::string> TSeqGamma<FImpl>::getInput(void)$/;"	f	class:TSeqGamma
getInput	extras/Hadrons/Modules/MSource/Wall.hpp	/^std::vector<std::string> TWall<FImpl>::getInput(void)$/;"	f	class:TWall
getInput	extras/Hadrons/Modules/MSource/Z2.hpp	/^std::vector<std::string> TZ2<FImpl>::getInput(void)$/;"	f	class:TZ2
getInput	lib/Hadrons/Modules/MAction/DWF.hpp	/^std::vector<std::string> TDWF<FImpl>::getInput(void)$/;"	f	class:TDWF
getInput	lib/Hadrons/Modules/MAction/Wilson.hpp	/^std::vector<std::string> TWilson<FImpl>::getInput(void)$/;"	f	class:TWilson
getInput	lib/Hadrons/Modules/MContraction/Baryon.hpp	/^std::vector<std::string> TBaryon<FImpl1, FImpl2, FImpl3>::getInput(void)$/;"	f	class:TBaryon
getInput	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^std::vector<std::string> TDiscLoop<FImpl>::getInput(void)$/;"	f	class:TDiscLoop
getInput	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^std::vector<std::string> TGamma3pt<FImpl1, FImpl2, FImpl3>::getInput(void)$/;"	f	class:TGamma3pt
getInput	lib/Hadrons/Modules/MContraction/Meson.hpp	/^std::vector<std::string> TMeson<FImpl1, FImpl2>::getInput(void)$/;"	f	class:TMeson
getInput	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^std::vector<std::string> TWeakHamiltonianEye::getInput(void)$/;"	f	class:TWeakHamiltonianEye
getInput	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^std::vector<std::string> TWeakHamiltonianNonEye::getInput(void)$/;"	f	class:TWeakHamiltonianNonEye
getInput	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^std::vector<std::string> TWeakNeutral4ptDisc::getInput(void)$/;"	f	class:TWeakNeutral4ptDisc
getInput	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^std::vector<std::string> TGaugeProp<FImpl>::getInput(void)$/;"	f	class:TGaugeProp
getInput	lib/Hadrons/Modules/MGauge/Load.cc	/^std::vector<std::string> TLoad::getInput(void)$/;"	f	class:TLoad
getInput	lib/Hadrons/Modules/MGauge/Random.cc	/^std::vector<std::string> TRandom::getInput(void)$/;"	f	class:TRandom
getInput	lib/Hadrons/Modules/MGauge/StochEm.cc	/^std::vector<std::string> TStochEm::getInput(void)$/;"	f	class:TStochEm
getInput	lib/Hadrons/Modules/MGauge/Unit.cc	/^std::vector<std::string> TUnit::getInput(void)$/;"	f	class:TUnit
getInput	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^std::vector<std::string> TNoiseLoop<FImpl>::getInput(void)$/;"	f	class:TNoiseLoop
getInput	lib/Hadrons/Modules/MScalar/ChargedProp.cc	/^std::vector<std::string> TChargedProp::getInput(void)$/;"	f	class:TChargedProp
getInput	lib/Hadrons/Modules/MScalar/FreeProp.cc	/^std::vector<std::string> TFreeProp::getInput(void)$/;"	f	class:TFreeProp
getInput	lib/Hadrons/Modules/MSink/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getInput(void)$/;"	f	class:TPoint
getInput	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^std::vector<std::string> TRBPrecCG<FImpl>::getInput(void)$/;"	f	class:TRBPrecCG
getInput	lib/Hadrons/Modules/MSource/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getInput(void)$/;"	f	class:TPoint
getInput	lib/Hadrons/Modules/MSource/SeqGamma.hpp	/^std::vector<std::string> TSeqGamma<FImpl>::getInput(void)$/;"	f	class:TSeqGamma
getInput	lib/Hadrons/Modules/MSource/Wall.hpp	/^std::vector<std::string> TWall<FImpl>::getInput(void)$/;"	f	class:TWall
getInput	lib/Hadrons/Modules/MSource/Z2.hpp	/^std::vector<std::string> TZ2<FImpl>::getInput(void)$/;"	f	class:TZ2
getInstance	lib/qcd/hmc/HMCRunnerModule.h	/^  static HMCRunnerModuleFactory& getInstance(void) {$/;"	f	class:Grid::HMCRunnerModuleFactory
getInstance	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  static HMC_CPModuleFactory& getInstance(void) {$/;"	f	class:Grid::HMC_CPModuleFactory
getInstance	lib/qcd/modules/ActionModules.h	/^  static HMC_ActionModuleFactory& getInstance(void) {$/;"	f	class:Grid::HMC_ActionModuleFactory
getInstance	lib/qcd/modules/FermionOperatorModules.h	/^  static HMC_FermionOperatorModuleFactory& getInstance(void) {$/;"	f	class:Grid::HMC_FermionOperatorModuleFactory
getInstance	lib/qcd/modules/ObservableModules.h	/^  static HMC_ObservablesModuleFactory& getInstance(void) {$/;"	f	class:Grid::HMC_ObservablesModuleFactory
getInstance	lib/qcd/modules/SolverModules.h	/^  static HMC_SolverModuleFactory& getInstance(void) {$/;"	f	class:Grid::HMC_SolverModuleFactory
getL	lib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	lib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m.adjoint()); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	lib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	lib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m.adjoint()); }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }$/;"	f	struct:Eigen::internal::traits
getLattice	lib/qcd/hmc/HMC_GridModules.h	/^  std::vector<int> getLattice(){return strToVec<int>(lattice);}$/;"	f	class:Grid::GridModuleParameters
getLinearMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE LinearMapper getLinearMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
getMatrix	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
getMatrix	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
getMatrix	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
getMaxIterations	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexEigenSolver
getMaxIterations	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexSchur
getMaxIterations	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::EigenSolver
getMaxIterations	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::RealSchur
getMinSchedule	extras/Hadrons/GeneticScheduler.hpp	/^GeneticScheduler<T>::getMinSchedule(void)$/;"	f	class:GeneticScheduler
getMinSchedule	lib/Hadrons/GeneticScheduler.hpp	/^GeneticScheduler<T>::getMinSchedule(void)$/;"	f	class:GeneticScheduler
getMinValue	extras/Hadrons/GeneticScheduler.hpp	/^int GeneticScheduler<T>::getMinValue(void)$/;"	f	class:GeneticScheduler
getMinValue	lib/Hadrons/GeneticScheduler.hpp	/^int GeneticScheduler<T>::getMinValue(void)$/;"	f	class:GeneticScheduler
getModule	extras/Hadrons/Environment.cc	/^ModuleBase * Environment::getModule(const std::string name) const$/;"	f	class:Environment
getModule	extras/Hadrons/Environment.cc	/^ModuleBase * Environment::getModule(const unsigned int address) const$/;"	f	class:Environment
getModule	extras/Hadrons/Environment.hpp	/^M * Environment::getModule(const std::string name) const$/;"	f	class:Environment
getModule	extras/Hadrons/Environment.hpp	/^M * Environment::getModule(const unsigned int address) const$/;"	f	class:Environment
getModule	lib/Hadrons/Environment.cc	/^ModuleBase * Environment::getModule(const std::string name) const$/;"	f	class:Environment
getModule	lib/Hadrons/Environment.cc	/^ModuleBase * Environment::getModule(const unsigned int address) const$/;"	f	class:Environment
getModule	lib/Hadrons/Environment.hpp	/^M * Environment::getModule(const std::string name) const$/;"	f	class:Environment
getModule	lib/Hadrons/Environment.hpp	/^M * Environment::getModule(const unsigned int address) const$/;"	f	class:Environment
getModuleAddress	extras/Hadrons/Environment.cc	/^unsigned int Environment::getModuleAddress(const std::string name) const$/;"	f	class:Environment
getModuleAddress	lib/Hadrons/Environment.cc	/^unsigned int Environment::getModuleAddress(const std::string name) const$/;"	f	class:Environment
getModuleName	extras/Hadrons/Environment.cc	/^std::string Environment::getModuleName(const unsigned int address) const$/;"	f	class:Environment
getModuleName	lib/Hadrons/Environment.cc	/^std::string Environment::getModuleName(const unsigned int address) const$/;"	f	class:Environment
getModuleNamespace	extras/Hadrons/Environment.cc	/^std::string Environment::getModuleNamespace(const std::string name) const$/;"	f	class:Environment
getModuleNamespace	extras/Hadrons/Environment.cc	/^std::string Environment::getModuleNamespace(const unsigned int address) const$/;"	f	class:Environment
getModuleNamespace	lib/Hadrons/Environment.cc	/^std::string Environment::getModuleNamespace(const std::string name) const$/;"	f	class:Environment
getModuleNamespace	lib/Hadrons/Environment.cc	/^std::string Environment::getModuleNamespace(const unsigned int address) const$/;"	f	class:Environment
getModuleType	extras/Hadrons/Environment.cc	/^std::string Environment::getModuleType(const std::string name) const$/;"	f	class:Environment
getModuleType	extras/Hadrons/Environment.cc	/^std::string Environment::getModuleType(const unsigned int address) const$/;"	f	class:Environment
getModuleType	lib/Hadrons/Environment.cc	/^std::string Environment::getModuleType(const std::string name) const$/;"	f	class:Environment
getModuleType	lib/Hadrons/Environment.cc	/^std::string Environment::getModuleType(const unsigned int address) const$/;"	f	class:Environment
getMpi	lib/qcd/hmc/HMC_GridModules.h	/^  std::vector<int> getMpi()    {return strToVec<int>(mpi);}$/;"	f	class:Grid::GridModuleParameters
getNModule	extras/Hadrons/Environment.cc	/^unsigned int Environment::getNModule(void) const$/;"	f	class:Environment
getNModule	lib/Hadrons/Environment.cc	/^unsigned int Environment::getNModule(void) const$/;"	f	class:Environment
getName	extras/Hadrons/Module.cc	/^std::string ModuleBase::getName(void) const$/;"	f	class:ModuleBase
getName	lib/Hadrons/Module.cc	/^std::string ModuleBase::getName(void) const$/;"	f	class:ModuleBase
getNd	extras/Hadrons/Environment.cc	/^unsigned int Environment::getNd(void) const$/;"	f	class:Environment
getNd	lib/Hadrons/Environment.cc	/^unsigned int Environment::getNd(void) const$/;"	f	class:Environment
getObject	extras/Hadrons/Environment.hpp	/^T * Environment::getObject(const std::string name) const$/;"	f	class:Environment
getObject	extras/Hadrons/Environment.hpp	/^T * Environment::getObject(const unsigned int address) const$/;"	f	class:Environment
getObject	lib/Hadrons/Environment.hpp	/^T * Environment::getObject(const std::string name) const$/;"	f	class:Environment
getObject	lib/Hadrons/Environment.hpp	/^T * Environment::getObject(const unsigned int address) const$/;"	f	class:Environment
getObjectAddress	extras/Hadrons/Environment.cc	/^unsigned int Environment::getObjectAddress(const std::string name) const$/;"	f	class:Environment
getObjectAddress	lib/Hadrons/Environment.cc	/^unsigned int Environment::getObjectAddress(const std::string name) const$/;"	f	class:Environment
getObjectLs	extras/Hadrons/Environment.cc	/^unsigned int Environment::getObjectLs(const std::string name) const$/;"	f	class:Environment
getObjectLs	extras/Hadrons/Environment.cc	/^unsigned int Environment::getObjectLs(const unsigned int address) const$/;"	f	class:Environment
getObjectLs	lib/Hadrons/Environment.cc	/^unsigned int Environment::getObjectLs(const std::string name) const$/;"	f	class:Environment
getObjectLs	lib/Hadrons/Environment.cc	/^unsigned int Environment::getObjectLs(const unsigned int address) const$/;"	f	class:Environment
getObjectModule	extras/Hadrons/Environment.cc	/^unsigned int Environment::getObjectModule(const std::string name) const$/;"	f	class:Environment
getObjectModule	extras/Hadrons/Environment.cc	/^unsigned int Environment::getObjectModule(const unsigned int address) const$/;"	f	class:Environment
getObjectModule	lib/Hadrons/Environment.cc	/^unsigned int Environment::getObjectModule(const std::string name) const$/;"	f	class:Environment
getObjectModule	lib/Hadrons/Environment.cc	/^unsigned int Environment::getObjectModule(const unsigned int address) const$/;"	f	class:Environment
getObjectName	extras/Hadrons/Environment.cc	/^std::string Environment::getObjectName(const unsigned int address) const$/;"	f	class:Environment
getObjectName	lib/Hadrons/Environment.cc	/^std::string Environment::getObjectName(const unsigned int address) const$/;"	f	class:Environment
getObjectSize	extras/Hadrons/Environment.cc	/^Environment::Size Environment::getObjectSize(const std::string name) const$/;"	f	class:Environment
getObjectSize	extras/Hadrons/Environment.cc	/^Environment::Size Environment::getObjectSize(const unsigned int address) const$/;"	f	class:Environment
getObjectSize	lib/Hadrons/Environment.cc	/^Environment::Size Environment::getObjectSize(const std::string name) const$/;"	f	class:Environment
getObjectSize	lib/Hadrons/Environment.cc	/^Environment::Size Environment::getObjectSize(const unsigned int address) const$/;"	f	class:Environment
getObjectType	extras/Hadrons/Environment.cc	/^std::string Environment::getObjectType(const std::string name) const$/;"	f	class:Environment
getObjectType	extras/Hadrons/Environment.cc	/^std::string Environment::getObjectType(const unsigned int address) const$/;"	f	class:Environment
getObjectType	lib/Hadrons/Environment.cc	/^std::string Environment::getObjectType(const std::string name) const$/;"	f	class:Environment
getObjectType	lib/Hadrons/Environment.cc	/^std::string Environment::getObjectType(const unsigned int address) const$/;"	f	class:Environment
getOutput	extras/Hadrons/Modules/MAction/DWF.hpp	/^std::vector<std::string> TDWF<FImpl>::getOutput(void)$/;"	f	class:TDWF
getOutput	extras/Hadrons/Modules/MAction/Wilson.hpp	/^std::vector<std::string> TWilson<FImpl>::getOutput(void)$/;"	f	class:TWilson
getOutput	extras/Hadrons/Modules/MContraction/Baryon.hpp	/^std::vector<std::string> TBaryon<FImpl1, FImpl2, FImpl3>::getOutput(void)$/;"	f	class:TBaryon
getOutput	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^std::vector<std::string> TDiscLoop<FImpl>::getOutput(void)$/;"	f	class:TDiscLoop
getOutput	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^std::vector<std::string> TGamma3pt<FImpl1, FImpl2, FImpl3>::getOutput(void)$/;"	f	class:TGamma3pt
getOutput	extras/Hadrons/Modules/MContraction/Meson.hpp	/^std::vector<std::string> TMeson<FImpl1, FImpl2>::getOutput(void)$/;"	f	class:TMeson
getOutput	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^std::vector<std::string> TWeakHamiltonianEye::getOutput(void)$/;"	f	class:TWeakHamiltonianEye
getOutput	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^std::vector<std::string> TWeakHamiltonianNonEye::getOutput(void)$/;"	f	class:TWeakHamiltonianNonEye
getOutput	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^std::vector<std::string> TWeakNeutral4ptDisc::getOutput(void)$/;"	f	class:TWeakNeutral4ptDisc
getOutput	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^std::vector<std::string> TGaugeProp<FImpl>::getOutput(void)$/;"	f	class:TGaugeProp
getOutput	extras/Hadrons/Modules/MGauge/Load.cc	/^std::vector<std::string> TLoad::getOutput(void)$/;"	f	class:TLoad
getOutput	extras/Hadrons/Modules/MGauge/Random.cc	/^std::vector<std::string> TRandom::getOutput(void)$/;"	f	class:TRandom
getOutput	extras/Hadrons/Modules/MGauge/StochEm.cc	/^std::vector<std::string> TStochEm::getOutput(void)$/;"	f	class:TStochEm
getOutput	extras/Hadrons/Modules/MGauge/Unit.cc	/^std::vector<std::string> TUnit::getOutput(void)$/;"	f	class:TUnit
getOutput	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^std::vector<std::string> TNoiseLoop<FImpl>::getOutput(void)$/;"	f	class:TNoiseLoop
getOutput	extras/Hadrons/Modules/MScalar/ChargedProp.cc	/^std::vector<std::string> TChargedProp::getOutput(void)$/;"	f	class:TChargedProp
getOutput	extras/Hadrons/Modules/MScalar/FreeProp.cc	/^std::vector<std::string> TFreeProp::getOutput(void)$/;"	f	class:TFreeProp
getOutput	extras/Hadrons/Modules/MSink/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getOutput(void)$/;"	f	class:TPoint
getOutput	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^std::vector<std::string> TRBPrecCG<FImpl>::getOutput(void)$/;"	f	class:TRBPrecCG
getOutput	extras/Hadrons/Modules/MSource/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getOutput(void)$/;"	f	class:TPoint
getOutput	extras/Hadrons/Modules/MSource/SeqGamma.hpp	/^std::vector<std::string> TSeqGamma<FImpl>::getOutput(void)$/;"	f	class:TSeqGamma
getOutput	extras/Hadrons/Modules/MSource/Wall.hpp	/^std::vector<std::string> TWall<FImpl>::getOutput(void)$/;"	f	class:TWall
getOutput	extras/Hadrons/Modules/MSource/Z2.hpp	/^std::vector<std::string> TZ2<FImpl>::getOutput(void)$/;"	f	class:TZ2
getOutput	lib/Hadrons/Modules/MAction/DWF.hpp	/^std::vector<std::string> TDWF<FImpl>::getOutput(void)$/;"	f	class:TDWF
getOutput	lib/Hadrons/Modules/MAction/Wilson.hpp	/^std::vector<std::string> TWilson<FImpl>::getOutput(void)$/;"	f	class:TWilson
getOutput	lib/Hadrons/Modules/MContraction/Baryon.hpp	/^std::vector<std::string> TBaryon<FImpl1, FImpl2, FImpl3>::getOutput(void)$/;"	f	class:TBaryon
getOutput	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^std::vector<std::string> TDiscLoop<FImpl>::getOutput(void)$/;"	f	class:TDiscLoop
getOutput	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^std::vector<std::string> TGamma3pt<FImpl1, FImpl2, FImpl3>::getOutput(void)$/;"	f	class:TGamma3pt
getOutput	lib/Hadrons/Modules/MContraction/Meson.hpp	/^std::vector<std::string> TMeson<FImpl1, FImpl2>::getOutput(void)$/;"	f	class:TMeson
getOutput	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^std::vector<std::string> TWeakHamiltonianEye::getOutput(void)$/;"	f	class:TWeakHamiltonianEye
getOutput	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^std::vector<std::string> TWeakHamiltonianNonEye::getOutput(void)$/;"	f	class:TWeakHamiltonianNonEye
getOutput	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^std::vector<std::string> TWeakNeutral4ptDisc::getOutput(void)$/;"	f	class:TWeakNeutral4ptDisc
getOutput	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^std::vector<std::string> TGaugeProp<FImpl>::getOutput(void)$/;"	f	class:TGaugeProp
getOutput	lib/Hadrons/Modules/MGauge/Load.cc	/^std::vector<std::string> TLoad::getOutput(void)$/;"	f	class:TLoad
getOutput	lib/Hadrons/Modules/MGauge/Random.cc	/^std::vector<std::string> TRandom::getOutput(void)$/;"	f	class:TRandom
getOutput	lib/Hadrons/Modules/MGauge/StochEm.cc	/^std::vector<std::string> TStochEm::getOutput(void)$/;"	f	class:TStochEm
getOutput	lib/Hadrons/Modules/MGauge/Unit.cc	/^std::vector<std::string> TUnit::getOutput(void)$/;"	f	class:TUnit
getOutput	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^std::vector<std::string> TNoiseLoop<FImpl>::getOutput(void)$/;"	f	class:TNoiseLoop
getOutput	lib/Hadrons/Modules/MScalar/ChargedProp.cc	/^std::vector<std::string> TChargedProp::getOutput(void)$/;"	f	class:TChargedProp
getOutput	lib/Hadrons/Modules/MScalar/FreeProp.cc	/^std::vector<std::string> TFreeProp::getOutput(void)$/;"	f	class:TFreeProp
getOutput	lib/Hadrons/Modules/MSink/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getOutput(void)$/;"	f	class:TPoint
getOutput	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^std::vector<std::string> TRBPrecCG<FImpl>::getOutput(void)$/;"	f	class:TRBPrecCG
getOutput	lib/Hadrons/Modules/MSource/Point.hpp	/^std::vector<std::string> TPoint<FImpl>::getOutput(void)$/;"	f	class:TPoint
getOutput	lib/Hadrons/Modules/MSource/SeqGamma.hpp	/^std::vector<std::string> TSeqGamma<FImpl>::getOutput(void)$/;"	f	class:TSeqGamma
getOutput	lib/Hadrons/Modules/MSource/Wall.hpp	/^std::vector<std::string> TWall<FImpl>::getOutput(void)$/;"	f	class:TWall
getOutput	lib/Hadrons/Modules/MSource/Z2.hpp	/^std::vector<std::string> TZ2<FImpl>::getOutput(void)$/;"	f	class:TZ2
getPFE	lib/algorithms/approx/Remez.cc	/^int AlgRemez::getPFE(double *Res, double *Pole, double *Norm) {$/;"	f	class:AlgRemez
getPar	extras/Hadrons/Application.cc	/^const Application::GlobalPar & Application::getPar(void)$/;"	f	class:Application
getPar	lib/Hadrons/Application.cc	/^const Application::GlobalPar & Application::getPar(void)$/;"	f	class:Application
getParallelSeeds	lib/qcd/hmc/HMCModules.h	/^  std::vector<int> getParallelSeeds(){return strToVec<int>(parallel_seeds);}$/;"	f	struct:Grid::QCD::RNGModuleParameters
getParents	extras/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getParents(const T &value) const$/;"	f	class:Graph
getParents	lib/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getParents(const T &value) const$/;"	f	class:Graph
getPrecision	lib/algorithms/approx/bigfloat.h	/^  unsigned long getPrecision(void) const { return mpf_get_prec(x); }$/;"	f	class:bigfloat
getPrecision	lib/algorithms/approx/bigfloat_double.h	/^  unsigned long getPrecision(void) const { return 64; }$/;"	f	class:bigfloat
getPrecision	lib/tensors/Tensor_traits.h	/^  class getPrecision{$/;"	c	namespace:Grid
getPt	extras/Hadrons/Environment.hpp	/^T * Holder<T>::getPt(void) const$/;"	f	class:Holder
getPt	lib/Hadrons/Environment.hpp	/^T * Holder<T>::getPt(void) const$/;"	f	class:Holder
getPtr	lib/qcd/hmc/HMCRunnerModule.h	/^  Product* getPtr() {$/;"	f	class:Grid::HMCModule
getPtr	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  Product* getPtr() {$/;"	f	class:Grid::CheckPointerModule
getPtr	lib/qcd/modules/ActionModules.h	/^  Product* getPtr() {$/;"	f	class:Grid::ActionModule
getPtr	lib/qcd/modules/FermionOperatorModules.h	/^  Product* getPtr() {$/;"	f	class:Grid::FermionOperatorModule
getPtr	lib/qcd/modules/ObservableModules.h	/^  Product* getPtr() {$/;"	f	class:Grid::ObservableModule
getPtr	lib/qcd/modules/SolverModules.h	/^  Product* getPtr() {$/;"	f	class:Grid::SolverModule
getRandomMarked	extras/Hadrons/Graph.hpp	/^const T * Graph<T>::getRandomMarked(const bool isMarked, Gen &gen)$/;"	f	class:Graph
getRandomMarked	lib/Hadrons/Graph.hpp	/^const T * Graph<T>::getRandomMarked(const bool isMarked, Gen &gen)$/;"	f	class:Graph
getRandomUnmarked	extras/Hadrons/Graph.hpp	/^const T * Graph<T>::getRandomUnmarked(Gen &gen)$/;"	f	class:Graph
getRandomUnmarked	lib/Hadrons/Graph.hpp	/^const T * Graph<T>::getRandomUnmarked(Gen &gen)$/;"	f	class:Graph
getRbGrid	extras/Hadrons/Environment.cc	/^GridRedBlackCartesian * Environment::getRbGrid(const unsigned int Ls) const$/;"	f	class:Environment
getRbGrid	lib/Hadrons/Environment.cc	/^GridRedBlackCartesian * Environment::getRbGrid(const unsigned int Ls) const$/;"	f	class:Environment
getRegisteredName	extras/Hadrons/Module.cc	/^std::string ModuleBase::getRegisteredName(void)$/;"	f	class:ModuleBase
getRegisteredName	lib/Hadrons/Module.cc	/^std::string ModuleBase::getRegisteredName(void)$/;"	f	class:ModuleBase
getRoots	extras/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getRoots(void) const$/;"	f	class:Graph
getRoots	lib/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getRoots(void) const$/;"	f	class:Graph
getSerialSeeds	lib/qcd/hmc/HMCModules.h	/^  std::vector<int> getSerialSeeds(){return strToVec<int>(serial_seeds);}$/;"	f	struct:Grid::QCD::RNGModuleParameters
getSolverOperator	lib/qcd/modules/ActionModules.h	/^  void getSolverOperator(Reader<ReaderClass>& Reader, solver_type &so, std::string section_name){$/;"	f	class:Grid::QCD::PseudoFermionModuleBase
getSubMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_ALWAYS_INLINE const_blas_data_mapper<Scalar, Index, StorageOrder> getSubMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::const_blas_data_mapper
getSubMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  getSubMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
getTotalSize	extras/Hadrons/Environment.cc	/^Environment::Size Environment::getTotalSize(void) const$/;"	f	class:Environment
getTotalSize	lib/Hadrons/Environment.cc	/^Environment::Size Environment::getTotalSize(void) const$/;"	f	class:Environment
getTrajectory	extras/Hadrons/Environment.cc	/^unsigned int Environment::getTrajectory(void) const$/;"	f	class:Environment
getTrajectory	lib/Hadrons/Environment.cc	/^unsigned int Environment::getTrajectory(void) const$/;"	f	class:Environment
getU	lib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	lib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	lib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m); }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	lib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }$/;"	f	struct:Eigen::internal::traits
getVector	lib/serialisation/BaseIO.h	/^  const V & Flatten<V>::getVector(void)$/;"	f	class:Grid::Flatten
getVector	lib/serialisation/BaseIO.h	/^  const V & Reconstruct<V>::getVector(void)$/;"	f	class:Grid::Reconstruct
getVectorMapper	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE VectorMapper getVectorMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
getVectorType	lib/lattice/Lattice_ET.h	/^struct getVectorType<Lattice<T> >{$/;"	s	namespace:Grid
getVectorType	lib/tensors/Tensor_traits.h	/^  struct getVectorType{$/;"	s	namespace:Grid
getVertices	extras/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getVertices(void) const$/;"	f	class:Graph
getVertices	lib/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::getVertices(void) const$/;"	f	class:Graph
get_SmearedU	lib/qcd/smearing/GaugeConfiguration.h	/^  Field& get_SmearedU() { return *ThinField; }$/;"	f	class:Grid::QCD::NoSmearing
get_SmearedU	lib/qcd/smearing/GaugeConfiguration.h	/^  GaugeField& get_SmearedU() { return SmearedSet[smearingLevels - 1]; }$/;"	f	class:Grid::QCD::SmearedConfiguration
get_U	lib/qcd/smearing/GaugeConfiguration.h	/^  Field& get_U(bool smeared = false) {$/;"	f	class:Grid::QCD::NoSmearing
get_U	lib/qcd/smearing/GaugeConfiguration.h	/^  GaugeField& get_U(bool smeared = false) {$/;"	f	class:Grid::QCD::SmearedConfiguration
get_allocator	lib/json/json.hpp	/^    static allocator_type get_allocator()$/;"	f	class:nlohmann::basic_json
get_allocator	lib/pugixml/pugixml.cc	/^	template <typename Object> inline xml_allocator& get_allocator(const Object* object)$/;"	f
get_and_create	lib/json/json.hpp	/^        reference get_and_create(reference j) const$/;"	f	class:nlohmann::basic_json::json_pointer
get_boolean	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable::get_boolean() const$/;"	f	class:pugi::xpath_variable
get_buffer_encoding	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_encoding get_buffer_encoding(xml_encoding encoding, const void* contents, size_t size)$/;"	f
get_checked	lib/json/json.hpp	/^        const_reference get_checked(const_pointer ptr) const$/;"	f	class:nlohmann::basic_json::json_pointer
get_checked	lib/json/json.hpp	/^        reference get_checked(pointer ptr) const$/;"	f	class:nlohmann::basic_json::json_pointer
get_document	lib/pugixml/pugixml.cc	/^	template <typename Object> inline xml_document_struct& get_document(const Object* object)$/;"	f
get_factor	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
get_factor	lib/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
get_file_size	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_status get_file_size(FILE* file, size_t& out_result)$/;"	f
get_full	lib/qcd/hmc/HMC_GridModules.h	/^  GridCartesian* get_full() { $/;"	f	class:Grid::GridModule
get_impl	lib/json/json.hpp	/^    T get_impl(T*) const$/;"	f	class:nlohmann::basic_json
get_impl	lib/json/json.hpp	/^    array_t get_impl(array_t*) const$/;"	f	class:nlohmann::basic_json
get_impl	lib/json/json.hpp	/^    constexpr boolean_t get_impl(boolean_t*) const$/;"	f	class:nlohmann::basic_json
get_impl	lib/json/json.hpp	/^    object_t get_impl(object_t*) const$/;"	f	class:nlohmann::basic_json
get_impl	lib/json/json.hpp	/^    std::vector<T> get_impl(std::vector<T>*) const$/;"	f	class:nlohmann::basic_json
get_integer_base	lib/pugixml/pugixml.cc	/^	PUGI__FN int get_integer_base(const char_t* value)$/;"	f
get_latin1_7bit_prefix_length	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t get_latin1_7bit_prefix_length(const uint8_t* data, size_t size)$/;"	f
get_memory_allocation_function	lib/pugixml/pugixml.cc	/^	PUGI__FN allocation_function PUGIXML_FUNCTION get_memory_allocation_function()$/;"	f	namespace:pugi
get_memory_deallocation_function	lib/pugixml/pugixml.cc	/^	PUGI__FN deallocation_function PUGIXML_FUNCTION get_memory_deallocation_function()$/;"	f	namespace:pugi
get_mutable_buffer	lib/pugixml/pugixml.cc	/^	PUGI__FN bool get_mutable_buffer(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)$/;"	f
get_node_set	lib/pugixml/pugixml.cc	/^	PUGI__FN const xpath_node_set& xpath_variable::get_node_set() const$/;"	f	class:pugi::xpath_variable
get_number	lib/json/json.hpp	/^        void get_number(basic_json& result) const$/;"	f	class:nlohmann::basic_json::lexer
get_number	lib/pugixml/pugixml.cc	/^	PUGI__FN double xpath_variable::get_number() const$/;"	f	class:pugi::xpath_variable
get_pRNG	lib/qcd/hmc/HMCModules.h	/^  GridParallelRNG& get_pRNG() { return *pRNG_.get(); }$/;"	f	class:Grid::QCD::RNGModule
get_page	lib/pugixml/pugixml.cc	/^		xml_memory_page* get_page() const$/;"	f	class:compact_header
get_rb	lib/qcd/hmc/HMC_GridModules.h	/^  GridRedBlackCartesian* get_rb() { $/;"	f	class:Grid::GridModule
get_ref	lib/json/json.hpp	/^    ReferenceType get_ref() const$/;"	f	class:nlohmann::basic_json
get_ref	lib/json/json.hpp	/^    ReferenceType get_ref()$/;"	f	class:nlohmann::basic_json
get_ref_impl	lib/json/json.hpp	/^    static ReferenceType get_ref_impl(ThisType& obj)$/;"	f	class:nlohmann::basic_json
get_sRNG	lib/qcd/hmc/HMCModules.h	/^  GridSerialRNG& get_sRNG() { return sRNG_; }$/;"	f	class:Grid::QCD::RNGModule
get_smeared_conf	lib/qcd/smearing/GaugeConfiguration.h	/^  const GaugeField& get_smeared_conf(int Level) const {$/;"	f	class:Grid::QCD::SmearedConfiguration
get_strconv_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN strconv_attribute_t get_strconv_attribute(unsigned int optmask)$/;"	f
get_strconv_pcdata	lib/pugixml/pugixml.cc	/^	PUGI__FN strconv_pcdata_t get_strconv_pcdata(unsigned int optmask)$/;"	f
get_string	lib/json/json.hpp	/^        string_t get_string() const$/;"	f	class:nlohmann::basic_json::lexer
get_string	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xpath_variable::get_string() const$/;"	f	class:pugi::xpath_variable
get_symmetrized_graph	lib/Eigen/src/MetisSupport/MetisSupport.h	/^  void get_symmetrized_graph(const MatrixType& A)$/;"	f	class:Eigen::MetisOrdering
get_token	lib/json/json.hpp	/^        typename lexer::token_type get_token()$/;"	f	class:nlohmann::basic_json::parser
get_token_string	lib/json/json.hpp	/^        string_t get_token_string() const$/;"	f	class:nlohmann::basic_json::lexer
get_unchecked	lib/json/json.hpp	/^        const_reference get_unchecked(const_pointer ptr) const$/;"	f	class:nlohmann::basic_json::json_pointer
get_unchecked	lib/json/json.hpp	/^        reference get_unchecked(pointer ptr) const$/;"	f	class:nlohmann::basic_json::json_pointer
get_valid_length	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t get_valid_length(const char_t* data, size_t length)$/;"	f
get_value_bool	lib/pugixml/pugixml.cc	/^	PUGI__FN bool get_value_bool(const char_t* value)$/;"	f
get_value_double	lib/pugixml/pugixml.cc	/^	PUGI__FN double get_value_double(const char_t* value)$/;"	f
get_value_float	lib/pugixml/pugixml.cc	/^	PUGI__FN float get_value_float(const char_t* value)$/;"	f
get_value_int	lib/pugixml/pugixml.cc	/^	PUGI__FN int get_value_int(const char_t* value)$/;"	f
get_value_llong	lib/pugixml/pugixml.cc	/^	PUGI__FN long long get_value_llong(const char_t* value)$/;"	f
get_value_uint	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned int get_value_uint(const char_t* value)$/;"	f
get_value_ullong	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned long long get_value_ullong(const char_t* value)$/;"	f
get_wchar_encoding	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_encoding get_wchar_encoding()$/;"	f
get_write_encoding	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_encoding get_write_encoding(xml_encoding encoding)$/;"	f
get_write_native_encoding	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_encoding get_write_native_encoding()$/;"	f
getlane	lib/simd/Grid_vector_types.h	/^  inline Scalar_type getlane(int lane) {$/;"	f	class:Grid::Grid_simd
give_advice	missing	/^give_advice ()$/;"	f
global_math_functions_filtering_base	lib/Eigen/src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
glue_shapes	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,SelfAdjointShape> { typedef SparseSelfAdjointShape type;  };$/;"	s	namespace:Eigen::internal
glue_shapes	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,TriangularShape > { typedef SparseTriangularShape  type;  };$/;"	s	namespace:Eigen::internal
gmu	lib/qcd/spin/Gamma.cc	/^const std::array<const Gamma, 4> Gamma::gmu = {{$/;"	m	class:Grid::QCD::Gamma	file:
gmu	lib/qcd/spin/Gamma.h	/^    static const std::array<const Gamma, 4>                      gmu;$/;"	m	class:Grid::QCD::Gamma
gnuplot	lib/algorithms/approx/MultiShiftFunction.cc	/^void MultiShiftFunction::gnuplot(std::ostream &out)$/;"	f	class:Grid::MultiShiftFunction
gotValue	extras/Hadrons/Graph.hpp	/^bool Graph<T>::gotValue(const T &value) const$/;"	f	class:Graph
gotValue	lib/Hadrons/Graph.hpp	/^bool Graph<T>::gotValue(const T &value) const$/;"	f	class:Graph
grab	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const EigenBase<MatrixDerived> &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
grab	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const InputType &A)$/;"	f	class:Eigen::IterativeSolverBase
grab	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const MatrixType &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
grab	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const Ref<const MatrixType> &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
grab	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grab(const EigenBase<MatrixDerived> &A)$/;"	f	class:Eigen::UmfPackLU
grab	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grab(const UmfpackMatrixRef &A)$/;"	f	class:Eigen::UmfPackLU
grabMatrix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT
grabMatrix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT
grabMatrix	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU
graph_	extras/Hadrons/GeneticScheduler.hpp	/^    Graph<T>                 &graph_;$/;"	m	class:GeneticScheduler
graph_	lib/Hadrons/GeneticScheduler.hpp	/^    Graph<T>                 &graph_;$/;"	m	class:GeneticScheduler
grid	lib/algorithms/iterative/AdefGeneric.h	/^  GridBase *grid;$/;"	m	class:TwoLevelFlexiblePcg
grid	lib/stencil/Lebesgue.h	/^    GridBase *grid;$/;"	m	class:Grid::LebesgueOrder
grid4d_	extras/Hadrons/Environment.hpp	/^    GridPt                                 grid4d_;$/;"	m	class:Environment
grid4d_	lib/Hadrons/Environment.hpp	/^    GridPt                                 grid4d_;$/;"	m	class:Environment
grid5d_	extras/Hadrons/Environment.hpp	/^    std::map<unsigned int, GridPt>         grid5d_;$/;"	m	class:Environment
grid5d_	lib/Hadrons/Environment.hpp	/^    std::map<unsigned int, GridPt>         grid5d_;$/;"	m	class:Environment
gridRb4d_	extras/Hadrons/Environment.hpp	/^    GridRbPt                               gridRb4d_;$/;"	m	class:Environment
gridRb4d_	lib/Hadrons/Environment.hpp	/^    GridRbPt                               gridRb4d_;$/;"	m	class:Environment
gridRb5d_	extras/Hadrons/Environment.hpp	/^    std::map<unsigned int, GridRbPt>       gridRb5d_;$/;"	m	class:Environment
gridRb5d_	lib/Hadrons/Environment.hpp	/^    std::map<unsigned int, GridRbPt>       gridRb5d_;$/;"	m	class:Environment
grid_	lib/qcd/hmc/HMC_GridModules.h	/^  std::unique_ptr<GridCartesian> grid_;$/;"	m	class:Grid::GridModule
group_	lib/serialisation/Hdf5IO.h	/^    H5NS::Group              group_;$/;"	m	class:Grid::Hdf5Reader
group_	lib/serialisation/Hdf5IO.h	/^    H5NS::Group              group_;$/;"	m	class:Grid::Hdf5Writer
gsites	tests/testu01/Test_smallcrush.cc	/^  static uint64_t gsites;$/;"	m	struct:TestRNG	file:
gsites	tests/testu01/Test_smallcrush.cc	/^uint64_t         TestRNG::gsites;$/;"	m	class:TestRNG	file:
guess	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC const GuessType&     guess() const { return m_guess; }$/;"	f	class:Eigen::SolveWithGuess
guess_buffer_encoding	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_encoding guess_buffer_encoding(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)$/;"	f
guesser	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    LinearFunction<FieldF> *guesser;$/;"	m	class:Grid::MixedPrecisionConjugateGradient
hCoeffs	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR
hCoeffs	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline const HCoeffsType& hCoeffs() const { return m_cpqr.hCoeffs(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
hCoeffs	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR
hCoeffs	lib/Eigen/src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR
half	lib/Eigen/src/Core/GenericPacketMath.h	/^  typedef T half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet4d half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet4d half;$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8f half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8f half;$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8i half;$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half() {}$/;"	f	struct:Eigen::half
half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half(const __half& h) : half_impl::half_base(h) {}$/;"	f	struct:Eigen::half
half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half(const half& h) : half_impl::half_base(h) {}$/;"	f	struct:Eigen::half
half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC half(bool b)$/;"	f	struct:Eigen::half
half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC half(const T& val)$/;"	f	struct:Eigen::half
half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC half(float f)$/;"	f	struct:Eigen::half
half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^struct half : public half_impl::half_base {$/;"	s	namespace:Eigen
half	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef double2 half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef float4 half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^  typedef half2 half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f half; \/\/ Packet2f intrinsics not implemented yet$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i half; \/\/ Packet2i intrinsics not implemented yet$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4i half;$/;"	t	struct:Eigen::internal::packet_traits
half	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^template<typename Packet> struct unpacket_traits<DoublePacket<Packet> > { typedef DoublePacket<Packet> half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half_base	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half_base() {}$/;"	f	struct:Eigen::half_impl::half_base
half_base	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half_base(const __half& h) : __half(h) {}$/;"	f	struct:Eigen::half_impl::half_base
half_base	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half_base(const half_base& h) : __half(h) {}$/;"	f	struct:Eigen::half_impl::half_base
half_base	lib/Eigen/src/Core/arch/CUDA/Half.h	/^struct half_base : public __half {$/;"	s	namespace:Eigen::half_impl
half_impl	lib/Eigen/src/Core/arch/CUDA/Half.h	/^namespace half_impl {$/;"	n	namespace:Eigen
half_to_float	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC float half_to_float(__half h) {$/;"	f	namespace:Eigen::half_impl
halogtime	lib/stencil/Stencil.h	/^  double halogtime;$/;"	m	class:Grid::CartesianStencil
handmade_aligned_free	lib/Eigen/src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
handmade_aligned_malloc	lib/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal
handmade_aligned_realloc	lib/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, std::size_t size, std::size_t = 0)$/;"	f	namespace:Eigen::internal
hasCreatedObject	extras/Hadrons/Environment.cc	/^bool Environment::hasCreatedObject(const std::string name) const$/;"	f	class:Environment
hasCreatedObject	extras/Hadrons/Environment.cc	/^bool Environment::hasCreatedObject(const unsigned int address) const$/;"	f	class:Environment
hasCreatedObject	lib/Hadrons/Environment.cc	/^bool Environment::hasCreatedObject(const std::string name) const$/;"	f	class:Environment
hasCreatedObject	lib/Hadrons/Environment.cc	/^bool Environment::hasCreatedObject(const unsigned int address) const$/;"	f	class:Environment
hasModule	extras/Hadrons/Environment.cc	/^bool Environment::hasModule(const std::string name) const$/;"	f	class:Environment
hasModule	extras/Hadrons/Environment.cc	/^bool Environment::hasModule(const unsigned int address) const$/;"	f	class:Environment
hasModule	lib/Hadrons/Environment.cc	/^bool Environment::hasModule(const std::string name) const$/;"	f	class:Environment
hasModule	lib/Hadrons/Environment.cc	/^bool Environment::hasModule(const unsigned int address) const$/;"	f	class:Environment
hasNaN	lib/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::hasNaN() const$/;"	f	class:Eigen::DenseBase
hasObject	extras/Hadrons/Environment.cc	/^bool Environment::hasObject(const std::string name) const$/;"	f	class:Environment
hasObject	extras/Hadrons/Environment.cc	/^bool Environment::hasObject(const unsigned int address) const$/;"	f	class:Environment
hasObject	lib/Hadrons/Environment.cc	/^bool Environment::hasObject(const std::string name) const$/;"	f	class:Environment
hasObject	lib/Hadrons/Environment.cc	/^bool Environment::hasObject(const unsigned int address) const$/;"	f	class:Environment
hasOwners	extras/Hadrons/Environment.cc	/^bool Environment::hasOwners(const std::string name) const$/;"	f	class:Environment
hasOwners	extras/Hadrons/Environment.cc	/^bool Environment::hasOwners(const unsigned int address) const$/;"	f	class:Environment
hasOwners	lib/Hadrons/Environment.cc	/^bool Environment::hasOwners(const std::string name) const$/;"	f	class:Environment
hasOwners	lib/Hadrons/Environment.cc	/^bool Environment::hasOwners(const unsigned int address) const$/;"	f	class:Environment
hasRegisteredObject	extras/Hadrons/Environment.cc	/^bool Environment::hasRegisteredObject(const std::string name) const$/;"	f	class:Environment
hasRegisteredObject	extras/Hadrons/Environment.cc	/^bool Environment::hasRegisteredObject(const unsigned int address) const$/;"	f	class:Environment
hasRegisteredObject	lib/Hadrons/Environment.cc	/^bool Environment::hasRegisteredObject(const std::string name) const$/;"	f	class:Environment
hasRegisteredObject	lib/Hadrons/Environment.cc	/^bool Environment::hasRegisteredObject(const unsigned int address) const$/;"	f	class:Environment
has_ReturnType	lib/Eigen/src/Core/util/Meta.h	/^struct has_ReturnType$/;"	s	namespace:Eigen::internal
has_binary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	lib/Eigen/src/Core/util/Meta.h	/^struct has_binary_operator$/;"	s	namespace:Eigen::internal
has_declaration	lib/pugixml/pugixml.cc	/^	PUGI__FN bool has_declaration(xml_node_struct* node)$/;"	f
has_direct_access	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon114
has_direct_access	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
has_element_node_siblings	lib/pugixml/pugixml.cc	/^		static bool has_element_node_siblings(xml_node_struct* node)$/;"	f	struct:xml_parser
has_generate_template	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    struct has_generate_template$/;"	s	namespace:sitmo
has_mapped_type	lib/json/json.hpp	/^struct has_mapped_type$/;"	s	namespace:nlohmann::__anon693
has_none	lib/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
has_nullary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	lib/Eigen/src/Core/util/Meta.h	/^struct has_nullary_operator$/;"	s	namespace:Eigen::internal
has_std_result_type	lib/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
has_tr1_result	lib/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
has_unary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	lib/Eigen/src/Core/util/Meta.h	/^struct has_unary_operator$/;"	s	namespace:Eigen::internal
has_write_access	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon114
hash	lib/Eigen/src/Core/arch/CUDA/Half.h	/^struct hash<Eigen::half> {$/;"	s	namespace:std
hash	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType hash ;  \/* hash value, if col is not in a degree list *\/$/;"	m	union:internal::colamd_col::__anon625
hash	lib/json/json.hpp	/^struct hash<nlohmann::json>$/;"	s	namespace:std
hash	lib/pugixml/pugixml.cc	/^		compact_hash_table hash;$/;"	m	struct:xml_document_struct	file:
hash	lib/pugixml/pugixml.cc	/^		static unsigned int hash(const void* key)$/;"	f	class:compact_hash_table	file:
hash_next	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType hash_next ;   \/* next column, if col is in a hash list *\/$/;"	m	union:internal::colamd_col::__anon626
hash_string	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned int hash_string(const char_t* str)$/;"	f
hash_value	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t xml_attribute::hash_value() const$/;"	f	class:pugi::xml_attribute
hash_value	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t xml_node::hash_value() const$/;"	f	class:pugi::xml_node
have_CheckPointer	lib/qcd/hmc/HMCResourceManager.h	/^  bool have_CheckPointer;$/;"	m	class:Grid::QCD::HMCResourceManager
have_RNG	lib/qcd/hmc/HMCResourceManager.h	/^  bool have_RNG;$/;"	m	class:Grid::QCD::HMCResourceManager
head	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType head(Index n) const$/;"	f
head	lib/Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType head(Index n)$/;"	f
head	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type head(Index n = N) const$/;"	f
head	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type head(Index n = N)$/;"	f
head	lib/communicator/Communicator_mpi3_leader.cc	/^  volatile int head;$/;"	m	class:Grid::SlaveState	file:
header	benchmarks/Benchmark_comms.cc	/^void header(){$/;"	f
header	lib/pugixml/pugixml.cc	/^		impl::compact_header header;$/;"	m	struct:pugi::xml_attribute_struct	file:
header	lib/pugixml/pugixml.cc	/^		impl::compact_header header;$/;"	m	struct:pugi::xml_node_struct	file:
headhash	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType headhash ;  \/* head of a hash bucket, if col is at the head of *\/$/;"	m	union:internal::colamd_col::__anon625
heap_bytes	lib/communicator/Communicator_base.h	/^  size_t heap_bytes;$/;"	m	class:Grid::CartesianCommunicator
heap_relax_snode	lib/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^void SparseLUImpl<Scalar,StorageIndex>::heap_relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl
heap_top	lib/communicator/Communicator_base.h	/^  size_t heap_top;$/;"	m	class:Grid::CartesianCommunicator
helper	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef homogeneous_left_product_refactoring_helper<Lhs,typename Rhs::NestedExpression> helper;$/;"	t	struct:Eigen::internal::product_evaluator
helper	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef homogeneous_right_product_refactoring_helper<typename Lhs::NestedExpression,Rhs> helper;$/;"	t	struct:Eigen::internal::product_evaluator
helper	lib/sitmo_rng/sitmo_prng_engine.hpp	/^        template<typename F, void (F::*)(int *, int *)> struct helper {};$/;"	s	struct:sitmo::has_generate_template
hessenbergTriangular	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    void RealQZ<MatrixType>::hessenbergTriangular()$/;"	f	class:Eigen::RealQZ
hi	lib/algorithms/approx/Chebyshev.h	/^    RealD hi;$/;"	m	class:Grid::Chebyshev
hi	lib/algorithms/approx/MultiShiftFunction.h	/^  RealD lo,hi;$/;"	m	class:Grid::MultiShiftFunction
high	lib/pugixml/pugixml.cc	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:latin1_writer
high	lib/pugixml/pugixml.cc	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer
high	lib/pugixml/pugixml.cc	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer
high	lib/pugixml/pugixml.cc	/^		static value_type high(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer
high	lib/pugixml/pugixml.cc	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf16_counter
high	lib/pugixml/pugixml.cc	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf32_counter
high	lib/pugixml/pugixml.cc	/^		static value_type high(value_type result, uint32_t)$/;"	f	struct:utf8_counter
higham	lib/algorithms/approx/Zolotarev.cc	/^zolotarev_data* higham(PRECISION epsilon, int n) {$/;"	f	namespace:Grid::Approx
highest	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half highest() {$/;"	f	struct:Eigen::NumTraits
hmc_string	lib/qcd/modules/Modules.cc	/^char hmc_string[]        = "HMC";$/;"	m	namespace:Grid	file:
hnormalized	lib/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase
hnormalized	lib/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous	lib/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase
homogeneous	lib/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous_left_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
homogeneous_left_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal
homogeneous_left_product_refactoring_helper	lib/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_refactoring_helper$/;"	s	namespace:Eigen::internal
homogeneous_right_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
homogeneous_right_product_impl	lib/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal
homogeneous_right_product_refactoring_helper	lib/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_refactoring_helper$/;"	s	namespace:Eigen::internal
householder	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
householderCoefficients	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition
householderCoefficients	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization
householderQ	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR
householderQ	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^CompleteOrthogonalDecomposition<MatrixType>::householderQ() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
householderQ	lib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR
householderQr	lib/Eigen/src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase
householderSequence	lib/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
householderU	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization
householderV	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization
householder_qr_inplace_blocked	lib/Eigen/src/QR/HouseholderQR.h	/^struct householder_qr_inplace_blocked$/;"	s	namespace:Eigen::internal
householder_qr_inplace_unblocked	lib/Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal
hseq_side_dependent_impl	lib/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
hseq_side_dependent_impl	lib/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
htobe32_v	lib/parallelIO/BinaryIO.h	/^  static inline void htobe32_v(void *file_object,uint32_t bytes){ be32toh_v(file_object,bytes);} $/;"	f	class:Grid::BinaryIO
htobe64_v	lib/parallelIO/BinaryIO.h	/^  static inline void htobe64_v(void *file_object,uint32_t bytes){ be64toh_v(file_object,bytes);} $/;"	f	class:Grid::BinaryIO
htole32_v	lib/parallelIO/BinaryIO.h	/^  static inline void htole32_v(void *file_object,uint32_t bytes){ le32toh_v(file_object,bytes);} $/;"	f	class:Grid::BinaryIO
htole64_v	lib/parallelIO/BinaryIO.h	/^  static inline void htole64_v(void *file_object,uint32_t bytes){ le64toh_v(file_object,bytes);} $/;"	f	class:Grid::BinaryIO
hypot	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext
hypotNorm	lib/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase
hypotNorm	lib/Eigen/src/Core/VectorwiseOp.h	/^    const HypotNormReturnType hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp
hypot_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
hypot_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
i	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  int32_t   i[4];$/;"	m	union:Eigen::internal::__anon308
i16	tests/IO/Test_serialisation.cc	/^int16_t  i16 = 1;$/;"	v
i32	tests/IO/Test_serialisation.cc	/^int32_t  i32 = 3;$/;"	v
i64	tests/IO/Test_serialisation.cc	/^int64_t  i64 = 5;$/;"	v
iCoorFromIindex	lib/cartesian/Cartesian_base.h	/^    inline void iCoorFromIindex(std::vector<int> &coor,int lane)$/;"	f	class:Grid::GridBase
iIndex	lib/cartesian/Cartesian_base.h	/^    virtual int iIndex(std::vector<int> &lcoor)$/;"	f	class:Grid::GridBase
iIndex	lib/cartesian/Cartesian_red_black.h	/^    virtual int iIndex(std::vector<int> &lcoor)$/;"	f	class:Grid::GridRedBlackCartesian
iMatrix	lib/tensors/Tensor_class.h	/^  iMatrix(const Zero &z) { *this = zero; };$/;"	f	class:Grid::iMatrix
iMatrix	lib/tensors/Tensor_class.h	/^  iMatrix(scalar_type s) {$/;"	f	class:Grid::iMatrix
iMatrix	lib/tensors/Tensor_class.h	/^class iMatrix {$/;"	c	namespace:Grid
iScalar	lib/tensors/Tensor_class.h	/^  iScalar(const Zero &z) { *this = zero; };$/;"	f	class:Grid::iScalar
iScalar	lib/tensors/Tensor_class.h	/^  iScalar(scalar_type s) : _internal(s){};  \/\/ recurse down and hit the constructor for vector_type$/;"	f	class:Grid::iScalar
iScalar	lib/tensors/Tensor_class.h	/^class iScalar {$/;"	c	namespace:Grid
iSites	lib/cartesian/Cartesian_base.h	/^    inline int iSites(void) const { return _isites; };$/;"	f	class:Grid::GridBase
iVector	lib/tensors/Tensor_class.h	/^  iVector(const Zero &z) { *this = zero; };$/;"	f	class:Grid::iVector
iVector	lib/tensors/Tensor_class.h	/^class iVector {$/;"	c	namespace:Grid
i_A	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^  i_A = 1,$/;"	e	enum:__anon5
i_A	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^  i_A = 1,$/;"	e	enum:__anon688
i_V	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^  i_V = 0,$/;"	e	enum:__anon5
i_V	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^  i_V = 0,$/;"	e	enum:__anon688
icc_11_workaround	lib/Eigen/src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform
ignore_unused_variable	lib/Eigen/src/Core/util/Macros.h	/^    template<typename T> EIGEN_DEVICE_FUNC void ignore_unused_variable(const T&) {}$/;"	f	namespace:Eigen::internal
ildgFormat	lib/parallelIO/IldgIOtypes.h	/^  ildgFormat() { version=1.0; };$/;"	f	struct:Grid::ildgFormat
ildgFormat	lib/parallelIO/IldgIOtypes.h	/^struct ildgFormat : Serializable {$/;"	s	namespace:Grid
imag	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::numext
imag	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() const { return ImagReturnType(derived()); }$/;"	f
imag	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() { return NonConstImagReturnType(derived()); }$/;"	f
imag	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> imag(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
imag_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_default_impl$/;"	s	namespace:Eigen::internal
imag_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
imag_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_impl<std::complex<T> >$/;"	s	namespace:Eigen::internal
imag_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
imag_ref	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::numext
imag_ref	lib/Eigen/src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext
imag_ref_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
imag_ref_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
imag_ref_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
imag_ref_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
imag_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
image	lib/Eigen/src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU
image_retval	lib/Eigen/src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
image_retval_base	lib/Eigen/src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base
image_retval_base	lib/Eigen/src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal
impl	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const linspaced_op_impl<Scalar,PacketType,NumTraits<Scalar>::IsInteger> impl;$/;"	m	struct:Eigen::internal::linspaced_op
implicit_update_P	lib/qcd/hmc/integrators/Integrator.h	/^  void implicit_update_P(Field& U, int level, double ep, bool intermediate = false) {$/;"	f	class:Grid::QCD::Integrator
implicit_update_U	lib/qcd/hmc/integrators/Integrator.h	/^  void implicit_update_U(Field&U, double ep){$/;"	f	class:Grid::QCD::Integrator
inc_counter	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void inc_counter()$/;"	f	class:sitmo::prng_engine
inc_counter	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void inc_counter(uint64_t z)$/;"	f	class:sitmo::prng_engine
incrementToNonZero	lib/Eigen/src/SparseCore/SparseView.h	/^        void incrementToNonZero()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
indent	lib/serialisation/TextIO.cc	/^void TextWriter::indent(void)$/;"	f	class:TextWriter
indent_flags_t	lib/pugixml/pugixml.cc	/^	enum indent_flags_t$/;"	g	file:
indent_indent	lib/pugixml/pugixml.cc	/^		indent_indent = 2$/;"	e	enum:indent_flags_t	file:
indent_newline	lib/pugixml/pugixml.cc	/^		indent_newline = 1,$/;"	e	enum:indent_flags_t	file:
index	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index index() const           { return m_iter.index(); }$/;"	f	class:Eigen::InnerIterator
index	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::internal::inner_iterator_selector
index	lib/Eigen/src/Core/Diagonal.h	/^    inline Index index() const$/;"	f	class:Eigen::Diagonal
index	lib/Eigen/src/Core/Redux.h	/^    index = Start * redux_traits<Func, Derived>::PacketSize,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon123
index	lib/Eigen/src/SparseCore/AmbiVector.h	/^      StorageIndex index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
index	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
index	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline StorageIndex& index(Index i) { eigen_internal_assert(m_indices!=0); return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const StorageIndex& index(Index i) const { eigen_internal_assert(m_indices!=0); return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline StorageIndex index() const { return EvalIterator::index() - convert_index<StorageIndex>(IsRowMajor ? m_block.startCol() : m_block.startRow()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
index	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline StorageIndex index() const { return convert_index<StorageIndex>(m_outerPos - (IsRowMajor ? m_eval.m_block.startCol() : m_eval.m_block.startRow())); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
index	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
index	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
index	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE StorageIndex index() const { return m_id; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
index	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE StorageIndex index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
index	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE StorageIndex index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
index	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline StorageIndex index() const  { return m_sparseIter.index(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
index	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      inline StorageIndex index() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
index	lib/Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE StorageIndex index() const { return m_inner; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
index	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index index() const { return m_matrix.rowIndex()[m_idrow]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
indexPtr	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    StorageIndex* indexPtr() { return m_indices; }$/;"	f	class:Eigen::internal::CompressedStorage
indexPtr	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    const StorageIndex* indexPtr() const { return m_indices; }$/;"	f	class:Eigen::internal::CompressedStorage
indexRank	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int indexRank(const iMatrix<vtype,N> tmp){ return N; }$/;"	f	class:Grid::TensorIndexRecursion
indexRank	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int indexRank(const iMatrix<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::indexRank(tmp._internal[0][0]);  }$/;"	f	class:Grid::TensorIndexRecursion
indexRank	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int indexRank(const iVector<vtype,N> tmp){ return N; }$/;"	f	class:Grid::TensorIndexRecursion
indexRank	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int indexRank(const iVector<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::indexRank(tmp._internal[0]);  }$/;"	f	class:Grid::TensorIndexRecursion
indexRank	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int indexRank(const iScalar<vtype> tmp)  { return 1; }$/;"	f	class:Grid::TensorIndexRecursion
indexRank	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int indexRank(const iScalar<vtype> tmp)  { return TensorIndexRecursion<Level-1>::indexRank(tmp._internal);  }$/;"	f	class:Grid::TensorIndexRecursion
indexRank	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline int indexRank(void)$/;"	f	namespace:Grid
indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper
indices	lib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	lib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	lib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	lib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
indices	lib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	lib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	lib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	lib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
infinity	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half infinity() {$/;"	f	struct:Eigen::NumTraits
infinity	lib/Eigen/src/Core/util/Meta.h	/^  static T infinity() { assert(false && "Infinity not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
infinity	lib/Eigen/src/Core/util/Meta.h	/^  static double infinity() { return CUDART_INF; }$/;"	f	struct:Eigen::internal::device::numeric_limits
infinity	lib/Eigen/src/Core/util/Meta.h	/^  static float infinity() { return CUDART_INF_F; }$/;"	f	struct:Eigen::internal::device::numeric_limits
info	lib/Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT
info	lib/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT
info	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase
info	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver
info	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur
info	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver
info	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::GeneralizedEigenSolver
info	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      ComputationInfo info() const$/;"	f	class:Eigen::RealQZ
info	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur
info	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
info	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    ComputationInfo info() { return Success; }$/;"	f	class:Eigen::DiagonalPreconditioner
info	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    ComputationInfo info() { return Success; }$/;"	f	class:Eigen::IdentityPreconditioner
info	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    ComputationInfo info() { return Success; }$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
info	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteCholesky
info	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT
info	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase
info	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase
info	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl
info	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ColPivHouseholderQR
info	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  ComputationInfo info() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
info	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SPQR
info	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase
info	lib/Eigen/src/SparseLU/SparseLU.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseLU
info	lib/Eigen/src/SparseQR/SparseQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseQR
info	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase
info	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU
init	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition
init	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT
init	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT
init	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT
init	lib/Eigen/src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::internal::BlockImpl_dense
init	lib/Eigen/src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor
init	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase
init	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT
init	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT
init	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU
init	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase
init	lib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector
init	lib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector
init	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU
init	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU
init	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase
init	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU
init	lib/perfmon/Stat.cc	/^void PmuStat::init(const char *regname)$/;"	f	class:Grid::PmuStat
initAcc	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacketType& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits
initAssignment	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix
initFactorization	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase
initFrancisQRStep	lib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur
initParallel	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void initParallel(Index rows, Index cols, Index depth, Index num_threads)$/;"	f	class:Eigen::internal::gemm_blocking_space
initParallel	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void initParallel(Index, Index, Index, Index)$/;"	f	class:Eigen::internal::gemm_blocking_space
initParallel	lib/Eigen/src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen
initParallelSession	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession(Index num_threads) const$/;"	f	struct:Eigen::internal::gemm_functor
initPopulation	extras/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::initPopulation(void)$/;"	f	class:GeneticScheduler
initPopulation	lib/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::initPopulation(void)$/;"	f	class:GeneticScheduler
init_rows_cols	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static IndexType init_rows_cols  \/* returns true if OK, or false otherwise *\/$/;"	f	namespace:internal
init_scoring	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static void init_scoring$/;"	f	namespace:internal
initialGuess	lib/algorithms/approx/Remez.cc	/^void AlgRemez::initialGuess() {$/;"	f	class:AlgRemez
initialize	lib/qcd/hmc/GenericHMCrunner.h	/^  void initialize(ReaderClass & TheReader){$/;"	f	class:Grid::QCD::HMCWrapperTemplate
initialize	lib/qcd/hmc/HMC.h	/^  void initialize(Reader<ReaderClass> &TheReader){$/;"	f	struct:Grid::QCD::HMCparameters
initialize	lib/qcd/hmc/HMCResourceManager.h	/^  void initialize(ReaderClass &Read){$/;"	f	class:Grid::QCD::HMCResourceManager
initialize	lib/qcd/hmc/HMCRunnerModule.h	/^  virtual void initialize(){$/;"	f	class:Grid::HMCForceGradient
initialize	lib/qcd/hmc/HMCRunnerModule.h	/^  virtual void initialize(){$/;"	f	class:Grid::HMCLeapFrog
initialize	lib/qcd/hmc/HMCRunnerModule.h	/^  virtual void initialize(){$/;"	f	class:Grid::HMCMinimumNorm2
initialize	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  void initialize(const CheckpointerParameters &Params_) { Params = Params_; }$/;"	f	class:Grid::QCD::BinaryHmcCheckpointer
initialize	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::BinaryCPModule
initialize	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::ILDGCPModule
initialize	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::NerscCPModule
initialize	lib/qcd/hmc/checkpointers/ILDGCheckpointer.h	/^  void initialize(const CheckpointerParameters &Params_) {$/;"	f	class:Grid::QCD::ILDGHmcCheckpointer
initialize	lib/qcd/hmc/checkpointers/NerscCheckpointer.h	/^  void initialize(const CheckpointerParameters &Params_) {$/;"	f	class:Grid::QCD::NerscHmcCheckpointer
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::OneFlavourEOFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::OneFlavourFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::OneFlavourRatioEOFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::OneFlavourRatioFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::TwoFlavourEOFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::TwoFlavourFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::TwoFlavourRatioEOFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize() {$/;"	f	class:Grid::QCD::TwoFlavourRatioFModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::DBW2GModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::IwasakiGModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::PlaqPlusRectangleGModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::RBCGModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::SymanzikGModule
initialize	lib/qcd/modules/ActionModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::WilsonGModule
initialize	lib/qcd/modules/FermionOperatorModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::DomainWallFermionModule
initialize	lib/qcd/modules/FermionOperatorModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::MobiusFermionModule
initialize	lib/qcd/modules/FermionOperatorModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::WilsonFermionModule
initialize	lib/qcd/modules/ObservableModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::PlaquetteMod
initialize	lib/qcd/modules/ObservableModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::QCD::TopologicalChargeMod
initialize	lib/qcd/modules/SolverModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::ConjugateGradientModule
initialize	lib/qcd/modules/SolverModules.h	/^  virtual void initialize(){$/;"	f	class:Grid::ConjugateResidualModule
initialize	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^  virtual void initialize(){$/;"	f	class:MagMod	file:
initperfvalues	lib/Eigen/src/SparseLU/SparseLU.h	/^    void initperfvalues()$/;"	f	class:Eigen::SparseLU
inner	lib/Eigen/src/Core/AssignEvaluator.h	/^    inner = Index % DstXprType::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling::__anon146
inner	lib/Eigen/src/Core/AssignEvaluator.h	/^    inner = Index % DstXprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon147
inner	lib/Eigen/src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon121
inner	lib/Eigen/src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon123
inner	lib/Eigen/src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride
innerInd	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon15
innerIndexPtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline StorageIndex* innerIndexPtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerIndexPtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const StorageIndex* innerIndexPtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerIndexPtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex* innerIndexPtr() { return derived().innerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerIndexPtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const StorageIndex* innerIndexPtr() const { return derived().innerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerIndexPtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline StorageIndex* innerIndexPtr()   { return Base::m_innerIndices; }$/;"	f	class:Eigen::SparseMapBase
innerIndexPtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline const StorageIndex* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::SparseMapBase
innerIndexPtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline StorageIndex* innerIndexPtr() { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const StorageIndex* innerIndexPtr() const { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline StorageIndex* innerIndexPtr() { return derived().nestedExpression().innerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerIndexPtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline const StorageIndex* innerIndexPtr() const { return derived().nestedExpression().innerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerIndexPtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE StorageIndex* innerIndexPtr() { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseVector
innerIndexPtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const StorageIndex* innerIndexPtr() const { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseVector
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline StorageIndex* innerNonZeroPtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const StorageIndex* innerNonZeroPtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex* innerNonZeroPtr() { return derived().innerNonZeroPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return derived().innerNonZeroPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline StorageIndex* innerNonZeroPtr() { return Base::m_innerNonZeros; }$/;"	f	class:Eigen::SparseMapBase
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMapBase
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline StorageIndex* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline StorageIndex* innerNonZeroPtr() { return derived().nestedExpression().innerNonZeroPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return derived().nestedExpression().innerNonZeroPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline StorageIndex* innerNonZeroPtr() { return 0; }$/;"	f	class:Eigen::SparseVector
innerNonZeroPtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return 0; }$/;"	f	class:Eigen::SparseVector
innerNonZeros	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    Eigen::Map<IndexVector> innerNonZeros() { return Eigen::Map<IndexVector>(innerNonZeroPtr(), isCompressed()?0:derived().outerSize()); }$/;"	f	class:Eigen::SparseCompressedBase
innerNonZeros	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const  Eigen::Map<const IndexVector> innerNonZeros() const { return Eigen::Map<const IndexVector>(innerNonZeroPtr(), isCompressed()?0:derived().outerSize()); }$/;"	f	class:Eigen::SparseCompressedBase
innerProduct	lib/lattice/Lattice_reduction.h	/^inline ComplexD innerProduct(const Lattice<vobj> &left,const Lattice<vobj> &right) $/;"	f	namespace:Grid
innerProduct	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> innerProduct(const Grid_simd<S, V> &l,$/;"	f	namespace:Grid
innerProduct	lib/simd/Simd.h	/^  inline ComplexD innerProduct(const ComplexD & l, const ComplexD & r) { return conjugate(l)*r; }$/;"	f	namespace:Grid
innerProduct	lib/simd/Simd.h	/^  inline ComplexF innerProduct(const ComplexF & l, const ComplexF & r) { return conjugate(l)*r; }$/;"	f	namespace:Grid
innerProduct	lib/simd/Simd.h	/^  inline RealD innerProduct(const RealD & l, const RealD & r) { return l*r; }$/;"	f	namespace:Grid
innerProduct	lib/simd/Simd.h	/^  inline RealF innerProduct(const RealF & l, const RealF & r) { return l*r; }$/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline ComplexD innerProductD(const ComplexD &l,const ComplexD &r){  return innerProduct(l,r); }$/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline ComplexD innerProductD(const ComplexF &l,const ComplexF &r){  return innerProduct(l,r); }$/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline RealD    innerProductD(const RealD    &l,const RealD    &r){  return innerProduct(l,r); }$/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline RealD    innerProductD(const RealF    &l,const RealF    &r){  return innerProduct(l,r); }$/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline vComplexD innerProductD(const vComplexD &l,const vComplexD &r){  return innerProduct(l,r); }$/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline vComplexD innerProductD(const vComplexF &l,const vComplexF &r){  $/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline vRealD    innerProductD(const vRealD    &l,const vRealD    &r){  return innerProduct(l,r); }$/;"	f	namespace:Grid
innerProductD	lib/tensors/Tensor_inner.h	/^inline vRealD innerProductD(const vRealF &l,const vRealF &r){  $/;"	f	namespace:Grid
innerSize	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index innerSize() const   { return m_dstExpr.innerSize(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
innerSize	lib/Eigen/src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase
innerSize	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index innerSize() const { return m_xpr.innerSize(); }$/;"	f	class:Eigen::internal::redux_evaluator
innerSize	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMapBase
innerSize	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
innerSize	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase
innerSize	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector
innerSize	lib/Eigen/src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView
innerStride	lib/Eigen/src/Core/Array.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array
innerStride	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper
innerStride	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper
innerStride	lib/Eigen/src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense
innerStride	lib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
innerStride	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
innerStride	lib/Eigen/src/Core/Diagonal.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Diagonal
innerStride	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
innerStride	lib/Eigen/src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map
innerStride	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix
innerStride	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue
innerStride	lib/Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC inline Index innerStride() const$/;"	f	class:Eigen::RefBase
innerStride	lib/Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const$/;"	f	class:Eigen::Reverse
innerStride	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView
innerStride	lib/Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl
innerStride	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase
innerStride	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TriangularViewImpl
innerVector	lib/Eigen/src/SparseCore/SparseBlock.h	/^const typename SparseMatrixBase<Derived>::ConstInnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase
innerVector	lib/Eigen/src/SparseCore/SparseBlock.h	/^typename SparseMatrixBase<Derived>::InnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	lib/Eigen/src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	lib/Eigen/src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase
inner_iterator_selector	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE inner_iterator_selector(const EvaluatorType &eval, const Index &outerId, const Index &\/*innerSize*\/)$/;"	f	class:Eigen::internal::inner_iterator_selector
inner_iterator_selector	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE inner_iterator_selector(const EvaluatorType &eval, const Index &outerId, const Index &innerSize)$/;"	f	class:Eigen::internal::inner_iterator_selector
inner_iterator_selector	lib/Eigen/src/Core/CoreIterators.h	/^class inner_iterator_selector<XprType, IndexBased>$/;"	c	namespace:Eigen::internal
inner_iterator_selector	lib/Eigen/src/Core/CoreIterators.h	/^class inner_iterator_selector<XprType, IteratorBased>$/;"	c	namespace:Eigen::internal
inner_stride_at_compile_time	lib/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
inner_stride_at_compile_time	lib/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
inplace_decomposition	lib/Eigen/src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits
inplace_transpose_selector	lib/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false,MatchPacketSize> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	lib/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true,false> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	lib/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true,true> { \/\/ PacketSize x PacketSize$/;"	s	namespace:Eigen::internal
input	extras/Hadrons/Environment.hpp	/^        std::vector<unsigned int> input;$/;"	m	struct:Environment::ModuleInfo
input	lib/Hadrons/Environment.hpp	/^        std::vector<unsigned int> input;$/;"	m	struct:Environment::ModuleInfo
insert	lib/Eigen/src/SparseCore/SparseMatrix.h	/^typename SparseMatrix<_Scalar,_Options,_StorageIndex>::Scalar& SparseMatrix<_Scalar,_Options,_StorageIndex>::insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insert	lib/Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector
insert	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector
insert	lib/Eigen/src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque
insert	lib/Eigen/src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque
insert	lib/Eigen/src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list
insert	lib/Eigen/src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list
insert	lib/Eigen/src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector
insert	lib/Eigen/src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector
insert	lib/json/json.hpp	/^    iterator insert(const_iterator pos, basic_json&& val)$/;"	f	class:nlohmann::basic_json
insert	lib/json/json.hpp	/^    iterator insert(const_iterator pos, const basic_json& val)$/;"	f	class:nlohmann::basic_json
insert	lib/json/json.hpp	/^    iterator insert(const_iterator pos, const_iterator first, const_iterator last)$/;"	f	class:nlohmann::basic_json
insert	lib/json/json.hpp	/^    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)$/;"	f	class:nlohmann::basic_json
insert	lib/json/json.hpp	/^    iterator insert(const_iterator pos, std::initializer_list<basic_json> ilist)$/;"	f	class:nlohmann::basic_json
insert	lib/pugixml/pugixml.cc	/^		void** insert(const void* key)$/;"	f	class:compact_hash_table
insertBack	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertBack	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector
insertBackByOuterInner	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackByOuterInner	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector
insertBackByOuterInnerUnordered	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackByOuterInnerUnordered	lib/Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector
insertBackUncompressed	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_STRONG_INLINE Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertBackUnordered	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackUnordered(Index i)$/;"	f	class:Eigen::SparseVector
insertByOuterInner	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix
insertCompressed	lib/Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_StorageIndex>::Scalar& SparseMatrix<_Scalar,_Options,_StorageIndex>::insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertUncompressed	lib/Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_StorageIndex>::Scalar& SparseMatrix<_Scalar,_Options,_StorageIndex>::insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insert_attribute_after	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::insert_attribute_after(const char_t* name_, const xml_attribute& attr)$/;"	f	class:pugi::xml_node
insert_attribute_after	lib/pugixml/pugixml.cc	/^	inline void insert_attribute_after(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)$/;"	f
insert_attribute_before	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::insert_attribute_before(const char_t* name_, const xml_attribute& attr)$/;"	f	class:pugi::xml_node
insert_attribute_before	lib/pugixml/pugixml.cc	/^	inline void insert_attribute_before(xml_attribute_struct* attr, xml_attribute_struct* place, xml_node_struct* node)$/;"	f
insert_child_after	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_child_after(const char_t* name_, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_child_after	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_child_after(xml_node_type type_, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_child_before	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_child_before(const char_t* name_, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_child_before	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_child_before(xml_node_type type_, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_copy_after	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::insert_copy_after(const xml_attribute& proto, const xml_attribute& attr)$/;"	f	class:pugi::xml_node
insert_copy_after	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_copy_after(const xml_node& proto, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_copy_before	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::insert_copy_before(const xml_attribute& proto, const xml_attribute& attr)$/;"	f	class:pugi::xml_node
insert_copy_before	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_copy_before(const xml_node& proto, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_move_after	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_move_after(const xml_node& moved, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_move_before	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::insert_move_before(const xml_node& moved, const xml_node& node)$/;"	f	class:pugi::xml_node
insert_node_after	lib/pugixml/pugixml.cc	/^	inline void insert_node_after(xml_node_struct* child, xml_node_struct* node)$/;"	f
insert_node_before	lib/pugixml/pugixml.cc	/^	inline void insert_node_before(xml_node_struct* child, xml_node_struct* node)$/;"	f
insertion_sort	lib/pugixml/pugixml.cc	/^	template <typename I, typename Pred, typename T> void insertion_sort(I begin, I end, const Pred& pred, T*)$/;"	f
inst	lib/perfmon/Stat.h	/^    uint64_t inst, ref, cyc;   \/\/ fixed counters$/;"	m	class:Grid::PmuStat
integrate	lib/qcd/hmc/integrators/Integrator.h	/^  void integrate(Field& U) {$/;"	f	class:Grid::QCD::Integrator
integrator_name	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  std::string integrator_name(){return "ForceGradient";}$/;"	f	class:Grid::QCD::ForceGradient
integrator_name	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  std::string integrator_name(){return "ImplicitLeapFrog";}$/;"	f	class:Grid::QCD::ImplicitLeapFrog
integrator_name	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  std::string integrator_name(){return "ImplicitMininumNorm2";}$/;"	f	class:Grid::QCD::ImplicitMinimumNorm2
integrator_name	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  std::string integrator_name(){return "LeapFrog";}$/;"	f	class:Grid::QCD::LeapFrog
integrator_name	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  std::string integrator_name(){return "MininumNorm2";}$/;"	f	class:Grid::QCD::MinimumNorm2
internal	benchmarks/Benchmark_dwf.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	benchmarks/Benchmark_dwf_sweep.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	benchmarks/Benchmark_wilson.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	benchmarks/Benchmark_wilson_sweep.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	gcc-bug-report/broken.cc	/^  obj internal;$/;"	m	class:Recursive	file:
internal	lib/Eigen/src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Cholesky/LLT_LAPACKE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/AssignEvaluator.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/ConditionEstimator.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/CoreEvaluators.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/CoreIterators.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/CwiseTernaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/DenseBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/MathFunctionsImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/NumTraits.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Product.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/ProductEvaluators.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Ref.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/SolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AVX/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/CUDA/Half.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/NEON/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/functors/StlFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/functors/TernaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/Constants.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/Macros.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/LU/InverseImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/LU/PartialPivLU_LAPACKE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^namespace internal {$/;"	n
internal	lib/Eigen/src/OrderingMethods/Ordering.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/QR/HouseholderQR_LAPACKE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SVD/BDCSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseAssign.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseColEtree.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseMap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseRef.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseTranspose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLUImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_Utils.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_column_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_pivotL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_pruneL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseLU/SparseLU_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SparseQR/SparseQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	lib/Eigen/src/misc/RealSvd2x2.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	tests/Test_cayley_even_odd_vec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/Test_dwf_mixedcg_prec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/Test_dwf_mixedcg_prec_halfcomms.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_cf_coarsen_support.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_checker.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_contfrac_even_odd.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_dwf_even_odd.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_dwf_rb5d.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_mobius_even_odd.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_wilson_even_odd.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_wilson_twisted_mass_even_odd.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/core/Test_zmobius_even_odd.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/debug/Test_cayley_cg.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/debug/Test_cayley_coarsen_support.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/debug/Test_cayley_even_odd.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_cf_cr_unprec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_contfrac_cg.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_dwf_cg_prec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_dwf_cg_prec_LsVec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_dwf_cg_schur.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_dwf_cg_unprec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_dwf_cr_unprec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_dwf_fpgcr.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_staggered_block_cg_unprec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_staggered_cg_unprec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_wilson_cg_prec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_wilson_cg_schur.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_wilson_cg_unprec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_wilson_cr_unprec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal	tests/solver/Test_zmobius_cg_prec.cc	/^  d internal;$/;"	m	struct:scal	file:
internal_iterator	lib/json/json.hpp	/^    struct internal_iterator$/;"	s	class:nlohmann::basic_json
internal_object	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute_struct* xml_attribute::internal_object() const$/;"	f	class:pugi::xml_attribute
internal_object	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_struct* xml_node::internal_object() const$/;"	f	class:pugi::xml_node
intersection	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
intersection	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane
intersection	lib/Eigen/src/Geometry/ParametrizedLine.h	/^EIGEN_DEVICE_FUNC inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersectionParameter	lib/Eigen/src/Geometry/ParametrizedLine.h	/^EIGEN_DEVICE_FUNC inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersectionPoint	lib/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersects	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool intersects(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
invKHatSquared	lib/qcd/action/gauge/Photon.h	/^  void Photon<Gimpl>::invKHatSquared(GaugeLinkField &out)$/;"	f	class:Grid::QCD::Photon
inverse	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase
inverse	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline InverseReturnType inverse() const$/;"	f	class:Eigen::PermutationBase
inverse	lib/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase
inverse	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis
inverse	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase
inverse	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D inverse() const { return Rotation2D(-m_angle); }$/;"	f	class:Eigen::Rotation2D
inverse	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase
inverse	lib/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling
inverse	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform
inverse	lib/Eigen/src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation
inverse	lib/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence
inverse	lib/Eigen/src/LU/FullPivLU.h	/^    inline const Inverse<FullPivLU> inverse() const$/;"	f	class:Eigen::FullPivLU
inverse	lib/Eigen/src/LU/InverseImpl.h	/^inline const Inverse<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase
inverse	lib/Eigen/src/LU/PartialPivLU.h	/^    inline const Inverse<PartialPivLU> inverse() const$/;"	f	class:Eigen::PartialPivLU
inverse	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline const Inverse<ColPivHouseholderQR> inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR
inverse	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline const Inverse<FullPivHouseholderQR> inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR
inverse	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^inverse() const$/;"	f
ioTest	tests/IO/Test_serialisation.cc	/^void ioTest(const std::string &filename, const O &object, const std::string &name)$/;"	f
iparm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<StorageIndex,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase
iparm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase
isActive	lib/log/Log.h	/^  int  isActive(void) {return active;};$/;"	f	class:Grid::Logger
isApprox	lib/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase
isApprox	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApprox	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	lib/Eigen/src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApprox	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const AlignedBox& other, const RealScalar& prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox
isApprox	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis
isApprox	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane
isApprox	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const ParametrizedLine& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine
isApprox	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase
isApprox	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Rotation2D& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D
isApprox	lib/Eigen/src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling
isApprox	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Transform& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform
isApprox	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Translation& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation
isApprox	lib/Eigen/src/SparseCore/SparseFuzzy.h	/^bool SparseMatrixBase<Derived>::isApprox(const SparseMatrixBase<OtherDerived>& other, const RealScalar &prec) const$/;"	f	class:Eigen::SparseMatrixBase
isApprox	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase
isApproxOrLessThan	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApproxOrLessThan	lib/Eigen/src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApproxToConstant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase
isApprox_selector	lib/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
isApprox_selector	lib/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isComplex	lib/tensors/Tensor_traits.h	/^  template<> struct isComplex<ComplexD> {$/;"	s	namespace:Grid
isComplex	lib/tensors/Tensor_traits.h	/^  template<> struct isComplex<ComplexF> {$/;"	s	namespace:Grid
isComplex	lib/tensors/Tensor_traits.h	/^  template<typename T> struct isComplex {$/;"	s	namespace:Grid
isCompressed	lib/Eigen/src/SparseCore/SparseBlock.h	/^    bool isCompressed() const { return m_matrix.innerNonZeroPtr()==0; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
isCompressed	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline bool isCompressed() const { return innerNonZeroPtr()==0; }$/;"	f	class:Eigen::SparseCompressedBase
isCompressed	lib/Eigen/src/SparseCore/SparseMap.h	/^    bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMapBase
isConstant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase
isDiagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isDryRun	extras/Hadrons/Environment.cc	/^bool Environment::isDryRun(void) const$/;"	f	class:Environment
isDryRun	lib/Hadrons/Environment.cc	/^bool Environment::isDryRun(void) const$/;"	f	class:Environment
isEmpty	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox
isFinite	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^isFinite() const$/;"	f
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<ComplexD > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<ComplexF > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<Integer > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<RealD > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<RealF > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<int > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<vComplexD > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<vComplexF > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<vInteger > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<vRealD > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<> struct isGridTensor<vRealF > {$/;"	s	namespace:Grid
isGridTensor	lib/tensors/Tensor_traits.h	/^  template<typename T> struct isGridTensor {$/;"	s	namespace:Grid
isHorizontal	lib/Eigen/src/Core/VectorwiseOp.h	/^      isHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon159
isIdentity	lib/Eigen/src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase
isInf	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^isInf() const$/;"	f
isInjective	lib/Eigen/src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU
isInjective	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInjective	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline bool isInjective() const { return m_cpqr.isInjective(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
isInjective	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isInvertible	lib/Eigen/src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU
isInvertible	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInvertible	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline bool isInvertible() const { return m_cpqr.isInvertible(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
isInvertible	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR
isLowerTriangular	lib/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isMarked	extras/Hadrons/Graph.hpp	/^bool Graph<T>::isMarked(const T &value) const$/;"	f	class:Graph
isMarked	lib/Hadrons/Graph.hpp	/^bool Graph<T>::isMarked(const T &value) const$/;"	f	class:Graph
isMarked_	extras/Hadrons/Graph.hpp	/^    std::map<T, bool>  isMarked_;$/;"	m	class:Graph
isMarked_	lib/Hadrons/Graph.hpp	/^    std::map<T, bool>  isMarked_;$/;"	m	class:Graph
isMatrix	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isMatrix(const iMatrix<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::isMatrix(tmp._internal[0][0]);  }$/;"	f	class:Grid::TensorIndexRecursion
isMatrix	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isMatrix(const iMatrix<vtype,N> tmp){ return true;}$/;"	f	class:Grid::TensorIndexRecursion
isMatrix	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isMatrix(const iVector<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::isMatrix(tmp._internal[0]);  }$/;"	f	class:Grid::TensorIndexRecursion
isMatrix	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isMatrix(const iVector<vtype,N> tmp){ return false;}$/;"	f	class:Grid::TensorIndexRecursion
isMatrix	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int isMatrix(const iScalar<vtype> tmp)  { return TensorIndexRecursion<Level-1>::isMatrix(tmp._internal);  }$/;"	f	class:Grid::TensorIndexRecursion
isMatrix	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int isMatrix(const iScalar<vtype> tmp)  { return false;}$/;"	f	class:Grid::TensorIndexRecursion
isMatrix	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline int isMatrix(void)$/;"	f	namespace:Grid
isMuchSmallerThan	lib/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase
isMuchSmallerThan	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isMuchSmallerThan	lib/Eigen/src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal
isMuchSmallerThan_object_selector	lib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_object_selector	lib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	lib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	lib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
isNaN	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^isNaN() const$/;"	f
isNative	lib/serialisation/Hdf5Type.h	/^    static constexpr bool isNative = false;$/;"	m	class:Grid::Hdf5Type
isNegative	lib/Eigen/src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT
isNull	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox
isObject5d	extras/Hadrons/Environment.cc	/^bool Environment::isObject5d(const std::string name) const$/;"	f	class:Environment
isObject5d	extras/Hadrons/Environment.cc	/^bool Environment::isObject5d(const unsigned int address) const$/;"	f	class:Environment
isObject5d	lib/Hadrons/Environment.cc	/^bool Environment::isObject5d(const std::string name) const$/;"	f	class:Environment
isObject5d	lib/Hadrons/Environment.cc	/^bool Environment::isObject5d(const unsigned int address) const$/;"	f	class:Environment
isObjectOfType	extras/Hadrons/Environment.hpp	/^bool Environment::isObjectOfType(const std::string name) const$/;"	f	class:Environment
isObjectOfType	extras/Hadrons/Environment.hpp	/^bool Environment::isObjectOfType(const unsigned int address) const$/;"	f	class:Environment
isObjectOfType	lib/Hadrons/Environment.hpp	/^bool Environment::isObjectOfType(const std::string name) const$/;"	f	class:Environment
isObjectOfType	lib/Hadrons/Environment.hpp	/^bool Environment::isObjectOfType(const unsigned int address) const$/;"	f	class:Environment
isOnes	lib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase
isOrthogonal	lib/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase
isPeriodicGaugeField	lib/qcd/action/gauge/GaugeImplementations.h	/^  static inline bool isPeriodicGaugeField(void) { return false; }$/;"	f	class:Grid::QCD::ConjugateGaugeImpl
isPeriodicGaugeField	lib/qcd/action/gauge/GaugeImplementations.h	/^  static inline bool isPeriodicGaugeField(void) { return true; }$/;"	f	class:Grid::QCD::PeriodicGaugeImpl
isPositive	lib/Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT
isRValue	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase
isReader	lib/serialisation/BaseIO.h	/^  template<typename T> struct isReader {$/;"	s	namespace:Grid
isReader	lib/serialisation/JSON_IO.h	/^  struct isReader< JSONReader > {$/;"	s	namespace:Grid
isReader	lib/serialisation/XmlIO.h	/^  struct isReader< XmlReader > {$/;"	s	namespace:Grid
isSIMDvectorized	lib/tensors/Tensor_traits.h	/^  class isSIMDvectorized{$/;"	c	namespace:Grid
isScalar	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isScalar(const iMatrix<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::isScalar(tmp._internal[0][0]);  }$/;"	f	class:Grid::TensorIndexRecursion
isScalar	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isScalar(const iMatrix<vtype,N> tmp){ return false;}$/;"	f	class:Grid::TensorIndexRecursion
isScalar	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isScalar(const iVector<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::isScalar(tmp._internal[0]);  }$/;"	f	class:Grid::TensorIndexRecursion
isScalar	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isScalar(const iVector<vtype,N> tmp){ return false;}$/;"	f	class:Grid::TensorIndexRecursion
isScalar	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int isScalar(const iScalar<vtype> tmp)  { return TensorIndexRecursion<Level-1>::isScalar(tmp._internal);  }$/;"	f	class:Grid::TensorIndexRecursion
isScalar	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int isScalar(const iScalar<vtype> tmp)  { return true;}$/;"	f	class:Grid::TensorIndexRecursion
isScalar	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline int isScalar(void)$/;"	f	namespace:Grid
isSpinor	lib/qcd/QCD.h	/^    template<typename T> struct isSpinor {$/;"	s	namespace:Grid::QCD
isSurjective	lib/Eigen/src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU
isSurjective	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isSurjective	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline bool isSurjective() const { return m_cpqr.isSurjective(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
isSurjective	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isSymmetric	lib/Eigen/src/SparseLU/SparseLU.h	/^    void isSymmetric(bool sym)$/;"	f	class:Eigen::SparseLU
isUnitary	lib/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isUpperTriangular	lib/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isVector	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase
isVector	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isVector(const iMatrix<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::isVector(tmp._internal[0][0]);  }$/;"	f	class:Grid::TensorIndexRecursion
isVector	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isVector(const iMatrix<vtype,N> tmp){ return false;}$/;"	f	class:Grid::TensorIndexRecursion
isVector	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isVector(const iVector<vtype,N> tmp){ return TensorIndexRecursion<Level-1>::isVector(tmp._internal[0]);  }$/;"	f	class:Grid::TensorIndexRecursion
isVector	lib/tensors/Tensor_index.h	/^  template<class vtype,int N> static inline int isVector(const iVector<vtype,N> tmp){ return true;}$/;"	f	class:Grid::TensorIndexRecursion
isVector	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int isVector(const iScalar<vtype> tmp)  { return TensorIndexRecursion<Level-1>::isVector(tmp._internal);  }$/;"	f	class:Grid::TensorIndexRecursion
isVector	lib/tensors/Tensor_index.h	/^  template<class vtype>       static inline int isVector(const iScalar<vtype> tmp)  { return false;}$/;"	f	class:Grid::TensorIndexRecursion
isVector	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline int isVector(void)$/;"	f	namespace:Grid
isVertical	lib/Eigen/src/Core/VectorwiseOp.h	/^      isVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon159
isWriter	lib/serialisation/BaseIO.h	/^  template<typename T> struct isWriter {$/;"	s	namespace:Grid
isWriter	lib/serialisation/JSON_IO.h	/^  struct isWriter< JSONWriter > {$/;"	s	namespace:Grid
isWriter	lib/serialisation/XmlIO.h	/^  struct isWriter<XmlWriter > {$/;"	s	namespace:Grid
isZero	lib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isZero(const RealScalar& prec) const$/;"	f	class:Eigen::DenseBase
is_active	lib/log/Log.h	/^  bool is_active;$/;"	m	class:Grid::Colours
is_arithmetic	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct is_arithmetic<__m512> {$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct is_arithmetic<__m512d> {$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct is_arithmetic<__m512i> {$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/CUDA/Half.h	/^template<> struct is_arithmetic<half> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<double2> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<float4>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct is_arithmetic<half2> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
is_attribute_of	lib/pugixml/pugixml.cc	/^	PUGI__FN bool is_attribute_of(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f
is_complex	lib/simd/Grid_vector_types.h	/^template <> struct is_complex<std::complex<double> > : public std::true_type {};$/;"	s	namespace:Grid
is_complex	lib/simd/Grid_vector_types.h	/^template <> struct is_complex<std::complex<float> > : public std::true_type {};$/;"	s	namespace:Grid
is_complex	lib/simd/Grid_vector_types.h	/^template <typename T> struct is_complex : public std::false_type {};$/;"	s	namespace:Grid
is_const	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_const	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_convertible	lib/Eigen/src/Core/util/Meta.h	/^struct is_convertible$/;"	s	namespace:Eigen::internal
is_convertible_impl	lib/Eigen/src/Core/util/Meta.h	/^struct is_convertible_impl$/;"	s	namespace:Eigen::internal
is_dynamic_size_storage	lib/Eigen/src/Core/Matrix.h	/^      is_dynamic_size_storage = _MaxRows==Dynamic || _MaxCols==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon171
is_fundamental	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    constexpr bool is_fundamental() const{return Dimension == Nc ? 1 : 0;}$/;"	f	class:Grid::QCD::StaggeredImpl
is_fundamental	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    constexpr bool is_fundamental() const{return Dimension == Nc ? 1 : 0;}$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
is_fundamental	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    constexpr bool is_fundamental() const{return Dimension == Nc ? 1 : 0;}$/;"	f	class:Grid::QCD::WilsonImpl
is_init	lib/perfmon/Stat.h	/^    static bool is_init(void){ return pmu_initialized;}$/;"	f	class:Grid::PmuStat
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<bool>            { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<char>            { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed char>     { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed int>      { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed long>     { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed short>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_integral        { enum { value = false }; };$/;"	s	namespace:Eigen::internal
is_large	lib/Eigen/src/Core/GeneralProduct.h	/^  enum { is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon184
is_little_endian	lib/pugixml/pugixml.cc	/^	PUGI__FN bool is_little_endian()$/;"	f
is_malloc_allowed	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal
is_malloc_allowed_impl	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal
is_nan	lib/pugixml/pugixml.cc	/^	PUGI__FN bool is_nan(double value)$/;"	f
is_number	lib/serialisation/BaseIO.h	/^    static constexpr bool is_number = false;$/;"	m	struct:Grid::element
is_number	lib/serialisation/BaseIO.h	/^    static constexpr bool is_number = std::is_arithmetic<T>::value$/;"	m	struct:Grid::element
is_posinv_expr	lib/pugixml/pugixml.cc	/^		bool is_posinv_expr() const$/;"	f	class:xpath_ast_node
is_posinv_step	lib/pugixml/pugixml.cc	/^		bool is_posinv_step() const$/;"	f	class:xpath_ast_node
is_ref_compatible	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct is_ref_compatible$/;"	s	namespace:Eigen::internal
is_ref_compatible_impl	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct is_ref_compatible_impl$/;"	s	namespace:Eigen::internal
is_root	lib/json/json.hpp	/^        bool is_root() const$/;"	f	class:nlohmann::basic_json::json_pointer
is_row_major	lib/Eigen/src/Core/ProductEvaluators.h	/^  template<typename T> struct is_row_major : internal::conditional<(int(T::Flags)&RowMajorBit), internal::true_type, internal::false_type>::type {};$/;"	s	struct:Eigen::internal::generic_product_impl
is_same	lib/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_same	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_simd	lib/simd/Grid_vector_types.h	/^struct is_simd : public std::false_type {};$/;"	s	namespace:Grid
is_simd	lib/simd/Grid_vector_types.h	/^template <> struct is_simd<vComplexD>  : public std::true_type {};$/;"	s	namespace:Grid
is_simd	lib/simd/Grid_vector_types.h	/^template <> struct is_simd<vComplexF>  : public std::true_type {};$/;"	s	namespace:Grid
is_simd	lib/simd/Grid_vector_types.h	/^template <> struct is_simd<vInteger>   : public std::true_type {};$/;"	s	namespace:Grid
is_simd	lib/simd/Grid_vector_types.h	/^template <> struct is_simd<vRealD>     : public std::true_type {};$/;"	s	namespace:Grid
is_simd	lib/simd/Grid_vector_types.h	/^template <> struct is_simd<vRealF>     : public std::true_type {};$/;"	s	namespace:Grid
is_smeared	lib/qcd/action/ActionBase.h	/^  bool is_smeared = false;$/;"	m	class:Grid::QCD::Action
is_text_node	lib/pugixml/pugixml.cc	/^	inline bool is_text_node(xml_node_struct* node)$/;"	f
is_xpath_attribute	lib/pugixml/pugixml.cc	/^	inline bool is_xpath_attribute(const char_t* name)$/;"	f
iscomplex	lib/qcd/action/fermion/CayleyFermion5D.h	/^       static inline int iscomplex()  { return 0; } $/;"	f	struct:Grid::QCD::switcheroo
iscomplex	lib/qcd/action/fermion/CayleyFermion5D.h	/^       static inline int iscomplex()  { return 1; } $/;"	f	struct:Grid::QCD::switcheroo
isfinite	lib/Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool (isfinite)(const T &x) { return internal::isfinite_impl(x); }$/;"	f	namespace:Eigen::numext
isfinite	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isfinite)(const half& a) {$/;"	f	namespace:Eigen::half_impl
isfinite	lib/Eigen/src/Core/arch/CUDA/Half.h	/^bool (isfinite)(const Eigen::half& h) {$/;"	f	namespace:Eigen::numext
isfinite_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC bool isfinite_impl(const std::complex<T>& x)$/;"	f	namespace:Eigen::internal
isfinite_impl	lib/Eigen/src/Core/MathFunctions.h	/^isfinite_impl(const T& x)$/;"	f	namespace:Eigen::internal
isfinite_impl	lib/Eigen/src/Core/MathFunctions.h	/^isfinite_impl(const T&) { return true; }$/;"	f	namespace:Eigen::internal
isinf	lib/Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool (isinf)   (const T &x) { return internal::isinf_impl(x); }$/;"	f	namespace:Eigen::numext
isinf	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isinf)(const half& a) {$/;"	f	namespace:Eigen::half_impl
isinf	lib/Eigen/src/Core/arch/CUDA/Half.h	/^bool (isinf)(const Eigen::half& h) {$/;"	f	namespace:Eigen::numext
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC bool isinf_impl(const std::complex<T>& x)$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isinf_impl(const double& x)      { return isinf_msvc_helper(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isinf_impl(const float& x)       { return isinf_msvc_helper(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isinf_impl(const long double& x) { return isinf_msvc_helper(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^isinf_impl(const T& x)$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^isinf_impl(const T&) { return false; }$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const double& x)      { return __builtin_isinf(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const float& x)       { return __builtin_isinf(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const long double& x) { return __builtin_isinf(x); }$/;"	f	namespace:Eigen::internal
isinf_msvc_helper	lib/Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool isinf_msvc_helper(T x)$/;"	f	namespace:Eigen::internal
isnan	lib/Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool (isnan)   (const T &x) { return internal::isnan_impl(x); }$/;"	f	namespace:Eigen::numext
isnan	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isnan)(const half& a) {$/;"	f	namespace:Eigen::half_impl
isnan	lib/Eigen/src/Core/arch/CUDA/Half.h	/^bool (isnan)(const Eigen::half& h) {$/;"	f	namespace:Eigen::numext
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC bool isnan_impl(const std::complex<T>& x)$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isnan_impl(const double& x)      { return _isnan(x)!=0; }$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isnan_impl(const float& x)       { return _isnan(x)!=0; }$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isnan_impl(const long double& x) { return _isnan(x)!=0; }$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^isnan_impl(const T& x)$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^isnan_impl(const T&) { return false; }$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const double& x)      { return __builtin_isnan(x); }$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const float& x)       { return __builtin_isnan(x); }$/;"	f	namespace:Eigen::internal
isnan_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const long double& x) { return __builtin_isnan(x); }$/;"	f	namespace:Eigen::internal
it_	lib/serialisation/JSON_IO.h	/^    json::iterator      it_;$/;"	m	class:Grid::JSONReader
it_end_	lib/serialisation/JSON_IO.h	/^    json::iterator      it_end_;$/;"	m	class:Grid::JSONReader
item_t	lib/pugixml/pugixml.cc	/^		struct item_t$/;"	s	class:compact_hash_table	file:
iter	lib/algorithms/approx/Remez.h	/^  int nd1, iter;$/;"	m	class:AlgRemez
iter_impl	lib/json/json.hpp	/^    class iter_impl : public std::iterator<std::random_access_iterator_tag, U>$/;"	c	class:nlohmann::basic_json
iteration_proxy	lib/json/json.hpp	/^        explicit iteration_proxy(typename IteratorType::reference cont)$/;"	f	class:nlohmann::basic_json::iteration_proxy
iteration_proxy	lib/json/json.hpp	/^    class iteration_proxy$/;"	c	class:nlohmann::basic_json
iteration_proxy_internal	lib/json/json.hpp	/^        class iteration_proxy_internal$/;"	c	class:nlohmann::basic_json::iteration_proxy
iterations	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      Index iterations() const$/;"	f	class:Eigen::RealQZ
iterations	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index iterations() const$/;"	f	class:Eigen::IterativeSolverBase
iterator	lib/pugixml/pugixml.h	/^		typedef It iterator;$/;"	t	class:pugi::xml_object_range
iterator	lib/pugixml/pugixml.h	/^		typedef const xpath_node* iterator;$/;"	t	class:pugi::xpath_node_set
iterator	lib/pugixml/pugixml.h	/^		typedef xml_node_iterator iterator;$/;"	t	class:pugi::xml_node
iterator_category	lib/pugixml/pugixml.h	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_attribute_iterator
iterator_category	lib/pugixml/pugixml.h	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_named_node_iterator
iterator_category	lib/pugixml/pugixml.h	/^		typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:pugi::xml_node_iterator
iterator_wrapper	lib/json/json.hpp	/^    static iteration_proxy<const_iterator> iterator_wrapper(const_reference cont)$/;"	f	class:nlohmann::basic_json
iterator_wrapper	lib/json/json.hpp	/^    static iteration_proxy<iterator> iterator_wrapper(reference cont)$/;"	f	class:nlohmann::basic_json
jacobiSvd	lib/Eigen/src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase
jcur_	lib/serialisation/JSON_IO.h	/^    json                jcur_;  \/\/ current json object$/;"	m	class:Grid::JSONReader
jobject_	lib/serialisation/JSON_IO.h	/^    json                jobject_; \/\/ main object$/;"	m	class:Grid::JSONReader
jold_	lib/serialisation/JSON_IO.h	/^    std::vector<json>   jold_;  \/\/ previous json object$/;"	m	class:Grid::JSONReader
json_pointer	lib/json/json.hpp	/^        explicit json_pointer(const std::string& s = "")$/;"	f	class:nlohmann::basic_json::json_pointer
json_pointer	lib/json/json.hpp	/^    class json_pointer$/;"	c	class:nlohmann::basic_json
json_reverse_iterator	lib/json/json.hpp	/^    class json_reverse_iterator : public std::reverse_iterator<Base>$/;"	c	class:nlohmann::basic_json
json_value	lib/json/json.hpp	/^        json_value(const array_t& value)$/;"	f	union:nlohmann::basic_json::json_value
json_value	lib/json/json.hpp	/^        json_value(const object_t& value)$/;"	f	union:nlohmann::basic_json::json_value
json_value	lib/json/json.hpp	/^        json_value(const string_t& value)$/;"	f	union:nlohmann::basic_json::json_value
json_value	lib/json/json.hpp	/^        json_value(value_t t)$/;"	f	union:nlohmann::basic_json::json_value
json_value	lib/json/json.hpp	/^    union json_value$/;"	u	class:nlohmann::basic_json
kappa	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    std::vector<Coeff_t> kappa, kappaDag, kappaInv, kappaInvDag;$/;"	m	class:Grid::KappaSimilarityTransform
kappa	lib/qcd/utils/CovariantLaplacian.h	/^  RealD kappa;$/;"	m	class:Grid::QCD::LaplacianAdjointField
kappa	lib/qcd/utils/CovariantLaplacian.h	/^  RealD kappa;$/;"	m	class:Grid::QCD::LaplacianAlgebraField
kappaDag	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    std::vector<Coeff_t> kappa, kappaDag, kappaInv, kappaInvDag;$/;"	m	class:Grid::KappaSimilarityTransform
kappaInv	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    std::vector<Coeff_t> kappa, kappaDag, kappaInv, kappaInvDag;$/;"	m	class:Grid::KappaSimilarityTransform
kappaInvDag	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    std::vector<Coeff_t> kappa, kappaDag, kappaInv, kappaInvDag;$/;"	m	class:Grid::KappaSimilarityTransform
kc	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline Index kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking
keep_diag	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT
keep_diag	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase
kernel	lib/Eigen/src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU
kernel_p	lib/stencil/Stencil.h	/^    cobj * kernel_p;$/;"	m	struct:Grid::CartesianStencil::Decompress
kernel_retval	lib/Eigen/src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
kernel_retval_base	lib/Eigen/src/misc/Kernel.h	/^  explicit kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base
kernel_retval_base	lib/Eigen/src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal
key	lib/json/json.hpp	/^            typename basic_json::string_t key() const$/;"	f	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
key	lib/json/json.hpp	/^        key,$/;"	m	class:nlohmann::basic_json::parse_event_t
key	lib/json/json.hpp	/^        typename object_t::key_type key() const$/;"	f	class:nlohmann::basic_json::iter_impl
key	lib/json/json.hpp	/^        typename object_t::key_type key() const$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
key	lib/pugixml/pugixml.cc	/^			const void* key;$/;"	m	struct:compact_hash_table::item_t	file:
knl_gbl_	lib/perfmon/Stat.h	/^struct knl_gbl_$/;"	s	namespace:Grid
l	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  int64_t   l[2];$/;"	m	union:Eigen::internal::__anon308
l1CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen
l2CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen
l3CacheSize	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l3CacheSize()$/;"	f	namespace:Eigen
lSites	lib/cartesian/Cartesian_base.h	/^    inline int lSites(void) const { return _isites*_osites; }; $/;"	f	class:Grid::GridBase
lambda	lib/qcd/action/scalar/ScalarAction.h	/^    RealD lambda;$/;"	m	class:Grid::ScalarAction
lambda	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    RealD lambda;$/;"	m	class:Grid::ScalarInteractionAction
lambda	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  const RealD lambda = 0.1931833275037836;$/;"	m	class:Grid::QCD::ImplicitMinimumNorm2
lambda	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  const RealD lambda = 0.1931833275037836;$/;"	m	class:Grid::QCD::MinimumNorm2
lambda	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  const RealD lambda = 1.0 \/ 6.0;$/;"	m	class:Grid::QCD::ForceGradient
lapack_complex_double	lib/Eigen/src/misc/lapacke.h	96;"	d
lapack_complex_double_imag	lib/Eigen/src/misc/lapacke.h	104;"	d
lapack_complex_double_real	lib/Eigen/src/misc/lapacke.h	100;"	d
lapack_complex_float	lib/Eigen/src/misc/lapacke.h	80;"	d
lapack_complex_float_imag	lib/Eigen/src/misc/lapacke.h	88;"	d
lapack_complex_float_real	lib/Eigen/src/misc/lapacke.h	84;"	d
lapack_int	lib/Eigen/src/misc/lapacke.h	53;"	d
lapack_logical	lib/Eigen/src/misc/lapacke.h	57;"	d
laplace_stencil	lib/qcd/utils/CovariantLaplacian.h	/^  Stencil laplace_stencil;$/;"	m	class:Grid::QCD::LaplacianAdjointField
lastCoeff	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
lastErrorMessage	lib/Eigen/src/SparseLU/SparseLU.h	/^    std::string lastErrorMessage() const$/;"	f	class:Eigen::SparseLU
lastErrorMessage	lib/Eigen/src/SparseQR/SparseQR.h	/^    std::string lastErrorMessage() const { return m_lastError; }$/;"	f	class:Eigen::SparseQR
last_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::last_attribute() const$/;"	f	class:pugi::xml_node
last_child	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::last_child() const$/;"	f	class:pugi::xml_node
last_token	lib/json/json.hpp	/^        typename lexer::token_type last_token = lexer::token_type::uninitialized;$/;"	m	class:nlohmann::basic_json::parser
last_token_type	lib/json/json.hpp	/^        token_type last_token_type = token_type::end_of_input;$/;"	m	class:nlohmann::basic_json::lexer
latin1_writer	lib/pugixml/pugixml.cc	/^	struct latin1_writer$/;"	s	file:
lattice4dSize	extras/Hadrons/Environment.hpp	/^unsigned int Environment::lattice4dSize(void) const$/;"	f	class:Environment
lattice4dSize	lib/Hadrons/Environment.hpp	/^unsigned int Environment::lattice4dSize(void) const$/;"	f	class:Environment
lattice_	extras/Hadrons/Environment.hpp	/^    std::map<unsigned int, LatticePt>      lattice_;$/;"	m	class:Environment
lattice_	lib/Hadrons/Environment.hpp	/^    std::map<unsigned int, LatticePt>      lattice_;$/;"	m	class:Environment
lazyAssign	lib/Eigen/src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
lazyAssign	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
lazyAssign	lib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
lazyAssign	lib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
lazyProduct	lib/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
lazyproduct	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> lazyproduct;$/;"	t	struct:Eigen::internal::generic_product_impl
lda	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon15::__anon16
ldlt	lib/Eigen/src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase
ldlt	lib/Eigen/src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView
ldlt_inplace	lib/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
ldlt_inplace	lib/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
le32toh_v	lib/parallelIO/BinaryIO.h	/^  static inline void le32toh_v(void *file_object,uint64_t bytes)$/;"	f	class:Grid::BinaryIO
le64toh_v	lib/parallelIO/BinaryIO.h	/^  static inline void le64toh_v(void *file_object,uint64_t bytes)$/;"	f	class:Grid::BinaryIO
least_square_conjugate_gradient	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^void least_square_conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
lee	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> lee;    $/;"	m	class:Grid::QCD::CayleyFermion5D
leem	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> leem;    $/;"	m	class:Grid::QCD::CayleyFermion5D
leftCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr leftCols(Index n)$/;"	f
leftCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr leftCols(Index n) const$/;"	f
leftCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type leftCols(Index n = N) const$/;"	f
leftCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type leftCols(Index n = N)$/;"	f
length	lib/Eigen/src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
length	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType length ;  \/* number of principal columns in this row *\/$/;"	m	struct:internal::Colamd_Row
length	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType length ;  \/* number of rows in this column *\/$/;"	m	struct:internal::colamd_col
length	lib/pugixml/pugixml.cc	/^		size_t length() const$/;"	f	class:xpath_string
less	lib/pugixml/pugixml.cc	/^	struct less$/;"	s	file:
less_equal	lib/pugixml/pugixml.cc	/^	struct less_equal$/;"	s	file:
less_lmd	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  static bool less_lmd(RealD left,RealD right){$/;"	f	class:Grid::SortEigen
less_pair	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  static bool less_pair(std::pair<RealD,Field const*>& left,$/;"	f	class:Grid::SortEigen
level3_blocking	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking
level3_blocking	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
levels	lib/qcd/hmc/integrators/Integrator.h	/^  int levels;  \/\/ number of integration levels$/;"	m	class:Grid::QCD::Integrator
lex_axis_attribute	lib/pugixml/pugixml.cc	/^		lex_axis_attribute,$/;"	e	enum:lexeme_t	file:
lex_close_brace	lib/pugixml/pugixml.cc	/^		lex_close_brace,$/;"	e	enum:lexeme_t	file:
lex_close_square_brace	lib/pugixml/pugixml.cc	/^		lex_close_square_brace,$/;"	e	enum:lexeme_t	file:
lex_comma	lib/pugixml/pugixml.cc	/^		lex_comma,$/;"	e	enum:lexeme_t	file:
lex_dot	lib/pugixml/pugixml.cc	/^		lex_dot,$/;"	e	enum:lexeme_t	file:
lex_double_colon	lib/pugixml/pugixml.cc	/^		lex_double_colon,$/;"	e	enum:lexeme_t	file:
lex_double_dot	lib/pugixml/pugixml.cc	/^		lex_double_dot,$/;"	e	enum:lexeme_t	file:
lex_double_slash	lib/pugixml/pugixml.cc	/^		lex_double_slash,$/;"	e	enum:lexeme_t	file:
lex_eof	lib/pugixml/pugixml.cc	/^		lex_eof$/;"	e	enum:lexeme_t	file:
lex_equal	lib/pugixml/pugixml.cc	/^		lex_equal,$/;"	e	enum:lexeme_t	file:
lex_greater	lib/pugixml/pugixml.cc	/^		lex_greater,$/;"	e	enum:lexeme_t	file:
lex_greater_or_equal	lib/pugixml/pugixml.cc	/^		lex_greater_or_equal,$/;"	e	enum:lexeme_t	file:
lex_less	lib/pugixml/pugixml.cc	/^		lex_less,$/;"	e	enum:lexeme_t	file:
lex_less_or_equal	lib/pugixml/pugixml.cc	/^		lex_less_or_equal,$/;"	e	enum:lexeme_t	file:
lex_minus	lib/pugixml/pugixml.cc	/^		lex_minus,$/;"	e	enum:lexeme_t	file:
lex_multiply	lib/pugixml/pugixml.cc	/^		lex_multiply,$/;"	e	enum:lexeme_t	file:
lex_none	lib/pugixml/pugixml.cc	/^		lex_none = 0,$/;"	e	enum:lexeme_t	file:
lex_not_equal	lib/pugixml/pugixml.cc	/^		lex_not_equal,$/;"	e	enum:lexeme_t	file:
lex_number	lib/pugixml/pugixml.cc	/^		lex_number,$/;"	e	enum:lexeme_t	file:
lex_open_brace	lib/pugixml/pugixml.cc	/^		lex_open_brace,$/;"	e	enum:lexeme_t	file:
lex_open_square_brace	lib/pugixml/pugixml.cc	/^		lex_open_square_brace,$/;"	e	enum:lexeme_t	file:
lex_plus	lib/pugixml/pugixml.cc	/^		lex_plus,$/;"	e	enum:lexeme_t	file:
lex_quoted_string	lib/pugixml/pugixml.cc	/^		lex_quoted_string,$/;"	e	enum:lexeme_t	file:
lex_sites	lib/lattice/Lattice_coordinate.h	/^    template<class vobj> void lex_sites(Lattice<vobj> &l){$/;"	f	namespace:Grid
lex_slash	lib/pugixml/pugixml.cc	/^		lex_slash,$/;"	e	enum:lexeme_t	file:
lex_string	lib/pugixml/pugixml.cc	/^		lex_string,$/;"	e	enum:lexeme_t	file:
lex_union	lib/pugixml/pugixml.cc	/^		lex_union,$/;"	e	enum:lexeme_t	file:
lex_var_ref	lib/pugixml/pugixml.cc	/^		lex_var_ref,$/;"	e	enum:lexeme_t	file:
lexeme_t	lib/pugixml/pugixml.cc	/^	enum lexeme_t$/;"	g	file:
lexer	lib/json/json.hpp	/^        explicit lexer(std::istream& s)$/;"	f	class:nlohmann::basic_json::lexer
lexer	lib/json/json.hpp	/^    class lexer$/;"	c	class:nlohmann::basic_json
lgamma	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^lgamma() const$/;"	f
lhs	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp
lhs	lib/Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC const LhsNestedCleaned& lhs() const { return m_lhs; }$/;"	f	class:Eigen::Product
lhs_length	lib/Eigen/src/Core/products/Parallelizer.h	/^  Index lhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo
lhs_start	lib/Eigen/src/Core/products/Parallelizer.h	/^  Index lhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo
linear	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linear	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linearExt	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform
linearExt	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform
linkTrace	lib/qcd/utils/WilsonLoops.h	/^  static RealD linkTrace(const GaugeLorentz &Umu) {$/;"	f	class:Grid::QCD::WilsonLoops
linspaced_op	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  linspaced_op(const Scalar& low, const Scalar& high, Index num_steps)$/;"	f	struct:Eigen::internal::linspaced_op
linspaced_op	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^template <typename Scalar, typename PacketType> struct linspaced_op$/;"	s	namespace:Eigen::internal
linspaced_op_impl	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :$/;"	f	struct:Eigen::internal::linspaced_op_impl
linspaced_op_impl	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct linspaced_op_impl<Scalar,Packet,\/*IsInteger*\/false>$/;"	s	namespace:Eigen::internal
linspaced_op_impl	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct linspaced_op_impl<Scalar,Packet,\/*IsInteger*\/true>$/;"	s	namespace:Eigen::internal
list	lib/Eigen/src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
list_base	lib/Eigen/src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list
literal_false	lib/json/json.hpp	/^            literal_false,   \/\/\/< the `false` literal$/;"	m	class:nlohmann::basic_json::lexer::token_type
literal_null	lib/json/json.hpp	/^            literal_null,    \/\/\/< the `null` literal$/;"	m	class:nlohmann::basic_json::lexer::token_type
literal_true	lib/json/json.hpp	/^            literal_true,    \/\/\/< the `true` literal$/;"	m	class:nlohmann::basic_json::lexer::token_type
llt	lib/Eigen/src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase
llt	lib/Eigen/src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView
llt_inplace	lib/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
llt_inplace	lib/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
llt_rank_update_lower	lib/Eigen/src/Cholesky/LLT.h	/^static Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal
lmultGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaT	lib/qcd/spin/Gamma.h	/^inline void lmultGammaT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaTGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultGammaTGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaX	lib/qcd/spin/Gamma.h	/^inline void lmultGammaX(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaXGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultGammaXGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaY	lib/qcd/spin/Gamma.h	/^inline void lmultGammaY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaYGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultGammaYGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaZ	lib/qcd/spin/Gamma.h	/^inline void lmultGammaZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultGammaZGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultGammaZGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultIdentity	lib/qcd/spin/Gamma.h	/^inline void lmultIdentity(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaT	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaTGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaTGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaX	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaX(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaXGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaXGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaY	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaYGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaYGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaZ	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusGammaZGamma5	lib/qcd/spin/Gamma.h	/^inline void lmultMinusGammaZGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusIdentity	lib/qcd/spin/Gamma.h	/^inline void lmultMinusIdentity(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusSigmaXT	lib/qcd/spin/Gamma.h	/^inline void lmultMinusSigmaXT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusSigmaXY	lib/qcd/spin/Gamma.h	/^inline void lmultMinusSigmaXY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusSigmaXZ	lib/qcd/spin/Gamma.h	/^inline void lmultMinusSigmaXZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusSigmaYT	lib/qcd/spin/Gamma.h	/^inline void lmultMinusSigmaYT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusSigmaYZ	lib/qcd/spin/Gamma.h	/^inline void lmultMinusSigmaYZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultMinusSigmaZT	lib/qcd/spin/Gamma.h	/^inline void lmultMinusSigmaZT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultSigmaXT	lib/qcd/spin/Gamma.h	/^inline void lmultSigmaXT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultSigmaXY	lib/qcd/spin/Gamma.h	/^inline void lmultSigmaXY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultSigmaXZ	lib/qcd/spin/Gamma.h	/^inline void lmultSigmaXZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultSigmaYT	lib/qcd/spin/Gamma.h	/^inline void lmultSigmaYT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultSigmaYZ	lib/qcd/spin/Gamma.h	/^inline void lmultSigmaYZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lmultSigmaZT	lib/qcd/spin/Gamma.h	/^inline void lmultSigmaZT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
lo	lib/algorithms/approx/Chebyshev.h	/^    RealD lo;$/;"	m	class:Grid::Chebyshev
lo	lib/algorithms/approx/MultiShiftFunction.h	/^  RealD lo,hi;$/;"	m	class:Grid::MultiShiftFunction
load	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet load(Index i) const {$/;"	f	class:Eigen::internal::BlasVectorMapper
load	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load(const char_t* contents, unsigned int options)$/;"	f	class:pugi::xml_document
load	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document
load	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options)$/;"	f	class:pugi::xml_document
loadHalfPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HalfPacket loadHalfPacket(Index i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
loadHalfPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HalfPacket loadHalfPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
loadLhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadLhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadLhsUnaligned	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhsUnaligned(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadLhsUnaligned	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhsUnaligned(const LhsScalar* a, LhsPacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadLinkElement	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void loadLinkElement(Simd &reg, ref &memory) {$/;"	f	class:Grid::QCD::StaggeredImpl
loadLinkElement	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void loadLinkElement(Simd &reg, ref &memory) {$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
loadLinkElement	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void loadLinkElement(Simd &reg, ref &memory) {$/;"	f	class:Grid::QCD::WilsonImpl
loadLinkElement	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  inline void loadLinkElement(Simd &reg, ref &memory) {$/;"	f	class:Grid::QCD::DomainWallVec5dImpl
loadPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
loadPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
loadRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhsQuad	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhsQuad(const RhsScalar* b, DoublePacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhsQuad	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhsQuad(const RhsScalar* b, ResPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhsQuad	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhsQuad(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadSchedule	extras/Hadrons/Application.cc	/^void Application::loadSchedule(const std::string filename)$/;"	f	class:Application
loadSchedule	lib/Hadrons/Application.cc	/^void Application::loadSchedule(const std::string filename)$/;"	f	class:Application
load_buffer	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document
load_buffer_impl	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result load_buffer_impl(xml_document_struct* doc, xml_node_struct* root, void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own, char_t** out_buffer)$/;"	f
load_buffer_inplace	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load_buffer_inplace(void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document
load_buffer_inplace_own	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load_buffer_inplace_own(void* contents, size_t size, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document
load_file	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load_file(const char* path_, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document
load_file	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load_file(const wchar_t* path_, unsigned int options, xml_encoding encoding)$/;"	f	class:pugi::xml_document
load_file_impl	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result load_file_impl(xml_document& doc, FILE* file, unsigned int options, xml_encoding encoding)$/;"	f
load_stream_data_noseek	lib/pugixml/pugixml.cc	/^	template <typename T> PUGI__FN xml_parse_status load_stream_data_noseek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)$/;"	f
load_stream_data_seek	lib/pugixml/pugixml.cc	/^	template <typename T> PUGI__FN xml_parse_status load_stream_data_seek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)$/;"	f
load_stream_impl	lib/pugixml/pugixml.cc	/^	template <typename T> PUGI__FN xml_parse_result load_stream_impl(xml_document& doc, std::basic_istream<T>& stream, unsigned int options, xml_encoding encoding)$/;"	f
load_string	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result xml_document::load_string(const char_t* contents, unsigned int options)$/;"	f	class:pugi::xml_document
locVol_	extras/Hadrons/Application.hpp	/^    long unsigned int         locVol_;$/;"	m	class:Application
locVol_	extras/Hadrons/Environment.hpp	/^    unsigned int                           traj_, locVol_;$/;"	m	class:Environment
locVol_	lib/Hadrons/Application.hpp	/^    long unsigned int         locVol_;$/;"	m	class:Application
locVol_	lib/Hadrons/Environment.hpp	/^    unsigned int                           traj_, locVol_;$/;"	m	class:Environment
localConvert	lib/lattice/Lattice_transfer.h	/^void localConvert(const Lattice<vobj> &in,Lattice<vvobj> &out)$/;"	f	namespace:Grid
local_name	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* local_name(const xpath_node& node)$/;"	f
log	lib/Eigen/src/Core/MathFunctions.h	/^T log(const T &x) {$/;"	f	namespace:Eigen::numext
log	lib/Eigen/src/Core/MathFunctions.h	/^double log(const double &x) { return ::log(x); }$/;"	f	namespace:Eigen::numext
log	lib/Eigen/src/Core/MathFunctions.h	/^float log(const float &x) { return ::logf(x); }$/;"	f	namespace:Eigen::numext
log	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log(const half& a) {$/;"	f	namespace:Eigen::half_impl
log	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log() const$/;"	f
log	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> log(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
log10	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log10(const half& a) {$/;"	f	namespace:Eigen::half_impl
log10	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log10() const$/;"	f
log1p	lib/Eigen/src/Core/MathFunctions.h	/^  EIGEN_DEVICE_FUNC inline Scalar log1p(const Scalar& x) {$/;"	f	namespace:Eigen::internal::std_fallback
log1p	lib/Eigen/src/Core/MathFunctions.h	/^double log1p(const double &x) { return ::log1p(x); }$/;"	f	namespace:Eigen::numext
log1p	lib/Eigen/src/Core/MathFunctions.h	/^float log1p(const float &x) { return ::log1pf(x); }$/;"	f	namespace:Eigen::numext
log1p	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(log1p, Scalar) log1p(const Scalar& x)$/;"	f	namespace:Eigen::numext
log1p	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log1p(const half& a) {$/;"	f	namespace:Eigen::half_impl
log1p	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log1p() const$/;"	f
log1p_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct log1p_impl {$/;"	s	namespace:Eigen::internal
log1p_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct log1p_retval$/;"	s	namespace:Eigen::internal
log2	lib/Eigen/src/Core/MathFunctions.h	/^inline int log2(int x)$/;"	f	namespace:Eigen::numext
logAbsDeterminant	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
logAbsDeterminant	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^CompleteOrthogonalDecomposition<MatrixType>::logAbsDeterminant() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
logAbsDeterminant	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
logAbsDeterminant	lib/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR
logAbsDeterminant	lib/Eigen/src/SparseLU/SparseLU.h	/^    Scalar logAbsDeterminant() const$/;"	f	class:Eigen::SparseLU
logDeterminant	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Scalar logDeterminant() const$/;"	f	class:Eigen::CholmodBase
logh	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half logh(const Eigen::half& a) {$/;"	f
low	lib/pugixml/pugixml.cc	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:latin1_writer
low	lib/pugixml/pugixml.cc	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf16_writer
low	lib/pugixml/pugixml.cc	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf32_writer
low	lib/pugixml/pugixml.cc	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf8_counter
low	lib/pugixml/pugixml.cc	/^		static value_type low(value_type result, uint32_t ch)$/;"	f	struct:utf8_writer
low	lib/pugixml/pugixml.cc	/^		static value_type low(value_type result, uint32_t)$/;"	f	struct:utf16_counter
low	lib/pugixml/pugixml.cc	/^		static value_type low(value_type result, uint32_t)$/;"	f	struct:utf32_counter
lowest	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half lowest() {$/;"	f	struct:Eigen::NumTraits
lpNorm	lib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase
lpNorm	lib/Eigen/src/Core/VectorwiseOp.h	/^    const typename LpNormReturnType<p>::Type lpNorm() const$/;"	f	class:Eigen::VectorwiseOp
lpNorm_selector	lib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
lpNorm_selector	lib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
lpNorm_selector	lib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
lpNorm_selector	lib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
lsub	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector lsub; \/\/ Compressed row indices of L rectangular supernodes. $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
lu	lib/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase
lusup	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  lusup; \/\/ nonzero values of L ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
m_E	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable StorageIndex *m_E; \/\/ The permutation applied to columns$/;"	m	class:Eigen::SPQR
m_H	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_H;  \/\/The householder vectors$/;"	m	class:Eigen::SPQR
m_HPinv	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable StorageIndex *m_HPinv; \/\/ The row permutation of H$/;"	m	class:Eigen::SPQR
m_HTau	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_dense *m_HTau; \/\/ The Householder coefficients$/;"	m	class:Eigen::SPQR
m_L	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    FactorType m_L;              \/\/ The lower part stored in CSC$/;"	m	class:Eigen::IncompleteCholesky
m_LDLT	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky
m_Lstore	lib/Eigen/src/SparseLU/SparseLU.h	/^    SCMatrix m_Lstore; \/\/ The lower triangular matrix (supernodal)$/;"	m	class:Eigen::SparseLU
m_P	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT
m_P	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_Pinv	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT
m_Pinv	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_Q	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_Q	lib/Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_Q;               \/\/ The orthogonal reflectors$/;"	m	class:Eigen::SparseQR
m_R	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable MatrixType m_R; \/\/ The sparse matrix R in Eigen format$/;"	m	class:Eigen::SPQR
m_R	lib/Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_R;               \/\/ The triangular factor matrix$/;"	m	class:Eigen::SparseQR
m_S	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_T	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_Ustore	lib/Eigen/src/SparseLU/SparseLU.h	/^    MappedSparseMatrix<Scalar,ColMajor,StorageIndex> m_Ustore; \/\/ The upper triangular matrix$/;"	m	class:Eigen::SparseLU
m_Z	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_actualAlpha	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor
m_adjoint	lib/Eigen/src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_algoswap	lib/Eigen/src/SVD/BDCSVD.h	/^  int m_algoswap;$/;"	m	class:Eigen::BDCSVD
m_allocatedElements	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage
m_allow_tol	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_allow_tol; \/\/ Allow to use some tolerance during numerical factorization.$/;"	m	class:Eigen::SPQR
m_alphas	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType m_alphas;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_analysisIsOk	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase
m_analysisIsOk	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    bool m_analysisIsOk; $/;"	m	class:Eigen::IncompleteCholesky
m_analysisIsOk	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_analysisIsOk	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_analysisIsOk	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase
m_analysisIsOk	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_analysisIsOk	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SPQR
m_analysisIsOk	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_analysisIsOk	lib/Eigen/src/SparseLU/SparseLU.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SparseLU
m_analysisIsOk	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase
m_analysisIsOk	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU
m_analysisIsok	lib/Eigen/src/SparseQR/SparseQR.h	/^    bool m_analysisIsok;$/;"	m	class:Eigen::SparseQR
m_angle	lib/Eigen/src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis
m_angle	lib/Eigen/src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D
m_arg	lib/Eigen/src/Core/CoreEvaluators.h	/^  const ArgType& m_arg;$/;"	m	class:Eigen::internal::EvalToTemp
m_arg	lib/Eigen/src/Core/CoreEvaluators.h	/^  const ArgTypeNested m_arg;$/;"	m	struct:Eigen::internal::unary_evaluator
m_arg	lib/Eigen/src/Core/CoreEvaluators.h	/^  typename internal::add_const_on_value_type<ArgTypeNested>::type m_arg;$/;"	m	struct:Eigen::internal::evaluator
m_arg	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  const ArgType& m_arg;$/;"	m	struct:Eigen::internal::unary_evaluator
m_arg1	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  Arg1Nested m_arg1;$/;"	m	class:Eigen::CwiseTernaryOp
m_arg1Impl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Arg1> m_arg1Impl;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_arg2	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  Arg2Nested m_arg2;$/;"	m	class:Eigen::CwiseTernaryOp
m_arg2Impl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Arg2> m_arg2Impl;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_arg3	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  Arg3Nested m_arg3;$/;"	m	class:Eigen::CwiseTernaryOp
m_arg3Impl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Arg3> m_arg3Impl;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_argImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::evaluator
m_argImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::evaluator_wrapper_base
m_argImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgTypeNestedCleaned> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	lib/Eigen/src/SparseCore/SparseBlock.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	lib/Eigen/src/SparseCore/SparseView.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_axis	lib/Eigen/src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis
m_betas	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType m_betas;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_bidiagonal	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_block	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const XprType &m_block;$/;"	m	struct:Eigen::internal::unary_evaluator
m_block	lib/Eigen/src/SparseCore/SparseBlock.h	/^  const XprType& m_block;$/;"	m	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
m_blockA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking
m_blockB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking
m_blockCols	lib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_blockCols	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::BlockImpl
m_blockRows	lib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_blockRows	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::BlockImpl
m_blocking	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor
m_buffer	lib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector
m_c	lib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_cR	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_cR; \/\/ The sparse R factor in cholmod format$/;"	m	class:Eigen::SPQR
m_cachedIndex	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_cachedIndex; \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_cachedValue	lib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_cc	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_common m_cc; \/\/ Workspace and parameters$/;"	m	class:Eigen::SPQR
m_cholmod	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase
m_cholmodFactor	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase
m_coeff	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typename DiagonalCoeffType::Scalar m_coeff;$/;"	m	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
m_coeffs	lib/Eigen/src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix
m_coeffs	lib/Eigen/src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_coeffs	lib/Eigen/src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane
m_coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	lib/Eigen/src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion
m_coeffs	lib/Eigen/src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation
m_coeffs	lib/Eigen/src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence
m_col	lib/Eigen/src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer
m_col	lib/Eigen/src/SparseCore/SparseUtil.h	/^  StorageIndex m_row, m_col;$/;"	m	class:Eigen::Triplet
m_col	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_col; \/\/ Number of columns$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_colFactor	lib/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate
m_colNormsDirect	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colNormsDirect;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colNormsUpdated	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colNormsUpdated;$/;"	m	class:Eigen::ColPivHouseholderQR
m_col_to_sup	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_col_to_sup; \/\/ col_to_sup[j] is the supernode number to which column j belongs$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_cols	lib/Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ArgType::ColsAtCompileTime> m_cols;$/;"	m	struct:Eigen::internal::unary_evaluator
m_cols	lib/Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ReverseCol ? ArgType::ColsAtCompileTime : 1> m_cols;$/;"	m	struct:Eigen::internal::unary_evaluator
m_cols	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp
m_cols	lib/Eigen/src/Core/DenseStorage.h	/^    Index m_cols;$/;"	m	class:Eigen::DenseStorage
m_cols	lib/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase
m_cols	lib/Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_cols	lib/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_cols	lib/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_colsPermutation	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colsTranspositions	lib/Eigen/src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_colsTranspositions	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR
m_cols_permutation	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR
m_cols_transpositions	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_comm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase
m_compU	lib/Eigen/src/SVD/BDCSVD.h	/^  bool m_isTranspose, m_compU, m_compV;$/;"	m	class:Eigen::BDCSVD
m_compV	lib/Eigen/src/SVD/BDCSVD.h	/^  bool m_isTranspose, m_compU, m_compV;$/;"	m	class:Eigen::BDCSVD
m_computationOptions	lib/Eigen/src/SVD/SVDBase.h	/^  unsigned int m_computationOptions;$/;"	m	class:Eigen::SVDBase
m_computeFullU	lib/Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::SVDBase
m_computeFullV	lib/Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::SVDBase
m_computeQZ	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      bool m_computeQZ;$/;"	m	class:Eigen::RealQZ
m_computeThinU	lib/Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::SVDBase
m_computeThinV	lib/Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::SVDBase
m_computed	lib/Eigen/src/SVD/BDCSVD.h	/^  MatrixXr m_computed;$/;"	m	class:Eigen::BDCSVD
m_condition	lib/Eigen/src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select
m_conditionImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ConditionMatrixType> m_conditionImpl;$/;"	m	struct:Eigen::internal::evaluator
m_containsDiag	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      bool m_containsDiag;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_content	lib/json/json.hpp	/^            : m_content(buff)$/;"	f	class:nlohmann::basic_json::lexer
m_content	lib/json/json.hpp	/^        const lexer_char_t* m_content = nullptr;$/;"	m	class:nlohmann::basic_json::lexer
m_control	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackControl m_control;$/;"	m	class:Eigen::UmfPackLU
m_cpqr	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  ColPivHouseholderQR<MatrixType> m_cpqr;$/;"	m	class:Eigen::CompleteOrthogonalDecomposition
m_currentBlockRows	lib/Eigen/src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer
m_currentEl	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_currentEl;   \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_cursor	lib/json/json.hpp	/^        const lexer_char_t* m_cursor = nullptr;$/;"	m	class:nlohmann::basic_json::lexer
m_data	lib/Eigen/src/Core/CoreEvaluators.h	/^  PointerType m_data;$/;"	m	struct:Eigen::internal::mapbase_evaluator
m_data	lib/Eigen/src/Core/CoreEvaluators.h	/^  const Scalar *m_data;$/;"	m	struct:Eigen::internal::evaluator
m_data	lib/Eigen/src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage
m_data	lib/Eigen/src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage
m_data	lib/Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize)+(ForceAlignment?EIGEN_MAX_ALIGN_BYTES:0),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if
m_data	lib/Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0,EIGEN_PLAIN_ENUM_MIN(AlignedMax,PacketSize)> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if
m_data	lib/Eigen/src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase
m_data	lib/Eigen/src/Core/util/BlasUtil.h	/^  Scalar *m_data;$/;"	m	class:Eigen::internal::BlasLinearMapper
m_data	lib/Eigen/src/Core/util/BlasUtil.h	/^  Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper
m_data	lib/Eigen/src/Core/util/BlasUtil.h	/^  Scalar* m_data;$/;"	m	class:Eigen::internal::BlasVectorMapper
m_data	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix
m_data	lib/Eigen/src/SparseCore/SparseVector.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseVector
m_deallocate	lib/Eigen/src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_dec	lib/Eigen/src/Core/Solve.h	/^  const Decomposition &m_dec;$/;"	m	class:Eigen::Solve
m_dec	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  const Decomposition &m_dec;$/;"	m	class:Eigen::SolveWithGuess
m_dec	lib/Eigen/src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base
m_dec	lib/Eigen/src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_dest	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor
m_detPermC	lib/Eigen/src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU
m_detPermR	lib/Eigen/src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU
m_det_p	lib/Eigen/src/LU/PartialPivLU.h	/^    signed char m_det_p;$/;"	m	class:Eigen::PartialPivLU
m_det_pq	lib/Eigen/src/LU/FullPivLU.h	/^    signed char m_det_pq;$/;"	m	class:Eigen::FullPivLU
m_det_pq	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR
m_det_pq	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR
m_diag	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase
m_diagCoeffImpl	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  evaluator<DiagonalCoeffType> m_diagCoeffImpl;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_diagCoeffNested	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    DiagCoeffNested m_diagCoeffNested;$/;"	m	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
m_diagCoeffNested	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  DiagCoeffNested m_diagCoeffNested;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_diagImpl	lib/Eigen/src/Core/ProductEvaluators.h	/^  evaluator<DiagonalType> m_diagImpl;$/;"	m	struct:Eigen::internal::diagonal_product_evaluator_base
m_diagSize	lib/Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_diagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix
m_diagonal	lib/Eigen/src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper
m_diagpivotthresh	lib/Eigen/src/SparseLU/SparseLU.h	/^    RealScalar m_diagpivotthresh; \/\/ Specifies the threshold used for a diagonal entry to be an acceptable pivot$/;"	m	class:Eigen::SparseLU
m_direction	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_divisor	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_divisor;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_dparm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Array<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_droptol	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT
m_dst	lib/Eigen/src/Core/AssignEvaluator.h	/^  DstEvaluatorType& m_dst;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_dstExpr	lib/Eigen/src/Core/AssignEvaluator.h	/^  DstXprType& m_dstExpr;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_dummy	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  MatrixType m_dummy; \/\/ used to default initialize the Ref<> object$/;"	m	class:Eigen::internal::generic_matrix_wrapper
m_dummy	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_dummy;$/;"	m	class:Eigen::UmfPackLU
m_eigenvectorsOk	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver
m_eigenvectorsOk	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver
m_eigenvectorsOk	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivalues	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivalues	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver
m_eivalues	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivec	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivec	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver
m_eivec	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvectorsType m_eivec;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_eivec	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    EigenvectorsType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_else	lib/Eigen/src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select
m_elseImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ElseMatrixType> m_elseImpl;$/;"	m	struct:Eigen::internal::evaluator
m_empty	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    bool m_empty;$/;"	m	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
m_end	lib/Eigen/src/Core/CoreIterators.h	/^  const Index m_end;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_end	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_end;$/;"	m	class:Eigen::internal::AmbiVector
m_end	lib/Eigen/src/SparseCore/SparseBlock.h	/^  Index m_end;$/;"	m	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
m_end	lib/Eigen/src/SparseCore/SparseBlock.h	/^  Index m_end;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_end	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_end;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_end	lib/Eigen/src/SparseCore/SparseView.h	/^        const Index m_end;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_endidrow	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_endidrow;                       \/\/ End index of row indices of the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_endidval	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_endidval;                 \/\/ End of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_epsilon	lib/Eigen/src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_epsilon	lib/Eigen/src/SparseCore/SparseView.h	/^  RealScalar m_epsilon;$/;"	m	class:Eigen::SparseView
m_error	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase
m_etree	lib/Eigen/src/SparseLU/SparseLU.h	/^    IndexVector m_etree; \/\/ Column elimination tree $/;"	m	class:Eigen::SparseLU
m_etree	lib/Eigen/src/SparseQR/SparseQR.h	/^    IndexVector m_etree;            \/\/ Column elimination tree$/;"	m	class:Eigen::SparseQR
m_eval	lib/Eigen/src/Core/CoreIterators.h	/^  EvaluatorType m_eval;$/;"	m	class:Eigen::InnerIterator
m_eval	lib/Eigen/src/Core/CoreIterators.h	/^  const EvaluatorType& m_eval;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_eval	lib/Eigen/src/SparseCore/SparseBlock.h	/^  const unary_evaluator& m_eval;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_evaluator	lib/Eigen/src/Core/Redux.h	/^  internal::evaluator<XprType> m_evaluator;$/;"	m	class:Eigen::internal::redux_evaluator
m_evaluator	lib/Eigen/src/Core/Visitor.h	/^  internal::evaluator<XprType> m_evaluator;$/;"	m	class:Eigen::internal::visitor_evaluator
m_expr	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  const XprType &m_expr;$/;"	m	struct:Eigen::internal::binary_evaluator
m_expression	lib/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper
m_expression	lib/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper
m_expression	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess
m_expression	lib/Eigen/src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue
m_expression	lib/Eigen/src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias
m_extractedDataAreDirty	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase
m_extractedDataAreDirty	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU
m_fact_errorCode	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_fact_errorCode;$/;"	m	class:Eigen::UmfPackLU
m_factor	lib/Eigen/src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling
m_factor	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
m_factorizationIsOk	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase
m_factorizationIsOk	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    bool m_factorizationIsOk; $/;"	m	class:Eigen::IncompleteCholesky
m_factorizationIsOk	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_factorizationIsOk	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_factorizationIsOk	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase
m_factorizationIsOk	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_factorizationIsOk	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SPQR
m_factorizationIsOk	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_factorizationIsOk	lib/Eigen/src/SparseLU/SparseLU.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SparseLU
m_factorizationIsOk	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase
m_factorizationIsOk	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU
m_factorizationIsok	lib/Eigen/src/SparseQR/SparseQR.h	/^    bool m_factorizationIsok;$/;"	m	class:Eigen::SparseQR
m_fillfactor	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT
m_firstRowElt	lib/Eigen/src/SparseQR/SparseQR.h	/^    IndexVector m_firstRowElt;      \/\/ First element in each row$/;"	m	class:Eigen::SparseQR
m_flip	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const bool m_flip;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_format	lib/Eigen/src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat
m_functor	lib/Eigen/src/Core/AssignEvaluator.h	/^  const Functor &m_functor;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_functor	lib/Eigen/src/Core/CoreEvaluators.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::binary_evaluator
m_functor	lib/Eigen/src/Core/CoreEvaluators.h	/^  const MemberOp m_functor;$/;"	m	struct:Eigen::internal::evaluator
m_functor	lib/Eigen/src/Core/CoreEvaluators.h	/^  const NullaryOp m_functor;$/;"	m	struct:Eigen::internal::evaluator
m_functor	lib/Eigen/src/Core/CoreEvaluators.h	/^  const TernaryOp m_functor;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_functor	lib/Eigen/src/Core/CoreEvaluators.h	/^  const UnaryOp m_functor;$/;"	m	struct:Eigen::internal::unary_evaluator
m_functor	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp
m_functor	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp
m_functor	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  const TernaryOp m_functor;$/;"	m	class:Eigen::CwiseTernaryOp
m_functor	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp
m_functor	lib/Eigen/src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView
m_functor	lib/Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr
m_functor	lib/Eigen/src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux
m_functor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_functor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_functor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::binary_evaluator
m_functor	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::sparse_conjunction_evaluator
m_functor	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_functor	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	struct:Eigen::internal::unary_evaluator
m_functor	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_functor	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	struct:Eigen::internal::unary_evaluator
m_global_iter	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      Index m_global_iter;$/;"	m	class:Eigen::RealQZ
m_glu	lib/Eigen/src/SparseLU/SparseLU.h	/^    typename Base::GlobalLU_t m_glu; $/;"	m	class:Eigen::SparseLU
m_glu	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typename SparseLUImpl<Scalar, StorageIndex>::GlobalLU_t& m_glu;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_guess	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  const GuessType     &m_guess;$/;"	m	class:Eigen::SolveWithGuess
m_hCoeffs	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition
m_hCoeffs	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization
m_hCoeffs	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR
m_hCoeffs	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR
m_hCoeffs	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_hCoeffs	lib/Eigen/src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR
m_hasCopy	lib/Eigen/src/SparseCore/SparseRef.h	/^    bool m_hasCopy;$/;"	m	class:Eigen::Ref
m_hcoeffs	lib/Eigen/src/SparseQR/SparseQR.h	/^    ScalarVector m_hcoeffs;         \/\/ The Householder coefficients$/;"	m	class:Eigen::SparseQR
m_hess	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur
m_hess	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
m_hess	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur
m_high	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_high;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_householder	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_id	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_id;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_id	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_id;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_id	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    StorageIndex m_id;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_idrow	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idrow;                          \/\/ Index to browse the row indices $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_idval	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idval;                          \/\/ Index to browse the values in the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_index	lib/Eigen/src/Core/CoreEvaluators.h	/^  const internal::variable_if_dynamicindex<Index, XprType::DiagIndex> m_index;$/;"	m	struct:Eigen::internal::evaluator
m_index	lib/Eigen/src/Core/Diagonal.h	/^    const internal::variable_if_dynamicindex<Index, DiagIndex> m_index;$/;"	m	class:Eigen::Diagonal
m_index	lib/Eigen/src/SparseCore/SparseMatrix.h	/^        StorageIndex m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_indexPtr	lib/Eigen/src/MetisSupport/MetisSupport.h	/^    IndexVector m_indexPtr; \/\/ Pointer to the adjacenccy list of each row\/column$/;"	m	class:Eigen::MetisOrdering
m_indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix
m_indices	lib/Eigen/src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper
m_indices	lib/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	lib/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions
m_indices	lib/Eigen/src/Core/Transpositions.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper
m_indices	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    StorageIndex* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage
m_indices	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const StorageIndex* m_indices;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_indices	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const StorageIndex* m_indices;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_info	lib/Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LDLT
m_info	lib/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT
m_info	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase
m_info	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur
m_info	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::EigenSolver
m_info	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      ComputationInfo m_info;$/;"	m	class:Eigen::RealQZ
m_info	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur
m_info	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_info	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteCholesky
m_info	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT
m_info	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase
m_info	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase
m_info	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl
m_info	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SPQR
m_info	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_info	lib/Eigen/src/SparseLU/SparseLU.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseLU
m_info	lib/Eigen/src/SparseQR/SparseQR.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseQR
m_info	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase
m_info	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU
m_initialShift	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    RealScalar m_initialShift;   \/\/ The initial shift parameter$/;"	m	class:Eigen::IncompleteCholesky
m_initisOk	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase
m_inner	lib/Eigen/src/Core/CoreIterators.h	/^  Index m_inner;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_inner	lib/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride
m_inner	lib/Eigen/src/SparseCore/SparseView.h	/^        Index m_inner;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_innerDim	lib/Eigen/src/Core/ProductEvaluators.h	/^  Index m_innerDim;$/;"	m	struct:Eigen::internal::product_evaluator
m_innerIndex	lib/Eigen/src/SparseCore/SparseBlock.h	/^  const Index m_innerIndex;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_innerIndices	lib/Eigen/src/MetisSupport/MetisSupport.h	/^    IndexVector m_innerIndices; \/\/ Adjacency list $/;"	m	class:Eigen::MetisOrdering
m_innerIndices	lib/Eigen/src/SparseCore/SparseMap.h	/^    IndexPointer  m_innerIndices;$/;"	m	class:Eigen::SparseMapBase
m_innerNonZeros	lib/Eigen/src/SparseCore/SparseMap.h	/^    IndexPointer  m_innerNonZeros;$/;"	m	class:Eigen::SparseMapBase
m_innerNonZeros	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    StorageIndex* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix
m_innerSize	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    StorageIndex m_innerSize;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_innerSize	lib/Eigen/src/SparseCore/SparseMap.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::SparseMapBase
m_innerSize	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix
m_innerStride	lib/Eigen/src/Core/CoreEvaluators.h	/^  const internal::variable_if_dynamic<Index, XprType::InnerStrideAtCompileTime> m_innerStride;$/;"	m	struct:Eigen::internal::mapbase_evaluator
m_interPacket	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Packet m_interPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_invdiag	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner
m_invp	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<StorageIndex,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase
m_iparm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Array<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_iparm	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable ParameterType m_iparm;$/;"	m	class:Eigen::PardisoImpl
m_isAllocated	lib/Eigen/src/SVD/SVDBase.h	/^  bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_isDense	lib/Eigen/src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_isEtreeOk	lib/Eigen/src/SparseQR/SparseQR.h	/^    bool m_isEtreeOk;               \/\/ whether the elimination tree match the initial input matrix$/;"	m	class:Eigen::SparseQR
m_isInitialized	lib/Eigen/src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT
m_isInitialized	lib/Eigen/src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT
m_isInitialized	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver
m_isInitialized	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur
m_isInitialized	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver
m_isInitialized	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition
m_isInitialized	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      bool m_isInitialized;$/;"	m	class:Eigen::RealQZ
m_isInitialized	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur
m_isInitialized	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_isInitialized	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization
m_isInitialized	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner
m_isInitialized	lib/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_isInitialized	lib/Eigen/src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU
m_isInitialized	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_isInitialized	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_isInitialized	lib/Eigen/src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR
m_isInitialized	lib/Eigen/src/SVD/SVDBase.h	/^  bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_isInitialized	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_isInitialized	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    mutable bool m_isInitialized;$/;"	m	class:Eigen::SparseSolverBase
m_isQSorted	lib/Eigen/src/SparseQR/SparseQR.h	/^    bool m_isQSorted;               \/\/ whether Q is sorted or not$/;"	m	class:Eigen::SparseQR
m_isRUpToDate	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable bool m_isRUpToDate;$/;"	m	class:Eigen::SPQR
m_isRValue	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase
m_isTranspose	lib/Eigen/src/SVD/BDCSVD.h	/^  bool m_isTranspose, m_compU, m_compV;$/;"	m	class:Eigen::BDCSVD
m_it	lib/Eigen/src/SparseCore/SparseBlock.h	/^  EvalIterator m_it;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_it	lib/json/json.hpp	/^            : m_object(other.m_object), m_it(other.m_it)$/;"	f	class:nlohmann::basic_json::iter_impl
m_it	lib/json/json.hpp	/^        difference_type m_it = std::numeric_limits<std::ptrdiff_t>::denorm_min();$/;"	m	class:nlohmann::basic_json::primitive_iterator_t
m_it	lib/json/json.hpp	/^        internal_iterator m_it = internal_iterator();$/;"	m	class:nlohmann::basic_json::iter_impl
m_iter	lib/Eigen/src/Core/CoreIterators.h	/^  IteratorType m_iter;$/;"	m	class:Eigen::InnerIterator
m_iterations	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable Index m_iterations;$/;"	m	class:Eigen::IterativeSolverBase
m_jcol	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_jcol	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::panel_dfs_traits
m_jsuper_ref	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  Index& m_jsuper_ref;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_kc	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_kc;$/;"	m	class:Eigen::internal::level3_blocking
m_l	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase
m_l	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU
m_l1	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  std::ptrdiff_t m_l1;$/;"	m	struct:Eigen::internal::CacheSizes
m_l1_norm	lib/Eigen/src/Cholesky/LDLT.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::LDLT
m_l1_norm	lib/Eigen/src/Cholesky/LLT.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::LLT
m_l1_norm	lib/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::FullPivLU
m_l1_norm	lib/Eigen/src/LU/PartialPivLU.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::PartialPivLU
m_l2	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  std::ptrdiff_t m_l2;$/;"	m	struct:Eigen::internal::CacheSizes
m_l3	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  std::ptrdiff_t m_l3;$/;"	m	struct:Eigen::internal::CacheSizes
m_lastError	lib/Eigen/src/SparseLU/SparseLU.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseLU
m_lastError	lib/Eigen/src/SparseQR/SparseQR.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseQR
m_length	lib/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence
m_lexer	lib/json/json.hpp	/^        lexer m_lexer;$/;"	m	class:nlohmann::basic_json::parser
m_lhs	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_lhs	lib/Eigen/src/Core/Product.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::Product
m_lhs	lib/Eigen/src/Core/ProductEvaluators.h	/^  typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_lhs	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_lhs	lib/Eigen/src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_lhs	lib/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_lhs	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  const LhsArg m_lhs;$/;"	m	struct:Eigen::internal::sparse_dense_outer_product_evaluator
m_lhs	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typename Rhs::PlainObject m_lhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_lhsEval	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const LhsEvaluator &m_lhsEval;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_lhsEval	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const evaluator<Lhs> &m_lhsEval;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_lhsImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Lhs> m_lhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_lhsImpl	lib/Eigen/src/Core/ProductEvaluators.h	/^  LhsEtorType m_lhsImpl;$/;"	m	struct:Eigen::internal::product_evaluator
m_lhsImpl	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<Lhs> m_lhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_lhsImpl	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<LhsArg> m_lhsImpl;$/;"	m	struct:Eigen::internal::sparse_conjunction_evaluator
m_lhsIter	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_lhsIter	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_lhsXprImpl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  evaluator<ActualLhs> m_lhsXprImpl;$/;"	m	struct:Eigen::internal::sparse_dense_outer_product_evaluator
m_limit	lib/json/json.hpp	/^        const lexer_char_t* m_limit = nullptr;$/;"	m	class:nlohmann::basic_json::lexer
m_llCurrent	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector
m_llSize	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_llSize;$/;"	m	class:Eigen::internal::AmbiVector
m_llStart	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_llStart;$/;"	m	class:Eigen::internal::AmbiVector
m_low	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_lu	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT
m_lu	lib/Eigen/src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU
m_lu	lib/Eigen/src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU
m_luImpl	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  SparseLUImpl<Scalar, StorageIndex>& m_luImpl;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_mapL	lib/Eigen/src/SparseLU/SparseLU.h	/^  const MappedSupernodalType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixLReturnType
m_mapL	lib/Eigen/src/SparseLU/SparseLU.h	/^  const MatrixLType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType
m_mapU	lib/Eigen/src/SparseLU/SparseLU.h	/^  const MatrixUType& m_mapU;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType
m_marker	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  StorageIndex* m_marker;$/;"	m	struct:Eigen::internal::panel_dfs_traits
m_marker	lib/json/json.hpp	/^        const lexer_char_t* m_marker = nullptr;$/;"	m	class:nlohmann::basic_json::lexer
m_mat	lib/Eigen/src/SparseLU/SparseLU.h	/^    NCMatrix m_mat; \/\/ The input (permuted ) matrix $/;"	m	class:Eigen::SparseLU
m_matImpl	lib/Eigen/src/Core/ProductEvaluators.h	/^  evaluator<MatrixType>   m_matImpl;$/;"	m	struct:Eigen::internal::diagonal_product_evaluator_base
m_matT	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matT	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver
m_matT	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur
m_matU	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matU	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur
m_matUisUptodate	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur
m_matUisUptodate	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur
m_matX	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver
m_matrix	lib/Eigen/src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT
m_matrix	lib/Eigen/src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT
m_matrix	lib/Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::CwiseUnaryView
m_matrix	lib/Eigen/src/Core/Diagonal.h	/^    typename internal::ref_selector<MatrixType>::non_const_type m_matrix;$/;"	m	class:Eigen::Diagonal
m_matrix	lib/Eigen/src/Core/IO.h	/^    typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat
m_matrix	lib/Eigen/src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate
m_matrix	lib/Eigen/src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse
m_matrix	lib/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView
m_matrix	lib/Eigen/src/Core/Transpose.h	/^    typename internal::ref_selector<MatrixType>::non_const_type m_matrix;$/;"	m	class:Eigen::Transpose
m_matrix	lib/Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView
m_matrix	lib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp
m_matrix	lib/Eigen/src/Core/VectorwiseOp.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr
m_matrix	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition
m_matrix	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization
m_matrix	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
m_matrix	lib/Eigen/src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous
m_matrix	lib/Eigen/src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform
m_matrix	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ActualMatrixType m_matrix;$/;"	m	class:Eigen::internal::generic_matrix_wrapper
m_matrix	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl
m_matrix	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_matrix	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typename internal::ref_selector<SparseMatrixType>::non_const_type m_matrix;$/;"	m	class:Eigen::internal::sparse_matrix_block_impl
m_matrix	lib/Eigen/src/SparseCore/SparseBlock.h	/^    typename internal::ref_selector<XprType>::non_const_type m_matrix;$/;"	m	class:Eigen::BlockImpl
m_matrix	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  const Derived *m_matrix;$/;"	m	struct:Eigen::internal::evaluator
m_matrix	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView
m_matrix	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_matrix	lib/Eigen/src/SparseCore/SparseVector.h	/^  const SparseVectorType *m_matrix;$/;"	m	struct:Eigen::internal::evaluator
m_matrix	lib/Eigen/src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView
m_matrix	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const MappedSuperNodalMatrix& m_matrix; \/\/ Supernodal lower triangular matrix $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_matrix	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase
m_matrixU	lib/Eigen/src/SVD/SVDBase.h	/^  MatrixUType m_matrixU;$/;"	m	class:Eigen::SVDBase
m_matrixV	lib/Eigen/src/SVD/SVDBase.h	/^  MatrixVType m_matrixV;$/;"	m	class:Eigen::SVDBase
m_matrixWrapper	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  MatrixWrapper m_matrixWrapper;$/;"	m	class:Eigen::IterativeSolverBase
m_max	lib/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_maxIterations	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_maxIterations	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase
m_maxIterationsPerRow	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterationsPerRow = 30;$/;"	m	class:Eigen::ComplexSchur
m_maxIterationsPerRow	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterationsPerRow = 40;$/;"	m	class:Eigen::RealSchur
m_maxIters	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::ComplexSchur
m_maxIters	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      Index m_maxIters;$/;"	m	class:Eigen::RealQZ
m_maxIters	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::RealSchur
m_maxpivot	lib/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_maxpivot	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_maxpivot	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_mc	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_mc;$/;"	m	class:Eigen::internal::level3_blocking
m_min	lib/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_mode	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_mode;$/;"	m	class:Eigen::internal::AmbiVector
m_msglvl	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    StorageIndex m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_multiplier	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_multiplier;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_nRec	lib/Eigen/src/SVD/BDCSVD.h	/^  Index m_nRec;$/;"	m	class:Eigen::BDCSVD
m_naiveU	lib/Eigen/src/SVD/BDCSVD.h	/^  MatrixXr m_naiveU, m_naiveV;$/;"	m	class:Eigen::BDCSVD
m_naiveV	lib/Eigen/src/SVD/BDCSVD.h	/^  MatrixXr m_naiveU, m_naiveV;$/;"	m	class:Eigen::BDCSVD
m_nc	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_nc;$/;"	m	class:Eigen::internal::level3_blocking
m_nnzL	lib/Eigen/src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU
m_nnzU	lib/Eigen/src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU
m_nonZerosPerCol	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorI m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_nonzeroSingularValues	lib/Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_nonzero_pivots	lib/Eigen/src/LU/FullPivLU.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU
m_nonzero_pivots	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR
m_nonzero_pivots	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR
m_nonzeropivots	lib/Eigen/src/SparseQR/SparseQR.h	/^    Index m_nonzeropivots;          \/\/ Number of non zero pivots found$/;"	m	class:Eigen::SparseQR
m_normOfS	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ
m_normOfT	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ
m_nsuper	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_nsuper; \/\/ Number of supernodes$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_numIters	lib/Eigen/src/SVD/BDCSVD.h	/^  int m_numIters;$/;"	m	class:Eigen::BDCSVD
m_numeric	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU
m_nzval	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* m_nzval; \/\/array of nonzero values packed by column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_nzval_colptr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_nzval_colptr; \/\/nzval_colptr[j] Stores the location in nzval[] which starts column j$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_object	lib/Eigen/src/Core/Ref.h	/^    TPlainObjectType m_object;$/;"	m	class:Eigen::Ref
m_object	lib/json/json.hpp	/^            : m_object(object)$/;"	f	class:nlohmann::basic_json::iter_impl
m_object	lib/json/json.hpp	/^        pointer m_object = nullptr;$/;"	m	class:nlohmann::basic_json::iter_impl
m_object_bytes	lib/Eigen/src/SparseCore/SparseRef.h	/^    char m_object_bytes[sizeof(TPlainObjectType)];$/;"	m	class:Eigen::Ref
m_ordering	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_ordering; \/\/ Ordering method to use, see SPQR's manual$/;"	m	class:Eigen::SPQR
m_origin	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_originalMatrix	lib/Eigen/src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base
m_other	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op
m_other	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const Derived& m_other; $/;"	m	struct:Eigen::SPQR_QProduct
m_other	lib/Eigen/src/SparseQR/SparseQR.h	/^  const Derived& m_other;$/;"	m	struct:Eigen::SparseQR_QProduct
m_outer	lib/Eigen/src/Core/CoreIterators.h	/^  const Index m_outer;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_outer	lib/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride
m_outer	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const OuterType m_outer;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_outer	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const OuterType m_outer;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_outer	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_outer	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
m_outer	lib/Eigen/src/SparseCore/SparseView.h	/^        const Index m_outer;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_outer	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_outer;                    \/\/ Current column $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_outerIndex	lib/Eigen/src/SparseCore/SparseMap.h	/^    IndexPointer  m_outerIndex;$/;"	m	class:Eigen::SparseMapBase
m_outerIndex	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    StorageIndex* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix
m_outerPos	lib/Eigen/src/SparseCore/SparseBlock.h	/^  Index m_outerPos;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_outerSize	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, OuterSize> m_outerSize;$/;"	m	class:Eigen::BlockImpl
m_outerSize	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, OuterSize> m_outerSize;$/;"	m	class:Eigen::internal::sparse_matrix_block_impl
m_outerSize	lib/Eigen/src/SparseCore/SparseMap.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::SparseMapBase
m_outerSize	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix
m_outerStart	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::BlockImpl
m_outerStart	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::internal::sparse_matrix_block_impl
m_outerStride	lib/Eigen/src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_outerStride	lib/Eigen/src/Core/CoreEvaluators.h	/^                                                    : RowsAtCompileTime> m_outerStride;$/;"	m	struct:Eigen::internal::evaluator
m_outerStride	lib/Eigen/src/Core/CoreEvaluators.h	/^  const internal::variable_if_dynamic<Index, XprType::OuterStrideAtCompileTime> m_outerStride;$/;"	m	struct:Eigen::internal::mapbase_evaluator
m_outputPerm_c	lib/Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_outputPerm_c; \/\/ The final column permutation$/;"	m	class:Eigen::SparseQR
m_p	lib/Eigen/src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU
m_p	lib/Eigen/src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU
m_p	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase
m_p	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU
m_parent	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorI m_parent;                                 \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase
m_pastixdata	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase
m_perfv	lib/Eigen/src/SparseLU/SparseLU.h	/^    internal::perfvalues m_perfv;$/;"	m	class:Eigen::SparseLU
m_perm	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    PermutationType m_perm; $/;"	m	class:Eigen::IncompleteCholesky
m_perm	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<StorageIndex,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase
m_perm	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl
m_perm	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_perm_c	lib/Eigen/src/SparseLU/SparseLU.h	/^    PermutationType m_perm_c; \/\/ Column permutation $/;"	m	class:Eigen::SparseLU
m_perm_c	lib/Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_perm_c;       \/\/ Fill-reducing  Column  permutation$/;"	m	class:Eigen::SparseQR
m_perm_r	lib/Eigen/src/SparseLU/SparseLU.h	/^    PermutationType m_perm_r ; \/\/ Row permutation$/;"	m	class:Eigen::SparseLU
m_pivotperm	lib/Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_pivotperm;    \/\/ The permutation for rank revealing$/;"	m	class:Eigen::SparseQR
m_pmat	lib/Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_pmat;            \/\/ Temporary matrix$/;"	m	class:Eigen::SparseQR
m_precision	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR
m_preconditioner	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase
m_prescribedThreshold	lib/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_prescribedThreshold	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_prescribedThreshold	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_prescribedThreshold	lib/Eigen/src/SVD/SVDBase.h	/^  RealScalar m_prescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_pt	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl
m_ptr	lib/Eigen/src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_ptr	lib/Eigen/src/Core/util/Memory.h	/^  T* m_ptr;$/;"	m	class:Eigen::internal::scoped_array
m_q	lib/Eigen/src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU
m_q	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase
m_q	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU
m_qr	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR
m_qr	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR
m_qr	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_qr	lib/Eigen/src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR
m_qr	lib/Eigen/src/SVD/JacobiSVD.h	/^  QRType m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	lib/Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQReturnType
m_qr	lib/Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQTransposeReturnType
m_qr	lib/Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQR_QProduct
m_qr_precond_morecols	lib/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD
m_qr_precond_morerows	lib/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD
m_rank	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index m_rank; \/\/ The rank of the matrix$/;"	m	class:Eigen::SPQR
m_rank	lib/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_rank	lib/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_realQZ	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    RealQZ<MatrixType> m_realQZ;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_realSchur	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver
m_reference	lib/Eigen/src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView
m_result	lib/Eigen/src/Core/CoreEvaluators.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	lib/Eigen/src/Core/Inverse.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::unary_evaluator
m_result	lib/Eigen/src/Core/ProductEvaluators.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::product_evaluator
m_result	lib/Eigen/src/Core/ReturnByValue.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	lib/Eigen/src/Core/Solve.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	lib/Eigen/src/SparseCore/SparsePermutation.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::product_evaluator
m_result	lib/Eigen/src/SparseCore/SparseProduct.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::unary_evaluator
m_result	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::product_evaluator
m_returnOne	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      bool m_returnOne;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_rhs	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_rhs	lib/Eigen/src/Core/Product.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::Product
m_rhs	lib/Eigen/src/Core/ProductEvaluators.h	/^  typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_rhs	lib/Eigen/src/Core/Solve.h	/^  const RhsType       &m_rhs;$/;"	m	class:Eigen::Solve
m_rhs	lib/Eigen/src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_rhs	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_rhs	lib/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_rhs	lib/Eigen/src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_rhs	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  const RhsType       &m_rhs;$/;"	m	class:Eigen::SolveWithGuess
m_rhs	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typename Lhs::PlainObject m_rhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_rhsEval	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const evaluator<Rhs> &m_rhsEval;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_rhsEval	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const evaluator<RhsArg> &m_rhsEval;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_rhsImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Rhs> m_rhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_rhsImpl	lib/Eigen/src/Core/ProductEvaluators.h	/^  RhsEtorType m_rhsImpl;$/;"	m	struct:Eigen::internal::product_evaluator
m_rhsImpl	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<Rhs> m_rhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_rhsImpl	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<RhsArg> m_rhsImpl;$/;"	m	struct:Eigen::internal::sparse_conjunction_evaluator
m_rhsIter	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_rhsIter	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_rhsXprImpl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  evaluator<ActualRhs> m_rhsXprImpl;$/;"	m	struct:Eigen::internal::sparse_dense_outer_product_evaluator
m_row	lib/Eigen/src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer
m_row	lib/Eigen/src/SparseCore/SparseUtil.h	/^  StorageIndex m_row, m_col;$/;"	m	class:Eigen::Triplet
m_row	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_row; \/\/ Number of rows$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rowFactor	lib/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate
m_rowind	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_rowind; \/\/ Array of compressed row indices of rectangular supernodes$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rowind_colptr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_rowind_colptr; \/\/rowind_colptr[j] stores the location in rowind[] which starts column j$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rows	lib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix
m_rows	lib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_rows	lib/Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ArgType::RowsAtCompileTime> m_rows;$/;"	m	struct:Eigen::internal::unary_evaluator
m_rows	lib/Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ReverseRow ? ArgType::RowsAtCompileTime : 1> m_rows;$/;"	m	struct:Eigen::internal::unary_evaluator
m_rows	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp
m_rows	lib/Eigen/src/Core/DenseStorage.h	/^    Index m_rows;$/;"	m	class:Eigen::DenseStorage
m_rows	lib/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase
m_rows	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    Index m_rows;$/;"	m	class:Eigen::SPQR
m_rows	lib/Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_rowsTranspositions	lib/Eigen/src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_rowsTranspositions	lib/Eigen/src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU
m_rowsTranspositions	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename IntDiagSizeVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_rows_transpositions	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_s	lib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_scale	lib/Eigen/src/Core/ProductEvaluators.h	/^    Scalar m_scale;$/;"	m	struct:Eigen::internal::generic_product_impl::adds
m_scale	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    VectorRx m_scale;            \/\/ The vector for scaling the matrix $/;"	m	class:Eigen::IncompleteCholesky
m_scaledMatrix	lib/Eigen/src/SVD/JacobiSVD.h	/^    MatrixType m_scaledMatrix;$/;"	m	class:Eigen::JacobiSVD
m_schur	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver
m_shift	lib/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence
m_shiftOffset	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    double m_shiftOffset[2];$/;"	m	class:Eigen::CholmodBase
m_shiftOffset	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_shiftScale	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_sign	lib/Eigen/src/Cholesky/LDLT.h	/^    internal::SignMatrix m_sign;$/;"	m	class:Eigen::LDLT
m_singularValues	lib/Eigen/src/SVD/SVDBase.h	/^  SingularValuesType m_singularValues;$/;"	m	class:Eigen::SVDBase
m_size	lib/Eigen/src/Core/util/Memory.h	/^    std::size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_size	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase
m_size	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl
m_size	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_size;$/;"	m	class:Eigen::internal::AmbiVector
m_size	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    Index m_size;$/;"	m	class:Eigen::internal::CompressedStorage
m_size	lib/Eigen/src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector
m_size1	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Index m_size1;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_sizeA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sizeB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sluA	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase
m_sluB	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_sluBerr	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluCscale	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluEqued	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase
m_sluEtree	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase
m_sluFerr	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluL	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluOptions	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase
m_sluRscale	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluStat	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase
m_sluU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluX	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_sparseIter	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    SparseXprIter m_sparseIter;$/;"	m	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
m_sparseXprEval	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  evaluator<SparseXprType> m_sparseXprEval;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_sparseXprImpl	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  evaluator<SparseXprType> m_sparseXprImpl;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_spqr	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr; $/;"	m	struct:Eigen::SPQR_QProduct
m_spqr	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQReturnType
m_spqr	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQTransposeReturnType
m_src	lib/Eigen/src/Core/AssignEvaluator.h	/^  const SrcEvaluatorType& m_src;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_start	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_start;$/;"	m	class:Eigen::internal::AmbiVector
m_start	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_start;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_start	lib/json/json.hpp	/^        const lexer_char_t* m_start = nullptr;$/;"	m	class:nlohmann::basic_json::lexer
m_startCol	lib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, (XprType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_startCol	lib/Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, (ArgType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;$/;"	m	struct:Eigen::internal::unary_evaluator
m_startCol	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::BlockImpl
m_startRow	lib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, (XprType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_startRow	lib/Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, (ArgType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;$/;"	m	struct:Eigen::internal::unary_evaluator
m_startRow	lib/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::BlockImpl
m_startidval	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_startidval;               \/\/ Start of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_staticA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticA	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX char m_staticA[SizeA * sizeof(LhsScalar) + EIGEN_DEFAULT_ALIGN_BYTES-1];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticB	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX char m_staticB[SizeB * sizeof(RhsScalar) + EIGEN_DEFAULT_ALIGN_BYTES-1];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_step	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_storage	lib/Eigen/src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase
m_stream	lib/json/json.hpp	/^        std::istream* m_stream = nullptr;$/;"	m	class:nlohmann::basic_json::lexer
m_stride	lib/Eigen/src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map
m_stride	lib/Eigen/src/Core/Ref.h	/^  StrideBase m_stride;$/;"	m	class:Eigen::RefBase
m_stride	lib/Eigen/src/Core/util/BlasUtil.h	/^  const Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper
m_structureIsUptodate	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU
m_subdiag	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_subs	lib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix
m_subs	lib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_sup_to_col	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_sup_to_col; \/\/sup_to_col[s] points to the starting column of the s-th supernode$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_supers	lib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix
m_supers	lib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_supno	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_supno;                    \/\/ Current SuperNode number$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_sve	lib/Eigen/src/SparseCore/SparseView.h	/^        const unary_evaluator &m_sve;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_symbolic	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU
m_symmetricmode	lib/Eigen/src/SparseLU/SparseLU.h	/^    bool m_symmetricmode;$/;"	m	class:Eigen::SparseLU
m_temp	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition
m_temp	lib/Eigen/src/Geometry/Homogeneous.h	/^  PlainObject m_temp;$/;"	m	struct:Eigen::internal::unary_evaluator
m_temp	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR
m_temp	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  RowVectorType m_temp;$/;"	m	class:Eigen::CompleteOrthogonalDecomposition
m_temp	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR
m_temp	lib/Eigen/src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR
m_temporary	lib/Eigen/src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT
m_then	lib/Eigen/src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select
m_thenImpl	lib/Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ThenMatrixType> m_thenImpl;$/;"	m	struct:Eigen::internal::evaluator
m_threshold	lib/Eigen/src/SparseQR/SparseQR.h	/^    RealScalar m_threshold;         \/\/ Threshold to determine null Householder reflections$/;"	m	class:Eigen::SparseQR
m_tmp	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver
m_tmp	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType m_tmp;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_tolerance	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase
m_tolerance	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    RealScalar m_tolerance; \/\/ treat columns with 2-norm below this tolerance as zero$/;"	m	class:Eigen::SPQR
m_trans	lib/Eigen/src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence
m_transpose	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  bool m_transpose; $/;"	m	struct:Eigen::SPQR_QProduct
m_transpose	lib/Eigen/src/SparseQR/SparseQR.h	/^  bool m_transpose;$/;"	m	struct:Eigen::SparseQR_QProduct
m_transpositions	lib/Eigen/src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT
m_transpositions	lib/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose
m_triangularMatrix	lib/Eigen/src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_type	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    StorageIndex m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_u	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase
m_u	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU
m_unaryOp	lib/Eigen/src/Core/CoreEvaluators.h	/^  const UnaryOp m_unaryOp;$/;"	m	struct:Eigen::internal::unary_evaluator
m_useDefaultThreshold	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SPQR
m_useDefaultThreshold	lib/Eigen/src/SparseQR/SparseQR.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SparseQR
m_usePrescribedThreshold	lib/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_usePrescribedThreshold	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_usePrescribedThreshold	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_usePrescribedThreshold	lib/Eigen/src/SVD/SVDBase.h	/^  bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_use_divisor	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const bool m_use_divisor;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_val	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  T m_val;$/;"	m	struct:Eigen::internal::eigen_packet_wrapper
m_value	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  first_argument_type m_value;$/;"	m	struct:Eigen::internal::bind1st_op
m_value	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  second_argument_type m_value;$/;"	m	struct:Eigen::internal::bind2nd_op
m_value	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_value	lib/Eigen/src/SparseCore/SparseMatrix.h	/^        StorageIndex m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_value	lib/Eigen/src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet
m_value	lib/json/json.hpp	/^        : m_type(value_t::boolean), m_value(val)$/;"	f	class:nlohmann::basic_json
m_value	lib/json/json.hpp	/^        : m_type(value_t::number_float), m_value(val)$/;"	f	class:nlohmann::basic_json
m_value	lib/json/json.hpp	/^        : m_type(value_t::number_integer), m_value(val)$/;"	f	class:nlohmann::basic_json
m_value	lib/json/json.hpp	/^        : m_type(value_t::number_unsigned), m_value(val)$/;"	f	class:nlohmann::basic_json
m_value	lib/json/json.hpp	/^    json_value m_value = {};$/;"	m	class:nlohmann::basic_json
m_values	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage
m_values	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_values	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_values	lib/Eigen/src/SparseCore/SparseMap.h	/^    ScalarPointer m_values;$/;"	m	class:Eigen::SparseMapBase
m_valuesOkay	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_valuesOkay, m_vectorsOkay;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_vector	lib/Eigen/src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_vectors	lib/Eigen/src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence
m_vectorsOkay	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_valuesOkay, m_vectorsOkay;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_view	lib/Eigen/src/SparseCore/SparseView.h	/^        const XprType &m_view;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_view	lib/Eigen/src/SparseCore/SparseView.h	/^    const XprType &m_view;$/;"	m	struct:Eigen::internal::unary_evaluator
m_workspace	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      Matrix<Scalar,Dynamic,1> m_workspace;$/;"	m	class:Eigen::RealQZ
m_workspace	lib/Eigen/src/SVD/BDCSVD.h	/^  ArrayXr m_workspace;$/;"	m	class:Eigen::BDCSVD
m_workspace	lib/Eigen/src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	lib/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	lib/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspaceI	lib/Eigen/src/SVD/BDCSVD.h	/^  ArrayXi m_workspaceI;$/;"	m	class:Eigen::BDCSVD
m_workspaceVector	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur
m_wrapper	lib/Eigen/src/Core/CoreEvaluators.h	/^  const internal::nullary_wrapper<CoeffReturnType,NullaryOp> m_wrapper;$/;"	m	struct:Eigen::internal::evaluator
m_xpr	lib/Eigen/src/Core/Block.h	/^    XprTypeNested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_xpr	lib/Eigen/src/Core/CommaInitializer.h	/^  XprType& m_xpr;           \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer
m_xpr	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    XprTypeNested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp
m_xpr	lib/Eigen/src/Core/Inverse.h	/^  XprTypeNested m_xpr;$/;"	m	class:Eigen::Inverse
m_xpr	lib/Eigen/src/Core/Redux.h	/^  const XprType &m_xpr;$/;"	m	class:Eigen::internal::redux_evaluator
m_xpr	lib/Eigen/src/Core/Visitor.h	/^  const XprType &m_xpr;$/;"	m	class:Eigen::internal::visitor_evaluator
m_zCoeffs	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  HCoeffsType m_zCoeffs;$/;"	m	class:Eigen::CompleteOrthogonalDecomposition
m_zero	lib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector
m_zero	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  const Scalar m_zero;$/;"	m	struct:Eigen::internal::evaluator
m_zero_nnz	lib/Eigen/src/SparseCore/SparseMap.h	/^    Array<StorageIndex,2,1>  m_zero_nnz;$/;"	m	class:Eigen::SparseMapBase
mac	lib/lattice/Lattice_arith.h	/^    void mac(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
mac	lib/lattice/Lattice_arith.h	/^    void mac(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const obj3 &rhs){$/;"	f	namespace:Grid
mac	lib/lattice/Lattice_arith.h	/^    void mac(Lattice<obj1> &ret,const obj2 &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
mac	lib/simd/Grid_avx.h	/^    inline void mac(__m256 &a, __m256 b, __m256 c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_avx.h	/^    inline void mac(__m256d &a, __m256d b, __m256d c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_avx512.h	/^    inline void mac(__m512 &a, __m512 b, __m512 c){         $/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_avx512.h	/^    inline void mac(__m512d &a, __m512d b, __m512d c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_imci.h	/^    inline void mac(__m512 &a, __m512 b, __m512 c){         $/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_imci.h	/^    inline void mac(__m512d &a, __m512d b, __m512d c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_neon.h	/^    inline float32x4_t mac(float32x4_t a, float32x4_t b, float32x4_t c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_neon.h	/^    inline float64x2_t mac(float64x2_t a, float64x2_t b, float64x2_t c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_sse4.h	/^    inline void mac(__m128 &a, __m128 b, __m128 c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_sse4.h	/^    inline void mac(__m128d &a, __m128d b, __m128d c){$/;"	f	struct:Grid::Optimization::Mult
mac	lib/simd/Grid_vector_types.h	/^  friend inline void mac(Grid_simd *__restrict__ y,$/;"	f	class:Grid::Grid_simd
mac	lib/simd/Simd.h	/^  inline void mac (ComplexD * __restrict__ y,const ComplexD * __restrict__ a,const ComplexD *__restrict__ x){ *y = (*a) * (*x)+(*y); };$/;"	f	namespace:Grid
mac	lib/simd/Simd.h	/^  inline void mac (ComplexF * __restrict__ y,const ComplexF * __restrict__ a,const ComplexF *__restrict__ x){ *y = (*a) * (*x)+(*y); }$/;"	f	namespace:Grid
mac	lib/simd/Simd.h	/^  inline void mac (RealD * __restrict__ y,const RealD * __restrict__ a,const RealD *__restrict__ x){  *y = (*a) * (*x)+(*y);}$/;"	f	namespace:Grid
mac	lib/simd/Simd.h	/^  inline void mac (RealF * __restrict__ y,const RealF * __restrict__ a,const RealF *__restrict__ x){  *y = (*a) * (*x)+(*y); }$/;"	f	namespace:Grid
mac	lib/tensors/Tensor_arith_mac.h	/^strong_inline  void mac(iScalar<rtype> * __restrict__ ret,const iScalar<vtype> * __restrict__ lhs,const iScalar<mtype> * __restrict__ rhs)$/;"	f	namespace:Grid
mac	lib/tensors/Tensor_arith_mac.h	/^strong_inline void mac(iMatrix<rrtype,N> * __restrict__ ret,const iMatrix<ltype,N> * __restrict__ lhs,const iMatrix<rtype,N> * __restrict__ rhs){$/;"	f	namespace:Grid
mac	lib/tensors/Tensor_arith_mac.h	/^strong_inline void mac(iMatrix<rrtype,N> * __restrict__ ret,const iMatrix<ltype,N> * __restrict__ lhs,const iScalar<rtype> * __restrict__ rhs){$/;"	f	namespace:Grid
mac	lib/tensors/Tensor_arith_mac.h	/^strong_inline void mac(iMatrix<rrtype,N> * __restrict__ ret,const iScalar<ltype> * __restrict__ lhs,const iMatrix<rtype,N> * __restrict__ rhs){$/;"	f	namespace:Grid
mac	lib/tensors/Tensor_arith_mac.h	/^strong_inline void mac(iVector<rrtype,N> * __restrict__ ret,const iMatrix<ltype,N> * __restrict__ lhs,const iVector<rtype,N> * __restrict__ rhs)$/;"	f	namespace:Grid
mac	lib/tensors/Tensor_arith_mac.h	/^strong_inline void mac(iVector<rrtype,N> * __restrict__ ret,const iScalar<ltype> * __restrict__ lhs,const iVector<rtype,N> * __restrict__ rhs)$/;"	f	namespace:Grid
mac	lib/tensors/Tensor_arith_mac.h	/^strong_inline void mac(iVector<rrtype,N> * __restrict__ ret,const iVector<ltype,N> * __restrict__ lhs,const iScalar<rtype> * __restrict__ rhs)$/;"	f	namespace:Grid
madd	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacketType& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacketType& a, const RhsPacketType& b, AccPacketType& c, AccPacketType& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits
main	benchmarks/Benchmark_comms.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_dwf.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_dwf_sweep.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_memory_asynch.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_memory_bandwidth.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_mooee.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_staggered.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_su3.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_wilson.cc	/^int main (int argc, char ** argv)$/;"	f
main	benchmarks/Benchmark_wilson_sweep.cc	/^int main (int argc, char ** argv)$/;"	f
main	config.guess	/^		main()$/;"	f
main	config.guess	/^	main ()$/;"	f
main	config.guess	/^main ()$/;"	f
main	extras/Hadrons/HadronsXmlRun.cc	/^int main(int argc, char *argv[])$/;"	f
main	extras/Hadrons/HadronsXmlSchedule.cc	/^int main(int argc, char *argv[])$/;"	f
main	extras/qed-fvol/qed-fvol.cc	/^int main(int argc, char *argv[])$/;"	f
main	gcc-bug-report/broken.cc	/^int main(int argc,char **argv)$/;"	f
main	lib/Hadrons/HadronsXmlRun.cc	/^int main(int argc, char *argv[])$/;"	f
main	lib/Hadrons/HadronsXmlSchedule.cc	/^int main(int argc, char *argv[])$/;"	f
main	lib/algorithms/approx/Zolotarev.cc	/^int main(int argc, char** argv) {$/;"	f
main	tests/IO/Test_ildg_io.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/IO/Test_ildg_read.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/IO/Test_nersc_io.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/IO/Test_nersc_read.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/IO/Test_serialisation.cc	/^int main(int argc,char **argv)$/;"	f
main	tests/Test_cayley_even_odd_vec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/Test_cshift.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/Test_dwf_mixedcg_prec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/Test_dwf_mixedcg_prec_halfcomms.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/Test_simd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/Test_stencil.cc	/^int main(int argc, char ** argv) {$/;"	f
main	tests/core/Test_GaugeAction.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_RectPlaq.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_cf_coarsen_support.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_checker.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_contfrac_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_cshift_red_black.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_cshift_red_black_rotate.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_cshift_rotate.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_dwf_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_dwf_rb5d.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_fft.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_fft_gfix.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_fftf.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_gamma.cc	/^int main(int argc, char *argv[])$/;"	f
main	tests/core/Test_gparity.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_gpwilson_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_lie_generators.cc	/^int main(int argc, char** argv) {$/;"	f
main	tests/core/Test_main.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/core/Test_mobius_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_poisson_fft.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_quenched_update.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_rng.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_rng_fixed.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_staggered.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_staggered5D.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_staggered5Dvec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_wilson_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_wilson_twisted_mass_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/core/Test_zmobius_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/debug/Test_cayley_cg.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/debug/Test_cayley_coarsen_support.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/debug/Test_cayley_even_odd.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/debug/Test_cayley_ldop_cr.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/debug/Test_cheby.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/debug/Test_synthetic_lanczos.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/debug/Test_zmm.cc	/^int main(int argc, char **argv)$/;"	f
main	tests/debug/Test_zmm.cc	/^int main(int argc,char **argv)$/;"	f
main	tests/debug/test_Grid_jacobi.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_contfrac_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_dwf_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_dwf_gpforce.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_gp_rect_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_gpdwf_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_gpwilson_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_laplacian_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_mobius_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_partfrac_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_rect_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_wilson_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/forces/Test_zmobius_force.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/hadrons/Test_hadrons_meson_3pt.cc	/^int main(int argc, char *argv[])$/;"	f
main	tests/hadrons/Test_hadrons_spectrum.cc	/^int main(int argc, char *argv[])$/;"	f
main	tests/hmc/Test_hmc_DBW2_Implicit.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_EODWFRatio.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_EODWFRatioLsVectorised.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_EODWFRatio_Gparity.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_EOMobiusRatio.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_EOMobiusRatioManyFlavour.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_EOWilsonFermionGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_EOWilsonRatio.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_Factories.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_GparityIwasakiGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_GparityWilsonGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_IwasakiGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_RectGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_ScalarAction.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_ScalarActionNxN.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonAdjointFermionGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonFermionGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonGauge_Implicit.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonMixedRepresentationsFermionGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonRatio.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonTMFermionGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_hmc_WilsonTwoIndexSymmetricFermionGauge.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_multishift_sqrt.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/hmc/Test_remez.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/hmc/Test_rhmc_EOWilson1p1.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_rhmc_EOWilsonRatio.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_rhmc_Wilson1p1.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/hmc/Test_rhmc_WilsonRatio.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/qdpxx/Test_qdpxx_loops_staples.cc	/^int main (int argc,char **argv )$/;"	f
main	tests/qdpxx/Test_qdpxx_munprec.cc	/^int main (int argc,char **argv )$/;"	f
main	tests/qdpxx/Test_qdpxx_stag.cc	/^int main (int argc,char **argv )$/;"	f
main	tests/smearing/Test_WilsonFlow.cc	/^int main(int argc, char **argv) {$/;"	f
main	tests/solver/Test_cf_cr_unprec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_contfrac_cg.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_dwf_cg_prec.cc	/^int main(int argc, char** argv) {$/;"	f
main	tests/solver/Test_dwf_cg_prec_LsVec.cc	/^int main(int argc, char** argv) {$/;"	f
main	tests/solver/Test_dwf_cg_schur.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_dwf_cg_unprec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_dwf_cr_unprec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_dwf_fpgcr.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_dwf_hdcr.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_dwf_lanczos.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_laplacian.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_staggered_block_cg_unprec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_staggered_cg_unprec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_wilson_cg_prec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_wilson_cg_schur.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_wilson_cg_unprec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_wilson_cr_unprec.cc	/^int main (int argc, char ** argv)$/;"	f
main	tests/solver/Test_wilson_lanczos.cc	/^int main(int argc, char** argv) {$/;"	f
main	tests/solver/Test_zmobius_cg_prec.cc	/^int main(int argc, char** argv) {$/;"	f
main	tests/testu01/Test_smallcrush.cc	/^int main (int argc, char ** argv)$/;"	f
makeAffine	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC void makeAffine()$/;"	f	class:Eigen::Transform
makeCompressed	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix
makeDependencyMatrix	extras/Hadrons/Graph.hpp	/^makeDependencyMatrix(const std::vector<std::vector<T>> &topSort)$/;"	f
makeDependencyMatrix	lib/Hadrons/Graph.hpp	/^makeDependencyMatrix(const std::vector<std::vector<T>> &topSort)$/;"	f
makeFiveDimDWFGrid	lib/qcd/utils/SpaceTimeGrid.cc	/^GridCartesian         *SpaceTimeGrid::makeFiveDimDWFGrid(int Ls,const GridCartesian *FourDimGrid)$/;"	f	class:Grid::QCD::SpaceTimeGrid
makeFiveDimDWFRedBlackGrid	lib/qcd/utils/SpaceTimeGrid.cc	/^GridRedBlackCartesian *SpaceTimeGrid::makeFiveDimDWFRedBlackGrid(int Ls,const GridCartesian *FourDimGrid)$/;"	f	class:Grid::QCD::SpaceTimeGrid
makeFiveDimGrid	lib/qcd/utils/SpaceTimeGrid.cc	/^GridCartesian         *SpaceTimeGrid::makeFiveDimGrid(int Ls,const GridCartesian *FourDimGrid)$/;"	f	class:Grid::QCD::SpaceTimeGrid
makeFiveDimRedBlackGrid	lib/qcd/utils/SpaceTimeGrid.cc	/^GridRedBlackCartesian *SpaceTimeGrid::makeFiveDimRedBlackGrid(int Ls,const GridCartesian *FourDimGrid)$/;"	f	class:Grid::QCD::SpaceTimeGrid
makeFourDimDWFGrid	lib/qcd/utils/SpaceTimeGrid.cc	/^GridCartesian *SpaceTimeGrid::makeFourDimDWFGrid(const std::vector<int> & latt,const std::vector<int> &mpi)$/;"	f	class:Grid::QCD::SpaceTimeGrid
makeFourDimGrid	lib/qcd/utils/SpaceTimeGrid.cc	/^GridCartesian *SpaceTimeGrid::makeFourDimGrid(const std::vector<int> & latt,const std::vector<int> &simd,const std::vector<int> &mpi)$/;"	f	class:Grid::QCD::SpaceTimeGrid
makeFourDimRedBlackGrid	lib/qcd/utils/SpaceTimeGrid.cc	/^GridRedBlackCartesian *SpaceTimeGrid::makeFourDimRedBlackGrid(const GridCartesian *FourDimGrid)$/;"	f	class:Grid::QCD::SpaceTimeGrid
makeGivens	lib/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation
makeGivens	lib/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation
makeGivens	lib/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)$/;"	f	class:Eigen::JacobiRotation
makeHouseholder	lib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase
makeHouseholderInPlace	lib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase
makeJacobi	lib/Eigen/src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)$/;"	f	class:Eigen::JacobiRotation
makeJacobi	lib/Eigen/src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, Index p, Index q)$/;"	f	class:Eigen::JacobiRotation
makeModuleGraph	extras/Hadrons/Environment.cc	/^Graph<unsigned int> Environment::makeModuleGraph(void) const$/;"	f	class:Environment
makeModuleGraph	lib/Hadrons/Environment.cc	/^Graph<unsigned int> Environment::makeModuleGraph(void) const$/;"	f	class:Environment
makeSubSliceGrid	lib/lattice/Lattice_reduction.h	/^inline GridBase         *makeSubSliceGrid(const GridBase *BlockSolverGrid,int Orthog)$/;"	f	namespace:Grid
make_block_householder_triangular_factor	lib/Eigen/src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal
make_dummy_depfile	depcomp	/^make_dummy_depfile ()$/;"	f
make_gauge	tests/qdpxx/Test_qdpxx_stag.cc	/^void make_gauge(GaugeField & Umu,FermionField &src)$/;"	f
make_parse_result	lib/pugixml/pugixml.cc	/^	inline xml_parse_result make_parse_result(xml_parse_status status, ptrdiff_t offset = 0)$/;"	f
make_psync_init	lib/communicator/Communicator_shmem.cc	/^std::array<long,_SHMEM_REDUCE_SYNC_SIZE> make_psync_init(void) {$/;"	f	namespace:Grid
manageErrorCode	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error) const$/;"	f	class:Eigen::PardisoImpl
manage_caching_sizes	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1, std::ptrdiff_t* l2, std::ptrdiff_t* l3)$/;"	f	namespace:Eigen::internal
manage_caching_sizes_helper	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal
manage_multi_threading	lib/Eigen/src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal
map_superlu	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal
mapbase_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit mapbase_evaluator(const XprType& map)$/;"	f	struct:Eigen::internal::mapbase_evaluator
mapbase_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct mapbase_evaluator : evaluator_base<Derived>$/;"	s	namespace:Eigen::internal
mark	extras/Hadrons/Graph.hpp	/^void Graph<T>::mark(const T &value, const bool doMark)$/;"	f	class:Graph
mark	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType mark ;  \/* for computing set differences and marking dead rows*\/$/;"	m	union:internal::Colamd_Row::__anon628
mark	lib/Hadrons/Graph.hpp	/^void Graph<T>::mark(const T &value, const bool doMark)$/;"	f	class:Graph
markAll	extras/Hadrons/Graph.hpp	/^void Graph<T>::markAll(const bool doMark)$/;"	f	class:Graph
markAll	lib/Hadrons/Graph.hpp	/^void Graph<T>::markAll(const bool doMark)$/;"	f	class:Graph
markAsRValue	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
mass	lib/qcd/action/fermion/CayleyFermion5D.h	/^      RealD mass;$/;"	m	class:Grid::QCD::CayleyFermion5D
mass	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      RealD mass;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
mass	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  RealD mass;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
mass	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    RealD mass;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
mass	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      RealD mass;$/;"	m	class:Grid::QCD::PartialFractionFermion5D
mass	lib/qcd/action/fermion/WilsonFermion.h	/^  RealD mass;$/;"	m	class:Grid::QCD::WilsonFermion
mass_square	lib/qcd/action/scalar/ScalarAction.h	/^    RealD mass_square;$/;"	m	class:Grid::ScalarAction
mass_square	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    RealD mass_square;$/;"	m	class:Grid::ScalarInteractionAction
matPrefix	lib/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
matSuffix	lib/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
match	lib/Eigen/src/Core/Ref.h	/^  template<typename Derived> struct match {$/;"	s	struct:Eigen::internal::traits
match	lib/Eigen/src/SparseCore/SparseRef.h	/^  template<typename Derived> struct match {$/;"	s	struct:Eigen::internal::traits
matchGridTensorIndex	lib/tensors/Tensor_traits.h	/^  template<typename T,int Level> struct matchGridTensorIndex {$/;"	s	namespace:Grid
matrix	lib/Eigen/src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return MatrixWrapper<Derived>(derived()); }$/;"	f	class:Eigen::ArrayBase
matrix	lib/Eigen/src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return MatrixWrapper<const Derived>(derived()); }$/;"	f	class:Eigen::ArrayBase
matrix	lib/Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	lib/Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
matrix	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const ActualMatrixType& matrix() const$/;"	f	class:Eigen::IterativeSolverBase
matrix	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const ActualMatrixType& matrix() const$/;"	f	class:Eigen::internal::generic_matrix_wrapper
matrix	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const NestedExpression& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
matrix	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView
matrix	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typename internal::remove_reference<MatrixTypeNested>::type& matrix() { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView
matrixH	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixL	lib/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT
matrixL	lib/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT
matrixL	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    const FactorType& matrixL() const { eigen_assert("m_factorizationIsOk"); return m_L; }$/;"	f	class:Eigen::IncompleteCholesky
matrixL	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixL	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT
matrixL	lib/Eigen/src/SparseLU/SparseLU.h	/^    SparseLUMatrixLReturnType<SCMatrix> matrixL() const$/;"	f	class:Eigen::SparseLU
matrixL	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU
matrixL	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU
matrixLDLT	lib/Eigen/src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT
matrixLLT	lib/Eigen/src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT
matrixLU	lib/Eigen/src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU
matrixLU	lib/Eigen/src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU
matrixQ	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixQ	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixQ() const {$/;"	f	class:Eigen::RealQZ
matrixQ	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization
matrixQ	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixQ	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  HouseholderSequenceType matrixQ(void) const { return m_cpqr.householderQ(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrixQ	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQ	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQRMatrixQReturnType<SPQR> matrixQ() const$/;"	f	class:Eigen::SPQR
matrixQ	lib/Eigen/src/SparseQR/SparseQR.h	/^    SparseQRMatrixQReturnType<SparseQR> matrixQ() const $/;"	f	class:Eigen::SparseQR
matrixQR	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixQR	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQR	lib/Eigen/src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR
matrixQTZ	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const MatrixType& matrixQTZ() const { return m_cpqr.matrixQR(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrixR	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixR() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixR	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    const MatrixType matrixR() const$/;"	f	class:Eigen::SPQR
matrixR	lib/Eigen/src/SparseQR/SparseQR.h	/^    const QRMatrixType& matrixR() const { return m_R; }$/;"	f	class:Eigen::SparseQR
matrixS	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixS() const {$/;"	f	class:Eigen::RealQZ
matrixT	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur
matrixT	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixT() const {$/;"	f	class:Eigen::RealQZ
matrixT	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur
matrixT	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization
matrixT	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const MatrixType& matrixT() const { return m_cpqr.matrixQR(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrixU	lib/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT
matrixU	lib/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT
matrixU	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur
matrixU	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur
matrixU	lib/Eigen/src/SVD/SVDBase.h	/^  const MatrixUType& matrixU() const$/;"	f	class:Eigen::SVDBase
matrixU	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixU	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT
matrixU	lib/Eigen/src/SparseLU/SparseLU.h	/^    SparseLUMatrixUReturnType<SCMatrix,MappedSparseMatrix<Scalar,ColMajor,StorageIndex> > matrixU() const$/;"	f	class:Eigen::SparseLU
matrixU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU
matrixU	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU
matrixV	lib/Eigen/src/SVD/SVDBase.h	/^  const MatrixVType& matrixV() const$/;"	f	class:Eigen::SVDBase
matrixZ	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixZ() const {$/;"	f	class:Eigen::RealQZ
matrixZ	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  MatrixType matrixZ() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrix_swap_impl	lib/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
matrix_swap_impl	lib/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
matrix_type_times_scalar_type	lib/Eigen/src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
max	benchmarks/Benchmark_comms.cc	/^  double max;$/;"	m	struct:time_statistics	file:
max	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half (max)(const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
max	lib/Eigen/src/Core/util/Meta.h	/^  static T (max)() { assert(false && "Highest not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static double (max)() { return DBL_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static float (max)() { return CUDART_MAX_NORMAL_F; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static int (max)() { return INT_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static long (max)() { return LONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static long long (max)() { return LLONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned int (max)() { return UINT_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned long (max)() { return ULONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned long long (max)() { return ULLONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^max$/;"	f
max	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    static constexpr result_type (max)() { return 0xFFFFFFFF; }$/;"	f	class:sitmo::prng_engine
max	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    static result_type (max)() { return 0xFFFFFFFF; }$/;"	f	class:sitmo::prng_engine
maxCoeff	lib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase
maxCoeff	lib/Eigen/src/Core/VectorwiseOp.h	/^    const MaxCoeffReturnType maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp
maxCoeff	lib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
maxCoeff	lib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* rowPtr, IndexType* colPtr) const$/;"	f	class:Eigen::DenseBase
maxIterations	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase
maxNameSize	extras/Hadrons/Global.cc	/^constexpr unsigned int maxNameSize = 1024u;$/;"	v
maxNameSize	lib/Hadrons/Global.cc	/^constexpr unsigned int maxNameSize = 1024u;$/;"	v
maxPivot	lib/Eigen/src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU
maxPivot	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR
maxPivot	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline RealScalar maxPivot() const { return m_cpqr.maxPivot(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
maxPivot	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR
max_coeff_visitor	lib/Eigen/src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
max_size	lib/Eigen/src/Core/Matrix.h	/^      max_size = is_dynamic_size_storage ? Dynamic : _MaxRows*_MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon171
max_size	lib/allocator/AlignedAllocator.h	/^    size_type max_size() const throw() { return size_t(-1) \/ sizeof(_Tp); }$/;"	f	class:Grid::alignedAllocator
max_size	lib/allocator/AlignedAllocator.h	/^  size_type  max_size() const throw() { return size_t(-1) \/ sizeof(_Tp); }$/;"	f	class:Grid::commAllocator
maxi	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_ALWAYS_INLINE T maxi(const T& x, const T& y)$/;"	f	namespace:Eigen::numext
maxsuper	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index maxsuper; \/\/ The maximum size for a supernode in complete LU$/;"	m	struct:Eigen::internal::perfvalues
mc	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline Index mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking
mc_rd	lib/perfmon/Stat.h	/^  int mc_rd[NMC];$/;"	m	struct:Grid::knl_gbl_
mc_wr	lib/perfmon/Stat.h	/^  int mc_wr[NMC];$/;"	m	struct:Grid::knl_gbl_
mcrd	lib/perfmon/Stat.h	/^    uint64_t mcrd[NMC];$/;"	m	struct:Grid::ctrs
mcwr	lib/perfmon/Stat.h	/^    uint64_t mcwr[NMC];$/;"	m	struct:Grid::ctrs
mean	benchmarks/Benchmark_comms.cc	/^  double mean;$/;"	m	struct:time_statistics	file:
mean	lib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase
mean	lib/Eigen/src/Core/VectorwiseOp.h	/^    const MeanReturnType mean() const$/;"	f	class:Eigen::VectorwiseOp
measure_interval	lib/qcd/smearing/WilsonFlow.h	/^    unsigned int measure_interval;$/;"	m	class:Grid::QCD::WilsonFlow
median	lib/pugixml/pugixml.cc	/^	template <typename I, typename Pred> void median(I first, I middle, I last, const Pred& pred)$/;"	f
median3	lib/pugixml/pugixml.cc	/^	template <typename I, typename Pred> void median3(I first, I middle, I last, const Pred& pred)$/;"	f
memInit	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,StorageIndex>::memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size,  GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
memPeak_	extras/Hadrons/Application.hpp	/^    Environment::Size         memPeak_;$/;"	m	class:Application
memPeak_	lib/Hadrons/Application.hpp	/^    Environment::Size         memPeak_;$/;"	m	class:Application
memXpand	lib/Eigen/src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,StorageIndex>::memXpand(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)$/;"	f	class:Eigen::internal::SparseLUImpl
mem_expand	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  void mem_expand(IndexVector& lsub, Index& nextl, Index chmark)$/;"	f	struct:Eigen::internal::column_dfs_traits
mem_expand	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  void mem_expand(IndexVector& \/*glu.lsub*\/, Index \/*nextl*\/, Index \/*chmark*\/) {}$/;"	f	struct:Eigen::internal::panel_dfs_traits
member_lpnorm	lib/Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC member_lpnorm() {}$/;"	f	struct:Eigen::internal::member_lpnorm
member_lpnorm	lib/Eigen/src/Core/VectorwiseOp.h	/^struct member_lpnorm {$/;"	s	namespace:Eigen::internal
member_redux	lib/Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC explicit member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux
member_redux	lib/Eigen/src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
merge	lib/tensors/Tensor_extract_merge.h	/^inline void merge(typename std::enable_if<!isGridTensor<vsimd>::value, vsimd >::type  &y,std::vector<scalar> &extracted){$/;"	f	namespace:Grid
merge	lib/tensors/Tensor_extract_merge.h	/^inline void merge(typename std::enable_if<!isGridTensor<vsimd>::value, vsimd >::type * y, $/;"	f	namespace:Grid
merge	lib/tensors/Tensor_extract_merge.h	/^void merge(vobj &vec,std::vector<typename vobj::scalar_object *> &extracted,int offset)$/;"	f	namespace:Grid
merge	lib/tensors/Tensor_extract_merge.h	/^void merge(vobj &vec,std::vector<typename vobj::scalar_object> &extracted)$/;"	f	namespace:Grid
merge1	lib/tensors/Tensor_extract_merge.h	/^template<class vobj> inline void merge1(vobj &vec,std::vector<typename vobj::scalar_object *> &extracted,int offset)$/;"	f	namespace:Grid
merge2	lib/tensors/Tensor_extract_merge.h	/^template<class vobj> inline void merge2(vobj &vec,std::vector<typename vobj::scalar_object *> &extracted,int offset)$/;"	f	namespace:Grid
merged	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
mergetime	lib/stencil/Stencil.h	/^  double mergetime;$/;"	m	class:Grid::CartesianStencil
mesonConnected	extras/Hadrons/Modules/MContraction/Meson.hpp	159;"	d
mesonConnected	lib/Hadrons/Modules/MContraction/Meson.hpp	159;"	d
meta_floor_log2	lib/Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2 {};$/;"	s	namespace:Eigen::internal
meta_floor_log2	lib/Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_bogus>$/;"	s	namespace:Eigen::internal
meta_floor_log2	lib/Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_down>$/;"	s	namespace:Eigen::internal
meta_floor_log2	lib/Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_up>$/;"	s	namespace:Eigen::internal
meta_floor_log2	lib/Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_terminate>$/;"	s	namespace:Eigen::internal
meta_floor_log2_bogus	lib/Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon251
meta_floor_log2_move_down	lib/Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon251
meta_floor_log2_move_up	lib/Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon251
meta_floor_log2_selector	lib/Eigen/src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct meta_floor_log2_selector$/;"	s	namespace:Eigen::internal
meta_floor_log2_terminate	lib/Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon251
meta_least_common_multiple	lib/Eigen/src/Core/util/Meta.h	/^struct meta_least_common_multiple$/;"	s	namespace:Eigen
meta_least_common_multiple	lib/Eigen/src/Core/util/Meta.h	/^struct meta_least_common_multiple<A,B,K,true>$/;"	s	namespace:Eigen
meta_no	lib/Eigen/src/Core/util/Meta.h	/^struct meta_no  { char a[2]; };$/;"	s	namespace:Eigen::internal
meta_sqrt	lib/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
meta_yes	lib/Eigen/src/Core/util/Meta.h	/^struct meta_yes { char a[1]; };$/;"	s	namespace:Eigen::internal
metropolis_test	lib/qcd/hmc/HMC.h	/^  bool metropolis_test(const RealD DeltaH) {$/;"	f	class:Grid::QCD::HybridMonteCarlo
mfloat	lib/algorithms/approx/bigfloat_double.h	/^typedef double mfloat; $/;"	t
middle	lib/Eigen/src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::meta_floor_log2_selector::__anon252
middleCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr middleCols(Index startCol, Index numCols)$/;"	f
middleCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr middleCols(Index startCol, Index numCols) const$/;"	f
middleCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N) const$/;"	f
middleCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N)$/;"	f
middleRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr middleRows(Index startRow, Index n) const$/;"	f
middleRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr middleRows(Index startRow, Index n)$/;"	f
middleRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N) const$/;"	f
middleRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N)$/;"	f
min	benchmarks/Benchmark_comms.cc	/^  double min;$/;"	m	struct:time_statistics	file:
min	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half (min)(const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
min	lib/Eigen/src/Core/util/Meta.h	/^  static T (min)() { assert(false && "Lowest not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static double (min)() { return DBL_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static float (min)() { return FLT_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static int (min)() { return INT_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static long (min)() { return LONG_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static long long (min)() { return LLONG_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned int (min)() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned long (min)() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Core/util/Meta.h	/^  static unsigned long long (min)() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^min$/;"	f
min	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    static constexpr result_type (min)() { return 0; }$/;"	f	class:sitmo::prng_engine
min	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    static result_type (min)() { return 0; }$/;"	f	class:sitmo::prng_engine
minCoeff	lib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase
minCoeff	lib/Eigen/src/Core/VectorwiseOp.h	/^    const MinCoeffReturnType minCoeff() const$/;"	f	class:Eigen::VectorwiseOp
minCoeff	lib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
minCoeff	lib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* rowId, IndexType* colId) const$/;"	f	class:Eigen::DenseBase
min_coeff_visitor	lib/Eigen/src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
min_element	lib/pugixml/pugixml.cc	/^	template <typename I, typename Pred> I min_element(I begin, I end, const Pred& pred)$/;"	f
mini	lib/Eigen/src/Core/MathFunctions.h	/^EIGEN_ALWAYS_INLINE T mini(const T& x, const T& y)$/;"	f	namespace:Eigen::numext
minimum_degree_ordering	lib/Eigen/src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,StorageIndex>& C, PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm)$/;"	f	namespace:Eigen::internal
mm	lib/algorithms/approx/Remez.h	/^  bigfloat *xx, *mm, *step;$/;"	m	class:AlgRemez
mmax	lib/algorithms/iterative/AdefGeneric.h	/^  const int mmax = 5;$/;"	m	class:TwoLevelFlexiblePcg
mmax	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    int mmax;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
mobius_scale	tests/qdpxx/Test_qdpxx_munprec.cc	/^double mobius_scale=2.0;$/;"	v
mod	lib/lattice/Lattice_unary.h	/^  template<class obj> Lattice<obj> mod(const Lattice<obj> &rhs,Integer y){$/;"	f	namespace:Grid
mod	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> mod(const Grid_simd<S, V> &r, Integer y) {$/;"	f	namespace:Grid
moduleAddress_	extras/Hadrons/Environment.hpp	/^    std::map<std::string, unsigned int>    moduleAddress_;$/;"	m	class:Environment
moduleAddress_	lib/Hadrons/Environment.hpp	/^    std::map<std::string, unsigned int>    moduleAddress_;$/;"	m	class:Environment
module_	extras/Hadrons/Environment.hpp	/^    std::vector<ModuleInfo>                module_;$/;"	m	class:Environment
module_	lib/Hadrons/Environment.hpp	/^    std::vector<ModuleInfo>                module_;$/;"	m	class:Environment
momD1	extras/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::momD1(ScalarField &s, FFT &fft)$/;"	f	class:TChargedProp
momD1	lib/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::momD1(ScalarField &s, FFT &fft)$/;"	f	class:TChargedProp
momD2	extras/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::momD2(ScalarField &s, FFT &fft)$/;"	f	class:TChargedProp
momD2	lib/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::momD2(ScalarField &s, FFT &fft)$/;"	f	class:TChargedProp
move	lib/Eigen/src/Core/DenseStorage.h	/^      , m_cols(std::move(other.m_cols))$/;"	f	class:Eigen::DenseStorage
move	lib/Eigen/src/Core/DenseStorage.h	/^      , m_rows(std::move(other.m_rows))$/;"	f	class:Eigen::DenseStorage
move	lib/Eigen/src/Core/PlainObjectBase.h	/^      : m_storage( std::move(other.m_storage) )$/;"	f	class:Eigen::PlainObjectBase
move	lib/json/json.hpp	/^          m_value(std::move(other.m_value))$/;"	f	class:nlohmann::basic_json
mp_matrix	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const ActualMatrixType *mp_matrix;$/;"	m	class:Eigen::internal::generic_matrix_wrapper
mp_matrix	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixRef mp_matrix;$/;"	m	class:Eigen::UmfPackLU
mpi_p	lib/stencil/Stencil.h	/^    cobj * mpi_p;$/;"	m	struct:Grid::CartesianStencil::Decompress
mpointer	lib/stencil/Stencil.h	/^    cobj * mpointer;$/;"	m	struct:Grid::CartesianStencil::Merge
mq	tests/qdpxx/Test_qdpxx_munprec.cc	/^double mq=0.01;$/;"	v
mq	tests/qdpxx/Test_qdpxx_stag.cc	/^double mq=0.1;$/;"	v
mr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = (EIGEN_PLAIN_ENUM_MIN(16,NumberOfRegisters)\/2\/nr)*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
mr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 3*LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
mr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
mr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = Vectorizable ? 3*LhsPacketSize : default_mr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
mrend	lib/perfmon/Stat.h	/^    uint64_t mrend;     \/\/ memory read counter at end of parallel region$/;"	m	class:Grid::PmuStat
mrstart	lib/perfmon/Stat.h	/^    uint64_t mrstart;   \/\/ memory read counter at start of parallel region$/;"	m	class:Grid::PmuStat
ms_from	lib/Eigen/src/Core/util/Meta.h	/^  static From ms_from;$/;"	m	struct:Eigen::internal::is_convertible_impl
ms_from	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  static MatrixType ms_from;$/;"	m	struct:Eigen::internal::is_ref_compatible_impl
mu	lib/algorithms/approx/Chebyshev.h	/^    RealD mu;$/;"	m	class:Grid::ChebyshevLanczos
mu	lib/qcd/action/fermion/WilsonCompressor.h	/^  int mu,dag;  $/;"	m	class:Grid::QCD::WilsonCompressorTemplate
mu	lib/qcd/action/fermion/WilsonTMFermion.h	/^     RealD mu; \/\/ TwistedMass parameter$/;"	m	class:Grid::QCD::WilsonTMFermion
mul	lib/qcd/spin/Gamma.cc	/^const std::array<std::array<Gamma::Algebra, Gamma::nGamma>, Gamma::nGamma> Gamma::mul = {{$/;"	m	class:Grid::QCD::Gamma	file:
mul	lib/qcd/spin/Gamma.h	/^    static const std::array<std::array<Algebra, nGamma>, nGamma> mul;$/;"	m	class:Grid::QCD::Gamma
mul_assign_op	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^struct mul_assign_op {$/;"	s	namespace:Eigen::internal
mult	lib/lattice/Lattice_arith.h	/^    void mult(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
mult	lib/lattice/Lattice_arith.h	/^    void mult(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const obj3 &rhs){$/;"	f	namespace:Grid
mult	lib/lattice/Lattice_arith.h	/^    void mult(Lattice<obj1> &ret,const obj2 &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
mult	lib/qcd/action/fermion/CayleyFermion5D.h	/^       static inline vec mult(vec a, vec b) {$/;"	f	struct:Grid::QCD::switcheroo
mult	lib/simd/Grid_vector_types.h	/^  friend inline void mult(Grid_simd *__restrict__ y,$/;"	f	class:Grid::Grid_simd
mult	lib/simd/Simd.h	/^  inline void mult(ComplexD * __restrict__ y,const ComplexD * __restrict__ l,const ComplexD *__restrict__ r){ *y = (*l) * (*r);}$/;"	f	namespace:Grid
mult	lib/simd/Simd.h	/^  inline void mult(ComplexF * __restrict__ y,const ComplexF * __restrict__ l,const ComplexF *__restrict__ r){ *y = (*l) * (*r); }$/;"	f	namespace:Grid
mult	lib/simd/Simd.h	/^  inline void mult(RealD * __restrict__ y,const RealD * __restrict__ l,const RealD *__restrict__ r){ *y = (*l) * (*r);}$/;"	f	namespace:Grid
mult	lib/simd/Simd.h	/^  inline void mult(RealF * __restrict__ y,const RealF * __restrict__ l,const RealF *__restrict__ r){ *y = (*l) * (*r); }$/;"	f	namespace:Grid
mult	lib/tensors/Tensor_arith_mul.h	/^strong_inline void mult(iMatrix<rrtype,N> * __restrict__ ret,const iMatrix<ltype,N> * __restrict__ lhs,const iMatrix<rtype,N> * __restrict__ rhs){$/;"	f	namespace:Grid
mult	lib/tensors/Tensor_arith_mul.h	/^strong_inline void mult(iMatrix<rrtype,N> * __restrict__ ret,const iMatrix<ltype,N> * __restrict__ lhs,const iScalar<rtype> * __restrict__ rhs){$/;"	f	namespace:Grid
mult	lib/tensors/Tensor_arith_mul.h	/^strong_inline void mult(iMatrix<rrtype,N> * __restrict__ ret,const iScalar<ltype>   * __restrict__ lhs,const iMatrix<rtype,N> * __restrict__ rhs){$/;"	f	namespace:Grid
mult	lib/tensors/Tensor_arith_mul.h	/^strong_inline void mult(iScalar<rtype> * __restrict__ ret,const iScalar<mtype> * __restrict__ lhs,const iScalar<vtype> * __restrict__ rhs){$/;"	f	namespace:Grid
mult	lib/tensors/Tensor_arith_mul.h	/^strong_inline void mult(iVector<rtype,N> * __restrict__ ret,$/;"	f	namespace:Grid
mult	lib/tensors/Tensor_arith_mul.h	/^strong_inline void mult(iVector<rtype,N> * __restrict__ ret,const iMatrix<mtype,N> * __restrict__ lhs,const iVector<vtype,N> * __restrict__ rhs)$/;"	f	namespace:Grid
multGamma5	lib/qcd/spin/Gamma.h	/^inline void multGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaT	lib/qcd/spin/Gamma.h	/^inline void multGammaT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaTGamma5	lib/qcd/spin/Gamma.h	/^inline void multGammaTGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaX	lib/qcd/spin/Gamma.h	/^inline void multGammaX(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaXGamma5	lib/qcd/spin/Gamma.h	/^inline void multGammaXGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaY	lib/qcd/spin/Gamma.h	/^inline void multGammaY(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaYGamma5	lib/qcd/spin/Gamma.h	/^inline void multGammaYGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaZ	lib/qcd/spin/Gamma.h	/^inline void multGammaZ(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multGammaZGamma5	lib/qcd/spin/Gamma.h	/^inline void multGammaZGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multIdentity	lib/qcd/spin/Gamma.h	/^inline void multIdentity(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multLink	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void multLink(SiteHalfSpinor &phi, const SiteDoubledGaugeField &U,$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
multLink	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void multLink(SiteHalfSpinor &phi,$/;"	f	class:Grid::QCD::WilsonImpl
multLink	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void multLink(SiteSpinor &phi,$/;"	f	class:Grid::QCD::StaggeredImpl
multLink	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  inline void multLink(SiteHalfSpinor &phi, const SiteDoubledGaugeField &U,$/;"	f	class:Grid::QCD::DomainWallVec5dImpl
multLink	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ inline void multLink(SiteHalfSpinor &phi, const SiteDoubledGaugeField &U,$/;"	f	class:Grid::QCD::GparityWilsonImpl
multLinkAdd	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void multLinkAdd(SiteHalfSpinor &phi, const SiteDoubledGaugeField &U,$/;"	f	class:Grid::QCD::StaggeredVec5dImpl
multLinkAdd	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    inline void multLinkAdd(SiteSpinor &phi,$/;"	f	class:Grid::QCD::StaggeredImpl
multMinusGamma5	lib/qcd/spin/Gamma.h	/^inline void multMinusGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaT	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaTGamma5	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaTGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaX	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaX(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaXGamma5	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaXGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaY	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaY(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaYGamma5	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaYGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaZ	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaZ(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusGammaZGamma5	lib/qcd/spin/Gamma.h	/^inline void multMinusGammaZGamma5(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusIdentity	lib/qcd/spin/Gamma.h	/^inline void multMinusIdentity(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusSigmaXT	lib/qcd/spin/Gamma.h	/^inline void multMinusSigmaXT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusSigmaXY	lib/qcd/spin/Gamma.h	/^inline void multMinusSigmaXY(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusSigmaXZ	lib/qcd/spin/Gamma.h	/^inline void multMinusSigmaXZ(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusSigmaYT	lib/qcd/spin/Gamma.h	/^inline void multMinusSigmaYT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusSigmaYZ	lib/qcd/spin/Gamma.h	/^inline void multMinusSigmaYZ(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multMinusSigmaZT	lib/qcd/spin/Gamma.h	/^inline void multMinusSigmaZT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multSigmaXT	lib/qcd/spin/Gamma.h	/^inline void multSigmaXT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multSigmaXY	lib/qcd/spin/Gamma.h	/^inline void multSigmaXY(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multSigmaXZ	lib/qcd/spin/Gamma.h	/^inline void multSigmaXZ(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multSigmaYT	lib/qcd/spin/Gamma.h	/^inline void multSigmaYT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multSigmaYZ	lib/qcd/spin/Gamma.h	/^inline void multSigmaYZ(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multSigmaZT	lib/qcd/spin/Gamma.h	/^inline void multSigmaZT(iVector<vtype, Ns> &ret, const iVector<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
multiplier	lib/qcd/action/ActionSet.h	/^  unsigned int multiplier;$/;"	m	struct:Grid::QCD::ActionLevel
multipliers	lib/qcd/hmc/HMCResourceManager.h	/^  std::vector<int> multipliers;$/;"	m	class:Grid::QCD::HMCResourceManager
mutation	extras/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::mutation(Gene &m, const Gene &c)$/;"	f	class:GeneticScheduler
mutation	lib/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::mutation(Gene &m, const Gene &c)$/;"	f	class:GeneticScheduler
mutationRate	extras/Hadrons/GeneticScheduler.hpp	/^        double       mutationRate;$/;"	m	struct:GeneticScheduler::Parameters
mutationRate	lib/Hadrons/GeneticScheduler.hpp	/^        double       mutationRate;$/;"	m	struct:GeneticScheduler::Parameters
mwend	lib/perfmon/Stat.h	/^    uint64_t mwend;     \/\/ memory write counter at end of parallel region$/;"	m	class:Grid::PmuStat
mwstart	lib/perfmon/Stat.h	/^    uint64_t mwstart;   \/\/ memory write counter at start of parallel region$/;"	m	class:Grid::PmuStat
myclass	tests/IO/Test_serialisation.cc	/^  myclass() {}$/;"	f	class:myclass
myclass	tests/IO/Test_serialisation.cc	/^  myclass(int i)$/;"	f	class:myclass
myclass	tests/IO/Test_serialisation.cc	/^class myclass: Serializable {$/;"	c	file:
myclass	tests/solver/Test_dwf_hdcr.cc	/^  myclass(){};$/;"	f	class:myclass
myclass	tests/solver/Test_dwf_hdcr.cc	/^class myclass: Serializable {$/;"	c	file:
n	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   n; \/\/ Number of columns in the matrix  $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
n	lib/algorithms/approx/Remez.h	/^  int n, d;$/;"	m	class:AlgRemez
n	lib/algorithms/approx/Zolotarev.h	/^  int n,	      \/* approximation degree *\/$/;"	m	struct:Grid::Approx::__anon695
n	lib/pugixml/pugixml.cc	/^		xpath_node n;$/;"	m	struct:xpath_context	file:
n	tests/Test_simd.cc	/^  int n;$/;"	m	class:funcExchange	file:
n	tests/Test_simd.cc	/^  int n;$/;"	m	class:funcPermute	file:
n	tests/Test_simd.cc	/^  int n;$/;"	m	class:funcRotate	file:
nGamma	lib/qcd/spin/Gamma.h	/^    static constexpr unsigned int nGamma = 32;$/;"	m	class:Grid::QCD::Gamma
n_eye_diag	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	/^    n_eye_diag = 2$/;"	e	enum:__anon4
n_eye_diag	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.hpp	/^    n_eye_diag = 2$/;"	e	enum:__anon687
n_i	extras/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^  n_i = 2$/;"	e	enum:__anon5
n_i	lib/Hadrons/Modules/MContraction/WeakHamiltonian.hpp	/^  n_i = 2$/;"	e	enum:__anon688
n_neut_disc_diag	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	/^    n_neut_disc_diag = 2$/;"	e	enum:__anon7
n_neut_disc_diag	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	/^    n_neut_disc_diag = 2$/;"	e	enum:__anon690
n_noneye_diag	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	/^    n_noneye_diag = 2$/;"	e	enum:__anon6
n_noneye_diag	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.hpp	/^    n_noneye_diag = 2$/;"	e	enum:__anon689
name	extras/Hadrons/Environment.hpp	/^        std::string               name;$/;"	m	struct:Environment::ModuleInfo
name	extras/Hadrons/Environment.hpp	/^        std::string             name;$/;"	m	struct:Environment::ObjInfo
name	lib/Hadrons/Environment.hpp	/^        std::string               name;$/;"	m	struct:Environment::ModuleInfo
name	lib/Hadrons/Environment.hpp	/^        std::string             name;$/;"	m	struct:Environment::ObjInfo
name	lib/log/Log.h	/^  std::string name, topName;$/;"	m	class:Grid::Logger
name	lib/perfmon/PerfCount.h	/^    const char *name;$/;"	m	struct:Grid::PerformanceCounter::__anon691
name	lib/perfmon/Stat.h	/^    const char *name;$/;"	m	class:Grid::PmuStat
name	lib/pugixml/pugixml.cc	/^		char_t name[1];$/;"	m	struct:xpath_variable_boolean	file:
name	lib/pugixml/pugixml.cc	/^		char_t name[1];$/;"	m	struct:xpath_variable_node_set	file:
name	lib/pugixml/pugixml.cc	/^		char_t name[1];$/;"	m	struct:xpath_variable_number	file:
name	lib/pugixml/pugixml.cc	/^		char_t name[1];$/;"	m	struct:xpath_variable_string	file:
name	lib/pugixml/pugixml.cc	/^		impl::compact_string<4, 2> name;$/;"	m	struct:pugi::xml_attribute_struct	file:
name	lib/pugixml/pugixml.cc	/^		impl::compact_string<4, 2> name;$/;"	m	struct:pugi::xml_node_struct	file:
name	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_attribute::name() const$/;"	f	class:pugi::xml_attribute
name	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_node::name() const$/;"	f	class:pugi::xml_node
name	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xpath_variable::name() const$/;"	f	class:pugi::xpath_variable
name	lib/qcd/hmc/HMC_GridModules.h	/^    std::string name;$/;"	m	class:Grid::GridModuleParameters
name	lib/qcd/spin/Gamma.cc	/^const std::array<const char *, Gamma::nGamma> Gamma::name = {{$/;"	m	class:Grid::QCD::Gamma	file:
name	lib/qcd/spin/Gamma.h	/^    static const std::array<const char *, nGamma>                name;$/;"	m	class:Grid::QCD::Gamma
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Adj"); }$/;"	f	class:funcAdj
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Conj"); }$/;"	f	class:funcConj
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Divide"); }$/;"	f	class:funcDivide
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Exchange"); }$/;"	f	class:funcExchange
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Minus"); }$/;"	f	class:funcMinus
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Permute"); }$/;"	f	class:funcPermute
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Plus"); }$/;"	f	class:funcPlus
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Reduce"); }$/;"	f	class:funcReduce
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Rotate"); }$/;"	f	class:funcRotate
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("Times"); }$/;"	f	class:funcTimes
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("imag"); }$/;"	f	class:funcImag
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("innerProduct"); }$/;"	f	class:funcInnerProduct
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("real"); }$/;"	f	class:funcReal
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("timesI"); }$/;"	f	class:funcTimesI
name	tests/Test_simd.cc	/^  std::string name(void) const { return std::string("timesMinusI"); }$/;"	f	class:funcTimesMinusI
name	tests/testu01/Test_smallcrush.cc	/^  static char *name;$/;"	m	struct:TestRNG	file:
name	tests/testu01/Test_smallcrush.cc	/^char * TestRNG::name = (char *)"Grid_Sitmo";$/;"	m	class:TestRNG	file:
name	tests/testu01/Test_smallcrush.cc	/^char * TestRNG::name = (char *)"Grid_mt19937";$/;"	m	class:TestRNG	file:
name	tests/testu01/Test_smallcrush.cc	/^char * TestRNG::name = (char *)"Grid_ranlux48";$/;"	m	class:TestRNG	file:
name_	extras/Hadrons/Module.hpp	/^    std::string name_;$/;"	m	class:ModuleBase
name_	lib/Hadrons/Module.hpp	/^    std::string name_;$/;"	m	class:ModuleBase
name_separator	lib/json/json.hpp	/^            name_separator,  \/\/\/< the name separator `:`$/;"	m	class:nlohmann::basic_json::lexer::token_type
namespace_uri	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* namespace_uri(const xpath_node& node)$/;"	f
namespace_uri	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* namespace_uri(xml_attribute attr, xml_node parent)$/;"	f
namespace_uri	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* namespace_uri(xml_node node)$/;"	f
namespace_uri_predicate	lib/pugixml/pugixml.cc	/^		namespace_uri_predicate(const char_t* name)$/;"	f	struct:namespace_uri_predicate
namespace_uri_predicate	lib/pugixml/pugixml.cc	/^	struct namespace_uri_predicate$/;"	s	file:
namevalue_base	lib/pugixml/pugixml.cc	/^		uint16_t namevalue_base;$/;"	m	struct:pugi::xml_attribute_struct	file:
namevalue_base	lib/pugixml/pugixml.cc	/^		uint16_t namevalue_base;$/;"	m	struct:pugi::xml_node_struct	file:
narrow_stream	lib/pugixml/pugixml.h	/^		std::basic_ostream<char, std::char_traits<char> >* narrow_stream;$/;"	m	class:pugi::xml_writer_stream
nbThreads	lib/Eigen/src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen
nc	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline Index nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking
nd1	lib/algorithms/approx/Remez.h	/^  int nd1, iter;$/;"	m	class:AlgRemez
nd_	extras/Hadrons/Environment.hpp	/^    unsigned int                           nd_;$/;"	m	class:Environment
nd_	lib/Hadrons/Environment.hpp	/^    unsigned int                           nd_;$/;"	m	class:Environment
need_endian_swap_utf	lib/pugixml/pugixml.cc	/^	PUGI__FN bool need_endian_swap_utf(xml_encoding le, xml_encoding re)$/;"	f
neq	lib/algorithms/approx/Remez.h	/^  int neq;$/;"	m	class:AlgRemez
nestByValue	lib/Eigen/src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase
nestedExpression	lib/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper
nestedExpression	lib/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper
nestedExpression	lib/Eigen/src/Core/Block.h	/^    XprType& nestedExpression() { return m_xpr; }$/;"	f	class:Eigen::internal::BlockImpl_dense
nestedExpression	lib/Eigen/src/Core/Block.h	/^    const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const$/;"	f	class:Eigen::internal::BlockImpl_dense
nestedExpression	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	lib/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	lib/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	lib/Eigen/src/Core/Diagonal.h	/^    nestedExpression() const $/;"	f	class:Eigen::Diagonal
nestedExpression	lib/Eigen/src/Core/Inverse.h	/^  EIGEN_DEVICE_FUNC const XprTypeNestedCleaned& nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::Inverse
nestedExpression	lib/Eigen/src/Core/Redux.h	/^  const XprType & nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::internal::redux_evaluator
nestedExpression	lib/Eigen/src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate
nestedExpression	lib/Eigen/src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse
nestedExpression	lib/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	lib/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	lib/Eigen/src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose
nestedExpression	lib/Eigen/src/Core/Transpose.h	/^    nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::Transpose
nestedExpression	lib/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& nestedExpression() const { return m_transpositions; }$/;"	f	class:Eigen::Transpose
nestedExpression	lib/Eigen/src/Core/TriangularMatrix.h	/^    NestedExpression& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::TriangularView
nestedExpression	lib/Eigen/src/Core/TriangularMatrix.h	/^    const NestedExpression& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView
nestedExpression	lib/Eigen/src/Core/VectorwiseOp.h	/^    typename MatrixType::Nested nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::PartialReduxExpr
nestedExpression	lib/Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC const NestedExpression& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Homogeneous
nestedExpression	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseMatrixType& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
nestedExpression	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline XprType& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::BlockImpl
nestedExpression	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const SparseMatrixType& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
nestedExpression	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const XprType& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::BlockImpl
nestedExpression	lib/Eigen/src/SparseCore/SparseView.h	/^  nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseView
nested_eval	lib/Eigen/src/Core/ReturnByValue.h	/^struct nested_eval<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
neut_disc_1_diag	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	/^    neut_disc_1_diag = 0,$/;"	e	enum:__anon7
neut_disc_1_diag	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	/^    neut_disc_1_diag = 0,$/;"	e	enum:__anon690
neut_disc_2_diag	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	/^    neut_disc_2_diag = 1,$/;"	e	enum:__anon7
neut_disc_2_diag	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.hpp	/^    neut_disc_2_diag = 1,$/;"	e	enum:__anon690
new_xpath_variable	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable* new_xpath_variable(xpath_value_type type, const char_t* name)$/;"	f
new_xpath_variable	lib/pugixml/pugixml.cc	/^	template <typename T> PUGI__FN T* new_xpath_variable(const char_t* name)$/;"	f
next	lib/Eigen/src/SparseCore/AmbiVector.h	/^      StorageIndex next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
next	lib/pugixml/pugixml.cc	/^		void next()$/;"	f	class:xpath_lexer
next	lib/pugixml/pugixml.cc	/^		xml_extra_buffer* next;$/;"	m	struct:xml_extra_buffer	file:
next	lib/pugixml/pugixml.cc	/^		xml_memory_page* next;$/;"	m	struct:xml_memory_page	file:
next	lib/pugixml/pugixml.cc	/^		xml_stream_chunk* next;$/;"	m	struct:xml_stream_chunk	file:
next	lib/pugixml/pugixml.cc	/^		xpath_memory_block* next;$/;"	m	struct:xpath_memory_block	file:
nextElement	lib/serialisation/JSON_IO.cc	/^bool JSONReader::nextElement(const std::string &s)$/;"	f	class:JSONReader
nextElement	lib/serialisation/XmlIO.cc	/^bool XmlReader::nextElement(const std::string &s)$/;"	f	class:XmlReader
nextGeneration	extras/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::nextGeneration(void)$/;"	f	class:GeneticScheduler
nextGeneration	lib/Hadrons/GeneticScheduler.hpp	/^void GeneticScheduler<T>::nextGeneration(void)$/;"	f	class:GeneticScheduler
next_attribute	lib/pugixml/pugixml.cc	/^		impl::compact_pointer<xml_attribute_struct, 7, 0> next_attribute;$/;"	m	struct:pugi::xml_attribute_struct	file:
next_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_attribute::next_attribute() const$/;"	f	class:pugi::xml_attribute
next_sibling	lib/pugixml/pugixml.cc	/^		impl::compact_pointer<xml_node_struct, 10, 0> next_sibling;$/;"	m	struct:pugi::xml_node_struct	file:
next_sibling	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::next_sibling() const$/;"	f	class:pugi::xml_node
next_sibling	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::next_sibling(const char_t* name_) const$/;"	f	class:pugi::xml_node
nlohmann	lib/json/json.hpp	/^namespace nlohmann$/;"	n
nnz	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon15::__anon16
no	lib/Eigen/src/Core/util/Meta.h	/^  struct no  {int a[2];};$/;"	s	struct:Eigen::internal::is_convertible_impl
no	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct no  {int a[2];};$/;"	s	struct:Eigen::internal::is_ref_compatible_impl
no_assignment_operator	lib/Eigen/src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
noalias	lib/Eigen/src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase
node	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xpath_node::node() const$/;"	f	class:pugi::xpath_node
node_	lib/serialisation/XmlIO.h	/^    pugi::xml_node     node_;$/;"	m	class:Grid::XmlReader
node_	lib/serialisation/XmlIO.h	/^    pugi::xml_node     node_;$/;"	m	class:Grid::XmlWriter
node_cdata	lib/pugixml/pugixml.h	/^		node_cdata,			\/\/ Character data, i.e. '<![CDATA[text]]>'$/;"	e	enum:pugi::xml_node_type
node_comment	lib/pugixml/pugixml.h	/^		node_comment,		\/\/ Comment tag, i.e. '<!-- text -->'$/;"	e	enum:pugi::xml_node_type
node_copy_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_copy_attribute(xml_attribute_struct* da, xml_attribute_struct* sa)$/;"	f
node_copy_contents	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_copy_contents(xml_node_struct* dn, xml_node_struct* sn, xml_allocator* shared_alloc)$/;"	f
node_copy_string	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_copy_string(String& dest, Header& header, uintptr_t header_mask, char_t* source, Header& source_header, xml_allocator* alloc)$/;"	f
node_copy_tree	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_copy_tree(xml_node_struct* dn, xml_node_struct* sn)$/;"	f
node_declaration	lib/pugixml/pugixml.h	/^		node_declaration,	\/\/ Document declaration, i.e. '<?xml version="1.0"?>'$/;"	e	enum:pugi::xml_node_type
node_doctype	lib/pugixml/pugixml.h	/^		node_doctype		\/\/ Document type declaration, i.e. '<!DOCTYPE doc>'$/;"	e	enum:pugi::xml_node_type
node_document	lib/pugixml/pugixml.h	/^		node_document,		\/\/ A document tree's absolute root$/;"	e	enum:pugi::xml_node_type
node_element	lib/pugixml/pugixml.h	/^		node_element,		\/\/ Element tag, i.e. '<node\/>'$/;"	e	enum:pugi::xml_node_type
node_is_ancestor	lib/pugixml/pugixml.cc	/^	PUGI__FN bool node_is_ancestor(xml_node_struct* parent, xml_node_struct* node)$/;"	f
node_is_before	lib/pugixml/pugixml.cc	/^	PUGI__FN bool node_is_before(xml_node_struct* ln, xml_node_struct* rn)$/;"	f
node_is_before_sibling	lib/pugixml/pugixml.cc	/^	PUGI__FN bool node_is_before_sibling(xml_node_struct* ln, xml_node_struct* rn)$/;"	f
node_null	lib/pugixml/pugixml.h	/^		node_null,			\/\/ Empty (null) node handle$/;"	e	enum:pugi::xml_node_type
node_output	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_output(xml_buffered_writer& writer, xml_node_struct* root, const char_t* indent, unsigned int flags, unsigned int depth)$/;"	f
node_output_attributes	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_output_attributes(xml_buffered_writer& writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)$/;"	f
node_output_comment	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_output_comment(xml_buffered_writer& writer, const char_t* s)$/;"	f
node_output_end	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_output_end(xml_buffered_writer& writer, xml_node_struct* node)$/;"	f
node_output_pi_value	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_output_pi_value(xml_buffered_writer& writer, const char_t* s)$/;"	f
node_output_simple	lib/pugixml/pugixml.cc	/^	PUGI__FN void node_output_simple(xml_buffered_writer& writer, xml_node_struct* node, unsigned int flags)$/;"	f
node_output_start	lib/pugixml/pugixml.cc	/^	PUGI__FN bool node_output_start(xml_buffered_writer& writer, xml_node_struct* node, const char_t* indent, size_t indent_length, unsigned int flags, unsigned int depth)$/;"	f
node_pcdata	lib/pugixml/pugixml.h	/^		node_pcdata,		\/\/ Plain character data, i.e. 'text'$/;"	e	enum:pugi::xml_node_type
node_pi	lib/pugixml/pugixml.h	/^		node_pi,			\/\/ Processing instruction, i.e. '<?name?>'$/;"	e	enum:pugi::xml_node_type
nodeset_eval_all	lib/pugixml/pugixml.cc	/^		nodeset_eval_all,$/;"	e	enum:nodeset_eval_t	file:
nodeset_eval_any	lib/pugixml/pugixml.cc	/^		nodeset_eval_any,$/;"	e	enum:nodeset_eval_t	file:
nodeset_eval_first	lib/pugixml/pugixml.cc	/^		nodeset_eval_first$/;"	e	enum:nodeset_eval_t	file:
nodeset_eval_t	lib/pugixml/pugixml.cc	/^	enum nodeset_eval_t$/;"	g	file:
nodetest	lib/pugixml/pugixml.cc	/^			const char_t* nodetest;$/;"	m	union:xpath_ast_node::__anon686	file:
nodetest_all	lib/pugixml/pugixml.cc	/^		nodetest_all,$/;"	e	enum:nodetest_t	file:
nodetest_all_in_namespace	lib/pugixml/pugixml.cc	/^		nodetest_all_in_namespace$/;"	e	enum:nodetest_t	file:
nodetest_name	lib/pugixml/pugixml.cc	/^		nodetest_name,$/;"	e	enum:nodetest_t	file:
nodetest_none	lib/pugixml/pugixml.cc	/^		nodetest_none,$/;"	e	enum:nodetest_t	file:
nodetest_pi	lib/pugixml/pugixml.cc	/^		nodetest_pi,$/;"	e	enum:nodetest_t	file:
nodetest_t	lib/pugixml/pugixml.cc	/^	enum nodetest_t$/;"	g	file:
nodetest_type_comment	lib/pugixml/pugixml.cc	/^		nodetest_type_comment,$/;"	e	enum:nodetest_t	file:
nodetest_type_node	lib/pugixml/pugixml.cc	/^		nodetest_type_node,$/;"	e	enum:nodetest_t	file:
nodetest_type_pi	lib/pugixml/pugixml.cc	/^		nodetest_type_pi,$/;"	e	enum:nodetest_t	file:
nodetest_type_text	lib/pugixml/pugixml.cc	/^		nodetest_type_text,$/;"	e	enum:nodetest_t	file:
noexcept	lib/json/json.hpp	/^                 nlohmann::json& j2) noexcept($/;"	f	namespace:std
noexcept	lib/json/json.hpp	/^        internal_iterator() noexcept$/;"	m	struct:nlohmann::basic_json::internal_iterator
noexcept	lib/json/json.hpp	/^        iter_impl& operator=(iter_impl other) noexcept($/;"	f	class:nlohmann::basic_json::iter_impl
noexcept	lib/json/json.hpp	/^    reference& operator=(basic_json other) noexcept ($/;"	f	class:nlohmann::basic_json
noexcept	lib/json/json.hpp	/^    void swap(reference other) noexcept ($/;"	f	class:nlohmann::basic_json
nonZeros	lib/Eigen/src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase
nonZeros	lib/Eigen/src/SparseCore/AmbiVector.h	/^Index AmbiVector<_Scalar,_StorageIndex>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector
nonZeros	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const { return Dynamic; }$/;"	f	class:Eigen::BlockImpl
nonZeros	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::BlockImpl
nonZeros	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseCompressedBase
nonZeros	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Index nonZeros() const { return m_zero_nnz[1]; }$/;"	f	class:Eigen::SparseMapBase
nonZeros	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
nonZeros	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return m_data.size(); }$/;"	f	class:Eigen::SparseVector
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::binary_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::sparse_conjunction_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  Index nonZerosEstimate() const { return m_sparseXprEval.nonZerosEstimate(); }$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  Index nonZerosEstimate() const { return m_sparseXprImpl.nonZerosEstimate(); }$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	lib/Eigen/src/SparseCore/SparseVector.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::evaluator
noncopyable	lib/Eigen/src/Core/util/Meta.h	/^  EIGEN_DEVICE_FUNC noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
noncopyable	lib/Eigen/src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
nonzeroPivots	lib/Eigen/src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU
nonzeroPivots	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR
nonzeroPivots	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index nonzeroPivots() const { return m_cpqr.nonzeroPivots(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
nonzeroPivots	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR
nonzeroSingularValues	lib/Eigen/src/SVD/SVDBase.h	/^  Index nonzeroSingularValues() const$/;"	f	class:Eigen::SVDBase
norm	lib/Eigen/src/Core/Dot.h	/^inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase
norm	lib/Eigen/src/Core/VectorwiseOp.h	/^    const NormReturnType norm() const$/;"	f	class:Eigen::VectorwiseOp
norm	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase
norm	lib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase
norm	lib/algorithms/approx/MultiShiftFunction.h	/^  RealD norm;$/;"	m	class:Grid::MultiShiftFunction
norm	lib/algorithms/approx/Remez.h	/^  bigfloat norm;$/;"	m	class:AlgRemez
norm1	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::numext
norm1_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
norm1_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
norm1_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
norm1_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
norm2	lib/lattice/Lattice_reduction.h	/^template<class vobj> inline RealD norm2(const Lattice<vobj> &arg){$/;"	f	namespace:Grid
norm2	lib/tensors/Tensor_inner.h	/^  template<class sobj> inline RealD norm2(const sobj &arg){$/;"	f	namespace:Grid
normal	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normalisation	lib/perfmon/PerfCount.h	/^    int normalisation;$/;"	m	struct:Grid::PerformanceCounter::__anon691
normalise	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  static RealD normalise(Field& v) $/;"	f	class:Grid::ImplicitlyRestartedLanczos
normalize	lib/Eigen/src/Core/Dot.h	/^inline void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase
normalize	lib/Eigen/src/Core/VectorwiseOp.h	/^    EIGEN_DEVICE_FUNC void normalize() {$/;"	f	class:Eigen::VectorwiseOp
normalize	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC void normalize(void)$/;"	f	class:Eigen::Hyperplane
normalize	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase
normalize_space	lib/pugixml/pugixml.cc	/^	PUGI__FN char_t* normalize_space(char_t* buffer)$/;"	f
normalized	lib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase
normalized	lib/Eigen/src/Core/VectorwiseOp.h	/^    normalized() const { return m_matrix.cwiseQuotient(extendedToOpposite(this->norm())); }$/;"	f	class:Eigen::VectorwiseOp
normalized	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase
nosplicetime	lib/stencil/Stencil.h	/^  double nosplicetime;$/;"	m	class:Grid::CartesianStencil
not_equal_to	lib/pugixml/pugixml.cc	/^	struct not_equal_to$/;"	s	file:
notvalue	lib/tensors/Tensor_traits.h	/^    static const bool notvalue = (Level!=T::TensorLevel);$/;"	m	struct:Grid::matchGridTensorIndex
notvalue	lib/tensors/Tensor_traits.h	/^    static const bool notvalue = false;$/;"	m	struct:Grid::isGridTensor
notvalue	lib/tensors/Tensor_traits.h	/^    static const bool notvalue = true;$/;"	m	struct:Grid::isGridTensor
npoint	lib/algorithms/CoarsenedMatrix.h	/^    int npoint;$/;"	m	class:Grid::Geometry
npoint	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  static const int npoint = 16;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermionStatic
npoint	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      const int npoint = 16;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5DStatic
npoint	lib/qcd/action/fermion/WilsonFermion.h	/^  static const int npoint = 8;$/;"	m	class:Grid::QCD::WilsonFermionStatic
npoint	lib/qcd/action/fermion/WilsonFermion5D.h	/^      const int npoint = 8;$/;"	m	class:Grid::QCD::WilsonFermion5DStatic
npoint	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    int npoint = 2*Ndim;$/;"	m	class:Grid::ScalarInteractionAction
npoint	lib/qcd/utils/CovariantLaplacian.h	/^  int npoint = 8;$/;"	m	class:Grid::QCD::LaplacianAdjointField
nr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon373
nr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon374
nr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon375
nr	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon376
nr_etdfs	lib/Eigen/src/SparseCore/SparseColEtree.h	/^void nr_etdfs (typename IndexVector::Scalar n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, typename IndexVector::Scalar postnum)$/;"	f	namespace:Eigen::internal
nstep	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    int nstep;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
nsuper	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index nsuper() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
null	lib/json/json.hpp	/^        null,            \/\/\/< null value$/;"	m	class:nlohmann::basic_json::value_t
nullary_wrapper	lib/Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper$/;"	s	namespace:Eigen::internal
nullary_wrapper	lib/Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,false,false,false> {};$/;"	s	namespace:Eigen::internal
nullary_wrapper	lib/Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,false,false,true>$/;"	s	namespace:Eigen::internal
nullary_wrapper	lib/Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,false,true,false>$/;"	s	namespace:Eigen::internal
nullary_wrapper	lib/Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,true,false,false>$/;"	s	namespace:Eigen::internal
num_expansions	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   num_expansions; $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
number	lib/pugixml/pugixml.cc	/^			double number;$/;"	m	union:xpath_ast_node::__anon686	file:
number_float	lib/json/json.hpp	/^        json_value(number_float_t v) noexcept : number_float(v) {}$/;"	f	union:nlohmann::basic_json::json_value
number_float	lib/json/json.hpp	/^        number_float,    \/\/\/< number value (floating-point)$/;"	m	class:nlohmann::basic_json::value_t
number_float	lib/json/json.hpp	/^        number_float_t number_float;$/;"	m	union:nlohmann::basic_json::json_value
number_float_t	lib/json/json.hpp	/^        : basic_json(number_float_t(val))$/;"	f	class:nlohmann::basic_json
number_integer	lib/json/json.hpp	/^        json_value(number_integer_t v) noexcept : number_integer(v) {}$/;"	f	union:nlohmann::basic_json::json_value
number_integer	lib/json/json.hpp	/^        number_integer,  \/\/\/< number value (signed integer)$/;"	m	class:nlohmann::basic_json::value_t
number_integer	lib/json/json.hpp	/^        number_integer_t number_integer;$/;"	m	union:nlohmann::basic_json::json_value
number_unsigned	lib/json/json.hpp	/^        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}$/;"	f	union:nlohmann::basic_json::json_value
number_unsigned	lib/json/json.hpp	/^        number_unsigned, \/\/\/< number value (unsigned integer)$/;"	m	class:nlohmann::basic_json::value_t
number_unsigned	lib/json/json.hpp	/^        number_unsigned_t number_unsigned;$/;"	m	union:nlohmann::basic_json::json_value
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<double>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<float>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<int>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<long long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<unsigned int>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<unsigned long long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<unsigned long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct numeric_limits$/;"	s	namespace:Eigen::internal::device
numext	lib/Eigen/src/Core/MathFunctions.h	/^namespace numext {$/;"	n	namespace:Eigen
numext	lib/Eigen/src/Core/arch/CUDA/Half.h	/^namespace numext {$/;"	n	namespace:Eigen
numext	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace numext {$/;"	n	namespace:Eigen
numext	lib/Eigen/src/Core/util/Meta.h	/^namespace numext {$/;"	n
nzlmax	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzlmax; \/\/ Current max size of lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
nzlumax	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzlumax; \/\/ Current max size of lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
nzumax	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzumax; \/\/ Current max size of ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
oCoorFromOindex	lib/cartesian/Cartesian_base.h	/^    inline void oCoorFromOindex (std::vector<int>& coor,int Oindex){$/;"	f	class:Grid::GridBase
oIndex	lib/cartesian/Cartesian_base.h	/^    virtual int oIndex(std::vector<int> &coor)$/;"	f	class:Grid::GridBase
oIndex	lib/cartesian/Cartesian_red_black.h	/^    virtual int oIndex(std::vector<int> &coor)$/;"	f	class:Grid::GridRedBlackCartesian
oIndexReduced	lib/cartesian/Cartesian_base.h	/^    inline int oIndexReduced(std::vector<int> &ocoor)$/;"	f	class:Grid::GridBase
oSites	lib/cartesian/Cartesian_base.h	/^    inline int oSites(void) const { return _osites; };$/;"	f	class:Grid::GridBase
obj_type	lib/qcd/hmc/HMCRunnerModule.h	/^  std::string obj_type() const {$/;"	f	class:Grid::HMCRunnerModuleFactory
obj_type	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  std::string obj_type() const {$/;"	f	class:Grid::HMC_CPModuleFactory
obj_type	lib/qcd/modules/ActionModules.h	/^    std::string obj_type() const {$/;"	f	class:Grid::HMC_ActionModuleFactory
obj_type	lib/qcd/modules/FermionOperatorModules.h	/^    std::string obj_type() const {$/;"	f	class:Grid::HMC_FermionOperatorModuleFactory
obj_type	lib/qcd/modules/ObservableModules.h	/^    std::string obj_type() const {$/;"	f	class:Grid::HMC_ObservablesModuleFactory
obj_type	lib/qcd/modules/SolverModules.h	/^    std::string obj_type() const {$/;"	f	class:Grid::HMC_SolverModuleFactory
object	lib/json/json.hpp	/^        object,          \/\/\/< object (unordered set of name\/value pairs)$/;"	m	class:nlohmann::basic_json::value_t
object	lib/json/json.hpp	/^        object_t* object;$/;"	m	union:nlohmann::basic_json::json_value
object	lib/json/json.hpp	/^    static basic_json object(std::initializer_list<basic_json> init =$/;"	f	class:nlohmann::basic_json
objectAddress_	extras/Hadrons/Environment.hpp	/^    std::map<std::string, unsigned int>    objectAddress_;$/;"	m	class:Environment
objectAddress_	lib/Hadrons/Environment.hpp	/^    std::map<std::string, unsigned int>    objectAddress_;$/;"	m	class:Environment
object_	extras/Hadrons/Environment.hpp	/^    std::vector<ObjInfo>                   object_;$/;"	m	class:Environment
object_	lib/Hadrons/Environment.hpp	/^    std::vector<ObjInfo>                   object_;$/;"	m	class:Environment
object_end	lib/json/json.hpp	/^        object_end,$/;"	m	class:nlohmann::basic_json::parse_event_t
object_iterator	lib/json/json.hpp	/^        typename object_t::iterator object_iterator;$/;"	m	struct:nlohmann::basic_json::internal_iterator
object_start	lib/json/json.hpp	/^        object_start,$/;"	m	class:nlohmann::basic_json::parse_event_t
observable_string	lib/qcd/modules/Modules.cc	/^char observable_string[] = "Observable";$/;"	m	namespace:Grid	file:
offset	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	lib/pugixml/pugixml.h	/^		ptrdiff_t offset;$/;"	m	struct:pugi::xml_parse_result
offset	lib/pugixml/pugixml.h	/^		ptrdiff_t offset;$/;"	m	struct:pugi::xpath_parse_result
offset_debug	lib/pugixml/pugixml.cc	/^	PUGI__FN ptrdiff_t xml_node::offset_debug() const$/;"	f	class:pugi::xml_node
omega	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> omega; $/;"	m	class:Grid::QCD::CayleyFermion5D
one	lib/simd/BGQQPX.h	108;"	d
one	lib/simd/IBM_qpx.h	71;"	d
open	lib/parallelIO/IldgIO.h	/^   void open(std::string &_filename) $/;"	f	class:Grid::QCD::GridLimeReader
open	lib/parallelIO/IldgIO.h	/^   void open(std::string &_filename) { $/;"	f	class:Grid::QCD::GridLimeWriter
open_file_wide	lib/pugixml/pugixml.cc	/^	PUGI__FN FILE* open_file_wide(const wchar_t* path, const wchar_t* mode)$/;"	f
operator !	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^operator!() const$/;"	f
operator !	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::operator!() const$/;"	f	class:pugi::xml_attribute
operator !	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::operator!() const$/;"	f	class:pugi::xml_node
operator !	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::operator!() const$/;"	f	class:pugi::xml_text
operator !	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_node::operator!() const$/;"	f	class:pugi::xpath_node
operator !	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_query::operator!() const$/;"	f	class:pugi::xpath_query
operator !=	lib/Eigen/src/Core/MatrixBase.h	/^    inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator !=	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ bool operator != (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator !=	lib/allocator/AlignedAllocator.h	/^  inline bool operator!=(const alignedAllocator<_Tp> &, const alignedAllocator<_Tp> &) { return false; }$/;"	f	namespace:Grid
operator !=	lib/allocator/AlignedAllocator.h	/^template<typename _Tp>  inline bool operator!=(const commAllocator<_Tp>&, const commAllocator<_Tp>&){ return false; }$/;"	f	namespace:Grid
operator !=	lib/json/json.hpp	/^            bool operator!= (const iteration_proxy_internal& o) const$/;"	f	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
operator !=	lib/json/json.hpp	/^        bool operator!=(const iter_impl& other) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator !=	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator != (const Lattice<lobj> & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator !=	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator != (const Lattice<lobj> & lhs, const robj & rhs) {$/;"	f	namespace:Grid
operator !=	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator != (const lobj & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator !=	lib/pugixml/pugixml.cc	/^		bool operator!=(const xpath_string& o) const$/;"	f	class:xpath_string
operator !=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::operator!=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute
operator !=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute_iterator::operator!=(const xml_attribute_iterator& rhs) const$/;"	f	class:pugi::xml_attribute_iterator
operator !=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_named_node_iterator::operator!=(const xml_named_node_iterator& rhs) const$/;"	f	class:pugi::xml_named_node_iterator
operator !=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::operator!=(const xml_node& r) const$/;"	f	class:pugi::xml_node
operator !=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node_iterator::operator!=(const xml_node_iterator& rhs) const$/;"	f	class:pugi::xml_node_iterator
operator !=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_node::operator!=(const xpath_node& n) const$/;"	f	class:pugi::xpath_node
operator !=	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    bool operator!=(const prng_engine& y) $/;"	f	class:sitmo::prng_engine
operator &	lib/pugixml/pugixml.cc	/^		uintptr_t operator&(uintptr_t mod) const$/;"	f	class:compact_header
operator &	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> operator&(const Grid_simd<S, V> &x,$/;"	f	namespace:Grid
operator &&	lib/Eigen/src/plugins/CommonCwiseBinaryOps.h	/^operator&&(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator &&	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator&&(const xml_attribute& lhs, bool rhs)$/;"	f	namespace:pugi
operator &&	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator&&(const xml_node& lhs, bool rhs)$/;"	f	namespace:pugi
operator &&	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator&&(const xml_text& lhs, bool rhs)$/;"	f	namespace:pugi
operator &&	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator&&(const xpath_node& lhs, bool rhs)$/;"	f	namespace:pugi
operator &&	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> operator&&(const Grid_simd<S, V> &x,$/;"	f	namespace:Grid
operator &=	lib/pugixml/pugixml.cc	/^		void operator&=(uintptr_t mod)$/;"	f	class:compact_header
operator ()	extras/Hadrons/Module.cc	/^void ModuleBase::operator()(void)$/;"	f	class:ModuleBase
operator ()	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i) const { return op(i); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j) const { return op(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j) const {$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j=0) const { return op(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType=0, IndexType=0) const { return op(); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	lib/Eigen/src/Core/ProductEvaluators.h	/^    template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const {$/;"	f	struct:Eigen::internal::generic_product_impl::adds
operator ()	lib/Eigen/src/Core/ProductEvaluators.h	/^  struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	f	struct:Eigen::internal::generic_product_impl::add
operator ()	lib/Eigen/src/Core/ProductEvaluators.h	/^  struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	f	struct:Eigen::internal::generic_product_impl::set
operator ()	lib/Eigen/src/Core/ProductEvaluators.h	/^  struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	f	struct:Eigen::internal::generic_product_impl::sub
operator ()	lib/Eigen/src/Core/Random.h	/^  inline const Scalar operator() () const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op
operator ()	lib/Eigen/src/Core/Transpositions.h	/^    inline StorageIndex& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	lib/Eigen/src/Core/Transpositions.h	/^    inline const StorageIndex& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
operator ()	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase
operator ()	lib/Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC inline ResultType operator()(const XprType& mat) const$/;"	f	struct:Eigen::internal::member_lpnorm
operator ()	lib/Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux
operator ()	lib/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor
operator ()	lib/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor
operator ()	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_difference_op
operator ()	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_product_op
operator ()	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_quotient_op
operator ()	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_sum_op
operator ()	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::size_t operator()(const Eigen::half& a) const {$/;"	f	struct:std::hash
operator ()	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Eigen::half operator() (const float& a) const {$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Eigen::half operator() (const int& a) const {$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float operator() (const Eigen::half& a) const {$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a ^ b; }$/;"	f	struct:Eigen::internal::scalar_boolean_xor_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return !(a<=b || b<=a);}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a!=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a<=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a<b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a==b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a>=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a>b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& _x, const Scalar& _y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return numext::maxi(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return numext::mini(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const first_argument_type& a) const { return BinaryOp::operator()(a,m_value); }$/;"	f	struct:Eigen::internal::bind2nd_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const second_argument_type& b) const { return BinaryOp::operator()(m_value,b); }$/;"	f	struct:Eigen::internal::bind1st_op
operator ()	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  inline result_type operator() (const Scalar& a, const Exponent& b) const { return numext::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_pow_op
operator ()	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() () const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op
operator ()	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op
operator ()	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const {$/;"	f	struct:Eigen::internal::linspaced_op_impl
operator ()	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType row, IndexType col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op
operator ()	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar operator() (IndexType i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a) const { return !a; }$/;"	f	struct:Eigen::internal::scalar_boolean_not_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::ceil(a); }$/;"	f	struct:Eigen::internal::scalar_ceil_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::floor(a); }$/;"	f	struct:Eigen::internal::scalar_floor_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::round(a); }$/;"	f	struct:Eigen::internal::scalar_round_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scal&, const result_type& a) const { return a; }$/;"	f	struct:Eigen::internal::abs_knowing_score
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { using numext::arg; return arg(a); }$/;"	f	struct:Eigen::internal::scalar_arg_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a, const Score&) const { return numext::abs(a); }$/;"	f	struct:Eigen::internal::abs_knowing_score
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isfinite)(a); }$/;"	f	struct:Eigen::internal::scalar_isfinite_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isinf)(a); }$/;"	f	struct:Eigen::internal::scalar_isinf_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isnan)(a); }$/;"	f	struct:Eigen::internal::scalar_isnan_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return numext::cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { EIGEN_USING_STD_MATH(log10) return log10(a); }$/;"	f	struct:Eigen::internal::scalar_log10_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return Scalar(1)\/numext::sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_rsqrt_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::atan(a); }$/;"	f	struct:Eigen::internal::scalar_atan_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::cosh(a); }$/;"	f	struct:Eigen::internal::scalar_cosh_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log1p(a); }$/;"	f	struct:Eigen::internal::scalar_log1p_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sinh(a); }$/;"	f	struct:Eigen::internal::scalar_sinh_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const$/;"	f	struct:Eigen::internal::scalar_sign_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::tanh(a); }$/;"	f	struct:Eigen::internal::scalar_tanh_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { using numext::conj; return conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op
operator ()	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op
operator ()	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_lhs
operator ()	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_rhs
operator ()	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(const DataMapper& res, const LhsScalar* blockA, const RhsScalar* blockB,$/;"	f	class:Eigen::internal::gebp_kernel
operator ()	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor
operator ()	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* _res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha)$/;"	f	struct:Eigen::internal::tribb_kernel
operator ()	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs
operator ()	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs
operator ()	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_ALWAYS_INLINE Scalar& operator()(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
operator ()	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar operator()(Index i) const {$/;"	f	class:Eigen::internal::BlasVectorMapper
operator ()	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar& operator()(Index i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
operator ()	lib/Eigen/src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) const { return numext::conj(x); }$/;"	f	struct:Eigen::internal::conj_if
operator ()	lib/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) const { return x; }$/;"	f	struct:Eigen::internal::conj_if
operator ()	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag
operator ()	lib/Eigen/src/MetisSupport/MetisSupport.h	/^  void operator() (const MatrixType& A, PermutationType& matperm)$/;"	f	class:Eigen::MetisOrdering
operator ()	lib/Eigen/src/OrderingMethods/Ordering.h	/^    void operator() (const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::COLAMDOrdering
operator ()	lib/Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& \/*mat*\/, PermutationType& perm)$/;"	f	class:Eigen::NaturalOrdering
operator ()	lib/Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering
operator ()	lib/Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const SparseSelfAdjointView<SrcType, SrcUpLo>& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering
operator ()	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag
operator ()	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
operator ()	lib/Hadrons/Module.cc	/^void ModuleBase::operator()(void)$/;"	f	class:ModuleBase
operator ()	lib/algorithms/Preconditioner.h	/^    void operator()(const Field &src, Field & psi){$/;"	f	class:Grid::TrivialPrecon
operator ()	lib/algorithms/approx/Chebyshev.h	/^    void operator() (LinearOperatorBase<Field> &Linop, const Field &in, Field &out) {$/;"	f	class:Grid::Chebyshev
operator ()	lib/algorithms/approx/Chebyshev.h	/^    void operator() (LinearOperatorBase<Field> &Linop, const Field &in, Field &out) {$/;"	f	class:Grid::ChebyshevLanczos
operator ()	lib/algorithms/approx/Chebyshev.h	/^    void operator() (LinearOperatorBase<Field> &Linop, const Field &in, Field &out) {$/;"	f	class:Grid::HermOpOperatorFunction
operator ()	lib/algorithms/approx/Chebyshev.h	/^    void operator() (LinearOperatorBase<Field> &Linop, const Field &in, Field &out) {$/;"	f	class:Grid::Polynomial
operator ()	lib/algorithms/iterative/AdefGeneric.h	/^  void operator() (const Field &src, Field &psi){$/;"	f	class:TwoLevelFlexiblePcg
operator ()	lib/algorithms/iterative/BlockConjugateGradient.h	/^void operator()(LinearOperatorBase<Field> &Linop, const Field &Src, Field &Psi) $/;"	f	class:Grid::BlockConjugateGradient
operator ()	lib/algorithms/iterative/ConjugateGradient.h	/^  void operator()(LinearOperatorBase<Field> &Linop, const Field &src,$/;"	f	class:Grid::ConjugateGradient
operator ()	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    void operator() (const FieldD &src_d_in, FieldD &sol_d){$/;"	f	class:Grid::MixedPrecisionConjugateGradient
operator ()	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^void operator() (LinearOperatorBase<Field> &Linop, const Field &src, Field &psi)$/;"	f	class:Grid::ConjugateGradientMultiShift
operator ()	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^void operator() (LinearOperatorBase<Field> &Linop, const Field &src, std::vector<Field> &psi)$/;"	f	class:Grid::ConjugateGradientMultiShift
operator ()	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^void operator() (LinearOperatorBase<Field> &Linop, const Field &src, std::vector<Field> &results, Field &psi)$/;"	f	class:Grid::ConjugateGradientMultiShift
operator ()	lib/algorithms/iterative/ConjugateResidual.h	/^    void operator() (LinearOperatorBase<Field> &Linop,const Field &src, Field &psi){$/;"	f	class:Grid::ConjugateResidual
operator ()	lib/algorithms/iterative/NormalEquations.h	/^    void operator() (const Field &in, Field &out){$/;"	f	class:Grid::NormalEquations
operator ()	lib/algorithms/iterative/PrecConjugateResidual.h	/^    void operator() (LinearOperatorBase<Field> &Linop,const Field &src, Field &psi){$/;"	f	class:Grid::PrecConjugateResidual
operator ()	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    void operator() (LinearOperatorBase<Field> &Linop,const Field &src, Field &psi){$/;"	f	class:Grid::PrecGeneralisedConjugateResidual
operator ()	lib/algorithms/iterative/SchurRedBlack.h	/^      void operator() (Matrix & _Matrix,const Field &in, Field &out){$/;"	f	class:Grid::SchurRedBlackDiagMooeeSolve
operator ()	lib/json/json.hpp	/^    std::size_t operator()(const nlohmann::json& j) const$/;"	f	struct:std::hash
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    Integer operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::seq
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    Integer operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::sge
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    Integer operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::sgt
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    Integer operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::sle
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    Integer operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::slt
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    Integer operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::sne
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    vInteger operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::veq
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    vInteger operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::vge
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    vInteger operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::vgt
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    vInteger operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::vle
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    vInteger operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::vlt
operator ()	lib/lattice/Lattice_comparison_utils.h	/^    vInteger operator()(const lobj &lhs, const robj &rhs)$/;"	f	class:Grid::vne
operator ()	lib/parallelIO/MetaData.h	/^      void operator() (fobj &in,sobj &out){$/;"	f	struct:Grid::QCD::Gauge3x2munger
operator ()	lib/parallelIO/MetaData.h	/^      void operator() (sobj &in,fobj &out){$/;"	f	struct:Grid::QCD::Gauge3x2unmunger
operator ()	lib/parallelIO/MetaData.h	/^      void operator()(fobj &in, sobj &out) {$/;"	f	struct:Grid::QCD::GaugeSimpleMunger
operator ()	lib/parallelIO/MetaData.h	/^      void operator()(sobj &in, fobj &out) {$/;"	f	struct:Grid::QCD::GaugeSimpleUnmunger
operator ()	lib/parallelIO/MetaData.h	/^  void operator()(fobj &in, sobj &out) {$/;"	f	struct:Grid::QCD::BinarySimpleMunger
operator ()	lib/parallelIO/MetaData.h	/^  void operator()(sobj &in, fobj &out) {$/;"	f	struct:Grid::QCD::BinarySimpleUnmunger
operator ()	lib/pugixml/pugixml.cc	/^		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const$/;"	f	struct:document_order_comparator
operator ()	lib/pugixml/pugixml.cc	/^		bool operator()(const xpath_node& lhs, const xpath_node& rhs) const$/;"	f	struct:duplicate_comparator
operator ()	lib/pugixml/pugixml.cc	/^		bool operator()(xml_attribute a) const$/;"	f	struct:namespace_uri_predicate
operator ()	lib/pugixml/pugixml.cc	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:equal_to
operator ()	lib/pugixml/pugixml.cc	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:less
operator ()	lib/pugixml/pugixml.cc	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:less_equal
operator ()	lib/pugixml/pugixml.cc	/^		template <typename T> bool operator()(const T& lhs, const T& rhs) const$/;"	f	struct:not_equal_to
operator ()	lib/qcd/hmc/integrators/Integrator.h	/^    void operator()(std::vector<Action<FieldType>*> repr_set, Repr& Rep,$/;"	f	struct:Grid::QCD::Integrator::_S
operator ()	lib/qcd/hmc/integrators/Integrator.h	/^    void operator()(std::vector<Action<FieldType>*> repr_set, Repr& Rep,$/;"	f	struct:Grid::QCD::Integrator::_refresh
operator ()	lib/qcd/hmc/integrators/Integrator.h	/^    void operator()(std::vector<Action<FieldType>*> repr_set, Repr& Rep,$/;"	f	struct:Grid::QCD::Integrator::_updateP
operator ()	lib/simd/Grid_avx.h	/^    inline Grid::ComplexF Reduce<Grid::ComplexF, __m256>::operator()(__m256 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx.h	/^    inline Out_type operator()(In_type in){$/;"	f	struct:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(Grid::ComplexF *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 a, __m256 b) {$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 a, __m256 b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 a, __m256 b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 a, __m256 b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 a, __m256 b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 a, __m256 b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 a, __m256 b, __m256 c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 in, __m256 ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(__m256 in, __m256 ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(float *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(float a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx.h	/^    inline __m256 operator()(float a, float b) {$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(Grid::ComplexD *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d a, __m256d b) {$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d a, __m256d b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d a, __m256d b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d a, __m256d b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d a, __m256d b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d a, __m256d b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d a, __m256d b, __m256d c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d in, __m256d ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(__m256d in, __m256d ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(double *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(double a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx.h	/^    inline __m256d operator()(double a, double b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx.h	/^    inline __m256i operator()(Integer *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx.h	/^    inline __m256i operator()(Integer a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx.h	/^    inline __m256i operator()(__m256i a, __m256i b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_avx.h	/^    inline __m256i operator()(__m256i a, __m256i b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_avx.h	/^    inline __m256i operator()(__m256i a, __m256i b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_avx.h	/^    inline void operator()(__m256 a, float* F){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_avx.h	/^    inline void operator()(__m256d a, double* D){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_avx.h	/^    inline void operator()(__m256i a, Integer* I){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_avx.h	/^    inline void operator()(double * a, __m256d b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_avx.h	/^    inline void operator()(float * a, __m256 b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_avx.h	/^  inline Grid::ComplexD Reduce<Grid::ComplexD, __m256d>::operator()(__m256d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx.h	/^  inline Grid::RealD Reduce<Grid::RealD, __m256d>::operator()(__m256d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx.h	/^  inline Grid::RealF Reduce<Grid::RealF, __m256>::operator()(__m256 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx.h	/^  inline Integer Reduce<Integer, __m256i>::operator()(__m256i in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^    inline Grid::ComplexD Reduce<Grid::ComplexD, __m512d>::operator()(__m512d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^    inline Grid::ComplexF Reduce<Grid::ComplexF, __m512>::operator()(__m512 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^    inline Grid::RealD Reduce<Grid::RealD, __m512d>::operator()(__m512d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^    inline Grid::RealF Reduce<Grid::RealF, __m512>::operator()(__m512 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^    inline Out_type operator()(In_type in){$/;"	f	struct:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(Grid::ComplexF *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 a, __m512 b, __m512 c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 in, __m512 ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(__m512 in, __m512 ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(float *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(float a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512 operator()(float a, float b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(Grid::ComplexD *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d a, __m512d b, __m512d c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d in, __m512d ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(__m512d in, __m512d ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(double *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(double a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512d operator()(double a, double b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512i operator()(Integer *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512i operator()(Integer a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512i operator()(__m512i a, __m512i b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512i operator()(__m512i a, __m512i b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_avx512.h	/^    inline __m512i operator()(__m512i a, __m512i b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_avx512.h	/^    inline void operator()(__m512 a, float* F){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_avx512.h	/^    inline void operator()(__m512d a, double* D){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_avx512.h	/^    inline void operator()(__m512i a, Integer* I){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_avx512.h	/^    inline void operator()(double * a, __m512d b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_avx512.h	/^    inline void operator()(float * a, __m512 b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_avx512.h	/^  inline Grid::ComplexD Reduce<Grid::ComplexD, __m512d>::operator()(__m512d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^  inline Grid::ComplexF Reduce<Grid::ComplexF, __m512>::operator()(__m512 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^  inline Grid::RealD Reduce<Grid::RealD, __m512d>::operator()(__m512d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^  inline Grid::RealF Reduce<Grid::RealF, __m512>::operator()(__m512 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_avx512.h	/^  inline Integer Reduce<Integer, __m512i>::operator()(__m512i in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_generic.h	/^    inline Out_type operator()(In_type in){$/;"	f	struct:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(T *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(T a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(T a, T b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(std::complex<T> *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_generic.h	/^    inline vec<T> operator()(vec<T> a, vec<T> b, vec<T> c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_generic.h	/^    inline void operator()(T * a, vec<T> b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_generic.h	/^    inline void operator()(vec<T> a, T *D){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_generic.h	/^  inline Grid::ComplexD Reduce<Grid::ComplexD, vecd>::operator()(vecd in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_generic.h	/^  inline Grid::ComplexF Reduce<Grid::ComplexF, vecf>::operator()(vecf in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_generic.h	/^  inline Grid::RealD Reduce<Grid::RealD, vecd>::operator()(vecd in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_generic.h	/^  inline Grid::RealF Reduce<Grid::RealF, vecf>::operator()(vecf in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_generic.h	/^  inline Integer Reduce<Integer, veci>::operator()(veci in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_imci.h	/^    inline Out_type operator()(In_type in){$/;"	f	struct:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(Grid::ComplexF *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 a, __m512 b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 in, __m512 ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(__m512 in, __m512 ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(float *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(float a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_imci.h	/^    inline __m512 operator()(float a, float b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(Grid::ComplexD *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d a, __m512d b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d in, __m512d ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(__m512d in, __m512d ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(double *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(double a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_imci.h	/^    inline __m512d operator()(double a, double b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_imci.h	/^    inline __m512i operator()(Integer *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_imci.h	/^    inline __m512i operator()(Integer a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_imci.h	/^    inline __m512i operator()(__m512i a, __m512i b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_imci.h	/^    inline __m512i operator()(__m512i a, __m512i b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_imci.h	/^    inline __m512i operator()(__m512i a, __m512i b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_imci.h	/^    inline void operator()(__m512 a, float* F){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_imci.h	/^    inline void operator()(__m512d a, double* D){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_imci.h	/^    inline void operator()(__m512i a, Integer* I){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_imci.h	/^    inline void operator()(double * a, __m512d b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_imci.h	/^    inline void operator()(float * a, __m512 b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_imci.h	/^  inline Grid::ComplexD Reduce<Grid::ComplexD, __m512d>::operator()(__m512d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_imci.h	/^  inline Grid::ComplexF Reduce<Grid::ComplexF, __m512>::operator()(__m512 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_imci.h	/^  inline Grid::RealD Reduce<Grid::RealD, __m512d>::operator()(__m512d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_imci.h	/^  inline Grid::RealF Reduce<Grid::RealF, __m512>::operator()(__m512 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_imci.h	/^  inline Integer Reduce<Integer, __m512i>::operator()(__m512i in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_neon.h	/^      inline Out_type operator()(In_type in){$/;"	f	struct:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(Grid::ComplexF *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float a, float b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t a, float32x4_t b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t a, float32x4_t b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t a, float32x4_t b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t a, float32x4_t b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t a, float32x4_t b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t a, float32x4_t b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t a, float32x4_t b, float32x4_t c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t in, float32x4_t ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_neon.h	/^    inline float32x4_t operator()(float32x4_t in, float32x4_t ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(Grid::ComplexD *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(double *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(double a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(double a, double b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t a, float64x2_t b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t a, float64x2_t b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t a, float64x2_t b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t a, float64x2_t b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t a, float64x2_t b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t a, float64x2_t b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t a, float64x2_t b, float64x2_t c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t in, float64x2_t ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_neon.h	/^    inline float64x2_t operator()(float64x2_t in, float64x2_t ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_neon.h	/^    inline uint32x4_t operator()(Integer *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_neon.h	/^    inline uint32x4_t operator()(Integer a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_neon.h	/^    inline uint32x4_t operator()(uint32x4_t a, uint32x4_t b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_neon.h	/^    inline uint32x4_t operator()(uint32x4_t a, uint32x4_t b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_neon.h	/^    inline uint32x4_t operator()(uint32x4_t a, uint32x4_t b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_neon.h	/^    inline void operator()(double * a, float64x2_t b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_neon.h	/^    inline void operator()(float * a, float32x4_t b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_neon.h	/^    inline void operator()(float32x4_t a, float* F){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_neon.h	/^    inline void operator()(float64x2_t a, double* D){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_neon.h	/^    inline void operator()(uint32x4_t a, Integer* I){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_neon.h	/^  inline Grid::ComplexD Reduce<Grid::ComplexD, float64x2_t>::operator()(float64x2_t in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_neon.h	/^  inline Grid::ComplexF Reduce<Grid::ComplexF, float32x4_t>::operator()(float32x4_t in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_neon.h	/^  inline Grid::RealD Reduce<Grid::RealD, float64x2_t>::operator()(float64x2_t in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_neon.h	/^  inline Grid::RealF Reduce<Grid::RealF, float32x4_t>::operator()(float32x4_t in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_neon.h	/^  inline Integer Reduce<Integer, uint32x4_t>::operator()(uint32x4_t in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_qpx.h	/^    inline Out_type operator()(In_type in){$/;"	f	struct:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_qpx.h	/^    inline veci operator()(Integer *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_qpx.h	/^    inline veci operator()(Integer a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_qpx.h	/^    inline veci operator()(veci a, veci b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_qpx.h	/^    inline veci operator()(veci a, veci b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_qpx.h	/^    inline veci operator()(veci a, veci b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_qpx.h	/^    inline veci operator()(veci a, veci b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(Grid::ComplexD *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(double *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(double a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(double a, double b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double a, vector4double b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double a, vector4double b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double a, vector4double b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double a, vector4double b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double a, vector4double b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double a, vector4double b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double a, vector4double b,vector4double c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double v){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double v, vector4double ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4double v, vector4double ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4double operator()(vector4float a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4float operator()(Grid::ComplexF *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4float operator()(float *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4float operator()(float a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_qpx.h	/^    inline vector4float operator()(float a, float b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(double *d, vector4double a){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(float *f, vector4double a){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(float *f, vector4float a){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(veci a, Integer *i){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(vector4double a, double *d){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(vector4double a, float *f){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(vector4double a, vector4float &f){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(vector4float a, float *f){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_qpx.h	/^    inline void operator()(vector4float f, vector4double a){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_qpx.h	/^  Reduce<Grid::ComplexD, vector4double>::operator()(vector4double v){ \/\/2 complex$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_qpx.h	/^  Reduce<Grid::ComplexF, vector4float>::operator()(vector4float v) { \/\/2 complex$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_qpx.h	/^  Reduce<Grid::RealD, vector4double>::operator()(vector4double v){ \/\/4 doubles$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_qpx.h	/^  Reduce<Grid::RealF, vector4float>::operator()(vector4float v){ \/\/4 floats$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_qpx.h	/^  inline Integer Reduce<Integer, veci>::operator()(veci in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_sse4.h	/^    inline Out_type operator()(In_type in){$/;"	f	struct:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(Grid::ComplexF *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 a, __m128 b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 a, __m128 b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 a, __m128 b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 a, __m128 b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 a, __m128 b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 a, __m128 b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 a, __m128 b, __m128 c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 in, __m128 ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(__m128 in, __m128 ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(float *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(float a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128 operator()(float a, float b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(Grid::ComplexD *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d a, __m128d b){$/;"	f	struct:Grid::Optimization::Div
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d a, __m128d b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d a, __m128d b){$/;"	f	struct:Grid::Optimization::MultComplex
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d a, __m128d b){$/;"	f	struct:Grid::Optimization::MultRealPart
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d a, __m128d b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d a, __m128d b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d a, __m128d b, __m128d c){$/;"	f	struct:Grid::Optimization::MaddRealPart
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d in){$/;"	f	struct:Grid::Optimization::Conj
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d in, __m128d ret){$/;"	f	struct:Grid::Optimization::TimesI
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(__m128d in, __m128d ret){$/;"	f	struct:Grid::Optimization::TimesMinusI
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(double *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(double a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128d operator()(double a, double b){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128i operator()(Integer *a){$/;"	f	struct:Grid::Optimization::Vset
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128i operator()(Integer a){$/;"	f	struct:Grid::Optimization::Vsplat
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128i operator()(__m128i a, __m128i b){$/;"	f	struct:Grid::Optimization::Mult
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128i operator()(__m128i a, __m128i b){$/;"	f	struct:Grid::Optimization::Sub
operator ()	lib/simd/Grid_sse4.h	/^    inline __m128i operator()(__m128i a, __m128i b){$/;"	f	struct:Grid::Optimization::Sum
operator ()	lib/simd/Grid_sse4.h	/^    inline void operator()(__m128 a, float* F){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_sse4.h	/^    inline void operator()(__m128d a, double* D){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_sse4.h	/^    inline void operator()(__m128i a, Integer* I){$/;"	f	struct:Grid::Optimization::Vstore
operator ()	lib/simd/Grid_sse4.h	/^    inline void operator()(double * a, __m128d b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_sse4.h	/^    inline void operator()(float * a, __m128 b){$/;"	f	struct:Grid::Optimization::Vstream
operator ()	lib/simd/Grid_sse4.h	/^  inline Grid::ComplexD Reduce<Grid::ComplexD, __m128d>::operator()(__m128d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_sse4.h	/^  inline Grid::ComplexF Reduce<Grid::ComplexF, __m128>::operator()(__m128 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_sse4.h	/^  inline Grid::RealD Reduce<Grid::RealD, __m128d>::operator()(__m128d in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_sse4.h	/^  inline Grid::RealF Reduce<Grid::RealF, __m128>::operator()(__m128 in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_sse4.h	/^  inline Integer Reduce<Integer, __m128i>::operator()(__m128i in){$/;"	f	class:Grid::Optimization::Reduce
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return (!a); }$/;"	f	struct:Grid::NotFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return Integer(a) % y; }$/;"	f	struct:Grid::ModIntFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return Integer(a) \/ y; }$/;"	f	struct:Grid::DivIntFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return acos(real(a)); }$/;"	f	struct:Grid::AcosRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return asin(real(a)); }$/;"	f	struct:Grid::AsinRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return cos(real(a)); }$/;"	f	struct:Grid::CosRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return exp(a); }$/;"	f	struct:Grid::ExpFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return log(real(a)); }$/;"	f	struct:Grid::LogRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return pow(real(a), y); }$/;"	f	struct:Grid::PowRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return sin(real(a)); }$/;"	f	struct:Grid::SinRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return sqrt(real(a)); }$/;"	f	struct:Grid::SqrtRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return std::abs(real(a)); }$/;"	f	struct:Grid::AbsRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return std::imag(a); }$/;"	f	struct:Grid::ImagFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const { return std::real(a); }$/;"	f	struct:Grid::RealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &a) const {$/;"	f	struct:Grid::RSqrtRealFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &x, const scalar &y) const { return x & y; }$/;"	f	struct:Grid::AndFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &x, const scalar &y) const { return x && y; }$/;"	f	struct:Grid::AndAndFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &x, const scalar &y) const { return x | y; }$/;"	f	struct:Grid::OrFunctor
operator ()	lib/simd/Grid_vector_unops.h	/^  scalar operator()(const scalar &x, const scalar &y) const { return x || y; }$/;"	f	struct:Grid::OrOrFunctor
operator ()	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    uint32_t operator()()$/;"	f	class:sitmo::prng_engine
operator ()	lib/stencil/SimpleCompressor.h	/^  inline vobj operator() (const vobj &arg) {$/;"	f	class:Grid::SimpleCompressor
operator ()	lib/tensors/Tensor_class.h	/^  strong_inline const vtype &operator()(int i) const { return _internal[i]; }$/;"	f	class:Grid::iVector
operator ()	lib/tensors/Tensor_class.h	/^  strong_inline const vtype &operator()(int i, int j) const {$/;"	f	class:Grid::iMatrix
operator ()	lib/tensors/Tensor_class.h	/^  strong_inline const vtype &operator()(void) const { return _internal; }$/;"	f	class:Grid::iScalar
operator ()	lib/tensors/Tensor_class.h	/^  strong_inline vtype &operator()(int i) { return _internal[i]; }$/;"	f	class:Grid::iVector
operator ()	lib/tensors/Tensor_class.h	/^  strong_inline vtype &operator()(int i, int j) { return _internal[i][j]; }$/;"	f	class:Grid::iMatrix
operator ()	lib/tensors/Tensor_class.h	/^  strong_inline vtype &operator()(void) { return _internal; }$/;"	f	class:Grid::iScalar
operator ()	tests/Test_simd.cc	/^  template<class vec>    void operator()(vec &r1,vec &r2,vec &i1,vec &i2) const { exchange(r1,r2,i1,i2,n);}$/;"	f	class:funcExchange
operator ()	tests/Test_simd.cc	/^  template<class vec>    void operator()(vec &rr,vec &i1,vec &i2) const { permute(rr,i1,n);}$/;"	f	class:funcPermute
operator ()	tests/Test_simd.cc	/^  template<class vec>    void operator()(vec &rr,vec &i1,vec &i2) const { rr=rotate(i1,n);}$/;"	f	class:funcRotate
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = adj(i1);}$/;"	f	class:funcAdj
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = conjugate(i1);}$/;"	f	class:funcConj
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = i1*i2;}$/;"	f	class:funcTimes
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = i1+i2;}$/;"	f	class:funcPlus
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = i1-i2;}$/;"	f	class:funcMinus
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = i1\/i2;}$/;"	f	class:funcDivide
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = imag(i1);}$/;"	f	class:funcImag
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = innerProduct(i1,i2);}$/;"	f	class:funcInnerProduct
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = real(i1);}$/;"	f	class:funcReal
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = timesI(i1);}$/;"	f	class:funcTimesI
operator ()	tests/Test_simd.cc	/^  template<class vec> void operator()(vec &rr,vec &i1,vec &i2) const { rr = timesMinusI(i1);}$/;"	f	class:funcTimesMinusI
operator ()	tests/debug/test_Grid_jacobi.cc	/^  operator () (const Lattice<vobj>&src,Lattice<vobj> &result) {};$/;"	f	class:LinearOperator
operator ()	tests/debug/test_Grid_jacobi.cc	/^  operator () (const Lattice<vobj>&src,Lattice<vobj> &result)$/;"	f	class:LinearOperatorJacobi	file:
operator ()	tests/solver/Test_dwf_hdcr.cc	/^  void operator()(const FineField &in, FineField & out) {$/;"	f	class:MultiGridPreconditioner
operator *	lib/Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase
operator *	lib/Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar) const$/;"	f	class:Eigen::DiagonalBase
operator *	lib/Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar, const DiagonalBase& other)$/;"	f	class:Eigen::DiagonalBase
operator *	lib/Eigen/src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &a_diagonal) const$/;"	f	class:Eigen::MatrixBase
operator *	lib/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
operator *	lib/Eigen/src/Core/MatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
operator *	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const InverseImpl<Other, PermutationStorage>& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase
operator *	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const InverseImpl<Other,PermutationStorage>& other) const$/;"	f	class:Eigen::PermutationBase
operator *	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase
operator *	lib/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::InverseImpl
operator *	lib/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const InverseType& trPerm)$/;"	f	class:Eigen::InverseImpl
operator *	lib/Eigen/src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<MatrixDerived> &matrix,$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView
operator *	lib/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView
operator *	lib/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const Scalar& s, const SelfAdjointView& mat)$/;"	f	class:Eigen::SelfAdjointView
operator *	lib/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose
operator *	lib/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose
operator *	lib/Eigen/src/Core/Transpositions.h	/^operator*(const MatrixBase<MatrixDerived> &matrix,$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionsDerived> &transpositions,$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularViewImpl& rhs)$/;"	f	class:Eigen::TriangularViewImpl
operator *	lib/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularViewImpl
operator *	lib/Eigen/src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator *	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half operator * (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator *	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis
operator *	lib/Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis
operator *	lib/Eigen/src/Geometry/AngleAxis.h	/^  friend EIGEN_DEVICE_FUNC inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	lib/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	lib/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous
operator *	lib/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	lib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
operator *	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D
operator *	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
operator *	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase
operator *	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase
operator *	lib/Eigen/src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase
operator *	lib/Eigen/src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling
operator *	lib/Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	lib/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling
operator *	lib/Eigen/src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling
operator *	lib/Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	lib/Eigen/src/Geometry/Scaling.h	/^operator*(const MatrixBase<Derived>& matrix, const UniformScaling<Scalar>& s)$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^  inline TransformTimeDiagonalReturnType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform
operator *	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation
operator *	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation
operator *	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation
operator *	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation
operator *	lib/Eigen/src/Geometry/Translation.h	/^  operator* (const MatrixBase<Derived>& vec) const$/;"	f	class:Eigen::Translation
operator *	lib/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation
operator *	lib/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation
operator *	lib/Eigen/src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence
operator *	lib/Eigen/src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation
operator *	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQReturnType
operator *	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType
operator *	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	lib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const InverseImpl<PermutationType,PermutationStorage>& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const InverseImpl<PermutationType, PermutationStorage>& tperm)$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen
operator *	lib/Eigen/src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	lib/Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
operator *	lib/Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType
operator *	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator*(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator *	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator*(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator *	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator*(const bigfloat& x, const unsigned long y) {$/;"	f	class:bigfloat
operator *	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator*(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator *	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator*(const bigfloat& x, const unsigned long y) {$/;"	f	class:bigfloat
operator *	lib/json/json.hpp	/^            iteration_proxy_internal& operator*()$/;"	f	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
operator *	lib/json/json.hpp	/^        reference operator*() const$/;"	f	class:nlohmann::basic_json::iter_impl
operator *	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute_iterator::operator*() const$/;"	f	class:pugi::xml_attribute_iterator
operator *	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node& xml_named_node_iterator::operator*() const$/;"	f	class:pugi::xml_named_node_iterator
operator *	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node& xml_node_iterator::operator*() const$/;"	f	class:pugi::xml_node_iterator
operator *	lib/qcd/spin/Dirac.h	/^inline Gamma operator*(const Gamma &g1, const Gamma &g2)$/;"	f	namespace:Grid::QCD
operator *	lib/simd/Grid_vector_types.h	/^  friend inline Grid_simd operator*(Grid_simd b, const Scalar_type &a) {$/;"	f	class:Grid::Grid_simd
operator *	lib/simd/Grid_vector_types.h	/^  friend inline Grid_simd operator*(const Scalar_type &a, Grid_simd b) {$/;"	f	class:Grid::Grid_simd
operator *	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> operator*(Grid_simd<S, V> a, Grid_simd<S, V> b) {$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_mul.h	/^iVector<rtype,N> operator * (const iMatrix<mtype,N>& lhs,const iVector<vtype,N>& rhs)$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_mul.h	/^iVector<rtype,N> operator * (const iScalar<mtype>& lhs,const iVector<vtype,N>& rhs)$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_mul.h	/^iVector<rtype,N> operator * (const iVector<mtype,N>& lhs,const iScalar<vtype>& rhs)$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (ComplexD lhs,const iMatrix<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (Integer lhs,const iMatrix<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (const iMatrix<l,N>& lhs,ComplexD rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (const iMatrix<l,N>& lhs,Integer rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (const iMatrix<l,N>& lhs,const typename iScalar<l>::scalar_type &rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (const iMatrix<l,N>& lhs,double rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (const typename iScalar<l>::scalar_type & lhs,const iMatrix<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator * (double lhs,const iMatrix<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (ComplexD lhs,const iVector<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (Integer lhs,const iVector<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (const iVector<l,N>& lhs,ComplexD rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (const iVector<l,N>& lhs,Integer rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (const iVector<l,N>& lhs,const typename iScalar<l>::scalar_type rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (const iVector<l,N>& lhs,double rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (const typename iScalar<l>::scalar_type lhs,const iVector<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iVector<l,N> operator * (double lhs,const iVector<l,N>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (ComplexD lhs,const iScalar<l>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (Integer lhs,const iScalar<l>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (const iScalar<l>& lhs,ComplexD rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (const iScalar<l>& lhs,Integer rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (const iScalar<l>& lhs,const typename iScalar<l>::scalar_type rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (const iScalar<l>& lhs,double rhs) $/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (const typename iScalar<l>::scalar_type lhs,const iScalar<l>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator * (double lhs,const iScalar<l>& rhs) {  return rhs*lhs; }$/;"	f	namespace:Grid
operator *=	lib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator *=	lib/Eigen/src/Core/MatrixBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator *=	lib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator *=	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() * other; }$/;"	f	class:Eigen::TriangularViewImpl
operator *=	lib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator *=	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half& operator *= (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator *=	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator *=	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D
operator *=	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform
operator *=	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform
operator *=	lib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linearExt() *= s; return *this; }$/;"	f	class:Eigen::Transform
operator *=	lib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform
operator *=	lib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform
operator *=	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator *=	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator*=(const bigfloat& y) { return *this = *this * y; }$/;"	f	class:bigfloat
operator *=	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator*=(const bigfloat& y) { return *this = *this * y; }$/;"	f	class:bigfloat
operator *=	lib/lattice/Lattice_base.h	/^  template<class T> strong_inline Lattice<vobj> &operator *=(const T &r) {$/;"	f	class:Grid::Lattice
operator *=	lib/simd/Grid_vector_types.h	/^  inline Grid_simd &operator*=(const Grid_simd &r) {$/;"	f	class:Grid::Grid_simd
operator *=	lib/tensors/Tensor_class.h	/^  strong_inline iMatrix<vtype, N> &operator*=(const T &r) {$/;"	f	class:Grid::iMatrix
operator *=	lib/tensors/Tensor_class.h	/^  strong_inline iScalar<vtype> &operator*=(const iScalar<vtype> &r) {$/;"	f	class:Grid::iScalar
operator *=	lib/tensors/Tensor_class.h	/^  strong_inline iVector<vtype, N> &operator*=(const iScalar<vtype> &r) {$/;"	f	class:Grid::iVector
operator +	lib/Eigen/src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator +	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half operator + (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator +	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator+(const MatrixBase<DenseDerived> &a, const SparseMatrixBase<SparseDerived> &b)$/;"	f	namespace:Eigen
operator +	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator+(const SparseMatrixBase<SparseDerived> &a, const MatrixBase<DenseDerived> &b)$/;"	f	namespace:Eigen
operator +	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator+(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator +	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator+(const bigfloat& x, const unsigned long y) {$/;"	f	class:bigfloat
operator +	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator+(const bigfloat& x, const bigfloat& y) { $/;"	f	class:bigfloat
operator +	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator+(const bigfloat& x, const unsigned long y) {$/;"	f	class:bigfloat
operator +	lib/json/json.hpp	/^        iter_impl operator+(difference_type i)$/;"	f	class:nlohmann::basic_json::iter_impl
operator +	lib/json/json.hpp	/^        json_reverse_iterator operator+(difference_type i) const$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator +	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> operator+(Grid_simd<S, V> a, Grid_simd<S, V> b) {$/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator + (Integer lhs,const iMatrix<l,N>& rhs) {  return rhs+lhs; }$/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator + (const iMatrix<l,N>& lhs,Integer rhs) $/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator + (const iMatrix<l,N>& lhs,const typename iScalar<l>::scalar_type rhs) $/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator + (const iMatrix<l,N>& lhs,double rhs) $/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator + (const typename iScalar<l>::scalar_type lhs,const iMatrix<l,N>& rhs) {  return rhs+lhs; }$/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator + (double lhs,const iMatrix<l,N>& rhs) {  return rhs+lhs; }$/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator + (Integer lhs,const iScalar<l>& rhs) {  return rhs+lhs; }$/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator + (const iScalar<l>& lhs,Integer rhs) $/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator + (const iScalar<l>& lhs,const typename iScalar<l>::scalar_type rhs) $/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator + (const iScalar<l>& lhs,double rhs) $/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator + (const typename iScalar<l>::scalar_type lhs,const iScalar<l>& rhs) {  return rhs+lhs; }$/;"	f	namespace:Grid
operator +	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator + (double lhs,const iScalar<l>& rhs) {  return rhs+lhs; }$/;"	f	namespace:Grid
operator ++	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()   { m_iter.operator++(); return *this; }$/;"	f	class:Eigen::InnerIterator
operator ++	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE inner_iterator_selector& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::internal::inner_iterator_selector
operator ++	lib/Eigen/src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator ++	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline OuterVectorInnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
operator ++	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
operator ++	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
operator ++	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator ++	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator ++	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { ++m_sparseIter; return *this; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
operator ++	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator ++	lib/Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator ++	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline InnerIterator& operator++()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
operator ++	lib/json/json.hpp	/^            iteration_proxy_internal& operator++()$/;"	f	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
operator ++	lib/json/json.hpp	/^        iter_impl operator++(int)$/;"	f	class:nlohmann::basic_json::iter_impl
operator ++	lib/json/json.hpp	/^        iter_impl& operator++()$/;"	f	class:nlohmann::basic_json::iter_impl
operator ++	lib/json/json.hpp	/^        json_reverse_iterator operator++(int)$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator ++	lib/json/json.hpp	/^        json_reverse_iterator& operator++()$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator ++	lib/pugixml/pugixml.cc	/^	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator++()$/;"	f	class:pugi::xml_attribute_iterator
operator ++	lib/pugixml/pugixml.cc	/^	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator++()$/;"	f	class:pugi::xml_named_node_iterator
operator ++	lib/pugixml/pugixml.cc	/^	PUGI__FN const xml_node_iterator& xml_node_iterator::operator++()$/;"	f	class:pugi::xml_node_iterator
operator ++	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator++(int)$/;"	f	class:pugi::xml_attribute_iterator
operator ++	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator++(int)$/;"	f	class:pugi::xml_named_node_iterator
operator ++	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_iterator xml_node_iterator::operator++(int)$/;"	f	class:pugi::xml_node_iterator
operator +=	lib/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator +=	lib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator +=	lib/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator +=	lib/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator +=	lib/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator +=	lib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator +=	lib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_STRONG_INLINE Derived& ArrayBase<Derived>::operator+=(const Scalar& other)$/;"	f	class:Eigen::ArrayBase
operator +=	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator+=(const DenseBase<Other>& other) {$/;"	f	class:Eigen::TriangularViewImpl
operator +=	lib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator +=	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half& operator += (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator +=	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator+=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator+=(const bigfloat& y) { return *this = *this + y; }$/;"	f	class:bigfloat
operator +=	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator+=(const bigfloat& y) { return *this = *this + y; }$/;"	f	class:bigfloat
operator +=	lib/json/json.hpp	/^        iter_impl& operator+=(difference_type i)$/;"	f	class:nlohmann::basic_json::iter_impl
operator +=	lib/json/json.hpp	/^        json_reverse_iterator& operator+=(difference_type i)$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator +=	lib/json/json.hpp	/^    reference operator+=(basic_json&& val)$/;"	f	class:nlohmann::basic_json
operator +=	lib/json/json.hpp	/^    reference operator+=(const basic_json& val)$/;"	f	class:nlohmann::basic_json
operator +=	lib/json/json.hpp	/^    reference operator+=(const typename object_t::value_type& val)$/;"	f	class:nlohmann::basic_json
operator +=	lib/json/json.hpp	/^    reference operator+=(std::initializer_list<basic_json> init)$/;"	f	class:nlohmann::basic_json
operator +=	lib/lattice/Lattice_base.h	/^  template<class T> strong_inline Lattice<vobj> &operator +=(const T &r) {$/;"	f	class:Grid::Lattice
operator +=	lib/simd/Grid_vector_types.h	/^  inline Grid_simd &operator+=(const Grid_simd &r) {$/;"	f	class:Grid::Grid_simd
operator +=	lib/tensors/Tensor_class.h	/^  strong_inline iMatrix<vtype, N> &operator+=(const T &r) {$/;"	f	class:Grid::iMatrix
operator +=	lib/tensors/Tensor_class.h	/^  strong_inline iScalar<vtype> &operator+=(const iScalar<vtype> &r) {$/;"	f	class:Grid::iScalar
operator +=	lib/tensors/Tensor_class.h	/^  strong_inline iVector<vtype, N> &operator+=(const iVector<vtype, N> &r) {$/;"	f	class:Grid::iVector
operator ,	lib/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
operator ,	lib/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
operator -	lib/Eigen/src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator -	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half operator - (const half& a) {$/;"	f	namespace:Eigen::half_impl
operator -	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half operator - (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator -	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator-(const MatrixBase<DenseDerived> &a, const SparseMatrixBase<SparseDerived> &b)$/;"	f	namespace:Eigen
operator -	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator-(const SparseMatrixBase<SparseDerived> &a, const MatrixBase<DenseDerived> &b)$/;"	f	namespace:Eigen
operator -	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator-() const { return NegativeReturnType(derived()); }$/;"	f
operator -	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator-(const bigfloat& x) {$/;"	f	class:bigfloat
operator -	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator-(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator -	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator-(const bigfloat& x, const unsigned long y) {$/;"	f	class:bigfloat
operator -	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator-(const unsigned long x, const bigfloat& y) {$/;"	f	class:bigfloat
operator -	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator-(const bigfloat& x) {$/;"	f	class:bigfloat
operator -	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator-(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator -	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator-(const bigfloat& x, const unsigned long y) {$/;"	f	class:bigfloat
operator -	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator-(const unsigned long x, const bigfloat& y) {$/;"	f	class:bigfloat
operator -	lib/json/json.hpp	/^        difference_type operator-(const iter_impl& other) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator -	lib/json/json.hpp	/^        difference_type operator-(const json_reverse_iterator& other) const$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator -	lib/json/json.hpp	/^        iter_impl operator-(difference_type i)$/;"	f	class:nlohmann::basic_json::iter_impl
operator -	lib/json/json.hpp	/^        json_reverse_iterator operator-(difference_type i) const$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator -	lib/lattice/Lattice_overload.h	/^  inline Lattice<vobj> operator -(const Lattice<vobj> &r)$/;"	f	namespace:Grid
operator -	lib/simd/Grid_vector_types.h	/^  friend inline Grid_simd operator-(const Grid_simd &r) {$/;"	f	class:Grid::Grid_simd
operator -	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> operator-(Grid_simd<S, V> a, Grid_simd<S, V> b) {$/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator - (Integer lhs,const iMatrix<l,N>& rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator - (const iMatrix<l,N>& lhs,Integer rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator - (const iMatrix<l,N>& lhs,const typename iScalar<l>::scalar_type rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator - (const iMatrix<l,N>& lhs,double rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator - (const typename iScalar<l>::scalar_type lhs,const iMatrix<l,N>& rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l,int N> strong_inline iMatrix<l,N> operator - (double lhs,const iMatrix<l,N>& rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator - (Integer lhs,const iScalar<l>& rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator - (const iScalar<l>& lhs,Integer rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator - (const iScalar<l>& lhs,const typename iScalar<l>::scalar_type rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator - (const iScalar<l>& lhs,double rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator - (const typename iScalar<l>::scalar_type lhs,const iScalar<l>& rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_arith_scalar.h	/^template<class l> strong_inline iScalar<l> operator - (double lhs,const iScalar<l>& rhs) $/;"	f	namespace:Grid
operator -	lib/tensors/Tensor_class.h	/^  friend strong_inline iMatrix<vtype, N> operator-(const iMatrix<vtype, N> &r) {$/;"	f	class:Grid::iMatrix
operator -	lib/tensors/Tensor_class.h	/^  friend strong_inline iScalar<vtype> operator-(const iScalar<vtype> &r) {$/;"	f	class:Grid::iScalar
operator -	lib/tensors/Tensor_class.h	/^  friend strong_inline iVector<vtype, N> operator-(const iVector<vtype, N> &r) {$/;"	f	class:Grid::iVector
operator --	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
operator --	lib/json/json.hpp	/^        iter_impl operator--(int)$/;"	f	class:nlohmann::basic_json::iter_impl
operator --	lib/json/json.hpp	/^        iter_impl& operator--()$/;"	f	class:nlohmann::basic_json::iter_impl
operator --	lib/json/json.hpp	/^        json_reverse_iterator operator--(int)$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator --	lib/json/json.hpp	/^        json_reverse_iterator& operator--()$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator --	lib/pugixml/pugixml.cc	/^	PUGI__FN const xml_attribute_iterator& xml_attribute_iterator::operator--()$/;"	f	class:pugi::xml_attribute_iterator
operator --	lib/pugixml/pugixml.cc	/^	PUGI__FN const xml_named_node_iterator& xml_named_node_iterator::operator--()$/;"	f	class:pugi::xml_named_node_iterator
operator --	lib/pugixml/pugixml.cc	/^	PUGI__FN const xml_node_iterator& xml_node_iterator::operator--()$/;"	f	class:pugi::xml_node_iterator
operator --	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute_iterator xml_attribute_iterator::operator--(int)$/;"	f	class:pugi::xml_attribute_iterator
operator --	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_named_node_iterator xml_named_node_iterator::operator--(int)$/;"	f	class:pugi::xml_named_node_iterator
operator --	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_iterator xml_node_iterator::operator--(int)$/;"	f	class:pugi::xml_node_iterator
operator -=	lib/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator -=	lib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase
operator -=	lib/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator -=	lib/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator -=	lib/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator -=	lib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator -=	lib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_STRONG_INLINE Derived& ArrayBase<Derived>::operator-=(const Scalar& other)$/;"	f	class:Eigen::ArrayBase
operator -=	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator-=(const DenseBase<Other>& other) {$/;"	f	class:Eigen::TriangularViewImpl
operator -=	lib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator -=	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half& operator -= (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator -=	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator-=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator-=(const bigfloat& y) { return *this = *this - y; }$/;"	f	class:bigfloat
operator -=	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator-=(const bigfloat& y) { return *this = *this - y; }$/;"	f	class:bigfloat
operator -=	lib/json/json.hpp	/^        iter_impl& operator-=(difference_type i)$/;"	f	class:nlohmann::basic_json::iter_impl
operator -=	lib/lattice/Lattice_base.h	/^  template<class T> strong_inline Lattice<vobj> &operator -=(const T &r) {$/;"	f	class:Grid::Lattice
operator -=	lib/simd/Grid_vector_types.h	/^  inline Grid_simd &operator-=(const Grid_simd &r) {$/;"	f	class:Grid::Grid_simd
operator -=	lib/tensors/Tensor_class.h	/^  strong_inline iMatrix<vtype, N> &operator-=(const T &r) {$/;"	f	class:Grid::iMatrix
operator -=	lib/tensors/Tensor_class.h	/^  strong_inline iScalar<vtype> &operator-=(const iScalar<vtype> &r) {$/;"	f	class:Grid::iScalar
operator -=	lib/tensors/Tensor_class.h	/^  strong_inline iVector<vtype, N> &operator-=(const iVector<vtype, N> &r) {$/;"	f	class:Grid::iVector
operator ->	lib/json/json.hpp	/^        pointer operator->() const$/;"	f	class:nlohmann::basic_json::iter_impl
operator ->	lib/pugixml/pugixml.cc	/^		T* operator->() const$/;"	f	class:compact_pointer
operator ->	lib/pugixml/pugixml.cc	/^		T* operator->() const$/;"	f	class:compact_pointer_parent
operator ->	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute* xml_attribute_iterator::operator->() const$/;"	f	class:pugi::xml_attribute_iterator
operator ->	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node* xml_named_node_iterator::operator->() const$/;"	f	class:pugi::xml_named_node_iterator
operator ->	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node* xml_node_iterator::operator->() const$/;"	f	class:pugi::xml_node_iterator
operator /	lib/Eigen/src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator /	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator \/ (const half& a, Index b) {$/;"	f	namespace:Eigen::half_impl
operator /	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half operator \/ (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator /	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator\/(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator /	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator\/(const bigfloat& x, const bigfloat& y){$/;"	f	class:bigfloat
operator /	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator\/(const bigfloat& x, const unsigned long y){$/;"	f	class:bigfloat
operator /	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat operator\/(const unsigned long x, const bigfloat& y){$/;"	f	class:bigfloat
operator /	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator\/(const bigfloat& x, const bigfloat& y){$/;"	f	class:bigfloat
operator /	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator\/(const bigfloat& x, const unsigned long y){$/;"	f	class:bigfloat
operator /	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat operator\/(const unsigned long x, const bigfloat& y){$/;"	f	class:bigfloat
operator /	lib/simd/Grid_vector_types.h	/^  friend inline Grid_simd operator\/(Grid_simd b, const Scalar_type &a) {$/;"	f	class:Grid::Grid_simd
operator /	lib/simd/Grid_vector_types.h	/^  friend inline Grid_simd operator\/(const Scalar_type &a, Grid_simd b) {$/;"	f	class:Grid::Grid_simd
operator /	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> operator\/(Grid_simd<S, V> a, Grid_simd<S, V> b) {$/;"	f	namespace:Grid
operator /	lib/tensors/Tensor_arith_mul.h	/^iMatrix<rtype,N> operator \/ (const iMatrix<rtype,N>& lhs,const iScalar<vtype>& rhs)$/;"	f	namespace:Grid
operator /	lib/tensors/Tensor_arith_mul.h	/^iScalar<rtype> operator \/ (const iScalar<rtype>& lhs,const iScalar<vtype>& rhs)$/;"	f	namespace:Grid
operator /	lib/tensors/Tensor_arith_mul.h	/^iVector<rtype,N> operator \/ (const iVector<rtype,N>& lhs,const iScalar<vtype>& rhs)$/;"	f	namespace:Grid
operator /=	lib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator /=	lib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator /=	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() \/ other; }$/;"	f	class:Eigen::TriangularViewImpl
operator /=	lib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator /=	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ half& operator \/= (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator /=	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator /=	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator\/=(const bigfloat& y) { return *this = *this \/ y; }$/;"	f	class:bigfloat
operator /=	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator\/=(const bigfloat& y) { return *this = *this \/ y; }$/;"	f	class:bigfloat
operator <	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ bool operator < (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator <	lib/algorithms/approx/bigfloat.h	/^  friend int operator<(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator <	lib/algorithms/approx/bigfloat_double.h	/^  friend int operator<(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator <	lib/json/json.hpp	/^        bool operator<(const iter_impl& other) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator <	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator < (const Lattice<lobj> & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator <	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator < (const Lattice<lobj> & lhs, const robj & rhs) {$/;"	f	namespace:Grid
operator <	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator < (const lobj & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator <	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::operator<(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute
operator <	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::operator<(const xml_node& r) const$/;"	f	class:pugi::xml_node
operator <<	extras/Hadrons/GeneticScheduler.hpp	/^    friend std::ostream & operator<<(std::ostream &out,$/;"	f	class:GeneticScheduler
operator <<	extras/Hadrons/Graph.hpp	/^    friend std::ostream & operator<<(std::ostream &out, const Graph<T> &g)$/;"	f	class:Graph
operator <<	extras/Hadrons/Graph.hpp	/^std::ostream & operator<<(std::ostream &out, const std::pair<T, T> &e)$/;"	f
operator <<	lib/Eigen/src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator <<	lib/Eigen/src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase
operator <<	lib/Eigen/src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat
operator <<	lib/Eigen/src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen
operator <<	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet16uc & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2d & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2l & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4f & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4i & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4ui & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_ALWAYS_INLINE std::ostream& operator << (std::ostream& os, const half& v) {$/;"	f	namespace:Eigen::half_impl
operator <<	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2d & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2l & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2ul & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4i & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4ui & v)$/;"	f	namespace:Eigen::internal
operator <<	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix
operator <<	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase
operator <<	lib/Eigen/src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector
operator <<	lib/Hadrons/GeneticScheduler.hpp	/^    friend std::ostream & operator<<(std::ostream &out,$/;"	f	class:GeneticScheduler
operator <<	lib/Hadrons/Graph.hpp	/^    friend std::ostream & operator<<(std::ostream &out, const Graph<T> &g)$/;"	f	class:Graph
operator <<	lib/Hadrons/Graph.hpp	/^std::ostream & operator<<(std::ostream &out, const std::pair<T, T> &e)$/;"	f
operator <<	lib/json/json.hpp	/^    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)$/;"	f	class:nlohmann::basic_json
operator <<	lib/lattice/Lattice_base.h	/^  template<class vobj> std::ostream& operator<< (std::ostream& stream, const Lattice<vobj> &o){$/;"	f	namespace:Grid
operator <<	lib/log/Log.h	/^  friend std::ostream& operator<< (std::ostream& stream, Logger& log){$/;"	f	class:Grid::Logger
operator <<	lib/perfmon/Timer.h	/^inline std::ostream& operator<< (std::ostream & stream, const std::chrono::milliseconds & time)$/;"	f	namespace:Grid
operator <<	lib/serialisation/BaseIO.h	/^    friend inline std::ostream & operator<<(std::ostream &os,$/;"	f	class:Grid::Serializable
operator <<	lib/serialisation/BaseIO.h	/^  inline std::ostream & operator<<(std::ostream &os, const std::pair<T1, T2> &p)$/;"	f	namespace:Grid
operator <<	lib/serialisation/BaseIO.h	/^  inline std::ostream & operator<<(std::ostream &os, const std::vector<T> &v)$/;"	f	namespace:Grid
operator <<	lib/simd/Grid_qpx.h	/^  inline std::ostream & operator<<(std::ostream& stream, const vector4double a)$/;"	f	namespace:Grid::Optimization
operator <<	lib/simd/Grid_qpx.h	/^  inline std::ostream & operator<<(std::ostream& stream, const vector4float a)$/;"	f	namespace:Grid::Optimization
operator <<	lib/simd/Simd.h	/^  inline std::ostream& operator<< (std::ostream& stream, const vComplexD &o){$/;"	f	namespace:Grid
operator <<	lib/simd/Simd.h	/^  inline std::ostream& operator<< (std::ostream& stream, const vComplexF &o){$/;"	f	namespace:Grid
operator <<	lib/simd/Simd.h	/^  inline std::ostream& operator<< (std::ostream& stream, const vInteger &o){$/;"	f	namespace:Grid
operator <<	lib/simd/Simd.h	/^  inline std::ostream& operator<< (std::ostream& stream, const vRealD &o){$/;"	f	namespace:Grid
operator <<	lib/simd/Simd.h	/^  inline std::ostream& operator<< (std::ostream& stream, const vRealF &o){$/;"	f	namespace:Grid
operator <<	lib/sitmo_rng/sitmo_prng_engine.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os, const prng_engine& s) {$/;"	f	class:sitmo::prng_engine
operator <<	lib/tensors/Tensor_class.h	/^  friend std::ostream &operator<<(std::ostream &stream,$/;"	f	class:Grid::iMatrix
operator <<	lib/tensors/Tensor_class.h	/^  friend std::ostream &operator<<(std::ostream &stream,$/;"	f	class:Grid::iVector
operator <<	lib/tensors/Tensor_class.h	/^  friend std::ostream &operator<<(std::ostream &stream,const iScalar<vtype> &o) {$/;"	f	class:Grid::iScalar
operator <=	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ bool operator <= (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator <=	lib/json/json.hpp	/^        bool operator<=(const iter_impl& other) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator <=	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator <= (const Lattice<lobj> & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator <=	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator <= (const Lattice<lobj> & lhs, const robj & rhs) {$/;"	f	namespace:Grid
operator <=	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator <= (const lobj & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator <=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::operator<=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute
operator <=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::operator<=(const xml_node& r) const$/;"	f	class:pugi::xml_node
operator =	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array
operator =	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::Array
operator =	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array
operator =	lib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Scalar &value)$/;"	f	class:Eigen::Array
operator =	lib/Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase
operator =	lib/Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const Scalar &value)$/;"	f	class:Eigen::ArrayBase
operator =	lib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase
operator =	lib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	lib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	lib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	lib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase
operator =	lib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	lib/Eigen/src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
operator =	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other) $/;"	f	class:Eigen::DenseStorage
operator =	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
operator =	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) { return *this; }$/;"	f	class:Eigen::DenseStorage
operator =	lib/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	lib/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	lib/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator =	lib/Eigen/src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase
operator =	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
operator =	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
operator =	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix
operator =	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix
operator =	lib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	lib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
operator =	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
operator =	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase
operator =	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase
operator =	lib/Eigen/src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable
operator =	lib/Eigen/src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	lib/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	lib/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	lib/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	lib/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map
operator =	lib/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions
operator =	lib/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
operator =	lib/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	lib/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView &other)$/;"	f	class:Eigen::TriangularView
operator =	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& operator=(const TriangularViewImpl& other)$/;"	f	class:Eigen::TriangularViewImpl
operator =	lib/Eigen/src/Core/TriangularMatrix.h	/^TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
operator =	lib/Eigen/src/Core/TriangularMatrix.h	/^TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
operator =	lib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator =	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half& operator=(const half& other) {$/;"	f	struct:Eigen::half
operator =	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE eigen_packet_wrapper& operator=(const T &v) {$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator =	lib/Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
operator =	lib/Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis
operator =	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase
operator =	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase
operator =	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC Rotation2D& operator=(const  MatrixBase<Derived>& m)$/;"	f	class:Eigen::Rotation2D
operator =	lib/Eigen/src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
operator =	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform
operator =	lib/Eigen/src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation
operator =	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
operator =	lib/Eigen/src/SparseCore/SparseAssign.h	/^Derived& SparseMatrixBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	lib/Eigen/src/SparseCore/SparseAssign.h	/^Derived& SparseMatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	lib/Eigen/src/SparseCore/SparseAssign.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	lib/Eigen/src/SparseCore/SparseAssign.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	lib/Eigen/src/SparseCore/SparseBlock.h	/^    BlockImpl& operator=(const T&)$/;"	f	class:Eigen::BlockImpl
operator =	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const BlockType& other)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
operator =	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
operator =	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator& operator=(const InnerIterator& other)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
operator =	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
operator =	lib/Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE SparseMatrix<Scalar,_Options,_StorageIndex>& SparseMatrix<Scalar,_Options,_StorageIndex>::operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcMode>& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcMode>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
operator =	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector
operator =	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
operator =	lib/Eigen/src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	lib/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
operator =	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator=(const bigfloat& y) {$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator=(const double y) {$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator=(const float y) {$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator=(const signed long y) {$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat.h	/^  bigfloat& operator=(const unsigned long y) { $/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator=(const bigfloat& y)     { x=y.x;    return *this;  }$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator=(const double y)   { x=y; return *this; }$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator=(const float y)    { x=y; return *this; }$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator=(const signed long y)   { x=y; return *this; }$/;"	f	class:bigfloat
operator =	lib/algorithms/approx/bigfloat_double.h	/^  bigfloat& operator=(const unsigned long y) { x=y; return *this; }$/;"	f	class:bigfloat
operator =	lib/lattice/Lattice_base.h	/^  template <typename Op, typename T1,typename T2,typename T3> strong_inline Lattice<vobj> & operator=(const LatticeTrinaryExpression<Op,T1,T2,T3> &expr)$/;"	f	class:Grid::Lattice
operator =	lib/lattice/Lattice_base.h	/^  template <typename Op, typename T1,typename T2> strong_inline Lattice<vobj> & operator=(const LatticeBinaryExpression<Op,T1,T2> &expr)$/;"	f	class:Grid::Lattice
operator =	lib/lattice/Lattice_base.h	/^  template <typename Op, typename T1>                         strong_inline Lattice<vobj> & operator=(const LatticeUnaryExpression<Op,T1> &expr)$/;"	f	class:Grid::Lattice
operator =	lib/lattice/Lattice_base.h	/^  template<class robj> strong_inline Lattice<vobj> & operator = (const Lattice<robj> & r){$/;"	f	class:Grid::Lattice
operator =	lib/lattice/Lattice_base.h	/^  template<class sobj> strong_inline Lattice<vobj> & operator = (const sobj & r){$/;"	f	class:Grid::Lattice
operator =	lib/pugixml/pugixml.cc	/^		void operator=(T* value)$/;"	f	class:compact_pointer
operator =	lib/pugixml/pugixml.cc	/^		void operator=(T* value)$/;"	f	class:compact_pointer_parent
operator =	lib/pugixml/pugixml.cc	/^		void operator=(char_t* value)$/;"	f	class:compact_string
operator =	lib/pugixml/pugixml.cc	/^		void operator=(const compact_pointer& rhs)$/;"	f	class:compact_pointer
operator =	lib/pugixml/pugixml.cc	/^		void operator=(const compact_pointer_parent& rhs)$/;"	f	class:compact_pointer_parent
operator =	lib/pugixml/pugixml.cc	/^		void operator=(const compact_string& rhs)$/;"	f	class:compact_string
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(bool rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(const char_t* rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(double rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(float rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(int rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(long long rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned int rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute& xml_attribute::operator=(unsigned long long rhs)$/;"	f	class:pugi::xml_attribute
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(bool rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(const char_t* rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(double rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(float rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(int rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(long long rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(unsigned int rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text& xml_text::operator=(unsigned long long rhs)$/;"	f	class:pugi::xml_text
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set& xpath_node_set::operator=(const xpath_node_set& ns)$/;"	f	class:pugi::xpath_node_set
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set& xpath_node_set::operator=(xpath_node_set&& rhs)$/;"	f	class:pugi::xpath_node_set
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable_set& xpath_variable_set::operator=(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set
operator =	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable_set& xpath_variable_set::operator=(xpath_variable_set&& rhs)$/;"	f	class:pugi::xpath_variable_set
operator =	lib/pugixml/pugixml.cc	/^	xpath_query& xpath_query::operator=(xpath_query&& rhs)$/;"	f	class:pugi::xpath_query
operator =	lib/simd/Grid_vector_types.h	/^  Grid_simd &operator=(Zero &z) {$/;"	f	class:Grid::Grid_simd
operator =	lib/simd/Grid_vector_types.h	/^  Grid_simd &operator=(const Grid_simd &&rhs) {$/;"	f	class:Grid::Grid_simd
operator =	lib/simd/Grid_vector_types.h	/^  Grid_simd &operator=(const Grid_simd &rhs) {$/;"	f	class:Grid::Grid_simd
operator =	lib/tensors/Tensor_class.h	/^  iMatrix &operator=(const iMatrix &rhs) {$/;"	f	class:Grid::iMatrix
operator =	lib/tensors/Tensor_class.h	/^  iMatrix<vtype, N> &operator=(const Zero &hero) {$/;"	f	class:Grid::iMatrix
operator =	lib/tensors/Tensor_class.h	/^  iScalar<vtype> &operator=(const Zero &hero) {$/;"	f	class:Grid::iScalar
operator =	lib/tensors/Tensor_class.h	/^  iVector<vtype, N> &operator=(const Zero &hero) {$/;"	f	class:Grid::iVector
operator =	lib/tensors/Tensor_class.h	/^  strong_inline iScalar<vtype> operator=(T arg) {$/;"	f	class:Grid::iScalar
operator =	lib/tensors/Tensor_class.h	/^  strong_inline iScalar<vtype> operator=(iScalar<ttype> &&arg) {$/;"	f	class:Grid::iScalar
operator ==	lib/Eigen/src/Core/MatrixBase.h	/^    inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator ==	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ bool operator == (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator ==	lib/allocator/AlignedAllocator.h	/^  inline bool operator==(const alignedAllocator<_Tp> &, const alignedAllocator<_Tp> &) { return true; }$/;"	f	namespace:Grid
operator ==	lib/allocator/AlignedAllocator.h	/^template<typename _Tp>  inline bool operator==(const commAllocator<_Tp>&, const commAllocator<_Tp>&){ return true; }$/;"	f	namespace:Grid
operator ==	lib/json/json.hpp	/^        bool operator==(const iter_impl& other) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator ==	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator == (const Lattice<lobj> & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator ==	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator == (const Lattice<lobj> & lhs, const robj & rhs) {$/;"	f	namespace:Grid
operator ==	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator == (const lobj & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator ==	lib/pugixml/pugixml.cc	/^		bool operator==(const char_t* other) const$/;"	f	struct:xpath_lexer_string
operator ==	lib/pugixml/pugixml.cc	/^		bool operator==(const xpath_string& o) const$/;"	f	class:xpath_string
operator ==	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::operator==(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute
operator ==	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute_iterator::operator==(const xml_attribute_iterator& rhs) const$/;"	f	class:pugi::xml_attribute_iterator
operator ==	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_named_node_iterator::operator==(const xml_named_node_iterator& rhs) const$/;"	f	class:pugi::xml_named_node_iterator
operator ==	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::operator==(const xml_node& r) const$/;"	f	class:pugi::xml_node
operator ==	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node_iterator::operator==(const xml_node_iterator& rhs) const$/;"	f	class:pugi::xml_node_iterator
operator ==	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_node::operator==(const xpath_node& n) const$/;"	f	class:pugi::xpath_node
operator ==	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    bool operator==(const prng_engine& y) $/;"	f	class:sitmo::prng_engine
operator >	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ bool operator > (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator >	lib/algorithms/approx/bigfloat.h	/^  friend int operator>(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator >	lib/algorithms/approx/bigfloat_double.h	/^  friend int operator>(const bigfloat& x, const bigfloat& y) {$/;"	f	class:bigfloat
operator >	lib/json/json.hpp	/^        bool operator>(const iter_impl& other) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator >	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator > (const Lattice<lobj> & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator >	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator > (const Lattice<lobj> & lhs, const robj & rhs) {$/;"	f	namespace:Grid
operator >	lib/lattice/Lattice_comparison.h	/^    inline Lattice<vInteger> operator > (const lobj & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator >	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::operator>(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute
operator >	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::operator>(const xml_node& r) const$/;"	f	class:pugi::xml_node
operator >=	lib/Eigen/src/Core/arch/CUDA/Half.h	/^__device__ bool operator >= (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator >=	lib/json/json.hpp	/^        bool operator>=(const iter_impl& other) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator >=	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator >= (const Lattice<lobj> & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator >=	lib/lattice/Lattice_comparison.h	/^     inline Lattice<vInteger> operator >= (const lobj & lhs, const Lattice<robj> & rhs) {$/;"	f	namespace:Grid
operator >=	lib/lattice/Lattice_comparison.h	/^   inline Lattice<vInteger> operator >= (const Lattice<lobj> & lhs, const robj & rhs) {$/;"	f	namespace:Grid
operator >=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::operator>=(const xml_attribute& r) const$/;"	f	class:pugi::xml_attribute
operator >=	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::operator>=(const xml_node& r) const$/;"	f	class:pugi::xml_node
operator >>	lib/json/json.hpp	/^    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)$/;"	f	class:nlohmann::basic_json
operator >>	lib/serialisation/BaseIO.h	/^  inline std::istream & operator>>(std::istream &is, std::pair<T1, T2> &buf)$/;"	f	namespace:Grid
operator >>	lib/sitmo_rng/sitmo_prng_engine.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is, prng_engine& s) {$/;"	f	class:sitmo::prng_engine
operator ComplexD	lib/tensors/Tensor_class.h	/^  operator ComplexD() const {$/;"	f	class:Grid::iScalar
operator ComplexF	lib/tensors/Tensor_class.h	/^  operator ComplexF() const {$/;"	f	class:Grid::iScalar
operator Derived&	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  operator Derived&() { return m_matrix->const_cast_derived(); }$/;"	f	struct:Eigen::internal::evaluator
operator Integer	lib/tensors/Tensor_class.h	/^  operator Integer() const {$/;"	f	class:Grid::iScalar
operator RealD	lib/tensors/Tensor_class.h	/^  operator RealD() const {$/;"	f	class:Grid::iScalar
operator SparseVectorType&	lib/Eigen/src/SparseCore/SparseVector.h	/^  operator SparseVectorType&() { return m_matrix->const_cast_derived(); }$/;"	f	struct:Eigen::internal::evaluator
operator T&	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE operator T&() { return m_val; }$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator T&	lib/Eigen/src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator T*	lib/pugixml/pugixml.cc	/^		operator T*() const$/;"	f	class:compact_pointer
operator T*	lib/pugixml/pugixml.cc	/^		operator T*() const$/;"	f	class:compact_pointer_parent
operator ValueType	lib/json/json.hpp	/^    operator ValueType() const$/;"	f	class:nlohmann::basic_json
operator []	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator []	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator []	lib/Eigen/src/Core/Transpositions.h	/^    inline StorageIndex& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	lib/Eigen/src/Core/Transpositions.h	/^    inline const StorageIndex& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	lib/Eigen/src/Core/util/Memory.h	/^  T& operator[](std::ptrdiff_t i) { return m_ptr[i]; }$/;"	f	class:Eigen::internal::scoped_array
operator []	lib/Eigen/src/Core/util/Memory.h	/^  const T& operator[](std::ptrdiff_t i) const { return m_ptr[i]; }$/;"	f	class:Eigen::internal::scoped_array
operator []	lib/Eigen/src/SparseCore/SparseMatrix.h	/^        StorageIndex operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector
operator []	lib/json/json.hpp	/^        reference operator[](difference_type n) const$/;"	f	class:nlohmann::basic_json::iter_impl
operator []	lib/json/json.hpp	/^        reference operator[](difference_type n) const$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
operator []	lib/json/json.hpp	/^    const_reference operator[](T * (&key)[n]) const$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    const_reference operator[](T* key) const$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    const_reference operator[](const json_pointer& ptr) const$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    const_reference operator[](const typename object_t::key_type& key) const$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    const_reference operator[](size_type idx) const$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    reference operator[](T * (&key)[n])$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    reference operator[](T* key)$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    reference operator[](const json_pointer& ptr)$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    reference operator[](const typename object_t::key_type& key)$/;"	f	class:nlohmann::basic_json
operator []	lib/json/json.hpp	/^    reference operator[](size_type idx)$/;"	f	class:nlohmann::basic_json
operator []	lib/lattice/Lattice_base.h	/^    const vobj & operator[](int i) const { return _odata[i]; };$/;"	f	class:Grid::Lattice
operator []	lib/lattice/Lattice_base.h	/^    vobj & operator[](int i) { return _odata[i]; };$/;"	f	class:Grid::Lattice
operator []	lib/pugixml/pugixml.cc	/^	PUGI__FN const xpath_node& xpath_node_set::operator[](size_t index) const$/;"	f	class:pugi::xpath_node_set
operator ^	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator^(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator bool	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE operator bool() const         { return m_iter; }$/;"	f	class:Eigen::InnerIterator
operator bool	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::internal::inner_iterator_selector
operator bool	lib/Eigen/src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator bool	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline operator bool() const { return EvalIterator::operator bool() && EvalIterator::index() < m_end; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline operator bool() const { return m_outerPos < m_end; }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id<m_innerSize; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE operator bool() const { return LhsIterator::operator bool() && (!m_empty); }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline operator bool() const  { return m_sparseIter; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator bool	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline operator bool() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
operator bool	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result::operator bool() const$/;"	f	class:pugi::xml_parse_result
operator bool	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_parse_result::operator bool() const$/;"	f	class:pugi::xpath_parse_result
operator char_t*	lib/pugixml/pugixml.cc	/^		operator char_t*() const$/;"	f	class:compact_string
operator const Derived&	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^  operator const Derived&() const { return *m_matrix; }$/;"	f	struct:Eigen::internal::evaluator
operator const ExpressionType&	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess
operator const ExpressionType&	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue
operator const Scalar	lib/Eigen/src/Core/Product.h	/^  operator const Scalar() const$/;"	f	class:Eigen::internal::dense_product_base
operator const SparseVectorType&	lib/Eigen/src/SparseCore/SparseVector.h	/^  operator const SparseVectorType&() const { return *m_matrix; }$/;"	f	struct:Eigen::internal::evaluator
operator const T&	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE operator const T&() const { return m_val; }$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator const T&	lib/Eigen/src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator const T*	lib/Eigen/src/Core/util/Memory.h	/^  operator const T*() const { return m_ptr; }$/;"	f	class:Eigen::internal::scoped_array
operator const_iterator	lib/json/json.hpp	/^        operator const_iterator() const$/;"	f	class:nlohmann::basic_json::iter_impl
operator double	lib/algorithms/approx/bigfloat.h	/^  operator double (void) const { return (double)mpf_get_d(x); }$/;"	f	class:bigfloat
operator double	lib/algorithms/approx/bigfloat_double.h	/^  operator double (void) const { return (double)x; }$/;"	f	class:bigfloat
operator std::string	lib/json/json.hpp	/^        operator std::string() const$/;"	f	class:nlohmann::basic_json::json_pointer
operator xml_attribute::unspecified_bool_type	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute::operator xml_attribute::unspecified_bool_type() const$/;"	f	class:pugi::xml_attribute
operator xml_node::unspecified_bool_type	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node::operator xml_node::unspecified_bool_type() const$/;"	f	class:pugi::xml_node
operator xml_text::unspecified_bool_type	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text::operator xml_text::unspecified_bool_type() const$/;"	f	class:pugi::xml_text
operator xpath_node::unspecified_bool_type	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node::operator xpath_node::unspecified_bool_type() const$/;"	f	class:pugi::xpath_node
operator xpath_query::unspecified_bool_type	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_query::operator xpath_query::unspecified_bool_type() const$/;"	f	class:pugi::xpath_query
operator |	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> operator|(const Grid_simd<S, V> &x,$/;"	f	namespace:Grid
operator |=	lib/pugixml/pugixml.cc	/^		void operator|=(uintptr_t mod)$/;"	f	class:compact_header
operator ||	lib/Eigen/src/plugins/CommonCwiseBinaryOps.h	/^operator||(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator ||	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator||(const xml_attribute& lhs, bool rhs)$/;"	f	namespace:pugi
operator ||	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator||(const xml_node& lhs, bool rhs)$/;"	f	namespace:pugi
operator ||	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator||(const xml_text& lhs, bool rhs)$/;"	f	namespace:pugi
operator ||	lib/pugixml/pugixml.cc	/^	PUGI__FN bool operator||(const xpath_node& lhs, bool rhs)$/;"	f	namespace:pugi
operator ||	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> operator||(const Grid_simd<S, V> &x,$/;"	f	namespace:Grid
operatorADEF1	tests/solver/Test_dwf_hdcr.cc	/^  void operatorADEF1(const FineField &in, FineField & out) {$/;"	f	class:MultiGridPreconditioner
operatorADEF2	tests/solver/Test_dwf_hdcr.cc	/^  void operatorADEF2(const FineField &in, FineField & out) {$/;"	f	class:MultiGridPreconditioner
operatorCheby	tests/solver/Test_dwf_hdcr.cc	/^  void operatorCheby(const FineField &in, FineField & out) {$/;"	f	class:MultiGridPreconditioner
operatorInverseSqrt	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
operatorNorm	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase
operatorNorm	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView
operatorSAP	tests/solver/Test_dwf_hdcr.cc	/^  void operatorSAP(const FineField &in, FineField & out) {$/;"	f	class:MultiGridPreconditioner
operatorSqrt	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
operator_type	lib/qcd/modules/ActionModules.h	/^  typedef std::unique_ptr<FermionOperatorModuleBase<FermionOperator<Impl>> > operator_type;$/;"	t	class:Grid::QCD::PseudoFermionModuleBase
opt_false	lib/pugixml/pugixml.cc	/^	struct opt_false$/;"	s	file:
opt_true	lib/pugixml/pugixml.cc	/^	struct opt_true$/;"	s	file:
optimize	lib/pugixml/pugixml.cc	/^		void optimize(xpath_allocator* alloc)$/;"	f	class:xpath_ast_node
optimize_self	lib/pugixml/pugixml.cc	/^		void optimize_self(xpath_allocator* alloc)$/;"	f	class:xpath_ast_node
options	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase
order	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType order ; \/* pivot ordering of this column, if col is dead *\/$/;"	m	union:internal::colamd_col::__anon624
order	lib/algorithms/approx/Chebyshev.h	/^    int order;$/;"	m	class:Grid::Chebyshev
order	lib/algorithms/approx/Chebyshev.h	/^    int order;$/;"	m	class:Grid::ChebyshevLanczos
order	lib/algorithms/approx/MultiShiftFunction.h	/^  int order;$/;"	m	class:Grid::MultiShiftFunction
order_children	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline  void order_children$/;"	f	namespace:internal
ordering	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, ConstCholMatrixPtr &pmat, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
ordering_helper_at_plus_a	lib/Eigen/src/OrderingMethods/Ordering.h	/^void ordering_helper_at_plus_a(const MatrixType& A, MatrixType& symmat)$/;"	f	namespace:Eigen::internal
origin	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
originalMatrix	lib/Eigen/src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base
orthogonalize	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void orthogonalize(Field& w, std::vector<Field>& evec, int k)$/;"	f	class:Grid::ImplicitlyRestartedLanczos
other	lib/Eigen/src/Core/util/Memory.h	/^    typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind
other	lib/Eigen/src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind
other	lib/allocator/AlignedAllocator.h	/^      typedef alignedAllocator<_Tp1> other;$/;"	t	struct:Grid::alignedAllocator::rebind
other	lib/allocator/AlignedAllocator.h	/^  template<typename _Tp1>  struct rebind { typedef commAllocator<_Tp1> other; };$/;"	t	struct:Grid::commAllocator::rebind
outer	lib/Eigen/src/Core/AssignEvaluator.h	/^    outer = Index \/ DstXprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling::__anon146
outer	lib/Eigen/src/Core/AssignEvaluator.h	/^    outer = Index \/ DstXprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon147
outer	lib/Eigen/src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon121
outer	lib/Eigen/src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon123
outer	lib/Eigen/src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride
outer	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Index outer()  const { return 0; }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
outer	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Index outer()  const { return EvalIterator::outer() - (IsRowMajor ? m_block.startRow() : m_block.startCol()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
outer	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
outer	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
outer	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_lhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
outer	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_lhsIter.outer(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
outer	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_rhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
outer	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_rhsIter.outer(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
outer	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
outer	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index outer() const  { return m_sparseIter.outer(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
outerInd	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon15
outerIndexPtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline StorageIndex* outerIndexPtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
outerIndexPtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const StorageIndex* outerIndexPtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
outerIndexPtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex* outerIndexPtr() { return derived().outerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
outerIndexPtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const StorageIndex* outerIndexPtr() const { return derived().outerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
outerIndexPtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline StorageIndex* outerIndexPtr()   { return Base::m_outerIndex; }$/;"	f	class:Eigen::SparseMapBase
outerIndexPtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline const StorageIndex* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMapBase
outerIndexPtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline StorageIndex* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerIndexPtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const StorageIndex* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerIndexPtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline StorageIndex* outerIndexPtr() { return derived().nestedExpression().outerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
outerIndexPtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline const StorageIndex* outerIndexPtr() const { return derived().nestedExpression().outerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
outerIndexPtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline StorageIndex* outerIndexPtr() { return 0; }$/;"	f	class:Eigen::SparseVector
outerIndexPtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline const StorageIndex* outerIndexPtr() const { return 0; }$/;"	f	class:Eigen::SparseVector
outerProduct	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> outerProduct(const Grid_simd<S, V> &l,$/;"	f	namespace:Grid
outerProduct	lib/tensors/Tensor_outer.h	/^inline ComplexD outerProduct(const ComplexD &l, const ComplexD& r)$/;"	f	namespace:Grid
outerProduct	lib/tensors/Tensor_outer.h	/^inline ComplexF outerProduct(const ComplexF &l, const ComplexF& r)$/;"	f	namespace:Grid
outerProduct	lib/tensors/Tensor_outer.h	/^inline RealD outerProduct(const RealD &l, const RealD& r)$/;"	f	namespace:Grid
outerProduct	lib/tensors/Tensor_outer.h	/^inline RealF outerProduct(const RealF &l, const RealF& r)$/;"	f	namespace:Grid
outerSize	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index outerSize() const   { return m_dstExpr.outerSize(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
outerSize	lib/Eigen/src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase
outerSize	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index outerSize() const { return m_xpr.outerSize(); }$/;"	f	class:Eigen::internal::redux_evaluator
outerSize	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMapBase
outerSize	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
outerSize	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase
outerSize	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector
outerSize	lib/Eigen/src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView
outerStride	lib/Eigen/src/Core/Array.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array
outerStride	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper
outerStride	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper
outerStride	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index outerStride() const { return m_dstExpr.outerStride(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
outerStride	lib/Eigen/src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense
outerStride	lib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
outerStride	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
outerStride	lib/Eigen/src/Core/Diagonal.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Diagonal
outerStride	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
outerStride	lib/Eigen/src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map
outerStride	lib/Eigen/src/Core/Matrix.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix
outerStride	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue
outerStride	lib/Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC inline Index outerStride() const$/;"	f	class:Eigen::RefBase
outerStride	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView
outerStride	lib/Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl
outerStride	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TriangularViewImpl
outerStride	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase
outer_product_selector_run	lib/Eigen/src/Core/ProductEvaluators.h	/^void outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const false_type&)$/;"	f	namespace:Eigen::internal
outer_product_selector_run	lib/Eigen/src/Core/ProductEvaluators.h	/^void outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const true_type&)$/;"	f	namespace:Eigen::internal
outer_stride_at_compile_time	lib/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
outer_stride_at_compile_time	lib/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
output_vector_string	lib/qcd/hmc/HMCResourceManager.h	/^  void output_vector_string(const std::vector<std::string> &vs){$/;"	f	class:Grid::QCD::HMCResourceManager
overlapComms	benchmarks/Benchmark_wilson.cc	/^bool overlapComms = false;$/;"	v
overlapComms	benchmarks/Benchmark_wilson_sweep.cc	/^bool overlapComms = false;$/;"	v
overlapCommsCompute	lib/qcd/action/ActionParams.h	/^    bool overlapCommsCompute;$/;"	m	struct:Grid::QCD::GparityWilsonImplParams
overlapCommsCompute	lib/qcd/action/ActionParams.h	/^    bool overlapCommsCompute;$/;"	m	struct:Grid::QCD::WilsonImplParams
overlapCommsCompute	lib/qcd/action/fermion/FermionOperatorImpl.h	/^    bool overlapCommsCompute(void) { return Params.overlapCommsCompute; };$/;"	f	class:Grid::QCD::WilsonImpl
overlapCommsCompute	lib/qcd/action/fermion/FermionOperatorImpl.h	/^  bool overlapCommsCompute(void) { return false; };$/;"	f	class:Grid::QCD::DomainWallVec5dImpl
overlapCommsCompute	lib/qcd/action/fermion/FermionOperatorImpl.h	/^ bool overlapCommsCompute(void) { return Params.overlapCommsCompute; };$/;"	f	class:Grid::QCD::GparityWilsonImpl
owners	extras/Hadrons/Environment.hpp	/^        std::set<unsigned int>  owners, properties;$/;"	m	struct:Environment::ObjInfo
owners	lib/Hadrons/Environment.hpp	/^        std::set<unsigned int>  owners, properties;$/;"	m	struct:Environment::ObjInfo
p	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType p ;   \/* used as a row pointer in init_rows_cols () *\/$/;"	m	union:internal::Colamd_Row::__anon627
p	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      std::vector<double> p; $/;"	m	class:Grid::QCD::PartialFractionFermion5D
p16uc_COMPLEX32_REV	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_COMPLEX32_REV = vec_sld(p16uc_REVERSE32, p16uc_REVERSE32, 8);                                         \/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX32_REV2	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_COMPLEX32_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);                                            \/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX32_REV2	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_COMPLEX32_REV2 = vec_sld(p16uc_PSET64_HI, p16uc_PSET64_LO, 8);                                            \/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE32_HI	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE32_HI = { 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE32_HI	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE32_HI = { 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = p16uc_REVERSE32; $/;"	m	namespace:Eigen::internal
p16uc_FORWARD	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_FORWARD =   { 0,1,2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_HALF64_0_16	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_HALF64_0_16 = vec_sld((Packet16uc)p4i_ZERO, vec_splat((Packet16uc) vec_abs(p4i_MINUS16), 3), 8);      \/\/{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16};$/;"	m	namespace:Eigen::internal
p16uc_HALF64_0_16	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_HALF64_0_16 = vec_sld(vec_splat((Packet16uc) vec_abs(p4i_MINUS16), 0), (Packet16uc)p4i_ZERO, 8);      \/\/{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16};$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WEVEN	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WEVEN  = vec_sld(p16uc_DUPLICATE32_HI, (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WEVEN	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WEVEN = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WEVEN	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET32_WEVEN  = vec_sld(p16uc_DUPLICATE32_HI, (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WODD	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WODD   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WODD	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WODD = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WODD	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET32_WODD   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_HI	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET64_HI = (Packet16uc) vec_mergeh((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     \/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_HI	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET64_HI = { 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_LO	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET64_LO = (Packet16uc) vec_mergel((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     \/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_LO	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET64_LO = (Packet16uc) vec_mergel((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     \/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE32	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE32 = { 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE32	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_REVERSE32 = { 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE64	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE64 = { 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE64	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_REVERSE64 = { 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_HI	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_HI = p16uc_PSET64_HI + p16uc_HALF64_0_16;                                         \/\/{ 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_HI	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_HI = { 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_LO	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_LO = p16uc_PSET64_LO + p16uc_HALF64_0_16;                                         \/\/{ 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31};$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_LO	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_LO = { 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31};$/;"	m	namespace:Eigen::internal
p2d_COUNTDOWN	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(p2d_ONE), reinterpret_cast<Packet4f>(p2d_ZERO), 8));$/;"	m	namespace:Eigen::internal
p2d_COUNTDOWN	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(p2d_ZERO), reinterpret_cast<Packet4f>(p2d_ONE), 8));$/;"	m	namespace:Eigen::internal
p2d_COUNTDOWN	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet16uc>(p2d_ZERO), reinterpret_cast<Packet16uc>(p2d_ONE), 8));$/;"	m	namespace:Eigen::internal
p2d_MZERO	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d  p2d_MZERO = { -0.0, -0.0 };$/;"	m	namespace:Eigen::internal
p2d_ONE	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d  p2d_ONE  = { 1.0, 1.0 }; $/;"	m	namespace:Eigen::internal
p2d_ONE	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet2d p2d_ONE = { 1.0, 1.0 }; $/;"	m	namespace:Eigen::internal
p2d_ZERO	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d  p2d_ZERO = reinterpret_cast<Packet2d>(p4f_ZERO);$/;"	m	namespace:Eigen::internal
p2d_ZERO_	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet2d p2d_ZERO_ = { -0.0, -0.0 };$/;"	m	namespace:Eigen::internal
p2l_1023	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^static Packet2l p2l_1023 = { 1023, 1023 };$/;"	m	namespace:Eigen::internal
p2l_ONE	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2l  p2l_ONE  = { 1, 1 };$/;"	m	namespace:Eigen::internal
p2l_ZERO	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2l  p2l_ZERO = reinterpret_cast<Packet2l>(p4i_ZERO);$/;"	m	namespace:Eigen::internal
p2ui_CONJ_XOR	lib/Eigen/src/Core/arch/NEON/Complex.h	/^inline uint32x2_t p2ui_CONJ_XOR() {$/;"	f	namespace:Eigen::internal
p2ul_52	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^static Packet2ul p2ul_52 = { 52, 52 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  static uint64x2_t p2ul_CONJ_XOR = vld1q_u64( p2ul_conj_XOR_DATA );$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  static uint64x2_t p2ul_CONJ_XOR = {0x0, 0x8000000000000000};$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR1	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR1 = (Packet2ul) vec_sld((Packet4ui) p2d_MZERO, (Packet4ui) p2l_ZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR1	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR1 = (Packet2ul) vec_sld((Packet4ui) p2l_ZERO,  (Packet4ui) p2d_MZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR1	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR1 = (Packet2ul) vec_sld((Packet4ui) p2d_ZERO_, (Packet4ui) p2l_ZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR2	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2d_MZERO, (Packet4ui) p2l_ZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR2	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2l_ZERO,  (Packet4ui) p2d_MZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR2	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2l_ZERO,  (Packet4ui) p2d_ZERO_, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_conj_XOR_DATA	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  const uint64_t  p2ul_conj_XOR_DATA[] = { 0x0, 0x8000000000000000 };$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 0.0, 1.0, 2.0, 3.0 };$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 0.0, 1.0, 2.0, 3.0 };$/;"	m	namespace:Eigen::internal
p4f_MZERO	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_MZERO = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1); \/\/{ 0x80000000, 0x80000000, 0x80000000, 0x80000000}$/;"	m	namespace:Eigen::internal
p4f_ONE	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0); \/\/{ 1.0, 1.0, 1.0, 1.0}$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 0, 1, 2, 3 };$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 0, 1, 2, 3 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_MZERO);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	lib/Eigen/src/Core/arch/NEON/Complex.h	/^inline uint32x4_t p4ui_CONJ_XOR() {$/;"	f	namespace:Eigen::internal
pChi_00	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	65;"	d	file:
pChi_01	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	66;"	d	file:
pChi_02	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	67;"	d	file:
pChi_10	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	68;"	d	file:
pChi_11	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	69;"	d	file:
pChi_12	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	70;"	d	file:
pChi_20	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	71;"	d	file:
pChi_21	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	72;"	d	file:
pChi_22	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	73;"	d	file:
pChi_30	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	74;"	d	file:
pChi_31	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	75;"	d	file:
pChi_32	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	76;"	d	file:
pIMM	lib/simd/IBM_qpx.h	77;"	d
pREP	lib/simd/IBM_qpx.h	76;"	d
pRNG	lib/qcd/hmc/HMC.h	/^  GridParallelRNG &pRNG; $/;"	m	class:Grid::QCD::HybridMonteCarlo
pRNG	tests/testu01/Test_smallcrush.cc	/^  static GridParallelRNG *pRNG;$/;"	m	struct:TestRNG	file:
pRNG	tests/testu01/Test_smallcrush.cc	/^GridParallelRNG *TestRNG::pRNG;$/;"	m	class:TestRNG	file:
pRNG_	lib/qcd/hmc/HMCModules.h	/^   std::unique_ptr<GridParallelRNG> pRNG_;$/;"	m	class:Grid::QCD::RNGModule
pUChi_00	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	78;"	d	file:
pUChi_01	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	79;"	d	file:
pUChi_02	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	80;"	d	file:
pUChi_10	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	81;"	d	file:
pUChi_11	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	82;"	d	file:
pUChi_12	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	83;"	d	file:
pUChi_20	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	84;"	d	file:
pUChi_21	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	85;"	d	file:
pUChi_22	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	86;"	d	file:
pUChi_30	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	87;"	d	file:
pUChi_31	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	88;"	d	file:
pUChi_32	lib/qcd/action/fermion/StaggeredKernelsAsm.cc	89;"	d	file:
pabs	lib/Eigen/src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { using std::abs; return abs(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pabs(const Packet4d& a)$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pabs(const Packet8f& a)$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pabs(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet16f pabs(const Packet16f& a)$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double2 pabs<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float4  pabs<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pabs<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a) { return vabsq_f64(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs<Packet2d>(const Packet2d& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pabs	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs<Packet4i>(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pack	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs
packedMatrix	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition
packedMatrix	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization
packet	lib/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
packet	lib/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const $/;"	f	struct:Eigen::internal::unary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::binary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::ternary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::unary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const $/;"	f	struct:Eigen::internal::unary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::binary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::ternary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::unary_evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(IndexType index) const$/;"	f	struct:Eigen::internal::evaluator
packet	lib/Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(IndexType row, IndexType col) const$/;"	f	struct:Eigen::internal::evaluator
packet	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	lib/Eigen/src/Core/GenericPacketMath.h	/^  Packet packet[N];$/;"	m	struct:Eigen::internal::PacketBlock
packet	lib/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase
packet	lib/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
packet	lib/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue
packet	lib/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
packet	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase
packet	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
packet	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet(Index idx) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	lib/Eigen/src/Core/ProductEvaluators.h	/^  const PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	lib/Eigen/src/Core/ProductEvaluators.h	/^  const PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	lib/Eigen/src/Core/Redux.h	/^  PacketType packet(Index index) const$/;"	f	class:Eigen::internal::redux_evaluator
packet	lib/Eigen/src/Core/Redux.h	/^  PacketType packet(Index row, Index col) const$/;"	f	class:Eigen::internal::redux_evaluator
packetByOuterInner	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
packetByOuterInner	lib/Eigen/src/Core/Redux.h	/^  PacketType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::internal::redux_evaluator
packetOp	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const { return op.template packetOp<T>(i); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	lib/Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const { return op.template packetOp<T>(i); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	lib/Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j) const { return op.template packetOp<T>(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	lib/Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j) const {$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	lib/Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j=0) const { return op.template packetOp<T>(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	lib/Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType=0, IndexType=0) const { return op.template packetOp<T>(); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::bind2nd_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op
packetOp	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& b) const$/;"	f	struct:Eigen::internal::bind1st_op
packetOp	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op
packetOp	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl
packetOp	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const PacketType packetOp() const { return internal::pset1<PacketType>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_arg_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::patan(a); }$/;"	f	struct:Eigen::internal::scalar_atan_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pceil(a); }$/;"	f	struct:Eigen::internal::scalar_ceil_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcosh(a); }$/;"	f	struct:Eigen::internal::scalar_cosh_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pfloor(a); }$/;"	f	struct:Eigen::internal::scalar_floor_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog10(a); }$/;"	f	struct:Eigen::internal::scalar_log10_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog1p(a); }$/;"	f	struct:Eigen::internal::scalar_log1p_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pround(a); }$/;"	f	struct:Eigen::internal::scalar_round_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::prsqrt(a); }$/;"	f	struct:Eigen::internal::scalar_rsqrt_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psinh(a); }$/;"	f	struct:Eigen::internal::scalar_sinh_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& x) const { return ptanh(x); }$/;"	f	struct:Eigen::internal::scalar_tanh_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op
packetOp	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op
packet_access_bit	lib/Eigen/src/Core/Matrix.h	/^      packet_access_bit = (packet_traits<_Scalar>::Vectorizable && (EIGEN_UNALIGNED_VECTORIZE || (actual_alignment>=required_alignment))) ? PacketAccessBit : 0$/;"	e	enum:Eigen::internal::traits::__anon171
packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
packet_impl	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
packet_traits	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits<const T> : packet_traits<T> { };$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct packet_traits<float> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct packet_traits<Eigen::half> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<double>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int32_t>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct packet_traits<float> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
pacos	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { using std::acos; return acos(a); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd padd<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf padd<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d padd<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_add_pd(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f padd<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_add_ps(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f padd<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d padd<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v + b.v); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(a.v + b.v); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return a + b; }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return a + b; }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return a + b; }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 padd<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 padd<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 padd<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(padd<Packet2d>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return vaddq_f64(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v + b.v); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a + b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a + b); }$/;"	f	namespace:Eigen::internal
padd	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^DoublePacket<Packet> padd(const DoublePacket<Packet> &a, const DoublePacket<Packet> &b)$/;"	f	namespace:Eigen::internal
page_offset	lib/pugixml/pugixml.cc	/^		uint16_t page_offset; \/\/ offset from page->data$/;"	m	struct:xml_memory_string_header	file:
palign	lib/Eigen/src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AVX/Complex.h	/^struct palign_impl<Offset,Packet2cd>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AVX/Complex.h	/^struct palign_impl<Offset,Packet4cf>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^struct palign_impl<Offset,Packet4d>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^struct palign_impl<Offset,Packet8f>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct palign_impl<Offset, Packet16f> {$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct palign_impl<Offset, Packet8d> {$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
pand	lib/Eigen/src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pand   <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pand   <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pand<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_and_pd(a,b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pand<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_and_ps(a,b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pand<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pand<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pand(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pand<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pand<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pand	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pandnot<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pandnot<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pandnot<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pandnot<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pandnot<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pandnot<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pandnot(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pandnot<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pandnot<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pandnot	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return pand<Packet4i>(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
panel_bmod	lib/Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^void SparseLUImpl<Scalar,StorageIndex>::panel_bmod(const Index m, const Index w, const Index jcol, $/;"	f	class:Eigen::internal::SparseLUImpl
panel_dfs	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,StorageIndex>::panel_dfs(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
panel_dfs_traits	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  panel_dfs_traits(Index jcol, StorageIndex* marker)$/;"	f	struct:Eigen::internal::panel_dfs_traits
panel_dfs_traits	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^struct panel_dfs_traits$/;"	s	namespace:Eigen::internal
panel_size	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index panel_size; \/\/ a panel consists of at most <panel_size> consecutive columns$/;"	m	struct:Eigen::internal::perfvalues
par	extras/Hadrons/Module.hpp	/^const P & Module<P>::par(void) const$/;"	f	class:Module
par	lib/Hadrons/Module.hpp	/^const P & Module<P>::par(void) const$/;"	f	class:Module
par_	extras/Hadrons/Application.hpp	/^    GlobalPar                 par_;$/;"	m	class:Application
par_	extras/Hadrons/GeneticScheduler.hpp	/^    const Parameters         par_;$/;"	m	class:GeneticScheduler
par_	extras/Hadrons/Module.hpp	/^    P par_;$/;"	m	class:Module
par_	lib/Hadrons/Application.hpp	/^    GlobalPar                 par_;$/;"	m	class:Application
par_	lib/Hadrons/GeneticScheduler.hpp	/^    const Parameters         par_;$/;"	m	class:GeneticScheduler
par_	lib/Hadrons/Module.hpp	/^    P par_;$/;"	m	class:Module
parallel_for	lib/threads/Threads.h	54;"	d
parallel_for	tests/forces/Test_laplacian_force.cc	34;"	d	file:
parallel_for_nest2	lib/threads/Threads.h	55;"	d
parallelize_gemm	lib/Eigen/src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, Index depth, bool transpose)$/;"	f	namespace:Eigen::internal
param	lib/algorithms/approx/Remez.h	/^  bigfloat *param, *roots, *poles;$/;"	m	class:AlgRemez
param	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  Params param;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
param	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      Params param;$/;"	m	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
param	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      Params param;$/;"	m	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
param	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      Params param;$/;"	m	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
param	lib/qcd/utils/CovariantLaplacian.h	/^  LaplacianParams param;$/;"	m	class:Grid::QCD::LaplacianAdjointField
params	tests/solver/Test_dwf_hdcr.cc	/^myclass params;$/;"	v
pardisoInit	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl
pardisoParameterArray	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ParameterType& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl
pardisoRelease	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl
pardiso_run_selector	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
pardiso_run_selector	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
pardiso_traits	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
parent	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType parent ;  \/* parent in parent tree super-column structure, if *\/$/;"	m	union:internal::colamd_col::__anon623
parent	lib/pugixml/pugixml.cc	/^		impl::compact_pointer_parent<xml_node_struct, 6> parent;$/;"	m	struct:pugi::xml_node_struct	file:
parent	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::parent() const$/;"	f	class:pugi::xml_node
parent	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xpath_node::parent() const$/;"	f	class:pugi::xpath_node
parg	lib/Eigen/src/Core/GenericPacketMath.h	/^parg(const Packet& a) { using numext::arg; return arg(a); }$/;"	f	namespace:Eigen::internal
parse	lib/json/json.hpp	/^        basic_json parse()$/;"	f	class:nlohmann::basic_json::parser
parse	lib/pugixml/pugixml.cc	/^			static binary_op_t parse(xpath_lexer& lexer)$/;"	f	struct:xpath_parser::binary_op_t
parse	lib/pugixml/pugixml.cc	/^		static char_t* parse(char_t* s)$/;"	f	struct:strconv_pcdata_impl
parse	lib/pugixml/pugixml.cc	/^		static xml_parse_result parse(char_t* buffer, size_t length, xml_document_struct* xmldoc, xml_node_struct* root, unsigned int optmsk)$/;"	f	struct:xml_parser
parse	lib/pugixml/pugixml.cc	/^		static xpath_ast_node* parse(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result)$/;"	f	struct:xpath_parser
parse	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse()$/;"	f	struct:xpath_parser
parseGammaString	extras/Hadrons/Modules/MContraction/Meson.hpp	/^void TMeson<FImpl1, FImpl2>::parseGammaString(std::vector<GammaPair> &gammaList)$/;"	f	class:TMeson
parseGammaString	lib/Hadrons/Modules/MContraction/Meson.hpp	/^void TMeson<FImpl1, FImpl2>::parseGammaString(std::vector<GammaPair> &gammaList)$/;"	f	class:TMeson
parseParameterFile	extras/Hadrons/Application.cc	/^void Application::parseParameterFile(const std::string parameterFileName)$/;"	f	class:Application
parseParameterFile	lib/Hadrons/Application.cc	/^void Application::parseParameterFile(const std::string parameterFileName)$/;"	f	class:Application
parseParameters	extras/Hadrons/Module.hpp	/^    virtual void parseParameters(XmlReader &reader, const std::string name) {};$/;"	f	class:Module
parseParameters	extras/Hadrons/Module.hpp	/^void Module<P>::parseParameters(XmlReader &reader, const std::string name)$/;"	f	class:Module
parseParameters	lib/Hadrons/Module.hpp	/^    virtual void parseParameters(XmlReader &reader, const std::string name) {};$/;"	f	class:Module
parseParameters	lib/Hadrons/Module.hpp	/^void Module<P>::parseParameters(XmlReader &reader, const std::string name)$/;"	f	class:Module
parse_axis_name	lib/pugixml/pugixml.cc	/^		axis_t parse_axis_name(const xpath_lexer_string& name, bool& specified)$/;"	f	struct:xpath_parser
parse_cdata	lib/pugixml/pugixml.h	/^	const unsigned int parse_cdata = 0x0004;$/;"	m	namespace:pugi
parse_comments	lib/pugixml/pugixml.h	/^	const unsigned int parse_comments = 0x0002;$/;"	m	namespace:pugi
parse_declaration	lib/pugixml/pugixml.h	/^	const unsigned int parse_declaration = 0x0100;$/;"	m	namespace:pugi
parse_default	lib/pugixml/pugixml.h	/^	const unsigned int parse_default = parse_cdata | parse_escapes | parse_wconv_attribute | parse_eol;$/;"	m	namespace:pugi
parse_doctype	lib/pugixml/pugixml.h	/^	const unsigned int parse_doctype = 0x0200;$/;"	m	namespace:pugi
parse_doctype_group	lib/pugixml/pugixml.cc	/^		char_t* parse_doctype_group(char_t* s, char_t endch)$/;"	f	struct:xml_parser
parse_doctype_ignore	lib/pugixml/pugixml.cc	/^		char_t* parse_doctype_ignore(char_t* s)$/;"	f	struct:xml_parser
parse_doctype_primitive	lib/pugixml/pugixml.cc	/^		char_t* parse_doctype_primitive(char_t* s)$/;"	f	struct:xml_parser
parse_eol	lib/pugixml/pugixml.cc	/^		static char_t* parse_eol(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl
parse_eol	lib/pugixml/pugixml.h	/^	const unsigned int parse_eol = 0x0020;$/;"	m	namespace:pugi
parse_error	lib/json/json.hpp	/^            parse_error,     \/\/\/< indicating a parse error$/;"	m	class:nlohmann::basic_json::lexer::token_type
parse_escapes	lib/pugixml/pugixml.h	/^	const unsigned int parse_escapes = 0x0010;$/;"	m	namespace:pugi
parse_event_t	lib/json/json.hpp	/^    enum class parse_event_t : uint8_t$/;"	c	class:nlohmann::basic_json
parse_exclamation	lib/pugixml/pugixml.cc	/^		char_t* parse_exclamation(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser
parse_expression	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_expression()$/;"	f	struct:xpath_parser
parse_expression_rec	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_expression_rec(xpath_ast_node* lhs, int limit)$/;"	f	struct:xpath_parser
parse_filter_expression	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_filter_expression()$/;"	f	struct:xpath_parser
parse_fragment	lib/pugixml/pugixml.h	/^	const unsigned int parse_fragment = 0x1000;$/;"	m	namespace:pugi
parse_full	lib/pugixml/pugixml.h	/^	const unsigned int parse_full = parse_default | parse_pi | parse_comments | parse_declaration | parse_doctype;$/;"	m	namespace:pugi
parse_function	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_function(const xpath_lexer_string& name, size_t argc, xpath_ast_node* args[2])$/;"	f	struct:xpath_parser
parse_function_helper	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_function_helper(ast_type_t type0, ast_type_t type1, size_t argc, xpath_ast_node* args[2])$/;"	f	struct:xpath_parser
parse_internal	lib/json/json.hpp	/^        basic_json parse_internal(bool keep)$/;"	f	class:nlohmann::basic_json::parser
parse_location_path	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_location_path()$/;"	f	struct:xpath_parser
parse_minimal	lib/pugixml/pugixml.h	/^	const unsigned int parse_minimal = 0x0000;$/;"	m	namespace:pugi
parse_node_test_type	lib/pugixml/pugixml.cc	/^		nodetest_t parse_node_test_type(const xpath_lexer_string& name)$/;"	f	struct:xpath_parser
parse_path_or_unary_expression	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_path_or_unary_expression()$/;"	f	struct:xpath_parser
parse_pi	lib/pugixml/pugixml.h	/^	const unsigned int parse_pi = 0x0001;$/;"	m	namespace:pugi
parse_primary_expression	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_primary_expression()$/;"	f	struct:xpath_parser
parse_question	lib/pugixml/pugixml.cc	/^		char_t* parse_question(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser
parse_relative_location_path	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_relative_location_path(xpath_ast_node* set)$/;"	f	struct:xpath_parser
parse_simple	lib/pugixml/pugixml.cc	/^		static char_t* parse_simple(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl
parse_skip_bom	lib/pugixml/pugixml.cc	/^		static char_t* parse_skip_bom(char_t* s)$/;"	f	struct:xml_parser
parse_step	lib/pugixml/pugixml.cc	/^		xpath_ast_node* parse_step(xpath_ast_node* set)$/;"	f	struct:xpath_parser
parse_tree	lib/pugixml/pugixml.cc	/^		char_t* parse_tree(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)$/;"	f	struct:xml_parser
parse_trim_pcdata	lib/pugixml/pugixml.h	/^	const unsigned int parse_trim_pcdata = 0x0800;$/;"	m	namespace:pugi
parse_wconv	lib/pugixml/pugixml.cc	/^		static char_t* parse_wconv(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl
parse_wconv_attribute	lib/pugixml/pugixml.h	/^	const unsigned int parse_wconv_attribute = 0x0040;$/;"	m	namespace:pugi
parse_wnorm	lib/pugixml/pugixml.cc	/^		static char_t* parse_wnorm(char_t* s, char_t end_quote)$/;"	f	struct:strconv_attribute_impl
parse_wnorm_attribute	lib/pugixml/pugixml.h	/^	const unsigned int parse_wnorm_attribute = 0x0080;$/;"	m	namespace:pugi
parse_ws_pcdata	lib/pugixml/pugixml.h	/^	const unsigned int parse_ws_pcdata = 0x0008;$/;"	m	namespace:pugi
parse_ws_pcdata_single	lib/pugixml/pugixml.h	/^	const unsigned int parse_ws_pcdata_single = 0x0400;$/;"	m	namespace:pugi
parser	lib/json/json.hpp	/^        parser(IteratorType first, IteratorType last, const parser_callback_t cb = nullptr)$/;"	f	class:nlohmann::basic_json::parser
parser	lib/json/json.hpp	/^        parser(const char* buff, const parser_callback_t cb = nullptr)$/;"	f	class:nlohmann::basic_json::parser
parser	lib/json/json.hpp	/^        parser(std::istream& is, const parser_callback_t cb = nullptr)$/;"	f	class:nlohmann::basic_json::parser
parser	lib/json/json.hpp	/^    class parser$/;"	c	class:nlohmann::basic_json
part_frac_chroma_convention	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      const int part_frac_chroma_convention=1;$/;"	m	class:Grid::QCD::PartialFractionFermion5D
partialPivLu	lib/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase
partial_lu_impl	lib/Eigen/src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
partial_lu_inplace	lib/Eigen/src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::StorageIndex& nb_transpositions)$/;"	f	namespace:Eigen::internal
partition	lib/pugixml/pugixml.cc	/^	template <typename I, typename Pred> void partition(I begin, I middle, I end, const Pred& pred, I* out_eqbeg, I* out_eqend)$/;"	f
pasin	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { using std::asin; return asin(a); }$/;"	f	namespace:Eigen::internal
pastix_traits	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
patan	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet patan(const Packet& a) { using std::atan; return atan(a); }$/;"	f	namespace:Eigen::internal
patch	lib/json/json.hpp	/^    basic_json patch(const basic_json& json_patch) const$/;"	f	class:nlohmann::basic_json
path	lib/pugixml/pugixml.cc	/^	PUGI__FN string_t xml_node::path(char_t delimiter) const$/;"	f	class:pugi::xml_node
path_	lib/serialisation/Hdf5IO.h	/^    std::vector<std::string> path_;$/;"	m	class:Grid::Hdf5Reader
path_	lib/serialisation/Hdf5IO.h	/^    std::vector<std::string> path_;$/;"	m	class:Grid::Hdf5Writer
pblend	lib/Eigen/src/Core/GenericPacketMath.h	/^pblend(const Selector<unpacket_traits<Packet>::size>& ifPacket, const Packet& thenPacket, const Packet& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pblend(const Selector<4>& ifPacket, const Packet4d& thenPacket, const Packet4d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pblend(const Selector<8>& ifPacket, const Packet8f& thenPacket, const Packet8f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pblend(const Selector<16>& \/*ifPacket*\/,$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pblend(const Selector<8>& \/*ifPacket*\/,$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<>  EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {$/;"	f	namespace:Eigen::internal
pbroadcast2	lib/Eigen/src/Core/GenericPacketMath.h	/^inline void pbroadcast2(const typename unpacket_traits<Packet>::type *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/GenericPacketMath.h	/^inline void pbroadcast4(const typename unpacket_traits<Packet>::type *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^pbroadcast4<Packet2d>(const double *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^pbroadcast4<Packet4f>(const float *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^pbroadcast4<Packet4i>(const int *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^pbroadcast4<Packet2d>(const double *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^pbroadcast4<Packet4f>(const float *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^pbroadcast4<Packet2d>(const double *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^pbroadcast4<Packet4f>(const float *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^pbroadcast4<Packet4i>(const int *a,$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/GenericPacketMath.h	/^pcast(const SrcPacket& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/GenericPacketMath.h	/^pcast(const SrcPacket& a, const SrcPacket& \/*b*\/) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/GenericPacketMath.h	/^pcast(const SrcPacket& a, const SrcPacket& \/*b*\/, const SrcPacket& \/*c*\/, const SrcPacket& \/*d*\/) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8f pcast<Packet8i, Packet8f>(const Packet8i& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8i pcast<Packet8f, Packet8i>(const Packet8f& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pcast<half2, float4>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE half2 pcast<float4, half2>(const float4& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet16f pcast<Packet16h, Packet16f>(const Packet16h& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet16h pcast<Packet16f, Packet16h>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet4h, Packet4f>(const Packet4h& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4h pcast<Packet4f, Packet4h>(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8f pcast<Packet8h, Packet8f>(const Packet8h& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8h pcast<Packet8f, Packet8h>(const Packet8f& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet2d pcast<Packet4f, Packet2d>(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet2d, Packet4f>(const Packet2d& a, const Packet2d& b) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet4i, Packet4f>(const Packet4i& a) {$/;"	f	namespace:Eigen::internal
pcast	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4i pcast<Packet4f, Packet4i>(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pceil(const Packet& a) { using numext::ceil; return ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pceil<Packet4d>(const Packet4d& a) { return _mm256_ceil_pd(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pceil<Packet8f>(const Packet8f& a) { return _mm256_ceil_ps(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const  Packet2d& a) { return vec_ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const  Packet4f& a) { return vec_ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const Packet2d& a) { return _mm_ceil_pd(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const Packet4f& a) { return _mm_ceil_ps(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const  Packet2d& a) { return vec_ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const  Packet4f& a)$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return numext::conj(a); }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pconj(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pconj(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pconj(const Packet4d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pconj(const Packet8f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pconj(const Packet8i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pconj(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i pconj(const Packet16i& a) {$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pconj(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd(pxor(a.v, reinterpret_cast<Packet2d>(p2ul_CONJ_XOR2))); }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf(pxor<Packet4f>(a.v, reinterpret_cast<Packet4f>(p4ui_CONJ_XOR))); }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pconj(const double2& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pconj(const float4& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pconj(const half2& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd(vreinterpretq_f64_u64(veorq_u64(vreinterpretq_u64_f64(a.v), p2ul_CONJ_XOR))); }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd((Packet2d)vec_xor((Packet2d)a.v, (Packet2d)p2ul_CONJ_XOR2)); }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	lib/Eigen/src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) const { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if
pconj	lib/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) const { return x; }$/;"	f	struct:Eigen::internal::conj_if
pcos	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { using std::cos; return cos(a); }$/;"	f	namespace:Eigen::internal
pcos	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pcosh	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pcosh(const Packet& a) { using std::cosh; return cosh(a); }$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pcplxflip<Packet2cd>(const Packet2cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pcplxflip<Packet4cf>(const Packet4cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/NEON/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/* <Packet1cd> *\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/* <Packet2cf> *\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pdiv<Packet2cd>(const Packet2cd& a, const Packet2cd& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pdiv<Packet4cf>(const Packet4cf& a, const Packet4cf& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pdiv<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_div_pd(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pdiv<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_div_ps(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pdiv<Packet8i>(const Packet8i& \/*a*\/, const Packet8i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pdiv<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pdiv<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_div(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pdiv<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pdiv<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pdiv<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return vdivq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a \/ b); }$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a \/ b); }$/;"	f	namespace:Eigen::internal
peekIndex	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline auto peekIndex (const vtype &arg,int i) -> RemoveCRV(TensorIndexRecursion<Level>::peekIndex(arg,0))$/;"	f	namespace:Grid
peekIndex	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline auto peekIndex (const vtype &arg,int i,int j) -> RemoveCRV(TensorIndexRecursion<Level>::peekIndex(arg,0,0))$/;"	f	namespace:Grid
peekIndex	tests/core/Test_main.cc	/^    -> decltype(peekIndex<2>(rhs, 0, 0)) {$/;"	f
peekIndex	tests/core/Test_main.cc	/^    -> decltype(peekIndex<3>(rhs, 0, 0)) {$/;"	f
peekIndex	tests/core/Test_main.cc	/^auto peekDumKopf(const vobj &rhs, int i) -> decltype(peekIndex<3>(rhs, 0)) {$/;"	f
peekLocalSite	lib/lattice/Lattice_peekpoke.h	/^    void peekLocalSite(sobj &s,const Lattice<vobj> &l,std::vector<int> &site){$/;"	f	namespace:Grid
peekSite	lib/lattice/Lattice_peekpoke.h	/^      void peekSite(sobj &s,const Lattice<vobj> &l,const std::vector<int> &site){$/;"	f	namespace:Grid
perf_event_open	lib/perfmon/PerfCount.h	/^static long perf_event_open(struct perf_event_attr *hw_event, pid_t pid,$/;"	f	namespace:Grid
performFrancisQRStep	lib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur
perfvalues	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^struct perfvalues {$/;"	s	namespace:Eigen::internal
perm	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& perm() const { return m_perm; }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
perm	lib/simd/Grid_generic.h	379;"	d
perm	lib/simd/Grid_generic.h	401;"	d
perm_reg	lib/simd/IBM_qpx.h	72;"	d
permutationP	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    const PermutationType& permutationP() const { eigen_assert("m_analysisIsOk"); return m_perm; }$/;"	f	class:Eigen::IncompleteCholesky
permutationP	lib/Eigen/src/LU/FullPivLU.h	/^    EIGEN_DEVICE_FUNC inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU
permutationP	lib/Eigen/src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU
permutationP	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationP	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU
permutationP	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU
permutationPinv	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationQ	lib/Eigen/src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU
permutationQ	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU
permutationQ	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU
permutation_matrix_product	lib/Eigen/src/Core/ProductEvaluators.h	/^struct permutation_matrix_product<ExpressionType, Side, Transposed, DenseShape>$/;"	s	namespace:Eigen::internal
permutation_matrix_product	lib/Eigen/src/Geometry/Homogeneous.h	/^struct permutation_matrix_product<ExpressionType, Side, Transposed, HomogeneousShape>$/;"	s	namespace:Eigen::internal
permutation_matrix_product	lib/Eigen/src/SparseCore/SparsePermutation.h	/^struct permutation_matrix_product<ExpressionType, Side, Transposed, SparseShape>$/;"	s	namespace:Eigen::internal
permute	lib/simd/Grid_vector_types.h	/^  friend inline void permute(Grid_simd &y, Grid_simd b, int perm) {$/;"	f	class:Grid::Grid_simd
permute	lib/simd/Grid_vector_types.h	/^inline void permute(ComplexD &y,ComplexD b, int perm) {  y=b; }$/;"	f	namespace:Grid
permute	lib/simd/Grid_vector_types.h	/^inline void permute(ComplexF &y,ComplexF b, int perm) {  y=b; }$/;"	f	namespace:Grid
permute	lib/simd/Grid_vector_types.h	/^inline void permute(RealD &y,RealD b, int perm) {  y=b; }$/;"	f	namespace:Grid
permute	lib/simd/Grid_vector_types.h	/^inline void permute(RealF &y,RealF b, int perm) {  y=b; }$/;"	f	namespace:Grid
permute	lib/tensors/Tensor_class.h	/^  friend strong_inline void permute(iMatrix<vtype,N> &out,const iMatrix<vtype,N> &in,int permutetype){$/;"	f	class:Grid::iMatrix
permute	lib/tensors/Tensor_class.h	/^  friend strong_inline void permute(iScalar<vtype> &out,$/;"	f	class:Grid::iScalar
permute	lib/tensors/Tensor_class.h	/^  friend strong_inline void permute(iVector<vtype,N> &out,const iVector<vtype,N> &in,int permutetype){$/;"	f	class:Grid::iVector
permute0	lib/simd/Grid_vector_types.h	/^  friend inline void permute0(Grid_simd &y, Grid_simd b) {$/;"	f	class:Grid::Grid_simd
permute1	lib/simd/Grid_vector_types.h	/^  friend inline void permute1(Grid_simd &y, Grid_simd b) {$/;"	f	class:Grid::Grid_simd
permute2	lib/simd/Grid_vector_types.h	/^  friend inline void permute2(Grid_simd &y, Grid_simd b) {$/;"	f	class:Grid::Grid_simd
permute3	lib/simd/Grid_vector_types.h	/^  friend inline void permute3(Grid_simd &y, Grid_simd b) {$/;"	f	class:Grid::Grid_simd
permute_symm_to_fullsymm	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::StorageIndex>& _dest, const typename MatrixType::StorageIndex* perm)$/;"	f	namespace:Eigen::internal
permute_symm_to_symm	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::StorageIndex>& _dest, const typename MatrixType::StorageIndex* perm)$/;"	f	namespace:Eigen::internal
perturbCol0	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::perturbCol0$/;"	f	class:Eigen::BDCSVD
pexp	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { using std::exp; return exp(a); }$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^pexp<Packet4d>(const Packet4d& _x) {$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^pexp<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^pexp<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 pexp<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 pexp<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 pexp<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pexp<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/NEON/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal
pexp	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
pfe	lib/algorithms/approx/Remez.cc	/^void AlgRemez::pfe(bigfloat *res, bigfloat *poles, bigfloat norm) {$/;"	f	class:AlgRemez
pfirst	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> pfirst<Packet2cd>(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet4cf>(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet4d>(const Packet4d& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet8f>(const Packet8f& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet8i>(const Packet8i& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double pfirst<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float pfirst<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE int pfirst<Packet16i>(const Packet16i& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double  pfirst<Packet2d>(const Packet2d& a) { double EIGEN_ALIGN16 x[2]; pstore<double>(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x; vec_ste(a, 0, &x); return x; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x; vec_ste(a, 0, &x); return x; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double pfirst<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  pfirst<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half pfirst<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return vgetq_lane_f64(a, 0); }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float   pfirst<Packet4f>(const Packet4f& a) { float   EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t pfirst<Packet4i>(const Packet4i& a) { int32_t EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double EIGEN_ALIGN16 x[2]; pstore(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float  EIGEN_ALIGN16 x[2]; vec_st2f(a.v4f[0], &x[0]); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int    EIGEN_ALIGN16 x[4]; pstore(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pfloor(const Packet& a) { using numext::floor; return floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pfloor<Packet4d>(const Packet4d& a) { return _mm256_floor_pd(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pfloor<Packet8f>(const Packet8f& a) { return _mm256_floor_ps(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return vec_floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) { return vec_floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return _mm_floor_pd(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) { return _mm_floor_ps(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return vec_floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/GenericPacketMath.h	/^ template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline Packet pgather(const Scalar* from, Index \/*stride*\/)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cd pgather<std::complex<double>, Packet2cd>(const std::complex<double>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4cf pgather<std::complex<float>, Packet4cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4d pgather<double, Packet4d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet8f pgather<float, Packet8f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline Packet16f pgather<float, Packet16f>(const float* from,$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline Packet8d pgather<double, Packet8d>(const double* from,$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double2 pgather<double, double2>(const double* from, Index stride) {$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float4 pgather<float, float4>(const float* from, Index stride) {$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pgather<Eigen::half, half2>(const Eigen::half* from, Index stride) {$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int32_t, Packet4i>(const int32_t* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride EIGEN_UNUSED)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)$/;"	f	namespace:Eigen::internal
phaseName_	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::vector<std::string>   phaseName_;$/;"	m	class:TChargedProp
phaseName_	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::vector<std::string>   phaseName_;$/;"	m	class:TChargedProp
phase_	extras/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::vector<ScalarField *> phase_;$/;"	m	class:TChargedProp
phase_	lib/Hadrons/Modules/MScalar/ChargedProp.hpp	/^    std::vector<ScalarField *> phase_;$/;"	m	class:TChargedProp
phider	lib/qcd/utils/ScalarObjs.h	/^  static void phider(typename Impl::Field &fsq,$/;"	f	class:Grid::ScalarObs
phifourth	lib/qcd/utils/ScalarObjs.h	/^  static void phifourth(typename Impl::Field &fsq,$/;"	f	class:Grid::ScalarObs
phisquared	lib/qcd/utils/ScalarObjs.h	/^  static void phisquared(typename Impl::Field &fsq,$/;"	f	class:Grid::ScalarObs
pickCheckerboard	lib/lattice/Lattice_transfer.h	/^  template<class vobj> inline void pickCheckerboard(int cb,Lattice<vobj> &half,const Lattice<vobj> &full){$/;"	f	namespace:Grid
pinsertfirst	lib/Eigen/src/Core/GenericPacketMath.h	/^pinsertfirst(const Packet& a, typename unpacket_traits<Packet>::type b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pinsertfirst(const Packet2cd& a, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pinsertfirst(const Packet4cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pinsertfirst(const Packet4d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pinsertfirst(const Packet8f& a, float b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pinsertfirst(const Packet1cd&, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pinsertfirst(const Packet2cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pinsertfirst(const Packet2d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertfirst	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pinsertfirst(const Packet4f& a, float b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/GenericPacketMath.h	/^pinsertlast(const Packet& a, typename unpacket_traits<Packet>::type b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pinsertlast(const Packet2cd& a, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pinsertlast(const Packet4cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pinsertlast(const Packet4d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pinsertlast(const Packet8f& a, float b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pinsertlast(const Packet1cd&, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pinsertlast(const Packet2cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pinsertlast(const Packet2d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertlast	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pinsertlast(const Packet4f& a, float b)$/;"	f	namespace:Eigen::internal
pivotL	lib/Eigen/src/SparseLU/SparseLU_pivotL.h	/^Index SparseLUImpl<Scalar,StorageIndex>::pivotL(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_DEVICE_FUNC plain_array() {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_DEVICE_FUNC plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^  plain_array() $/;"	f	struct:Eigen::internal::plain_array
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^  plain_array()$/;"	f	struct:Eigen::internal::plain_array
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) $/;"	f	struct:Eigen::internal::plain_array
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert)$/;"	f	struct:Eigen::internal::plain_array
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 32>$/;"	s	namespace:Eigen::internal
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 64>$/;"	s	namespace:Eigen::internal
plain_array	lib/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 8>$/;"	s	namespace:Eigen::internal
plain_matrix_type	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
plain_object_eval	lib/Eigen/src/SparseCore/SparseUtil.h	/^struct plain_object_eval<T,Sparse>$/;"	s	namespace:Eigen::internal
pload	lib/Eigen/src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pload <Packet2cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pload <Packet4cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet4cf(pload<Packet8f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pload<Packet4d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm256_load_pd(from); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pload<Packet8f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm256_load_ps(from); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pload<Packet8i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm256_load_si256(reinterpret_cast<const __m256i*>(from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pload<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i pload<Packet16i>(const int* from) {$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pload<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from) { return Packet1cd(pload<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>*        from) { return Packet2cf(pload<Packet4f>((const float *) from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pload<double2>(const double* from) {$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pload<float4>(const float* from) {$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pload<half2>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f64(from); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*    from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int32_t*  from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const __m128i*>(from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
pload	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
pload1	lib/Eigen/src/Core/GenericPacketMath.h	/^pload1(const typename unpacket_traits<Packet>::type  *a) { return pset1<Packet>(*a); }$/;"	f	namespace:Eigen::internal
pload1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pload1<Packet4d>(const double* from) { return _mm256_broadcast_sd(from); }$/;"	f	namespace:Eigen::internal
pload1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pload1<Packet8f>(const float*  from) { return _mm256_broadcast_ss(from); }$/;"	f	namespace:Eigen::internal
pload1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pload1<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
pload1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pload1<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
pload1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload1<Packet4f>(const float *from) {$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd ploaddup<Packet2cd>(const std::complex<double>* from) { return pset1<Packet2cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf ploaddup<Packet4cf>(const std::complex<float>* from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d ploaddup<Packet4d>(const double* from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f ploaddup<Packet8f>(const float* from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f ploaddup<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d ploaddup<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>*     from)  { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double2 ploaddup<double2>(const double*  from) {$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float4 ploaddup<float4>(const float*   from) {$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> EIGEN_STRONG_INLINE half2 ploaddup<half2>(const Eigen::half*  from) {$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int32_t* from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>*     from) {  return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*      from) {  return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*    from)$/;"	f	namespace:Eigen::internal
ploaddup	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploadquad	lib/Eigen/src/Core/GenericPacketMath.h	/^ploadquad(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadquad	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f ploadquad<Packet8f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadquad	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f ploadquad<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadquad	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d ploadquad<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadt	lib/Eigen/src/Core/GenericPacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadt_ro	lib/Eigen/src/Core/GenericPacketMath.h	/^inline Packet ploadt_ro(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadt_ro	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE double2 ploadt_ro<double2, Aligned>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE double2 ploadt_ro<double2, Unaligned>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE float4 ploadt_ro<float4, Aligned>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE float4 ploadt_ro<float4, Unaligned>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^ __device__ EIGEN_ALWAYS_INLINE half2 ploadt_ro<half2, Aligned>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^__device__ EIGEN_ALWAYS_INLINE half2 ploadt_ro<half2, Unaligned>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd ploadu<Packet2cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf ploadu<Packet4cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet4cf(ploadu<Packet8f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d ploadu<Packet4d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm256_loadu_pd(from); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f ploadu<Packet8f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm256_loadu_ps(from); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i ploadu<Packet8i>(const int* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm256_loadu_si256(reinterpret_cast<const __m256i*>(from)); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f ploadu<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i ploadu<Packet16i>(const int* from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d ploadu<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { return Packet1cd(ploadu<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>*       from) { return Packet2cf(ploadu<Packet4f>((const float*) from)); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 ploadu<double2>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 ploadu<float4>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 ploadu<half2>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f64(from); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*   from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int32_t* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double*    from) { return pload<Packet2d>(from); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*     from) { return pload<Packet4f>(from); }$/;"	f	namespace:Eigen::internal
ploadu	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*       from) { return pload<Packet4i>(from); }$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { using std::log; return log(a); }$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^plog<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^plog<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 plog<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 plog<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 plog<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 plog<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
plog	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
plog10	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet plog10(const Packet& a) { using std::log10; return log10(a); }$/;"	f	namespace:Eigen::internal
plog1p	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet plog1p(const Packet& a) { return numext::log1p(a); }$/;"	f	namespace:Eigen::internal
plog1p	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 plog1p<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
plog1p	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 plog1p<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
plog1p	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 plog1p<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/GenericPacketMath.h	/^plset(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d plset<Packet4d>(const double& a) { return _mm256_add_pd(_mm256_set1_pd(a), _mm256_set_pd(3.0,2.0,1.0,0.0)); }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f plset<Packet8f>(const float& a) { return _mm256_add_ps(_mm256_set1_ps(a), _mm256_set_ps(7.0,6.0,5.0,4.0,3.0,2.0,1.0,0.0)); }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f plset<Packet16f>(const float& a) {$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d plset<Packet8d>(const double& a) {$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return pset1<Packet2d>(a) + p2d_COUNTDOWN; }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) { return pset1<Packet4f>(a) + p4f_COUNTDOWN; }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a)   { return pset1<Packet4i>(a) + p4i_COUNTDOWN; }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 plset<double2>(const double& a) {$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 plset<float4>(const float& a) {$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 plset<half2>(const Eigen::half& a) {$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a)$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a)$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int32_t& a)$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return padd<Packet2d>(pset1<Packet2d>(a), p2d_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a)  { return padd<Packet4f>(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a)    { return padd<Packet4i>(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmadd(const Packet2cd& x, const Packet2cd& y, const Packet2cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmadd(const Packet2cd& x, const Packet4d& y, const Packet2cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmadd(const Packet4d& x, const Packet2cd& y, const Packet2cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmadd(const Packet4cf& x, const Packet4cf& y, const Packet4cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmadd(const Packet4cf& x, const Packet8f& y, const Packet4cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmadd(const Packet8f& x, const Packet4cf& y, const Packet4cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmadd(const Packet4d& a, const Packet4d& b, const Packet4d& c) {$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmadd(const Packet8f& a, const Packet8f& b, const Packet8f& c) {$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmadd(const Packet16f& a, const Packet16f& b,$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmadd(const Packet8d& a, const Packet8d& b,$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a,b,c); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return a*b + c; }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmadd<half2>(const half2& a, const half2& b, const half2& c) {$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vfmaq_f64(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vmlaq_f64(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vfmaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) {$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return _mm_fmadd_pd(a,b,c); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return _mm_fmadd_ps(a,b,c); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pmadd(const double& a, const double& b, const double& c) {$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float pmadd(const float& a, const float& b, const float& c) {$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c)$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd<Packet4i>(pmul<Packet4i>(a, b), c); }$/;"	f	namespace:Eigen::internal
pmadd	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const LhsScalar& x, const RhsScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmax	lib/Eigen/src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmax<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_max_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmax<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_max_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmax<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmax<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pmax<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pmax<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmax<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return vmaxq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmax	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmc0	lib/perfmon/Stat.h	/^    uint64_t pmc0, pmc1;\/\/ pmu$/;"	m	class:Grid::PmuStat
pmc1	lib/perfmon/Stat.h	/^    uint64_t pmc0, pmc1;\/\/ pmu$/;"	m	class:Grid::PmuStat
pmin	lib/Eigen/src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmin<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_min_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmin<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_min_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmin<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmin<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pmin<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pmin<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmin<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return vminq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmin	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmu_fini	lib/perfmon/Stat.cc	/^void PmuStat::pmu_fini(void) {}$/;"	f	class:Grid::PmuStat
pmu_init	lib/perfmon/Stat.cc	/^void PmuStat::pmu_init(void)$/;"	f	class:Grid::PmuStat
pmu_initialized	lib/perfmon/Stat.cc	/^bool PmuStat::pmu_initialized=false;$/;"	m	class:Grid::PmuStat	file:
pmu_initialized	lib/perfmon/Stat.h	/^    static bool pmu_initialized;$/;"	m	class:Grid::PmuStat
pmu_start	lib/perfmon/Stat.cc	/^void PmuStat::pmu_start(void) {};$/;"	f	class:Grid::PmuStat
pmu_stop	lib/perfmon/Stat.cc	/^void PmuStat::pmu_stop(void) {};$/;"	f	class:Grid::PmuStat
pmul	lib/Eigen/src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmul(const Packet2cd& a, const Packet2cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmul(const Packet2cd& x, const Packet4d& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmul(const Packet4d& x, const Packet2cd& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmul(const Packet4cf& a, const Packet4cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmul(const Packet4cf& x, const Packet8f& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmul(const Packet8f& x, const Packet4cf& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pmul<Packet2cd>(const Packet2cd& a, const Packet2cd& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pmul<Packet4cf>(const Packet4cf& a, const Packet4cf& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmul<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmul<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmul<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmul<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_madd(a,b,p2d_MZERO); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b, p4f_MZERO); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return a * b; }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pmul<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pmul<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmul<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return vmulq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a * b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a * b); }$/;"	f	namespace:Eigen::internal
pmul	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const LhsScalar& x, const RhsScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pnegate	lib/Eigen/src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pnegate(const Packet2cd& a) { return Packet2cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pnegate(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pnegate(const Packet4d& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pnegate(const Packet8f& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pnegate(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pnegate(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return p2d_ZERO - a; }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return p4f_ZERO - a; }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return p4i_ZERO - a; }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pnegate(const double2& a) {$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pnegate(const float4& a) {$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pnegate(const half2& a) {$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate<Packet2d>(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return vnegq_f64(a); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(Packet4f(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return (-a); }$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pnegate	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return (-a); }$/;"	f	namespace:Eigen::internal
pointAt	lib/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt(const _Scalar& t) const$/;"	f	class:Eigen::ParametrizedLine
pointer	lib/Eigen/src/Core/util/Memory.h	/^  typedef T*              pointer;$/;"	t	class:Eigen::aligned_allocator
pointer	lib/Eigen/src/StlSupport/details.h	/^    typedef T*              pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
pointer	lib/allocator/AlignedAllocator.h	/^    typedef _Tp *pointer;$/;"	t	class:Grid::alignedAllocator
pointer	lib/allocator/AlignedAllocator.h	/^  typedef _Tp*       pointer;$/;"	t	class:Grid::commAllocator
pointer	lib/pugixml/pugixml.h	/^		typedef xml_attribute* pointer;$/;"	t	class:pugi::xml_attribute_iterator
pointer	lib/pugixml/pugixml.h	/^		typedef xml_node* pointer;$/;"	t	class:pugi::xml_named_node_iterator
pointer	lib/pugixml/pugixml.h	/^		typedef xml_node* pointer;$/;"	t	class:pugi::xml_node_iterator
pokeColour	lib/qcd/QCD.h	/^      void pokeColour(Lattice<vobj> &lhs,$/;"	f	namespace:Grid::QCD
pokeColour	lib/qcd/QCD.h	/^    template<class vobj> void pokeColour(vobj &lhs,const decltype(peekIndex<ColourIndex>(lhs,0)) & rhs,int i)$/;"	f	namespace:Grid::QCD
pokeColour	lib/qcd/QCD.h	/^    template<class vobj> void pokeColour(vobj &lhs,const decltype(peekIndex<ColourIndex>(lhs,0,0)) & rhs,int i,int j)$/;"	f	namespace:Grid::QCD
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iMatrix<vtype,N> &ret, const iMatrix<decltype(TensorIndexRecursion<Level-1>::peekIndex(ret._internal[0][0],0)),N> &arg, int i)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iMatrix<vtype,N> &ret, const iMatrix<decltype(TensorIndexRecursion<Level-1>::peekIndex(ret._internal[0][0],0)),N> &arg, int i,int j)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iMatrix<vtype,N> &ret, const iScalar<vtype> &arg,int i,int j)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iScalar<vtype> &ret, const iScalar<decltype(TensorIndexRecursion<Level-1>::peekIndex(ret._internal,0))> &arg, int i)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iScalar<vtype> &ret, const iScalar<decltype(TensorIndexRecursion<Level-1>::peekIndex(ret._internal,0,0))> &arg, int i,int j)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iVector<vtype,N> &ret, const iScalar<vtype> &arg,int i)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iVector<vtype,N> &ret, const iVector<decltype(TensorIndexRecursion<Level-1>::peekIndex(ret._internal[0],0)),N> &arg, int i)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^    void pokeIndex(iVector<vtype,N> &ret, const iVector<decltype(TensorIndexRecursion<Level-1>::peekIndex(ret._internal[0],0)),N> &arg, int i,int j)$/;"	f	class:Grid::TensorIndexRecursion
pokeIndex	lib/tensors/Tensor_index.h	/^void pokeIndex (vtype &ret,const decltype(TensorIndexRecursion<Level>::peekIndex(ret,0)) &arg,int i) $/;"	f	namespace:Grid
pokeIndex	lib/tensors/Tensor_index.h	/^void pokeIndex (vtype &ret,const decltype(TensorIndexRecursion<Level>::peekIndex(ret,0,0)) &arg,int i,int j) $/;"	f	namespace:Grid
pokeLocalSite	lib/lattice/Lattice_peekpoke.h	/^    void pokeLocalSite(const sobj &s,Lattice<vobj> &l,std::vector<int> &site){$/;"	f	namespace:Grid
pokeLorentz	lib/qcd/QCD.h	/^      void pokeLorentz(Lattice<vobj> &lhs,$/;"	f	namespace:Grid::QCD
pokeLorentz	lib/qcd/QCD.h	/^    template<class vobj> void pokeLorentz(vobj &lhs,const decltype(peekIndex<LorentzIndex>(lhs,0)) & rhs,int i)$/;"	f	namespace:Grid::QCD
pokeSite	lib/lattice/Lattice_peekpoke.h	/^    void pokeSite(const sobj &s,Lattice<vobj> &l,const std::vector<int> &site){$/;"	f	namespace:Grid
pokeSpin	lib/qcd/QCD.h	/^      void pokeSpin(Lattice<vobj> &lhs,$/;"	f	namespace:Grid::QCD
pokeSpin	lib/qcd/QCD.h	/^    template<class vobj> void pokeSpin(vobj &lhs,const decltype(peekIndex<SpinIndex>(lhs,0)) & rhs,int i)$/;"	f	namespace:Grid::QCD
pokeSpin	lib/qcd/QCD.h	/^    template<class vobj> void pokeSpin(vobj &lhs,const decltype(peekIndex<SpinIndex>(lhs,0,0)) & rhs,int i,int j)$/;"	f	namespace:Grid::QCD
poles	lib/algorithms/approx/MultiShiftFunction.h	/^  std::vector<RealD> poles;$/;"	m	class:Grid::MultiShiftFunction
poles	lib/algorithms/approx/Remez.h	/^  bigfloat *param, *roots, *poles;$/;"	m	class:AlgRemez
polyDiff	lib/algorithms/approx/Remez.cc	/^bigfloat AlgRemez::polyDiff(bigfloat x, bigfloat *poly, long size) {$/;"	f	class:AlgRemez
polyEval	lib/algorithms/approx/Remez.cc	/^bigfloat AlgRemez::polyEval(bigfloat x, bigfloat *poly, long size) {$/;"	f	class:AlgRemez
poly_factored_to_dense	lib/algorithms/approx/Zolotarev.cc	/^static INTERNAL_PRECISION *poly_factored_to_dense(INTERNAL_PRECISION A, $/;"	f	namespace:Grid::Approx
pool	lib/communicator/Communicator_mpi3_leader.cc	/^const int pool = 48;$/;"	m	namespace:Grid	file:
pop	lib/serialisation/BaseIO.h	/^  inline void pop(Reader<T> &r)$/;"	f	namespace:Grid
pop	lib/serialisation/BaseIO.h	/^  inline void pop(Writer<T> &w)$/;"	f	namespace:Grid
pop	lib/serialisation/BaseIO.h	/^  void Reader<T>::pop(void)$/;"	f	class:Grid::Reader
pop	lib/serialisation/BaseIO.h	/^  void Writer<T>::pop(void)$/;"	f	class:Grid::Writer
pop	lib/serialisation/BinaryIO.h	/^    void pop(void) {};$/;"	f	class:Grid::BinaryReader
pop	lib/serialisation/BinaryIO.h	/^    void pop(void) {};$/;"	f	class:Grid::BinaryWriter
pop	lib/serialisation/Hdf5IO.cc	/^void Hdf5Reader::pop(void)$/;"	f	class:Hdf5Reader
pop	lib/serialisation/Hdf5IO.cc	/^void Hdf5Writer::pop(void)$/;"	f	class:Hdf5Writer
pop	lib/serialisation/JSON_IO.cc	/^void JSONReader::pop(void)$/;"	f	class:JSONReader
pop	lib/serialisation/JSON_IO.cc	/^void JSONWriter::pop(void)$/;"	f	class:JSONWriter
pop	lib/serialisation/TextIO.cc	/^void TextReader::pop(void)$/;"	f	class:TextReader
pop	lib/serialisation/TextIO.cc	/^void TextWriter::pop(void)$/;"	f	class:TextWriter
pop	lib/serialisation/XmlIO.cc	/^void XmlReader::pop(void)$/;"	f	class:XmlReader
pop	lib/serialisation/XmlIO.cc	/^void XmlWriter::pop(void)$/;"	f	class:XmlWriter
popSize	extras/Hadrons/GeneticScheduler.hpp	/^        unsigned int popSize, seed;$/;"	m	struct:GeneticScheduler::Parameters
popSize	lib/Hadrons/GeneticScheduler.hpp	/^        unsigned int popSize, seed;$/;"	m	struct:GeneticScheduler::Parameters
pop_back	lib/json/json.hpp	/^        std::string pop_back()$/;"	f	class:nlohmann::basic_json::json_pointer
population_	extras/Hadrons/GeneticScheduler.hpp	/^    std::multimap<int, Gene> population_;$/;"	m	class:GeneticScheduler
population_	lib/Hadrons/GeneticScheduler.hpp	/^    std::multimap<int, Gene> population_;$/;"	m	class:GeneticScheduler
por	lib/Eigen/src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd por    <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf por    <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d por<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_or_pd(a,b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f por<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_or_ps(a,b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f por<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d por<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(por(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(por<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(por<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
por	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
position	lib/pugixml/pugixml.cc	/^		size_t position, size;$/;"	m	struct:xpath_context	file:
pow	lib/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<ExponentDerived>& exponents) $/;"	f	namespace:Eigen
pow	lib/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Scalar& x, const Eigen::ArrayBase<Derived>& exponents)$/;"	f	namespace:Eigen
pow	lib/Eigen/src/Core/GlobalFunctions.h	/^  pow(const typename Derived::Scalar& x, const Eigen::ArrayBase<Derived>& exponents)$/;"	f	namespace:Eigen
pow	lib/Eigen/src/Core/MathFunctions.h	/^inline typename internal::pow_impl<ScalarX,ScalarY>::result_type pow(const ScalarX& x, const ScalarY& y)$/;"	f	namespace:Eigen::numext
pow	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half pow(const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
pow	lib/lattice/Lattice_unary.h	/^  template<class obj> Lattice<obj> pow(const Lattice<obj> &rhs,RealD y){$/;"	f	namespace:Grid
pow	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> pow(const Grid_simd<S, V> &r, double y) {$/;"	f	namespace:Grid
pow_bf	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat pow_bf(const bigfloat& a, bigfloat &power) {$/;"	f	class:bigfloat
pow_bf	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat pow_bf(const bigfloat& a, long power) {$/;"	f	class:bigfloat
pow_bf	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat pow_bf(const bigfloat& a, bigfloat &power) {$/;"	f	class:bigfloat
pow_bf	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat pow_bf(const bigfloat& a, long power) {$/;"	f	class:bigfloat
pow_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct pow_impl$/;"	s	namespace:Eigen::internal
pow_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct pow_impl<ScalarX,ScalarY, true>$/;"	s	namespace:Eigen::internal
power_den	lib/algorithms/approx/Remez.h	/^  unsigned long power_den;$/;"	m	class:AlgRemez
power_num	lib/algorithms/approx/Remez.h	/^  unsigned long power_num; $/;"	m	class:AlgRemez
powh	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half powh(const Eigen::half& a, const Eigen::half& b) {$/;"	f
prec	lib/algorithms/approx/Remez.h	/^  long prec;$/;"	m	class:AlgRemez
precedence	lib/pugixml/pugixml.cc	/^			int precedence;$/;"	m	struct:xpath_parser::binary_op_t	file:
precision	lib/Eigen/src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat
precisionChange	lib/lattice/Lattice_transfer.h	/^void precisionChange(Lattice<VobjOut> &out, const Lattice<VobjIn> &in){$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vComplexD *out,vComplexF *in,int nvec){ precisionChange((vRealD *)out,(vRealF *)in,nvec);}$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vComplexD *out,vComplexH *in,int nvec){ precisionChange((vRealD *)out,(vRealH *)in,nvec);}$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vComplexF *out,vComplexD *in,int nvec){ precisionChange((vRealF *)out,(vRealD *)in,nvec);}$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vComplexF *out,vComplexH *in,int nvec){ precisionChange((vRealF *)out,(vRealH *)in,nvec);}$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vComplexH *out,vComplexD *in,int nvec){ precisionChange((vRealH *)out,(vRealD *)in,nvec);}$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vComplexH *out,vComplexF *in,int nvec){ precisionChange((vRealH *)out,(vRealF *)in,nvec);}$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vRealD    *out,vRealF    *in,int nvec)$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vRealD    *out,vRealH    *in,int nvec)$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vRealF    *out,vRealD    *in,int nvec)$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vRealF    *out,vRealH    *in,int nvec)$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vRealH    *out,vRealD    *in,int nvec)$/;"	f	namespace:Grid
precisionChange	lib/simd/Grid_vector_types.h	/^inline void precisionChange(vRealH    *out,vRealF    *in,int nvec)$/;"	f	namespace:Grid
preconditioner	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
preconditioner	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
predicate_constant	lib/pugixml/pugixml.cc	/^		predicate_constant,$/;"	e	enum:predicate_t	file:
predicate_constant_one	lib/pugixml/pugixml.cc	/^		predicate_constant_one$/;"	e	enum:predicate_t	file:
predicate_default	lib/pugixml/pugixml.cc	/^		predicate_default,$/;"	e	enum:predicate_t	file:
predicate_posinv	lib/pugixml/pugixml.cc	/^		predicate_posinv,$/;"	e	enum:predicate_t	file:
predicate_t	lib/pugixml/pugixml.cc	/^	enum predicate_t$/;"	g	file:
predicatedWhere	lib/lattice/Lattice_ET.h	/^inline vobj predicatedWhere(const iobj &predicate, const vobj &iftrue,$/;"	f	namespace:Grid
predux	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet2cd>(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet4cf>(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return (vget_low_f64(a) + vget_high_f64(a))[0]; }$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return vget_lane_f64(vget_low_f64(a) + vget_high_f64(a), 0); }$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op
predux	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op
predux	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op
predux	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op
predux_downto4	lib/Eigen/src/Core/GenericPacketMath.h	/^predux_downto4(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_downto4	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f predux_downto4<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_downto4	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet4d predux_downto4<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_downto4	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8f predux_downto4<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_downto4	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const DoublePacket<Packet>& predux_downto4(const DoublePacket<Packet> &a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux_max<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux_max<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux_max<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux_max<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux_max<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a) { return vgetq_lane_f64(vpmaxq_f64(a, a), 0); }$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux_min<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux_min<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux_min<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux_min<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux_min<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a) { return vgetq_lane_f64(vpminq_f64(a, a), 0); }$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet2cd>(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet4cf>(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux_mul<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux_mul<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux_mul<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux_mul<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux_mul<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a) { return (vget_low_f64(a) * vget_high_f64(a))[0]; }$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a) { return vget_lane_f64(vget_low_f64(a) * vget_high_f64(a), 0); }$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd preduxp<Packet2cd>(const Packet2cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf preduxp<Packet4cf>(const Packet4cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d preduxp<Packet4d>(const Packet4d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f preduxp<Packet8f>(const Packet8f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet16f preduxp<Packet16f>(const Packet16f*$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8d preduxp<Packet8d>(const Packet8d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)        { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar> EIGEN_DEVICE_FUNC inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> * addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> * addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { EIGEN_ARM_PREFETCH((double *)addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { EIGEN_ARM_PREFETCH((float *)addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>  (const float*    addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int32_t>(const int32_t*  addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *     addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void prefetch(int i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
prefetch	lib/tensors/Tensor_class.h	/^  friend strong_inline void prefetch(iMatrix<vtype,N> &that){$/;"	f	class:Grid::iMatrix
prefetch	lib/tensors/Tensor_class.h	/^  friend strong_inline void prefetch(iScalar<vtype> &that) {$/;"	f	class:Grid::iScalar
prefetch	lib/tensors/Tensor_class.h	/^  friend strong_inline void prefetch(iVector<vtype, N> &that) {$/;"	f	class:Grid::iVector
prefetch_HINT_T0	lib/simd/Grid_avx.h	/^  inline void prefetch_HINT_T0(const char *ptr){$/;"	f	namespace:Grid
prefetch_HINT_T0	lib/simd/Grid_avx512.h	/^  inline void prefetch_HINT_T0(const char *ptr){$/;"	f	namespace:Grid
prefetch_HINT_T0	lib/simd/Grid_generic.h	/^  inline void prefetch_HINT_T0(const char *ptr){};$/;"	f	namespace:Grid
prefetch_HINT_T0	lib/simd/Grid_imci.h	/^  inline void prefetch_HINT_T0(const char *ptr){$/;"	f	namespace:Grid
prefetch_HINT_T0	lib/simd/Grid_neon.h	/^  inline void prefetch_HINT_T0(const char *ptr){};$/;"	f	namespace:Grid
prefetch_HINT_T0	lib/simd/Grid_qpx.h	/^inline void prefetch_HINT_T0(const char *ptr){};$/;"	f	namespace:Grid
prefetch_HINT_T0	lib/simd/Grid_sse4.h	/^  inline void prefetch_HINT_T0(const char *ptr){$/;"	f	namespace:Grid
prefix	lib/pugixml/pugixml.cc	/^		const char_t* prefix;$/;"	m	struct:namespace_uri_predicate	file:
prefix_length	lib/pugixml/pugixml.cc	/^		size_t prefix_length;$/;"	m	struct:namespace_uri_predicate	file:
prepend_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::prepend_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node
prepend_attribute	lib/pugixml/pugixml.cc	/^	inline void prepend_attribute(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f
prepend_child	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::prepend_child(const char_t* name_)$/;"	f	class:pugi::xml_node
prepend_child	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::prepend_child(xml_node_type type_)$/;"	f	class:pugi::xml_node
prepend_copy	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_node::prepend_copy(const xml_attribute& proto)$/;"	f	class:pugi::xml_node
prepend_copy	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::prepend_copy(const xml_node& proto)$/;"	f	class:pugi::xml_node
prepend_move	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::prepend_move(const xml_node& moved)$/;"	f	class:pugi::xml_node
prepend_node	lib/pugixml/pugixml.cc	/^	inline void prepend_node(xml_node_struct* child, xml_node_struct* node)$/;"	f
prerotate	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
prescale	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(const Scalar& s)$/;"	f	class:Eigen::Transform
prescale	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
preshear	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform
pretranslate	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
prev	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType prev ;  \/* previous column in degree list, if col is in a *\/$/;"	m	union:internal::colamd_col::__anon625
prev	lib/pugixml/pugixml.cc	/^		xml_memory_page* prev;$/;"	m	struct:xml_memory_page	file:
prev_attribute_c	lib/pugixml/pugixml.cc	/^		impl::compact_pointer<xml_attribute_struct, 6> prev_attribute_c;$/;"	m	struct:pugi::xml_attribute_struct	file:
prev_sibling_c	lib/pugixml/pugixml.cc	/^		impl::compact_pointer<xml_node_struct,  9>    prev_sibling_c;$/;"	m	struct:pugi::xml_node_struct	file:
preverse	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd preverse(const Packet2cd& a) {$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf preverse(const Packet4cf& a) {$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d preverse(const Packet4d& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f preverse(const Packet8f& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet16f preverse(const Packet16f& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8d preverse(const Packet8d& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a) { return vcombine_f64(vget_high_f64(a), vget_low_f64(a)); }$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(Packet2d(_mm_castps_pd(a.v))))); }$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
previous_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute xml_attribute::previous_attribute() const$/;"	f	class:pugi::xml_attribute
previous_sibling	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::previous_sibling() const$/;"	f	class:pugi::xml_node
previous_sibling	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::previous_sibling(const char_t* name_) const$/;"	f	class:pugi::xml_node
primitive_iterator	lib/json/json.hpp	/^            : object_iterator(), array_iterator(), primitive_iterator()$/;"	f	struct:nlohmann::basic_json::internal_iterator
primitive_iterator	lib/json/json.hpp	/^        primitive_iterator_t primitive_iterator;$/;"	m	struct:nlohmann::basic_json::internal_iterator
primitive_iterator_t	lib/json/json.hpp	/^    class primitive_iterator_t$/;"	c	class:nlohmann::basic_json
print	lib/perfmon/Stat.cc	/^void PmuStat::print(void)$/;"	f	class:Grid::PmuStat
print	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_node::print(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const$/;"	f	class:pugi::xml_node
print	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_node::print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags, unsigned int depth) const$/;"	f	class:pugi::xml_node
print	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_node::print(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const$/;"	f	class:pugi::xml_node
print	tests/core/Test_gamma.cc	/^void print(const SpinMatrix &g)$/;"	f
printBase	lib/qcd/utils/SUnTwoIndex.h	/^  static void printBase(void) {$/;"	f	class:Grid::QCD::SU_TwoIndex
printContent	extras/Hadrons/Environment.cc	/^void Environment::printContent(void)$/;"	f	class:Environment
printContent	lib/Hadrons/Environment.cc	/^void Environment::printContent(void)$/;"	f	class:Environment
printGenerators	lib/qcd/utils/SUn.h	/^  static void printGenerators(void) {$/;"	f	class:Grid::QCD::SU
printGenerators	lib/qcd/utils/SUnAdjoint.h	/^  static void printGenerators(void) {$/;"	f	class:Grid::QCD::SU_Adjoint
printGenerators	lib/qcd/utils/SUnTwoIndex.h	/^  static void printGenerators(void) {$/;"	f	class:Grid::QCD::SU_TwoIndex
printSchedule	extras/Hadrons/Application.cc	/^void Application::printSchedule(void)$/;"	f	class:Application
printSchedule	lib/Hadrons/Application.cc	/^void Application::printSchedule(void)$/;"	f	class:Application
print_actions	lib/qcd/hmc/integrators/Integrator.h	/^  void print_actions(){$/;"	f	class:Grid::QCD::Integrator
print_matrix	lib/Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal
print_parameters	lib/qcd/hmc/HMC.h	/^  void print_parameters() const {$/;"	f	struct:Grid::QCD::HMCparameters
print_parameters	lib/qcd/hmc/checkpointers/CheckPointerModules.h	/^  virtual void print_parameters(){$/;"	f	class:Grid::CheckPointerModule
print_parameters	lib/qcd/hmc/integrators/Integrator.h	/^  void print_parameters() const {$/;"	f	class:Grid::QCD::IntegratorParameters
print_parameters	lib/qcd/hmc/integrators/Integrator.h	/^  void print_parameters(){$/;"	f	class:Grid::QCD::Integrator
print_parameters	lib/qcd/modules/ActionModules.h	/^  virtual void print_parameters(){$/;"	f	class:Grid::ActionModule
print_parameters	lib/qcd/modules/FermionOperatorModules.h	/^  virtual void print_parameters(){$/;"	f	class:Grid::FermionOperatorModule
print_parameters	lib/qcd/modules/Modules.h	/^  virtual void print_parameters(){};  \/\/ default to nothing$/;"	f	class:Grid::HMCModuleBase
print_parameters	lib/qcd/modules/Modules.h	/^  void print_parameters(){$/;"	f	class:Grid::Parametrized
print_parameters	lib/qcd/modules/Modules.h	/^  void print_parameters(){}$/;"	f	class:Grid::Parametrized
print_parameters	lib/qcd/modules/ObservableModules.h	/^  virtual void print_parameters(){$/;"	f	class:Grid::ObservableModule
print_parameters	lib/qcd/modules/SolverModules.h	/^  virtual void print_parameters(){$/;"	f	class:Grid::SolverModule
prng_engine	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    prng_engine() $/;"	f	class:sitmo::prng_engine
prng_engine	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    prng_engine(Seq& q, typename sitmo_enable_if< has_generate_template<Seq>::value >::type* = 0 )$/;"	f	class:sitmo::prng_engine
prng_engine	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    prng_engine(const prng_engine& x)$/;"	f	class:sitmo::prng_engine
prng_engine	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    prng_engine(uint32_t s) $/;"	f	class:sitmo::prng_engine
prng_engine	lib/sitmo_rng/sitmo_prng_engine.hpp	/^class prng_engine$/;"	c	namespace:sitmo
processRow	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void processRow(const LhsEval& lhsEval, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha, Index i, Index col)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
processor_coor	lib/algorithms/FFT.h	/^    std::vector<int> processor_coor;$/;"	m	class:Grid::FFT
processors	lib/algorithms/FFT.h	/^    std::vector<int> processors;$/;"	m	class:Grid::FFT
prod	lib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase
prod	lib/Eigen/src/Core/VectorwiseOp.h	/^    const ProdReturnType prod() const$/;"	f	class:Eigen::VectorwiseOp
product_evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^  explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, LazyCoeffBasedProductMode, DenseShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, LazyProduct>, ProductTag, DenseShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, Options>, ProductTag, LhsShape, RhsShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, ProductKind>, ProductTag, DenseShape, DiagonalShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, ProductKind>, ProductTag, DiagonalShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/Geometry/Homogeneous.h	/^struct product_evaluator<Product<Lhs, Rhs, LazyProduct>, ProductTag, DenseShape, HomogeneousShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/Geometry/Homogeneous.h	/^struct product_evaluator<Product<Lhs, Rhs, LazyProduct>, ProductTag, HomogeneousShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, OuterProduct, DenseShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, OuterProduct, SparseShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  explicit product_evaluator(const XprType& xpr) : Base(xpr.lhs(), xpr.rhs().diagonal().transpose()) {}$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  explicit product_evaluator(const XprType& xpr) : Base(xpr.rhs(), xpr.lhs().diagonal()) {}$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, ProductTag, DiagonalShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, ProductTag, SparseShape, DiagonalShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparsePermutation.h	/^  explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/SparseCore/SparsePermutation.h	/^struct product_evaluator<Product<Lhs, Rhs, AliasFreeProduct>, ProductTag, PermutationShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparsePermutation.h	/^struct product_evaluator<Product<Lhs, Rhs, AliasFreeProduct>, ProductTag, SparseShape, PermutationShape >$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct product_evaluator<Product<Lhs, RhsView, DefaultProduct>, ProductTag, SparseShape, SparseSelfAdjointShape>$/;"	s	namespace:Eigen::internal
product_evaluator	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct product_evaluator<Product<LhsView, Rhs, DefaultProduct>, ProductTag, SparseSelfAdjointShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_promote_storage_type	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Dense,Sparse, OuterProduct> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_promote_storage_type	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Sparse,Dense, OuterProduct> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_promote_storage_type	lib/Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<PermutationStorage, Sparse,             ProductTag> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_promote_storage_type	lib/Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<Sparse,             PermutationStorage, ProductTag> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_size_category	lib/Eigen/src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix_trmm	lib/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal
product_type	lib/Eigen/src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<int M>         struct product_type_selector<M, 1, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	lib/Eigen/src/Core/GeneralProduct.h	/^template<int N>         struct product_type_selector<1, N, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
program_	extras/Hadrons/Application.hpp	/^    std::vector<unsigned int> program_;$/;"	m	class:Application
program_	lib/Hadrons/Application.hpp	/^    std::vector<unsigned int> program_;$/;"	m	class:Application
program_details	missing	/^program_details ()$/;"	f
projImag	lib/simd/Simd.h	/^  inline ComplexD projImag(const ComplexD &r){return (ComplexD(std::imag(r), 0.0));}$/;"	f	namespace:Grid
projImag	lib/simd/Simd.h	/^  inline ComplexF projImag(const ComplexF &r){return (ComplexF(std::imag(r), 0.0 ));}$/;"	f	namespace:Grid
projReal	lib/simd/Simd.h	/^  inline ComplexD projReal(const ComplexD &r){return( ComplexD(std::real(r), 0.0));}$/;"	f	namespace:Grid
projReal	lib/simd/Simd.h	/^  inline ComplexF projReal(const ComplexF &r){return( ComplexF(std::real(r), 0.0));}$/;"	f	namespace:Grid
projectForce	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline Field projectForce(Field &P) { return Ta(P); }$/;"	f	class:Grid::QCD::GaugeImplTypes
projectForce	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline Field projectForce(Field& P) {return P;}$/;"	f	class:Grid::ScalarAdjMatrixImplTypes
projectForce	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline Field projectForce(Field& P){return P;}$/;"	f	class:Grid::ScalarImplTypes
projectOnAlgebra	lib/qcd/representations/adjoint.h	/^  void projectOnAlgebra(typename SU<ncolour>::LatticeAlgebraVector &h_out,$/;"	f	class:Grid::QCD::AdjointRep
projectOnAlgebra	lib/qcd/representations/two_index.h	/^  void projectOnAlgebra(typename SU<ncolour>::LatticeAlgebraVector &h_out,$/;"	f	class:Grid::QCD::TwoIndexRep
projectOnAlgebra	lib/qcd/utils/SUn.h	/^  static void projectOnAlgebra(LatticeAlgebraVector &h_out, const LatticeMatrix &in, Real scale = 1.0) {$/;"	f	class:Grid::QCD::SU
projectOnAlgebra	lib/qcd/utils/SUnAdjoint.h	/^  static void projectOnAlgebra(typename SU<ncolour>::LatticeAlgebraVector &h_out, const LatticeAdjMatrix &in, Real scale = 1.0) {$/;"	f	class:Grid::QCD::SU_Adjoint
projectOnAlgebra	lib/qcd/utils/SUnTwoIndex.h	/^  static void projectOnAlgebra($/;"	f	class:Grid::QCD::SU_TwoIndex
projection	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane
projection	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
projective_transform_inverse	lib/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
projective_transform_inverse	lib/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
projector	lib/qcd/utils/SUnAdjoint.h	/^  static void projector(typename SU<ncolour>::LatticeAlgebraVector &h_out, const LatticeAdjMatrix &in, Real scale = 1.0) {$/;"	f	class:Grid::QCD::SU_Adjoint
projector	lib/qcd/utils/SUnTwoIndex.h	/^  static void projector(typename SU<ncolour>::LatticeAlgebraVector &h_out,$/;"	f	class:Grid::QCD::SU_TwoIndex
promote_index_type	lib/Eigen/src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
promote_scalar_arg	lib/Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg<S,T,false> : promote_scalar_arg_unsupported<S,T,typename NumTraits<S>::Literal> {};$/;"	s	namespace:Eigen::internal
promote_scalar_arg	lib/Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg<S,T,true>$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	lib/Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<ExprScalar,T,PromotedType,false,true>$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	lib/Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<S,T,PromotedType,ConvertibleToLiteral,false> {};$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	lib/Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<S,T,PromotedType,true,true>$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	lib/Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<S,T,S,false,true> {};$/;"	s	namespace:Eigen::internal
properties	extras/Hadrons/Environment.hpp	/^        std::set<unsigned int>  owners, properties;$/;"	m	struct:Environment::ObjInfo
properties	lib/Hadrons/Environment.hpp	/^        std::set<unsigned int>  owners, properties;$/;"	m	struct:Environment::ObjInfo
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
pround	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet pround(const Packet& a) { using numext::round; return round(a); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pround<Packet4d>(const Packet4d& a) { return _mm256_round_pd(a, _MM_FROUND_CUR_DIRECTION); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pround<Packet8f>(const Packet8f& a) { return _mm256_round_ps(a, _MM_FROUND_CUR_DIRECTION); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return vec_round(a); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a) { return vec_round(a); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return _mm_round_pd(a, 0); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a) { return _mm_round_ps(a, 0); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return vec_round(a); }$/;"	f	namespace:Eigen::internal
pround	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet prsqrt(const Packet& a) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet4d prsqrt<Packet4d>(const Packet4d& x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet8f prsqrt<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet8f prsqrt<Packet8f>(const Packet8f& x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^EIGEN_STRONG_INLINE Packet16f prsqrt<Packet16f>(const Packet16f& x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^prsqrt<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^prsqrt<Packet8d>(const Packet8d& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet2d prsqrt<Packet2d>(const Packet2d& x)$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 prsqrt<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 prsqrt<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 prsqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 prsqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet2d prsqrt<Packet2d>(const Packet2d& x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet2d prsqrt<Packet2d>(const Packet2d& x) {$/;"	f	namespace:Eigen::internal
prsqrt	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& x) {$/;"	f	namespace:Eigen::internal
prune	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage
prune	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix
prune	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix
prune	lib/Eigen/src/SparseCore/SparseVector.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector
pruneL	lib/Eigen/src/SparseLU/SparseLU_pruneL.h	/^void SparseLUImpl<Scalar,StorageIndex>::pruneL(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg,$/;"	f	class:Eigen::internal::SparseLUImpl
pruned	lib/Eigen/src/SparseCore/SparseView.h	/^SparseMatrixBase<Derived>::pruned(const Scalar& reference,$/;"	f	class:Eigen::SparseMatrixBase
pscatter	lib/Eigen/src/Core/GenericPacketMath.h	/^ template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pscatter(Scalar* to, const Packet& from, Index \/*stride*\/)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet2cd>(std::complex<double>* to, const Packet2cd& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet4cf>(std::complex<float>* to, const Packet4cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet4d>(double* to, const Packet4d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet8f>(float* to, const Packet8f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void pscatter<double, Packet8d>(double* to,$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void pscatter<float, Packet16f>(float* to,$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, double2>(double* to, const double2& from, Index stride) {$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, float4>(float* to, const float4& from, Index stride) {$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE void pscatter<Eigen::half, half2>(Eigen::half* to, const half2& from, Index stride) {$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int32_t, Packet4i>(int32_t* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride EIGEN_UNUSED)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pset1<Packet2cd>(const std::complex<double>& from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pset1<Packet4cf>(const std::complex<float>& from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pset1<Packet4d>(const double& from) { return _mm256_set1_pd(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pset1<Packet8f>(const float&  from) { return _mm256_set1_ps(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pset1<Packet8i>(const int&    from) { return _mm256_set1_epi32(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pset1<Packet16f>(const float& from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i pset1<Packet16i>(const int& from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pset1<Packet8d>(const double& from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double&  from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pset1<double2>(const double& from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pset1<float4>(const float&  from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pset1<half2>(const Eigen::half& from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double&  from) { return vdupq_n_f64(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int32_t&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps1(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) {$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&    from)$/;"	f	namespace:Eigen::internal
pset1	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)$/;"	f	namespace:Eigen::internal
pseudoEigenvalueMatrix	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver
pseudoEigenvectors	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver
pseudoInverse	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline const Inverse<CompleteOrthogonalDecomposition> pseudoInverse() const$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
pshiftleft	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^inline Packet8i pshiftleft(Packet8i v, int n)$/;"	f	namespace:Eigen::internal
pshiftright	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^inline Packet8f pshiftright(Packet8f v, int n)$/;"	f	namespace:Eigen::internal
psi_00	lib/simd/BGQQPX.h	73;"	d
psi_00	lib/simd/IBM_qpx.h	36;"	d
psi_00	lib/simd/Intel512wilson.h	34;"	d
psi_01	lib/simd/BGQQPX.h	74;"	d
psi_01	lib/simd/IBM_qpx.h	37;"	d
psi_01	lib/simd/Intel512wilson.h	35;"	d
psi_02	lib/simd/BGQQPX.h	75;"	d
psi_02	lib/simd/IBM_qpx.h	38;"	d
psi_02	lib/simd/Intel512wilson.h	36;"	d
psi_10	lib/simd/BGQQPX.h	77;"	d
psi_10	lib/simd/IBM_qpx.h	40;"	d
psi_10	lib/simd/Intel512wilson.h	38;"	d
psi_11	lib/simd/BGQQPX.h	78;"	d
psi_11	lib/simd/IBM_qpx.h	41;"	d
psi_11	lib/simd/Intel512wilson.h	39;"	d
psi_12	lib/simd/BGQQPX.h	79;"	d
psi_12	lib/simd/IBM_qpx.h	42;"	d
psi_12	lib/simd/Intel512wilson.h	40;"	d
psi_20	lib/simd/BGQQPX.h	81;"	d
psi_20	lib/simd/IBM_qpx.h	44;"	d
psi_20	lib/simd/Intel512wilson.h	42;"	d
psi_21	lib/simd/BGQQPX.h	82;"	d
psi_21	lib/simd/IBM_qpx.h	45;"	d
psi_21	lib/simd/Intel512wilson.h	43;"	d
psi_22	lib/simd/BGQQPX.h	83;"	d
psi_22	lib/simd/IBM_qpx.h	46;"	d
psi_22	lib/simd/Intel512wilson.h	44;"	d
psi_30	lib/simd/BGQQPX.h	85;"	d
psi_30	lib/simd/IBM_qpx.h	48;"	d
psi_30	lib/simd/Intel512wilson.h	46;"	d
psi_31	lib/simd/BGQQPX.h	86;"	d
psi_31	lib/simd/IBM_qpx.h	49;"	d
psi_31	lib/simd/Intel512wilson.h	47;"	d
psi_32	lib/simd/BGQQPX.h	87;"	d
psi_32	lib/simd/IBM_qpx.h	50;"	d
psi_32	lib/simd/Intel512wilson.h	48;"	d
psin	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { using std::sin; return sin(a); }$/;"	f	namespace:Eigen::internal
psin	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^psin<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
psin	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
psinh	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet psinh(const Packet& a) { using std::sinh; return sinh(a); }$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { using std::sqrt; return sqrt(a); }$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet4d psqrt<Packet4d>(const Packet4d& x) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet8f psqrt<Packet8f>(const Packet8f& x) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^psqrt<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^EIGEN_STRONG_INLINE Packet16f psqrt<Packet16f>(const Packet16f& x) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^EIGEN_STRONG_INLINE Packet8d psqrt<Packet8d>(const Packet8d& x) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^psqrt<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AVX512/MathFunctions.h	/^psqrt<Packet8d>(const Packet8d& _x) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet2d psqrt<Packet2d>(const Packet2d& x)$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 psqrt<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 psqrt<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 psqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 psqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet2d psqrt<Packet2d>(const Packet2d& x) { return _mm_sqrt_pd(x); }$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& x) { return _mm_sqrt_ps(x); }$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet2d psqrt<Packet2d>(const Packet2d& x)$/;"	f	namespace:Eigen::internal
psqrt	lib/Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet2cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float>* to, const Packet4cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet4d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm256_store_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet8f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm256_store_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet8i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm256_storeu_si256(reinterpret_cast<__m256i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet8d& from) {$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore<float>(float* to, const Packet16f& from) {$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore<int>(int* to, const Packet16i& from) {$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from)$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstore<double>(double* to, const double2& from) {$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstore<float>(float*   to, const float4& from) {$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE void pstore<Eigen::half>(Eigen::half* to, const half2& from) {$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f64(to, from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>  (float*    to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int32_t>(int32_t*  to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, Packet2d(from.v)); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), Packet4f(from.v)); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<__m128i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from)$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstore	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet8f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet8i>(int* to, const int& a)$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore1<Packet16f>(float* to, const float& a) {$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore1<Packet16i>(int* to, const int& a) {$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore1<Packet8d>(double* to, const double& a) {$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal
pstore1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal
pstoret	lib/Eigen/src/Core/GenericPacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet2cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float>* to, const Packet4cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet4d& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm256_storeu_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet8f& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm256_storeu_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet8i& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm256_storeu_si256(reinterpret_cast<__m256i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet8d& from) {$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstoreu<float>(float* to, const Packet16f& from) {$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstoreu<int>(int* to, const Packet16i& from) {$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from)$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const double2& from) {$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const float4& from) {$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE void pstoreu<Eigen::half>(Eigen::half* to, const half2& from) {$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f64(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>  (float*   to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int32_t>(int32_t* to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, Packet2d(from.v)); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), Packet4f(from.v)); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_si128(reinterpret_cast<__m128i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from) { pstore<double>(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*    to, const Packet4f& from) { pstore<float>(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*        to, const Packet4i& from) { pstore<int>(to, from); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd psub<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf psub<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d psub<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f psub<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f psub<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d psub<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v - b.v); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(a.v - b.v); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return a - b; }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return a - b; }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return a - b; }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 psub<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 psub<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 psub<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(psub<Packet2d>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return vsubq_f64(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v - b.v); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a - b); }$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
psub	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a - b); }$/;"	f	namespace:Eigen::internal
psync_init	lib/communicator/Communicator_shmem.cc	/^static std::array<long,_SHMEM_REDUCE_SYNC_SIZE> psync_init = make_psync_init();$/;"	m	namespace:Grid	file:
ptan	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { using std::tan; return tan(a); }$/;"	f	namespace:Eigen::internal
ptanh	lib/Eigen/src/Core/GenericPacketMath.h	/^Packet ptanh(const Packet& a) { using std::tanh; return tanh(a); }$/;"	f	namespace:Eigen::internal
ptanh	lib/Eigen/src/Core/arch/AVX/MathFunctions.h	/^ptanh<Packet8f>(const Packet8f& x) {$/;"	f	namespace:Eigen::internal
ptanh	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^ptanh<Packet4f>(const Packet4f& x) {$/;"	f	namespace:Eigen::internal
ptr	lib/Eigen/src/Core/util/Memory.h	/^  T* &ptr() { return m_ptr; }$/;"	f	class:Eigen::internal::scoped_array
ptr	lib/Eigen/src/Core/util/Memory.h	/^  const T* ptr() const { return m_ptr; }$/;"	f	class:Eigen::internal::scoped_array
ptranspose	lib/Eigen/src/Core/GenericPacketMath.h	/^ptranspose(PacketBlock<Packet,1>& \/*kernel*\/) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX/Complex.h	/^ptranspose(PacketBlock<Packet2cd,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX/Complex.h	/^ptranspose(PacketBlock<Packet4cf,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^ptranspose(PacketBlock<Packet4d,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^ptranspose(PacketBlock<Packet8f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^ptranspose(PacketBlock<Packet8f,8>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet16f, 16>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet16f, 4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet8d, 4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet8d, 8>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^ptranspose(PacketBlock<double2,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^ptranspose(PacketBlock<float4,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^ptranspose(PacketBlock<half2,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/NEON/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/NEON/Complex.h	/^ptranspose(PacketBlock<Packet2cf,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/SSE/Complex.h	/^ptranspose(PacketBlock<Packet2cf,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
pugi	lib/pugixml/pugixml.cc	/^namespace pugi$/;"	n	file:
pugi	lib/pugixml/pugixml.h	/^namespace pugi$/;"	n
punpackp	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal
push	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void push(std::vector<RealD>& lmd,int N) {$/;"	f	class:Grid::SortEigen
push	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void push(std::vector<RealD>& lmd,std::vector<Field>& evec,int N) {$/;"	f	class:Grid::SortEigen
push	lib/pugixml/pugixml.cc	/^		void push(char_t*& s, size_t count)$/;"	f	struct:gap
push	lib/serialisation/BaseIO.h	/^  bool Reader<T>::push(const std::string &s)$/;"	f	class:Grid::Reader
push	lib/serialisation/BaseIO.h	/^  inline bool push(Reader<T> &r, const char *s)$/;"	f	namespace:Grid
push	lib/serialisation/BaseIO.h	/^  inline bool push(Reader<T> &r, const std::string &s)$/;"	f	namespace:Grid
push	lib/serialisation/BaseIO.h	/^  inline void push(Writer<T> &w, const char *s)$/;"	f	namespace:Grid
push	lib/serialisation/BaseIO.h	/^  inline void push(Writer<T> &w, const std::string &s) {$/;"	f	namespace:Grid
push	lib/serialisation/BaseIO.h	/^  void Writer<T>::push(const std::string &s)$/;"	f	class:Grid::Writer
push	lib/serialisation/BinaryIO.h	/^    bool push(const std::string &s) {return true;}$/;"	f	class:Grid::BinaryReader
push	lib/serialisation/BinaryIO.h	/^    void push(const std::string &s) {};$/;"	f	class:Grid::BinaryWriter
push	lib/serialisation/Hdf5IO.cc	/^bool Hdf5Reader::push(const std::string &s)$/;"	f	class:Hdf5Reader
push	lib/serialisation/Hdf5IO.cc	/^void Hdf5Writer::push(const std::string &s)$/;"	f	class:Hdf5Writer
push	lib/serialisation/JSON_IO.cc	/^bool JSONReader::push(const string &s)$/;"	f	class:JSONReader
push	lib/serialisation/JSON_IO.cc	/^void JSONWriter::push(const string &s)$/;"	f	class:JSONWriter
push	lib/serialisation/TextIO.cc	/^bool TextReader::push(const string &s)$/;"	f	class:TextReader
push	lib/serialisation/TextIO.cc	/^void TextWriter::push(const string &s)$/;"	f	class:TextWriter
push	lib/serialisation/XmlIO.cc	/^bool XmlReader::push(const string &s)$/;"	f	class:XmlReader
push	lib/serialisation/XmlIO.cc	/^void XmlWriter::push(const string &s)$/;"	f	class:XmlWriter
pushDownZero	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::pushDownZero(Index z, Index f, Index l)$/;"	f	class:Eigen::RealQZ
pushModule	extras/Hadrons/Environment.cc	/^void Environment::pushModule(Environment::ModPt &pt)$/;"	f	class:Environment
pushModule	lib/Hadrons/Environment.cc	/^void Environment::pushModule(Environment::ModPt &pt)$/;"	f	class:Environment
push_back	lib/Eigen/src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque
push_back	lib/Eigen/src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list
push_back	lib/Eigen/src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector
push_back	lib/json/json.hpp	/^    void push_back(basic_json&& val)$/;"	f	class:nlohmann::basic_json
push_back	lib/json/json.hpp	/^    void push_back(const basic_json& val)$/;"	f	class:nlohmann::basic_json
push_back	lib/json/json.hpp	/^    void push_back(const typename object_t::value_type& val)$/;"	f	class:nlohmann::basic_json
push_back	lib/json/json.hpp	/^    void push_back(std::initializer_list<basic_json> init)$/;"	f	class:nlohmann::basic_json
push_back	lib/pugixml/pugixml.cc	/^		void push_back(const xpath_node& node, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw
push_back	lib/qcd/action/ActionSet.h	/^  void push_back(Action<GenField>* ptr) {$/;"	f	struct:Grid::QCD::ActionLevel
push_back_grow	lib/pugixml/pugixml.cc	/^	PUGI__FN_NO_INLINE void xpath_node_set_raw::push_back_grow(const xpath_node& node, xpath_allocator* alloc)$/;"	f	class:xpath_node_set_raw
push_front	lib/Eigen/src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque
putlane	lib/simd/Grid_vector_types.h	/^  inline void putlane(const Scalar_type &S, int lane){$/;"	f	class:Grid::Grid_simd
pxor	lib/Eigen/src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pxor   <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pxor   <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pxor<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pxor<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pxor<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pxor<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pxor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pxor<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pxor<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pxor	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
q	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      std::vector<double> q;$/;"	m	class:Grid::QCD::PartialFractionFermion5D
qr_decomp	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void qr_decomp(std::vector<RealD>& lmd,   \/\/ Nm $/;"	f	class:Grid::ImplicitlyRestartedLanczos
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	lib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
qr_preconditioner_should_do_anything	lib/Eigen/src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
qualified_name	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* qualified_name(const xpath_node& node)$/;"	f
quat_conj	lib/Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived, typename Scalar, int _Options> struct quat_conj$/;"	s	namespace:Eigen::internal
quat_conj	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_conj<Architecture::SSE, Derived, double, Alignment>$/;"	s	namespace:Eigen::internal
quat_conj	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_conj<Architecture::SSE, Derived, float, Alignment>$/;"	s	namespace:Eigen::internal
quat_product	lib/Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar, int _Options> struct quat_product$/;"	s	namespace:Eigen::internal
quat_product	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double, Alignment>$/;"	s	namespace:Eigen::internal
quat_product	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float, Aligned16>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	lib/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	lib/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
queryCacheSizes	lib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_amd	lib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel	lib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_codes	lib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_direct	lib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryL1CacheSize	lib/Eigen/src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal
queryTopLevelCacheSize	lib/Eigen/src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal
quiet_NaN	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half quiet_NaN() {$/;"	f	struct:Eigen::NumTraits
quiet_NaN	lib/Eigen/src/Core/util/Meta.h	/^  static T quiet_NaN() { assert(false && "quiet_NaN not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
quiet_NaN	lib/Eigen/src/Core/util/Meta.h	/^  static double quiet_NaN() { return CUDART_NAN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
quiet_NaN	lib/Eigen/src/Core/util/Meta.h	/^  static float quiet_NaN() { return CUDART_NAN_F; }$/;"	f	struct:Eigen::internal::device::numeric_limits
r	lib/simd/Grid_generic_types.h	/^    constexpr static unsigned int r = GEN_SIMD_WIDTH\/2u;$/;"	m	struct:Grid::Optimization::W
r	lib/simd/Grid_generic_types.h	/^    constexpr static unsigned int r = GEN_SIMD_WIDTH\/4u;$/;"	m	struct:Grid::Optimization::W
r	lib/simd/Grid_generic_types.h	/^    constexpr static unsigned int r = GEN_SIMD_WIDTH\/8u;$/;"	m	struct:Grid::Optimization::W
random	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal
random	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal
random	lib/lattice/Lattice_rng.h	/^  template <class sobj> inline void random(GridSerialRNG &rng,sobj &l)   { rng.fill(l,rng._uniform  ); }$/;"	f	namespace:Grid
random	lib/lattice/Lattice_rng.h	/^  template <class vobj> inline void random(GridParallelRNG &rng,Lattice<vobj> &l)   { rng.fill(l,rng._uniform);  }$/;"	f	namespace:Grid
random_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
random_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
random_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
random_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
random_default_impl	lib/Eigen/src/Core/arch/CUDA/Half.h	/^struct random_default_impl<half, false, false>$/;"	s	namespace:Eigen::internal
random_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
random_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
random_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
rank	lib/Eigen/src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU
rank	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR
rank	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index rank() const { return m_cpqr.rank(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
rank	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR
rank	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    Index rank() const$/;"	f	class:Eigen::SPQR
rank	lib/Eigen/src/SVD/SVDBase.h	/^  inline Index rank() const$/;"	f	class:Eigen::SVDBase
rank	lib/Eigen/src/SparseQR/SparseQR.h	/^    Index rank() const$/;"	f	class:Eigen::SparseQR
rank	lib/Eigen/src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base
rank	lib/Eigen/src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base
rank	lib/communicator/Communicator_mpi3_leader.cc	/^  int rank;$/;"	m	struct:Grid::Descriptor	file:
rankUpdate	lib/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w, const typename LDLT<MatrixType,_UpLo>::RealScalar& sigma)$/;"	f	class:Eigen::LDLT
rankUpdate	lib/Eigen/src/Cholesky/LLT.h	/^  static Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace
rankUpdate	lib/Eigen/src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT
rankUpdate	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,Mode>::rankUpdate(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SparseSelfAdjointView
rawMatrix	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky
raw_uint16_to_half	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half raw_uint16_to_half(unsigned short x) {$/;"	f	namespace:Eigen::half_impl
rbgrid_	lib/qcd/hmc/HMC_GridModules.h	/^  std::unique_ptr<GridRedBlackCartesian> rbgrid_;$/;"	m	class:Grid::GridModule
rbroadcast	lib/simd/Grid_vector_types.h	/^inline void rbroadcast(Grid_simd<S,V> &ret,const Grid_simd<S,V> &src,int lane){$/;"	f	namespace:Grid
rbuf	lib/communicator/Communicator_mpi3_leader.cc	/^  uint64_t rbuf;$/;"	m	struct:Grid::Descriptor	file:
rcond	lib/Eigen/src/Cholesky/LDLT.h	/^    RealScalar rcond() const$/;"	f	class:Eigen::LDLT
rcond	lib/Eigen/src/Cholesky/LLT.h	/^    RealScalar rcond() const$/;"	f	class:Eigen::LLT
rcond	lib/Eigen/src/LU/FullPivLU.h	/^    inline RealScalar rcond() const$/;"	f	class:Eigen::FullPivLU
rcond	lib/Eigen/src/LU/PartialPivLU.h	/^    inline RealScalar rcond() const$/;"	f	class:Eigen::PartialPivLU
rcond_compute_sign	lib/Eigen/src/Core/ConditionEstimator.h	/^struct rcond_compute_sign {$/;"	s	namespace:Eigen::internal
rcond_compute_sign	lib/Eigen/src/Core/ConditionEstimator.h	/^struct rcond_compute_sign<Vector, Vector, false> {$/;"	s	namespace:Eigen::internal
rcond_estimate_helper	lib/Eigen/src/Core/ConditionEstimator.h	/^rcond_estimate_helper(typename Decomposition::RealScalar matrix_norm, const Decomposition& dec)$/;"	f	namespace:Eigen::internal
rcond_invmatrix_L1_norm_estimate	lib/Eigen/src/Core/ConditionEstimator.h	/^typename Decomposition::RealScalar rcond_invmatrix_L1_norm_estimate(const Decomposition& dec)$/;"	f	namespace:Eigen::internal
read	lib/serialisation/BaseIO.h	/^    static inline void read(Reader<T> &RD,const std::string &s,$/;"	f	class:Grid::Serializable
read	lib/serialisation/BaseIO.h	/^  Reader<T>::read(const std::string &s, U &output)$/;"	f	class:Grid::Reader
read	lib/serialisation/BaseIO.h	/^  inline void read(Reader<T> &r, const std::string &s, U &output)$/;"	f	namespace:Grid
readConfiguration	lib/parallelIO/IldgIO.h	/^  void readConfiguration(Lattice<iLorentzColourMatrix<vsimd> > &Umu, FieldMetaData &FieldMetaData_) {$/;"	f	class:Grid::QCD::IldgReader
readConfiguration	lib/parallelIO/NerscIO.h	/^    static inline void readConfiguration(Lattice<iLorentzColourMatrix<vsimd> > &Umu,$/;"	f	class:Grid::QCD::NerscIO
readDefault	lib/serialisation/BinaryIO.cc	/^void BinaryReader::readDefault(const string &s, string &output)$/;"	f	class:BinaryReader
readDefault	lib/serialisation/BinaryIO.h	/^  void BinaryReader::readDefault(const std::string &s, U &output)$/;"	f	class:Grid::BinaryReader
readDefault	lib/serialisation/BinaryIO.h	/^  void BinaryReader::readDefault(const std::string &s, std::vector<U> &output)$/;"	f	class:Grid::BinaryReader
readDefault	lib/serialisation/Hdf5IO.cc	/^void Hdf5Reader::readDefault(const std::string &s, std::string &x)$/;"	f	class:Hdf5Reader
readDefault	lib/serialisation/Hdf5IO.h	/^  Hdf5Reader::readDefault(const std::string &s, std::vector<U> &x)$/;"	f	class:Grid::Hdf5Reader
readDefault	lib/serialisation/Hdf5IO.h	/^  void Hdf5Reader::readDefault(const std::string &s, U &output)$/;"	f	class:Grid::Hdf5Reader
readDefault	lib/serialisation/JSON_IO.cc	/^void JSONReader::readDefault(const string &s, string &output)$/;"	f	class:JSONReader
readDefault	lib/serialisation/JSON_IO.h	/^  void JSONReader::readDefault(const std::string &s, U &output)$/;"	f	class:Grid::JSONReader
readDefault	lib/serialisation/JSON_IO.h	/^  void JSONReader::readDefault(const std::string &s, std::complex<U> &output)$/;"	f	class:Grid::JSONReader
readDefault	lib/serialisation/JSON_IO.h	/^  void JSONReader::readDefault(const std::string &s, std::vector<U> &output)$/;"	f	class:Grid::JSONReader
readDefault	lib/serialisation/TextIO.cc	/^void TextReader::readDefault(const std::string &s, std::string &output)$/;"	f	class:TextReader
readDefault	lib/serialisation/TextIO.h	/^  void TextReader::readDefault(const std::string &s, U &output)$/;"	f	class:Grid::TextReader
readDefault	lib/serialisation/TextIO.h	/^  void TextReader::readDefault(const std::string &s, std::vector<U> &output)$/;"	f	class:Grid::TextReader
readDefault	lib/serialisation/XmlIO.cc	/^void XmlReader::readDefault(const string &s, string &output)$/;"	f	class:XmlReader
readDefault	lib/serialisation/XmlIO.h	/^  void XmlReader::readDefault(const std::string &s, U &output)$/;"	f	class:Grid::XmlReader
readDefault	lib/serialisation/XmlIO.h	/^  void XmlReader::readDefault(const std::string &s, std::vector<U> &output)$/;"	f	class:Grid::XmlReader
readHeader	lib/parallelIO/NerscIO.h	/^      static inline int readHeader(std::string file,GridBase *grid,  FieldMetaData &field)$/;"	f	class:Grid::QCD::NerscIO
readLatticeObject	lib/parallelIO/BinaryIO.h	/^  static inline void readLatticeObject(Lattice<vobj> &Umu,$/;"	f	class:Grid::BinaryIO
readLimeLatticeBinaryObject	lib/parallelIO/IldgIO.h	/^  void readLimeLatticeBinaryObject(Lattice<vobj> &field,std::string record_name)$/;"	f	class:Grid::QCD::GridLimeReader
readLimeObject	lib/parallelIO/IldgIO.h	/^  void readLimeObject(serialisable_object &object,std::string object_name,std::string record_name)$/;"	f	class:Grid::QCD::GridLimeReader
readRNG	lib/parallelIO/BinaryIO.h	/^  static inline void readRNG(GridSerialRNG &serial,$/;"	f	class:Grid::BinaryIO
readRNGState	lib/parallelIO/NerscIO.h	/^      static inline void readRNGState(GridSerialRNG &serial,GridParallelRNG & parallel,FieldMetaData& header,std::string file)$/;"	f	class:Grid::QCD::NerscIO
readSingleAttribute	lib/serialisation/Hdf5IO.h	/^  void Hdf5Reader::readSingleAttribute(U &x, const std::string &name,$/;"	f	class:Grid::Hdf5Reader
reads	lib/perfmon/Stat.h	/^    uint64_t reads;     \/\/ memory reads$/;"	m	class:Grid::PmuStat
real	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::numext
real	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() const { return RealReturnType(derived()); }$/;"	f
real	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() { return NonConstRealReturnType(derived()); }$/;"	f
real	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> real(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
real	lib/simd/Simd.h	/^  inline RealD real(const RealD  & r){ return r; }$/;"	f	namespace:Grid
real	lib/simd/Simd.h	/^  inline RealF real(const RealF  & r){ return r; }$/;"	f	namespace:Grid
real_2x2_jacobi_svd	lib/Eigen/src/misc/RealSvd2x2.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal
real_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct real_default_impl$/;"	s	namespace:Eigen::internal
real_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct real_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
real_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct real_impl<std::complex<T> >$/;"	s	namespace:Eigen::internal
real_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
real_madd	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> real_madd(Grid_simd<S, V> a, Grid_simd<S, V> b, Grid_simd<S,V> c) {$/;"	f	namespace:Grid
real_mult	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> real_mult(Grid_simd<S, V> a, Grid_simd<S, V> b) {$/;"	f	namespace:Grid
real_ref	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::numext
real_ref	lib/Eigen/src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext
real_ref_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
real_ref_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
real_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
real_scalar_type	lib/tensors/Tensor_traits.h	/^    typedef typename GridTypeMapper<scalar_type>::Realified real_scalar_type; \/\/remove any std::complex wrapper, should get us to the fundamental type$/;"	t	class:Grid::getPrecision
reallocate	lib/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector
reallocate	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void reallocate(Index size)$/;"	f	class:Eigen::internal::CompressedStorage
reallocate	lib/pugixml/pugixml.cc	/^		void* reallocate(void* ptr, size_t old_size, size_t new_size)$/;"	f	class:xpath_allocator
reallocateSparse	lib/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector
rebind	lib/Eigen/src/Core/util/Memory.h	/^  struct rebind$/;"	s	class:Eigen::aligned_allocator
rebind	lib/Eigen/src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection
rebind	lib/allocator/AlignedAllocator.h	/^    struct rebind$/;"	s	class:Grid::alignedAllocator
rebind	lib/allocator/AlignedAllocator.h	/^  template<typename _Tp1>  struct rebind { typedef commAllocator<_Tp1> other; };$/;"	s	class:Grid::commAllocator
reconstruct3	lib/parallelIO/MetaData.h	/^    inline void reconstruct3(LorentzColourMatrix & cm)$/;"	f	namespace:Grid::QCD
reconstructedMatrix	lib/Eigen/src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT
reconstructedMatrix	lib/Eigen/src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT
reconstructedMatrix	lib/Eigen/src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU
reconstructedMatrix	lib/Eigen/src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU
recurse_scalar_object	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::scalar_object recurse_scalar_object;$/;"	t	class:Grid::iMatrix
recurse_scalar_object	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::scalar_object recurse_scalar_object;$/;"	t	class:Grid::iScalar
recurse_scalar_object	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::scalar_object recurse_scalar_object;$/;"	t	class:Grid::iVector
recv_buf	lib/stencil/Stencil.h	/^    void * recv_buf;$/;"	m	struct:Grid::CartesianStencil::Packet
reduceToTriangularForm	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur
redux	lib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase
redux	lib/Eigen/src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp
redux	lib/Eigen/src/Geometry/Homogeneous.h	/^    redux(const Func& func) const$/;"	f	class:Eigen::Homogeneous
redux_evaluator	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC explicit redux_evaluator(const XprType &xpr) : m_evaluator(xpr), m_xpr(xpr) {}$/;"	f	class:Eigen::internal::redux_evaluator
redux_evaluator	lib/Eigen/src/Core/Redux.h	/^class redux_evaluator$/;"	c	namespace:Eigen::internal
redux_impl	lib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	lib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	lib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	lib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, Unrolling>$/;"	s	namespace:Eigen::internal
redux_impl	lib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	lib/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
redux_novec_unroller	lib/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	lib/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
redux_traits	lib/Eigen/src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
redux_vec_unroller	lib/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
redux_vec_unroller	lib/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
ref	lib/perfmon/Stat.h	/^    uint64_t inst, ref, cyc;   \/\/ fixed counters$/;"	m	class:Grid::PmuStat
reference	lib/Eigen/src/Core/util/Memory.h	/^  typedef T&              reference;$/;"	t	class:Eigen::aligned_allocator
reference	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
reference	lib/Eigen/src/SparseCore/SparseView.h	/^  Scalar reference() const { return m_reference; }$/;"	f	class:Eigen::SparseView
reference	lib/Eigen/src/StlSupport/details.h	/^    typedef T&              reference;$/;"	t	class:Eigen::aligned_allocator_indirection
reference	lib/allocator/AlignedAllocator.h	/^    typedef _Tp &reference;$/;"	t	class:Grid::alignedAllocator
reference	lib/allocator/AlignedAllocator.h	/^  typedef _Tp&       reference;$/;"	t	class:Grid::commAllocator
reference	lib/pugixml/pugixml.h	/^		typedef xml_attribute& reference;$/;"	t	class:pugi::xml_attribute_iterator
reference	lib/pugixml/pugixml.h	/^		typedef xml_node& reference;$/;"	t	class:pugi::xml_named_node_iterator
reference	lib/pugixml/pugixml.h	/^		typedef xml_node& reference;$/;"	t	class:pugi::xml_node_iterator
refresh	lib/qcd/action/gauge/PlaqPlusRectangleAction.h	/^      virtual void refresh(const GaugeField &U, GridParallelRNG& pRNG) {}; \/\/ noop as no pseudoferms$/;"	f	class:Grid::QCD::PlaqPlusRectangleAction
refresh	lib/qcd/action/gauge/WilsonGaugeAction.h	/^  virtual void refresh(const GaugeField &U,$/;"	f	class:Grid::QCD::WilsonGaugeAction
refresh	lib/qcd/action/pseudofermion/OneFlavourEvenOddRational.h	/^  virtual void refresh(const GaugeField &U, GridParallelRNG &pRNG) {$/;"	f	class:Grid::QCD::OneFlavourEvenOddRationalPseudoFermionAction
refresh	lib/qcd/action/pseudofermion/OneFlavourEvenOddRationalRatio.h	/^      virtual void refresh(const GaugeField &U, GridParallelRNG& pRNG) {$/;"	f	class:Grid::QCD::OneFlavourEvenOddRatioRationalPseudoFermionAction
refresh	lib/qcd/action/pseudofermion/OneFlavourRational.h	/^      virtual void refresh(const GaugeField &U, GridParallelRNG& pRNG) {$/;"	f	class:Grid::QCD::OneFlavourRationalPseudoFermionAction
refresh	lib/qcd/action/pseudofermion/OneFlavourRationalRatio.h	/^      virtual void refresh(const GaugeField &U, GridParallelRNG& pRNG) {$/;"	f	class:Grid::QCD::OneFlavourRatioRationalPseudoFermionAction
refresh	lib/qcd/action/pseudofermion/TwoFlavour.h	/^  virtual void refresh(const GaugeField &U, GridParallelRNG &pRNG) {$/;"	f	class:Grid::QCD::TwoFlavourPseudoFermionAction
refresh	lib/qcd/action/pseudofermion/TwoFlavourEvenOdd.h	/^      virtual void refresh(const GaugeField &U, GridParallelRNG& pRNG) {$/;"	f	class:Grid::QCD::TwoFlavourEvenOddPseudoFermionAction
refresh	lib/qcd/action/pseudofermion/TwoFlavourEvenOddRatio.h	/^      virtual void refresh(const GaugeField &U, GridParallelRNG& pRNG) {$/;"	f	class:Grid::QCD::TwoFlavourEvenOddRatioPseudoFermionAction
refresh	lib/qcd/action/pseudofermion/TwoFlavourRatio.h	/^      virtual void refresh(const GaugeField &U, GridParallelRNG& pRNG) {$/;"	f	class:Grid::QCD::TwoFlavourRatioPseudoFermionAction
refresh	lib/qcd/action/scalar/ScalarAction.h	/^    virtual void refresh(const Field &U, GridParallelRNG &pRNG) {}  \/\/ noop as no pseudoferms$/;"	f	class:Grid::ScalarAction
refresh	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    virtual void refresh(const Field &U, GridParallelRNG &pRNG) {}$/;"	f	class:Grid::ScalarInteractionAction
refresh	lib/qcd/hmc/integrators/Integrator.h	/^  void refresh(Field& U, GridParallelRNG& pRNG) {$/;"	f	class:Grid::QCD::Integrator
refresh_hireps	lib/qcd/hmc/integrators/Integrator.h	/^  } refresh_hireps{};$/;"	s	class:Grid::QCD::Integrator
registerBuilder	extras/Hadrons/Factory.hpp	/^void Factory<T>::registerBuilder(const std::string type, const Func &f)$/;"	f	class:Factory
registerBuilder	lib/Hadrons/Factory.hpp	/^void Factory<T>::registerBuilder(const std::string type, const Func &f)$/;"	f	class:Factory
registerBuilder	lib/qcd/modules/Factory.h	/^void Factory<T, CreatorInput>::registerBuilder(const std::string type, const Func &f)$/;"	f	class:Grid::Factory
registerLattice	extras/Hadrons/Environment.hpp	/^void Environment::registerLattice(const std::string name, const unsigned int Ls)$/;"	f	class:Environment
registerLattice	extras/Hadrons/Environment.hpp	/^void Environment::registerLattice(const unsigned int address,$/;"	f	class:Environment
registerLattice	lib/Hadrons/Environment.hpp	/^void Environment::registerLattice(const std::string name, const unsigned int Ls)$/;"	f	class:Environment
registerLattice	lib/Hadrons/Environment.hpp	/^void Environment::registerLattice(const unsigned int address,$/;"	f	class:Environment
registerObject	extras/Hadrons/Environment.cc	/^void Environment::registerObject(const std::string name,$/;"	f	class:Environment
registerObject	extras/Hadrons/Environment.cc	/^void Environment::registerObject(const unsigned int address,$/;"	f	class:Environment
registerObject	lib/Hadrons/Environment.cc	/^void Environment::registerObject(const std::string name,$/;"	f	class:Environment
registerObject	lib/Hadrons/Environment.cc	/^void Environment::registerObject(const unsigned int address,$/;"	f	class:Environment
rehash	lib/pugixml/pugixml.cc	/^	PUGI__FN_NO_INLINE bool compact_hash_table::rehash()$/;"	f	class:compact_hash_table
relax	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index relax; \/\/ To control degree of relaxing supernodes. If the number of nodes (columns) $/;"	m	struct:Eigen::internal::perfvalues
relax_snode	lib/Eigen/src/SparseLU/SparseLU_relax_snode.h	/^void SparseLUImpl<Scalar,StorageIndex>::relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl
release	lib/pugixml/pugixml.cc	/^		T* release()$/;"	f	struct:auto_deleter
release	lib/pugixml/pugixml.cc	/^		void release()$/;"	f	class:xpath_allocator
removeEdge	extras/Hadrons/Graph.hpp	/^void Graph<T>::removeEdge(const Edge &e)$/;"	f	class:Graph
removeEdge	extras/Hadrons/Graph.hpp	/^void Graph<T>::removeEdge(const T &start, const T &end)$/;"	f	class:Graph
removeEdge	lib/Hadrons/Graph.hpp	/^void Graph<T>::removeEdge(const Edge &e)$/;"	f	class:Graph
removeEdge	lib/Hadrons/Graph.hpp	/^void Graph<T>::removeEdge(const T &start, const T &end)$/;"	f	class:Graph
removeMarked	extras/Hadrons/Graph.hpp	/^void Graph<T>::removeMarked(const bool isMarked)$/;"	f	class:Graph
removeMarked	lib/Hadrons/Graph.hpp	/^void Graph<T>::removeMarked(const bool isMarked)$/;"	f	class:Graph
removeUnmarked	extras/Hadrons/Graph.hpp	/^void Graph<T>::removeUnmarked(void)$/;"	f	class:Graph
removeUnmarked	lib/Hadrons/Graph.hpp	/^void Graph<T>::removeUnmarked(void)$/;"	f	class:Graph
removeVertex	extras/Hadrons/Graph.hpp	/^void Graph<T>::removeVertex(const T &value)$/;"	f	class:Graph
removeVertex	lib/Hadrons/Graph.hpp	/^void Graph<T>::removeVertex(const T &value)$/;"	f	class:Graph
removeWhitespace	lib/parallelIO/BinaryIO.h	/^inline void removeWhitespace(std::string &key)$/;"	f	namespace:Grid
remove_all	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_all	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::remove_attribute(const char_t* name_)$/;"	f	class:pugi::xml_node
remove_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::remove_attribute(const xml_attribute& a)$/;"	f	class:pugi::xml_node
remove_attribute	lib/pugixml/pugixml.cc	/^	inline void remove_attribute(xml_attribute_struct* attr, xml_node_struct* node)$/;"	f
remove_child	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::remove_child(const char_t* name_)$/;"	f	class:pugi::xml_node
remove_child	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::remove_child(const xml_node& n)$/;"	f	class:pugi::xml_node
remove_const	lib/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
remove_const	lib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	lib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	lib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
remove_duplicates	lib/pugixml/pugixml.cc	/^		void remove_duplicates()$/;"	f	class:xpath_node_set_raw
remove_node	lib/pugixml/pugixml.cc	/^	inline void remove_node(xml_node_struct* node)$/;"	f
remove_pointer	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
replace_substring	lib/json/json.hpp	/^        static void replace_substring(std::string& s,$/;"	f	class:nlohmann::basic_json::json_pointer
replicate	lib/Eigen/src/Core/DenseBase.h	/^    const Replicate<Derived, Dynamic, Dynamic> replicate(Index rowFactor, Index colFactor) const$/;"	f	class:Eigen::DenseBase
replicate	lib/Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase
replicate	lib/Eigen/src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp
replicate	lib/Eigen/src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp
request	lib/communicator/Communicator_mpi3_leader.cc	/^  MPI_Request request;$/;"	m	struct:Grid::Descriptor	file:
required_alignment	lib/Eigen/src/Core/Matrix.h	/^      required_alignment = unpacket_traits<PacketScalar>::alignment,$/;"	e	enum:Eigen::internal::traits::__anon171
res	lib/Eigen/src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor
reserve	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    void reserve(Index size)$/;"	f	class:Eigen::internal::CompressedStorage
reserve	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix
reserve	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif =$/;"	f	class:Eigen::SparseMatrix
reserve	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector
reserve	lib/pugixml/pugixml.cc	/^		bool reserve()$/;"	f	class:compact_hash_table
reserve	lib/pugixml/pugixml.cc	/^		bool reserve()$/;"	f	struct:xml_allocator
reserveInnerVectors	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix
reset	extras/Hadrons/Environment.hpp	/^void Holder<T>::reset(T *pt)$/;"	f	class:Holder
reset	lib/Hadrons/Environment.hpp	/^void Holder<T>::reset(T *pt)$/;"	f	class:Holder
reset	lib/lattice/Lattice_base.h	/^  void reset(GridBase* grid) {$/;"	f	class:Grid::Lattice
reset	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_document::reset()$/;"	f	class:pugi::xml_document
reset	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_document::reset(const xml_document& proto)$/;"	f	class:pugi::xml_document
residues	lib/algorithms/approx/MultiShiftFunction.h	/^  std::vector<RealD> residues;$/;"	m	class:Grid::MultiShiftFunction
resize	lib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.resize(newSize); }$/;"	f	class:Eigen::ArrayWrapper
resize	lib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.resize(newSize); }$/;"	f	class:Eigen::MatrixWrapper
resize	lib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index rows, Index cols) { m_expression.resize(rows,cols); }$/;"	f	class:Eigen::ArrayWrapper
resize	lib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index rows, Index cols) { m_expression.resize(rows,cols); }$/;"	f	class:Eigen::MatrixWrapper
resize	lib/Eigen/src/Core/DenseBase.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::DenseBase
resize	lib/Eigen/src/Core/DenseBase.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
resize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index rows, Index)$/;"	f	class:Eigen::DenseStorage
resize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index, Index cols)$/;"	f	class:Eigen::DenseStorage
resize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index size, Index rows, Index cols)$/;"	f	class:Eigen::DenseStorage
resize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
resize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage
resize	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}$/;"	f	class:Eigen::DenseStorage
resize	lib/Eigen/src/Core/DenseStorage.h	/^    void resize(Index, Index, Index cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
resize	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix
resize	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline void resize(Index newSize)$/;"	f	class:Eigen::PermutationBase
resize	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
resize	lib/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
resize	lib/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase
resize	lib/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase
resize	lib/Eigen/src/Core/Transpose.h	/^    void resize(Index nrows, Index ncols) {$/;"	f	class:Eigen::Transpose
resize	lib/Eigen/src/Core/Transpositions.h	/^    inline void resize(Index newSize)$/;"	f	class:Eigen::TranspositionsBase
resize	lib/Eigen/src/Core/TriangularMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::TriangularBase
resize	lib/Eigen/src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector
resize	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    void resize(Index size, double reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage
resize	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
resize	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseSelfAdjointView
resize	lib/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector
resize	lib/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector
resize	lib/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque
resize	lib/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque
resize	lib/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list
resize	lib/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list
resize	lib/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector
resize	lib/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector
resize	lib/qcd/action/ActionSet.h	/^  static void resize(ActPtr ap, unsigned int n) {$/;"	f	struct:Grid::QCD::ActionLevel
resize	lib/serialisation/BaseIO.h	/^  void Reconstruct<V>::resize(W &v, const unsigned int dim)$/;"	f	class:Grid::Reconstruct
resize	lib/serialisation/BaseIO.h	/^  void Reconstruct<V>::resize(std::vector<Element> &v, const unsigned int dim)$/;"	f	class:Grid::Reconstruct
resizeLike	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase
resizeNonZeros	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix
resizeNonZeros	lib/Eigen/src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector
resize_if_allowed	lib/Eigen/src/Core/AssignEvaluator.h	/^void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const Functor &\/*func*\/)$/;"	f	namespace:Eigen::internal
resize_if_allowed	lib/Eigen/src/Core/AssignEvaluator.h	/^void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const internal::assign_op<T1,T2> &\/*func*\/)$/;"	f	namespace:Eigen::internal
restart	lib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::restart()$/;"	f	class:Eigen::internal::AmbiVector
result	lib/pugixml/pugixml.cc	/^		xpath_allocator result;$/;"	m	struct:xpath_stack_data	file:
result	lib/pugixml/pugixml.cc	/^		xpath_allocator* result;$/;"	m	struct:xpath_stack	file:
result	lib/pugixml/pugixml.cc	/^	PUGI__FN const xpath_parse_result& xpath_exception::result() const$/;"	f	class:pugi::xpath_exception
result	lib/pugixml/pugixml.cc	/^	PUGI__FN const xpath_parse_result& xpath_query::result() const$/;"	f	class:pugi::xpath_query
result_of	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct result_of<scalar_cmp_op<LhsScalar, RhsScalar, Cmp>(LhsScalar,RhsScalar)> {$/;"	s	namespace:Eigen::internal
result_of	lib/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
result_of	lib/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
result_of	lib/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1,ArgType2)> {$/;"	s	namespace:Eigen::internal
result_of	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of { };$/;"	s	namespace:Eigen::internal
result_of	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of {$/;"	s	namespace:Eigen::internal
result_type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef ScalarX result_type;$/;"	t	struct:Eigen::internal::pow_impl
result_type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename ScalarBinaryOpTraits<ScalarX,ScalarY,internal::scalar_pow_op<ScalarX,ScalarY> >::ReturnType result_type;$/;"	t	struct:Eigen::internal::pow_impl
result_type	lib/Eigen/src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux
result_type	lib/Eigen/src/Core/VectorwiseOp.h	/^  typedef ResultType result_type;$/;"	t	struct:Eigen::internal::member_lpnorm
result_type	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_difference_op
result_type	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_product_op
result_type	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_quotient_op
result_type	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_sum_op
result_type	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  typedef Eigen::half result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  typedef float result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_cmp_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::result_type          result_type;$/;"	t	struct:Eigen::internal::bind1st_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::result_type          result_type;$/;"	t	struct:Eigen::internal::bind2nd_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_conj_product_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_difference_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_difference_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_max_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_max_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_min_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_min_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_product_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_quotient_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_quotient_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_sum_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_sum_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<Scalar,Exponent,scalar_pow_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_pow_op
result_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename scalar_quotient_op<LhsScalar,RhsScalar>::result_type result_type;$/;"	t	struct:Eigen::internal::functor_traits
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_isfinite_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_isinf_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_isnan_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::abs_knowing_score
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_arg_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op
result_type	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op
result_type	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    typedef uint32_t result_type;$/;"	t	class:sitmo::prng_engine
ret	lib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon358
ret	lib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon360
ret	lib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon357
ret	lib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon359
ret	lib/Eigen/src/Core/GeneralProduct.h	/^    ret = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon187
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon192
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon200
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon199
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon201
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon194
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon198
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon203
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon202
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon208
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon211
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon206
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon209
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon197
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon196
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon204
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon193
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon207
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon210
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon205
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon195
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon191
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon188
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<int M>         struct product_type_selector<M, 1, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon189
ret	lib/Eigen/src/Core/GeneralProduct.h	/^template<int N>         struct product_type_selector<1, N, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon190
ret	lib/Eigen/src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon393
ret	lib/Eigen/src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon392
ret	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = !has_binary_operator<Functor>::value }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon486
ret	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon113
ret	lib/Eigen/src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon108
ret	lib/Eigen/src/Core/util/Meta.h	/^  enum { ret = A*K };$/;"	e	enum:Eigen::meta_least_common_multiple::__anon111
ret	lib/Eigen/src/Core/util/Meta.h	/^  enum { ret = meta_least_common_multiple<A,B,K+1>::ret };$/;"	e	enum:Eigen::meta_least_common_multiple::__anon110
ret	lib/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon109
ret	lib/Eigen/src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon653
ret	lib/Eigen/src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon615
ret	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Dense,Sparse, OuterProduct> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
ret	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Sparse,Dense, OuterProduct> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
ret	lib/Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<PermutationStorage, Sparse,             ProductTag> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
ret	lib/Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<Sparse,             PermutationStorage, ProductTag> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
rettype	lib/pugixml/pugixml.cc	/^			xpath_value_type rettype;$/;"	m	struct:xpath_parser::binary_op_t	file:
rettype	lib/pugixml/pugixml.cc	/^		xpath_value_type rettype() const$/;"	f	class:xpath_ast_node
return_type	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_value_type xpath_query::return_type() const$/;"	f	class:pugi::xpath_query
reverse	lib/Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC ConstReverseReturnType reverse() const$/;"	f	class:Eigen::DenseBase
reverse	lib/Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase
reverse	lib/Eigen/src/Core/VectorwiseOp.h	/^    ReverseReturnType reverse()$/;"	f	class:Eigen::VectorwiseOp
reverse	lib/Eigen/src/Core/VectorwiseOp.h	/^    const ConstReverseReturnType reverse() const$/;"	f	class:Eigen::VectorwiseOp
reverse	lib/pugixml/pugixml.cc	/^	template <typename I> void reverse(I begin, I end)$/;"	f
reverseInPlace	lib/Eigen/src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase
reverseInPlace	lib/Eigen/src/Core/Reverse.h	/^void VectorwiseOp<ExpressionType,Direction>::reverseInPlace()$/;"	f	class:Eigen::VectorwiseOp
reverse_momenta	lib/qcd/hmc/integrators/Integrator.h	/^  void reverse_momenta(){$/;"	f	class:Grid::QCD::Integrator
reverse_packet	lib/Eigen/src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse
reverse_packet_cond	lib/Eigen/src/Core/Reverse.h	/^template<typename PacketType, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
reverse_packet_cond	lib/Eigen/src/Core/Reverse.h	/^template<typename PacketType> struct reverse_packet_cond<PacketType,false>$/;"	s	namespace:Eigen::internal
revert	lib/pugixml/pugixml.cc	/^		void revert(const xpath_allocator& state)$/;"	f	class:xpath_allocator
rho	lib/qcd/smearing/APEsmearing.h	/^      	const std::vector<double> rho;\/*!< Array of weights *\/$/;"	m	class:Grid::QCD::Smear_APE
rhs	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp
rhs	lib/Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	class:Eigen::Product
rhs	lib/Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC const RhsType&       rhs() const { return m_rhs; }$/;"	f	class:Eigen::Solve
rhs	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC const RhsType&       rhs()   const { return m_rhs; }$/;"	f	class:Eigen::SolveWithGuess
rightCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr rightCols(Index n)$/;"	f
rightCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr rightCols(Index n) const$/;"	f
rightCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type rightCols(Index n = N) const$/;"	f
rightCols	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type rightCols(Index n = N)$/;"	f
rightHouseholderSequence	lib/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
rmultGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaT	lib/qcd/spin/Gamma.h	/^inline void rmultGammaT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaTGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultGammaTGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaX	lib/qcd/spin/Gamma.h	/^inline void rmultGammaX(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaXGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultGammaXGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaY	lib/qcd/spin/Gamma.h	/^inline void rmultGammaY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaYGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultGammaYGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaZ	lib/qcd/spin/Gamma.h	/^inline void rmultGammaZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultGammaZGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultGammaZGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultIdentity	lib/qcd/spin/Gamma.h	/^inline void rmultIdentity(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaT	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaTGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaTGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaX	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaX(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaXGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaXGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaY	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaYGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaYGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaZ	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusGammaZGamma5	lib/qcd/spin/Gamma.h	/^inline void rmultMinusGammaZGamma5(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusIdentity	lib/qcd/spin/Gamma.h	/^inline void rmultMinusIdentity(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusSigmaXT	lib/qcd/spin/Gamma.h	/^inline void rmultMinusSigmaXT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusSigmaXY	lib/qcd/spin/Gamma.h	/^inline void rmultMinusSigmaXY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusSigmaXZ	lib/qcd/spin/Gamma.h	/^inline void rmultMinusSigmaXZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusSigmaYT	lib/qcd/spin/Gamma.h	/^inline void rmultMinusSigmaYT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusSigmaYZ	lib/qcd/spin/Gamma.h	/^inline void rmultMinusSigmaYZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultMinusSigmaZT	lib/qcd/spin/Gamma.h	/^inline void rmultMinusSigmaZT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultSigmaXT	lib/qcd/spin/Gamma.h	/^inline void rmultSigmaXT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultSigmaXY	lib/qcd/spin/Gamma.h	/^inline void rmultSigmaXY(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultSigmaXZ	lib/qcd/spin/Gamma.h	/^inline void rmultSigmaXZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultSigmaYT	lib/qcd/spin/Gamma.h	/^inline void rmultSigmaYT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultSigmaYZ	lib/qcd/spin/Gamma.h	/^inline void rmultSigmaYZ(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rmultSigmaZT	lib/qcd/spin/Gamma.h	/^inline void rmultSigmaZT(iMatrix<vtype, Ns> &ret, const iMatrix<vtype, Ns> &rhs)$/;"	f	namespace:Grid::QCD
rng4d_	extras/Hadrons/Environment.hpp	/^    RngPt                                  rng4d_;$/;"	m	class:Environment
rng4d_	lib/Hadrons/Environment.hpp	/^    RngPt                                  rng4d_;$/;"	m	class:Environment
root	lib/algorithms/approx/Remez.cc	/^int AlgRemez::root() {$/;"	f	class:AlgRemez
root	lib/pugixml/pugixml.cc	/^		xpath_ast_node* root;$/;"	m	struct:xpath_query_impl	file:
root	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node xml_node::root() const$/;"	f	class:pugi::xml_node
roots	lib/algorithms/approx/Remez.h	/^  bigfloat *param, *roots, *poles;$/;"	m	class:AlgRemez
rot	lib/simd/Grid_generic.h	404;"	d
rot	lib/simd/Grid_generic.h	426;"	d
rotate	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
rotate	lib/simd/Grid_avx.h	/^    static inline __m256 rotate(__m256 in,int n){$/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_avx.h	/^    static inline __m256d rotate(__m256d in,int n){$/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_avx512.h	/^    static inline __m512 rotate(__m512 in,int n){ $/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_avx512.h	/^    static inline __m512d rotate(__m512d in,int n){ $/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_generic.h	/^    static inline vec<T> rotate(vec<T> in, int n){$/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_imci.h	/^    static inline __m512 rotate(__m512 in,int n){ $/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_imci.h	/^    static inline __m512d rotate(__m512d in,int n){ $/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_neon.h	/^    static inline float32x4_t rotate(float32x4_t in,int n){ \/\/ N:ok$/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_neon.h	/^    static inline float64x2_t rotate(float64x2_t in,int n){ \/\/ N:ok$/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_qpx.h	/^    static inline vector4double rotate(vector4double v, int n){$/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_qpx.h	/^    static inline vector4float rotate(vector4float v, int n){$/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_sse4.h	/^    static inline __m128 rotate(__m128 in,int n){ $/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_sse4.h	/^    static inline __m128d rotate(__m128d in,int n){ $/;"	f	struct:Grid::Optimization::Rotate
rotate	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> rotate(Grid_simd<S, V> b, int nrot) {$/;"	f	namespace:Grid
rotate	lib/simd/Grid_vector_types.h	/^inline void rotate( Grid_simd<S,V> &ret,Grid_simd<S,V> b,int nrot)$/;"	f	namespace:Grid
rotate	lib/simd/Grid_vector_types.h	/^inline void rotate(Grid_simd<S,V> &ret,Grid_simd<S,V> b,int nrot)$/;"	f	namespace:Grid
rotate	lib/tensors/Tensor_class.h	/^  friend strong_inline void rotate(iMatrix<vtype,N> &out,const iMatrix<vtype,N> &in,int rot){$/;"	f	class:Grid::iMatrix
rotate	lib/tensors/Tensor_class.h	/^  friend strong_inline void rotate(iScalar<vtype> &out,const iScalar<vtype> &in,int rot){$/;"	f	class:Grid::iScalar
rotate	lib/tensors/Tensor_class.h	/^  friend strong_inline void rotate(iVector<vtype,N> &out,const iVector<vtype,N> &in,int rot){$/;"	f	class:Grid::iVector
rotation	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform
rotation_base_generic_product_selector	lib/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	lib/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	lib/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
round	lib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(round, Scalar) round(const Scalar& x)$/;"	f	namespace:Eigen::numext
round	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^round() const$/;"	f
round_impl	lib/Eigen/src/Core/MathFunctions.h	/^  struct round_impl {$/;"	s	namespace:Eigen::internal
round_impl	lib/Eigen/src/Core/MathFunctions.h	/^  struct round_impl$/;"	s	namespace:Eigen::internal
round_nearest	lib/pugixml/pugixml.cc	/^	PUGI__FN double round_nearest(double value)$/;"	f
round_nearest_nzero	lib/pugixml/pugixml.cc	/^	PUGI__FN double round_nearest_nzero(double value)$/;"	f
round_retval	lib/Eigen/src/Core/MathFunctions.h	/^struct round_retval$/;"	s	namespace:Eigen::internal
row	lib/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Traits::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon215
row	lib/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Traits::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon216
row	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index row() const             { return m_iter.row(); }$/;"	f	class:Eigen::InnerIterator
row	lib/Eigen/src/Core/CoreIterators.h	/^  inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::internal::inner_iterator_selector
row	lib/Eigen/src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % DstXprType::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_loop::__anon23
row	lib/Eigen/src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon221
row	lib/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
row	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Index row()    const { return EvalIterator::row()   - m_block.startRow(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
row	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Index row()    const { return IsRowMajor ? 0 : index(); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
row	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index row() const { return IsRowMajor ? m_outer.value() : index(); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
row	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index row() const { return IsRowMajor ? m_outer.value() : index(); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
row	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return IsRowMajor ? m_lhsIter.outer() : m_id; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return IsRowMajor ? m_rhsIter.outer() : m_id; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index row()   const { return NeedToTranspose ? m_outer : LhsIterator::index(); }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index row() const    { return SparseXprType::IsRowMajor ? m_sparseIter.outer() : m_sparseIter.index(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseTranspose.h	/^      Index row() const { return EvalIterator::col(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
row	lib/Eigen/src/SparseCore/SparseUtil.h	/^  const StorageIndex& row() const { return m_row; }$/;"	f	class:Eigen::Triplet
row	lib/Eigen/src/SparseCore/SparseView.h	/^        inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
row	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index row() const { return index(); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
row	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowXpr row(Index i) const$/;"	f
row	lib/Eigen/src/plugins/BlockMethods.h	/^inline RowXpr row(Index i)$/;"	f
rowIndex	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* rowIndex()  { return m_rowind; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndex	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* rowIndex() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndexByOuterInner	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
rowIndexByOuterInner	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
rowIndexPtr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* rowIndexPtr() { return m_rowind_colptr; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndexPtr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* rowIndexPtr() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowOffset	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value() > 0 ? 0 : -m_index.value(); }$/;"	f	struct:Eigen::internal::evaluator
rowOffset	lib/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
rowPrefix	lib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowSeparator	lib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowSpacer	lib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowStride	lib/Eigen/src/Core/CoreEvaluators.h	/^  inline Index rowStride() const { return XprType::IsRowMajor ? m_outerStride.value() : m_innerStride.value(); }$/;"	f	struct:Eigen::internal::mapbase_evaluator
rowStride	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase
rowSuffix	lib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
row_major_bit	lib/Eigen/src/Core/Matrix.h	/^      row_major_bit = _Options&RowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon171
rowblk	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index rowblk; \/\/ The minimum row dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues
rows	lib/Eigen/src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT
rows	lib/Eigen/src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT
rows	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline StorageIndex rows() const { return internal::convert_index<StorageIndex, Index>(m_cholmodFactor->n); }$/;"	f	class:Eigen::CholmodBase
rows	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper
rows	lib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper
rows	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index rows() const        { return m_dstExpr.rows(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
rows	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix
rows	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
rows	lib/Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense
rows	lib/Eigen/src/Core/CoreEvaluators.h	/^  Index rows() const $/;"	f	class:Eigen::internal::EvalToTemp
rows	lib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp
rows	lib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
rows	lib/Eigen/src/Core/CwiseTernaryOp.h	/^  EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseTernaryOp
rows	lib/Eigen/src/Core/CwiseUnaryOp.h	/^    Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp
rows	lib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView
rows	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index rows() const {return m_rows;}$/;"	f	class:Eigen::DenseStorage
rows	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage
rows	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	lib/Eigen/src/Core/Diagonal.h	/^    inline Index rows() const$/;"	f	class:Eigen::Diagonal
rows	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
rows	lib/Eigen/src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase
rows	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess
rows	lib/Eigen/src/Core/Inverse.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::Inverse
rows	lib/Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase
rows	lib/Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue
rows	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline Index rows() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
rows	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase
rows	lib/Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::Product
rows	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::internal::redux_evaluator
rows	lib/Eigen/src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate
rows	lib/Eigen/src/Core/ReturnByValue.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue
rows	lib/Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse
rows	lib/Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select
rows	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView
rows	lib/Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_dec.cols(); }$/;"	f	class:Eigen::Solve
rows	lib/Eigen/src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
rows	lib/Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose
rows	lib/Eigen/src/Core/Transpositions.h	/^    Index rows() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
rows	lib/Eigen/src/Core/Transpositions.h	/^    Index rows() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
rows	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase
rows	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView
rows	lib/Eigen/src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr
rows	lib/Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::internal::visitor_evaluator
rows	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
rows	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
rows	lib/Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
rows	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
rows	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
rows	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return int(Mode)==int(Projective) ? m_matrix.cols() : (m_matrix.cols()-1); }$/;"	f	class:Eigen::Transform
rows	lib/Eigen/src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence
rows	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
rows	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    Index rows() const { return m_L.rows(); }$/;"	f	class:Eigen::IncompleteCholesky
rows	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT
rows	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return matrix().rows(); }$/;"	f	class:Eigen::IterativeSolverBase
rows	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_dec.cols(); }$/;"	f	class:Eigen::SolveWithGuess
rows	lib/Eigen/src/LU/FullPivLU.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU
rows	lib/Eigen/src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU
rows	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase
rows	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
rows	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR
rows	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index rows() const { return m_cpqr.rows(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
rows	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR
rows	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
rows	lib/Eigen/src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR
rows	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index rows() const {return m_rows; }$/;"	f	class:Eigen::SPQR
rows	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index rows() const { return m_transpose ? m_spqr.rows() : m_spqr.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct
rows	lib/Eigen/src/SVD/SVDBase.h	/^  inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::SVDBase
rows	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
rows	lib/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::BlockImpl
rows	lib/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
rows	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::BlockImpl
rows	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMapBase
rows	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
rows	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase
rows	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView
rows	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
rows	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector
rows	lib/Eigen/src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView
rows	lib/Eigen/src/SparseLU/SparseLU.h	/^    inline Index rows() const { return m_mat.rows(); }$/;"	f	class:Eigen::SparseLU
rows	lib/Eigen/src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
rows	lib/Eigen/src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
rows	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index rows() { return m_row; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rows	lib/Eigen/src/SparseQR/SparseQR.h	/^    inline Index rows() const { return m_pmat.rows(); }$/;"	f	class:Eigen::SparseQR
rows	lib/Eigen/src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
rows	lib/Eigen/src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_transpose ? m_qr.rows() : m_qr.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct
rows	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase
rows	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return mp_matrix.rows(); }$/;"	f	class:Eigen::UmfPackLU
rows	lib/Eigen/src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base
rows	lib/Eigen/src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base
rowsPermutation	lib/Eigen/src/SparseLU/SparseLU.h	/^    inline const PermutationType& rowsPermutation() const$/;"	f	class:Eigen::SparseLU
rowsTranspositions	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const IntDiagSizeVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR
rows_select	lib/Eigen/src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon186
rowwise	lib/Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC inline ConstRowwiseReturnType rowwise() const {$/;"	f	class:Eigen::DenseBase
rowwise	lib/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase
rpointers	lib/stencil/Stencil.h	/^    std::vector<scalar_object *> rpointers;$/;"	m	struct:Grid::CartesianStencil::Merge
rsplat	lib/simd/Grid_vector_types.h	/^inline void rsplat(Grid_simd<S, V> &ret, EnableIf<is_complex<S>, S> c) {$/;"	f	namespace:Grid
rsqrt	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^rsqrt() const$/;"	f
rsqrt	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> rsqrt(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
rsqrt	lib/simd/Grid_vector_unops.h	/^inline Scalar rsqrt(const Scalar &r) {$/;"	f	namespace:Grid
rtag	lib/communicator/Communicator_mpi3_leader.cc	/^  int rtag;$/;"	m	struct:Grid::Descriptor	file:
rtnewt	lib/algorithms/approx/Remez.cc	/^bigfloat AlgRemez::rtnewt(bigfloat *poly, long i, bigfloat x1, $/;"	f	class:AlgRemez
run	extras/Hadrons/Application.cc	/^void Application::run(void)$/;"	f	class:Application
run	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  static void run(CholmodType& mat) {$/;"	f	struct:Eigen::internal::cholmod_configure_matrix
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &, Index) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_InnerUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::dense_assignment_loop
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_InnerUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_InnerUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel& kernel)$/;"	f	struct:Eigen::internal::copy_using_evaluator_LinearTraversal_CompleteUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_LinearTraversal_CompleteUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_InnerUnrolling
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index, Index) {}$/;"	f	struct:Eigen::internal::unaligned_dense_assignment_loop
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)$/;"	f	struct:Eigen::internal::dense_assignment_loop
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_DONT_INLINE void run(Kernel &kernel,$/;"	f	struct:Eigen::internal::unaligned_dense_assignment_loop
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const Functor &func)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,SrcScalarType> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,SrcScalarType> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived & \/*mat*\/) { return false; }$/;"	f	struct:Eigen::internal::any_unroller
run	lib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller
run	lib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller
run	lib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &\/*mat*\/) { return true; }$/;"	f	struct:Eigen::internal::all_unroller
run	lib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller
run	lib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller
run	lib/Eigen/src/Core/ConditionEstimator.h	/^  static inline Vector run(const Vector& v) {$/;"	f	struct:Eigen::internal::rcond_compute_sign
run	lib/Eigen/src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl
run	lib/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	lib/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	lib/Eigen/src/Core/DiagonalMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/DiagonalMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/DiagonalMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	lib/Eigen/src/Core/Dot.h	/^  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck
run	lib/Eigen/src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	lib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isApprox_selector
run	lib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	lib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isApprox_selector
run	lib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	lib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	lib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	lib/Eigen/src/Core/GeneralProduct.h	/^  static inline void run(const Lhs &lhs, const Rhs &rhs, Dest& dest, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_dense_selector
run	lib/Eigen/src/Core/GeneralProduct.h	/^  static void run(const Lhs &lhs, const Rhs &rhs, Dest& dest, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_dense_selector
run	lib/Eigen/src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^    static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::arg_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^    static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::arg_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^    static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::round_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static EIGEN_DEVICE_FUNC inline ScalarX run(ScalarX x, ScalarY y)$/;"	f	struct:Eigen::internal::pow_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static EIGEN_DEVICE_FUNC inline result_type run(const ScalarX& x, const ScalarY& y)$/;"	f	struct:Eigen::internal::pow_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl_default
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::log1p_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline T run(const std::complex<T>& x)$/;"	f	struct:Eigen::internal::imag_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline T run(const std::complex<T>& x)$/;"	f	struct:Eigen::internal::real_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	lib/Eigen/src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	lib/Eigen/src/Core/NumTraits.h	/^  static int run() { return 0; }$/;"	f	struct:Eigen::internal::default_digits10_impl
run	lib/Eigen/src/Core/NumTraits.h	/^  static int run() { return std::numeric_limits<T>::digits10; }$/;"	f	struct:Eigen::internal::default_digits10_impl
run	lib/Eigen/src/Core/NumTraits.h	/^  static int run() {$/;"	f	struct:Eigen::internal::default_digits10_impl
run	lib/Eigen/src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow
run	lib/Eigen/src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index, Index)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow
run	lib/Eigen/src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl
run	lib/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	lib/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	lib/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	lib/Eigen/src/Core/ProductEvaluators.h	/^    static inline void run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)$/;"	f	struct:Eigen::internal::permutation_matrix_product
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, Index \/*innerDim*\/, Packet &res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index \/*innerDim*\/, Packet &res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  static inline void run(Dest& dst, const TranspositionType& tr, const ExpressionType& xpr)$/;"	f	struct:Eigen::internal::transposition_matrix_product
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const AssignFunc& func)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const InitialFunc& \/*func*\/)$/;"	f	struct:Eigen::internal::assignment_from_xpr_op_product
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC static Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	lib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	lib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	lib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	lib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	lib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	lib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	lib/Eigen/src/Core/Redux.h	/^  static Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	lib/Eigen/src/Core/Reverse.h	/^  static inline PacketType run(const PacketType& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	lib/Eigen/src/Core/Reverse.h	/^  static inline PacketType run(const PacketType& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	lib/Eigen/src/Core/Reverse.h	/^  static void run(ExpressionType &xpr)$/;"	f	struct:Eigen::internal::vectorwise_reverse_inplace_impl
run	lib/Eigen/src/Core/Solve.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector
run	lib/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	lib/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	lib/Eigen/src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	lib/Eigen/src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	lib/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	lib/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	lib/Eigen/src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector
run	lib/Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Kernel &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_loop
run	lib/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::triangular_assignment_loop
run	lib/Eigen/src/Core/TriangularMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/TriangularMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/TriangularMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	lib/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cd& first, const Packet2cd& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet4cf& first, const Packet4cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4d& first, const Packet4d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet8f& first, const Packet8f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet16f& first,$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet8d& first, const Packet8d& second) {$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  static inline half run()$/;"	f	struct:Eigen::internal::random_default_impl
run	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  static inline half run(const half& x, const half& y)$/;"	f	struct:Eigen::internal::random_default_impl
run	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static void run(MatrixType& mat, const ProductType& prod, const typename MatrixType::Scalar& alpha, bool beta)$/;"	f	struct:Eigen::general_product_to_triangular_selector
run	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,LhsMapper,ColMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product
run	lib/Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,LhsMapper,RowMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product
run	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix
run	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static void run(Dest &dst, const Lhs &a_lhs, const Rhs &a_rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_product_impl
run	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix
run	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix
run	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  static void run(Dest& dest, const Lhs &a_lhs, const Rhs &a_rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_product_impl
run	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^EIGEN_DONT_INLINE void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::selfadjoint_matrix_vector_product
run	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vecX, const Scalar* vecY, const Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update
run	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector
run	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector
run	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^                                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>::run($/;"	f	class:Eigen::internal::product_triangular_matrix_matrix
run	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix
run	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> static void run(Dest& dst, const Lhs &a_lhs, const Rhs &a_rhs, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::triangular_product_impl
run	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  ::run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	class:Eigen::internal::triangular_matrix_vector_product
run	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(const Lhs &lhs, const Rhs &rhs, Dest& dest, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::trmv_selector
run	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> static void run(Dest& dst, const Lhs &lhs, const Rhs &rhs, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::triangular_product_impl
run	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix
run	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix
run	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix
run	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector
run	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE To run(const From& x) { return To(x); }$/;"	f	struct:Eigen::internal::get_factor
run	lib/Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return numext::real(x); }$/;"	f	struct:Eigen::internal::get_factor
run	lib/Eigen/src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector
run	lib/Eigen/src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector
run	lib/Eigen/src/Core/util/Memory.h	/^  EIGEN_DEVICE_FUNC static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper
run	lib/Eigen/src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_memmove_helper
run	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg
run	lib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase
run	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename ArgType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	lib/Eigen/src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector
run	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product
run	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived>& q){$/;"	f	struct:Eigen::internal::quat_conj
run	lib/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_DEVICE_FUNC static inline void run(QuaternionBase<Derived>& q, const Other& a_mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	lib/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_DEVICE_FUNC static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	lib/Eigen/src/Geometry/RotationBase.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	lib/Eigen/src/Geometry/RotationBase.h	/^  EIGEN_DEVICE_FUNC static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	lib/Eigen/src/Geometry/RotationBase.h	/^  EIGEN_DEVICE_FUNC static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static void run(MatrixType &mat)$/;"	f	struct:Eigen::internal::transform_make_affine
run	lib/Eigen/src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl
run	lib/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl
run	lib/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	lib/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	lib/Eigen/src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	lib/Eigen/src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	lib/Eigen/src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	lib/Eigen/src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	lib/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	lib/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	lib/Eigen/src/Geometry/Transform.h	/^  template<typename MatrixType> EIGEN_DEVICE_FUNC static void run(MatrixType &) { }$/;"	f	struct:Eigen::internal::transform_make_affine
run	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& q)$/;"	f	struct:Eigen::internal::quat_conj
run	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	lib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& q)$/;"	f	struct:Eigen::internal::quat_conj
run	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	lib/Eigen/src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	lib/Eigen/src/LU/FullPivLU.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename MatrixType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/LU/InverseImpl.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check
run	lib/Eigen/src/LU/InverseImpl.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse
run	lib/Eigen/src/LU/InverseImpl.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename XprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/LU/InverseImpl.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	lib/Eigen/src/LU/PartialPivLU.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename LuType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& mat, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    static IndexType run( _MKL_DSS_HANDLE_t pt, IndexType maxfct, IndexType mnum, IndexType type, IndexType phase, IndexType n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector
run	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename QrType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename CodType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename QrType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/QR/HouseholderQR.h	/^  static void run(MatrixQR& mat, HCoeffs& hCoeffs, Index maxBlockSize=32,$/;"	f	struct:Eigen::internal::householder_qr_inplace_blocked
run	lib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	lib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	lib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	lib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	lib/Eigen/src/SVD/JacobiSVD.h	/^  static bool run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q, RealScalar& maxDiagEntry)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	lib/Eigen/src/SVD/JacobiSVD.h	/^  static bool run(typename SVD::WorkMatrixType&, SVD&, Index, Index, RealScalar&) { return true; }$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    static void run(const InputMatrixType& input, ConstCholMatrixPtr &pmat, CholMatrixType &tmp)$/;"	f	struct:Eigen::internal::simplicial_cholesky_grab_input
run	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    static void run(const MatrixType& input, ConstMatrixPtr &pmat, MatrixType &\/*tmp*\/)$/;"	f	struct:Eigen::internal::simplicial_cholesky_grab_input
run	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector
run	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::sparse_sparse_to_dense_product_selector
run	lib/Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseAssign.h	/^  static void run(SparseMatrix<Scalar,Options,StorageIndex> &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseAssign.h	/^  static void run(SparseMatrixBase<DstDerived> &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
run	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
run	lib/Eigen/src/SparseCore/SparsePermutation.h	/^    static inline void run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)$/;"	f	struct:Eigen::internal::permutation_matrix_product
run	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(DynamicSparseMatrix<DestScalar,ColMajor,StorageIndex>& dst, const SrcXprType &src, const AssignOpType&\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<DestScalar,StorageOrder,StorageIndex> &dst, const SrcXprType &src, const AssignFunc& func)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<DestScalar,StorageOrder,StorageIndex> &dst, const SrcXprType &src, const AssignOpType&\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<DestScalar,StorageOrder,StorageIndex> &dst, const SrcXprType &src,$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<Scalar,Options,DstIndex> &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename MatrixType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseSelfAdjointView<DestType,DestMode>& dst, const SrcXprType &src, const internal::assign_op<Scalar,typename MatrixType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, const RealScalar& tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
run	lib/Eigen/src/SparseCore/SparseVector.h	/^  static void run(Dest& dst, const Src& src) {$/;"	f	struct:Eigen::internal::sparse_vector_assign_selector
run	lib/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector
run	lib/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
run	lib/Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<1>::run(const Index \/*segsize*\/, BlockScalarVector& dense, ScalarVector& \/*tempv*\/, ScalarVector& lusup, Index& luptr,$/;"	f	class:Eigen::internal::LU_kernel_bmod
run	lib/Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<SegSizeAtCompileTime>::run(const Index segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda,$/;"	f	class:Eigen::internal::LU_kernel_bmod
run	lib/Eigen/src/SparseQR/SparseQR.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper
run	lib/Hadrons/Application.cc	/^void Application::run(void)$/;"	f	class:Application
running	lib/perfmon/Timer.h	/^  bool running;$/;"	m	class:Grid::GridStopWatch
s	lib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation
s	lib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation
s	lib/simd/Grid_vector_types.h	/^    Scalar_type s[sizeof(Vector_type) \/ sizeof(Scalar_type)];$/;"	m	union:Grid::Grid_simd::conv_t_union
sRNG	lib/qcd/hmc/HMC.h	/^  GridSerialRNG &sRNG;   $/;"	m	class:Grid::QCD::HybridMonteCarlo
sRNG	tests/core/Test_GaugeAction.cc	/^  GridSerialRNG & sRNG;$/;"	m	class:Metropolis	file:
sRNG	tests/core/Test_RectPlaq.cc	/^  GridSerialRNG & sRNG;$/;"	m	class:Metropolis	file:
sRNG	tests/testu01/Test_smallcrush.cc	/^  static GridSerialRNG *sRNG;$/;"	m	struct:TestRNG	file:
sRNG	tests/testu01/Test_smallcrush.cc	/^GridSerialRNG   *TestRNG::sRNG;$/;"	m	class:TestRNG	file:
sRNG_	lib/qcd/hmc/HMCModules.h	/^   GridSerialRNG sRNG_;$/;"	m	class:Grid::QCD::RNGModule
same_node	lib/qcd/action/fermion/WilsonCompressor.h	/^  std::vector<int> same_node;$/;"	m	class:Grid::QCD::WilsonStencil
sample	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox
saturated	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  bool saturated(RealD lmd, RealD thrs) {$/;"	f	class:Grid::SortEigen
save	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_document::save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document
save	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_document::save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags) const$/;"	f	class:pugi::xml_document
save	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_document::save(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document
save	lib/qcd/hmc/HMC_GridModules.h	/^  void save(Writer<WriterClass>& Writer){$/;"	f	class:Grid::GridModuleParameters
saveParameterFile	extras/Hadrons/Application.cc	/^void Application::saveParameterFile(const std::string parameterFileName)$/;"	f	class:Application
saveParameterFile	lib/Hadrons/Application.cc	/^void Application::saveParameterFile(const std::string parameterFileName)$/;"	f	class:Application
saveParameters	extras/Hadrons/Module.hpp	/^    virtual void saveParameters(XmlWriter &writer, const std::string name)$/;"	f	class:Module
saveParameters	extras/Hadrons/Module.hpp	/^void Module<P>::saveParameters(XmlWriter &writer, const std::string name)$/;"	f	class:Module
saveParameters	lib/Hadrons/Module.hpp	/^    virtual void saveParameters(XmlWriter &writer, const std::string name)$/;"	f	class:Module
saveParameters	lib/Hadrons/Module.hpp	/^void Module<P>::saveParameters(XmlWriter &writer, const std::string name)$/;"	f	class:Module
saveSchedule	extras/Hadrons/Application.cc	/^void Application::saveSchedule(const std::string filename)$/;"	f	class:Application
saveSchedule	lib/Hadrons/Application.cc	/^void Application::saveSchedule(const std::string filename)$/;"	f	class:Application
save_file	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_document::save_file(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document
save_file	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_document::save_file(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const$/;"	f	class:pugi::xml_document
save_file_impl	lib/pugixml/pugixml.cc	/^	PUGI__FN bool save_file_impl(const xml_document& doc, FILE* file, const char_t* indent, unsigned int flags, xml_encoding encoding)$/;"	f
scal	benchmarks/Benchmark_dwf.cc	/^struct scal {$/;"	s	file:
scal	benchmarks/Benchmark_dwf_sweep.cc	/^struct scal {$/;"	s	file:
scal	benchmarks/Benchmark_wilson.cc	/^struct scal {$/;"	s	file:
scal	benchmarks/Benchmark_wilson_sweep.cc	/^struct scal {$/;"	s	file:
scal	tests/Test_cayley_even_odd_vec.cc	/^struct scal {$/;"	s	file:
scal	tests/Test_dwf_mixedcg_prec.cc	/^struct scal {$/;"	s	file:
scal	tests/Test_dwf_mixedcg_prec_halfcomms.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_cf_coarsen_support.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_checker.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_contfrac_even_odd.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_dwf_even_odd.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_dwf_rb5d.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_mobius_even_odd.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_wilson_even_odd.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_wilson_twisted_mass_even_odd.cc	/^struct scal {$/;"	s	file:
scal	tests/core/Test_zmobius_even_odd.cc	/^struct scal {$/;"	s	file:
scal	tests/debug/Test_cayley_cg.cc	/^struct scal {$/;"	s	file:
scal	tests/debug/Test_cayley_coarsen_support.cc	/^struct scal {$/;"	s	file:
scal	tests/debug/Test_cayley_even_odd.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_cf_cr_unprec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_contfrac_cg.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_dwf_cg_prec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_dwf_cg_prec_LsVec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_dwf_cg_schur.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_dwf_cg_unprec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_dwf_cr_unprec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_dwf_fpgcr.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_staggered_block_cg_unprec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_staggered_cg_unprec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_wilson_cg_prec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_wilson_cg_schur.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_wilson_cg_unprec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_wilson_cr_unprec.cc	/^struct scal {$/;"	s	file:
scal	tests/solver/Test_zmobius_cg_prec.cc	/^struct scal {$/;"	s	file:
scalar_abs2_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
scalar_abs_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
scalar_acos_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
scalar_arg_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_arg_op {$/;"	s	namespace:Eigen::internal
scalar_asin_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
scalar_atan_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_atan_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_and_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_not_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_boolean_not_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_or_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_xor_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_boolean_xor_op {$/;"	s	namespace:Eigen::internal
scalar_cast_op	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct scalar_cast_op<Eigen::half, float> {$/;"	s	namespace:Eigen::internal
scalar_cast_op	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct scalar_cast_op<float, Eigen::half> {$/;"	s	namespace:Eigen::internal
scalar_cast_op	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct scalar_cast_op<int, Eigen::half> {$/;"	s	namespace:Eigen::internal
scalar_cast_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
scalar_ceil_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_ceil_op {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_EQ> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_GE> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_GT> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_LE> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_LT> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_NEQ> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_UNORD> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_conj_product_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_conj_product_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_conjugate_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
scalar_constant_op	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
scalar_cos_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
scalar_cosh_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_cosh_op {$/;"	s	namespace:Eigen::internal
scalar_cube_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
scalar_difference_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_difference_op<const std::complex<T>, const std::complex<T> >  : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_difference_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_difference_op<std::complex<T>, std::complex<T> > : scalar_difference_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_difference_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_difference_op : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_div_cost	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 16 }; };$/;"	s	namespace:Eigen::internal
scalar_div_cost	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 14 }; };$/;"	s	namespace:Eigen::internal
scalar_div_cost	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 8 }; };$/;"	s	namespace:Eigen::internal
scalar_div_cost	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 7 }; };$/;"	s	namespace:Eigen::internal
scalar_exp_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
scalar_floor_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_floor_op {$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	lib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	lib/Eigen/src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
scalar_hypot_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_hypot_op<Scalar,Scalar> : binary_op_base<Scalar,Scalar>$/;"	s	namespace:Eigen::internal
scalar_identity_op	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
scalar_imag_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
scalar_imag_ref_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
scalar_isfinite_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_isfinite_op {$/;"	s	namespace:Eigen::internal
scalar_isinf_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_isinf_op {$/;"	s	namespace:Eigen::internal
scalar_isnan_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_isnan_op {$/;"	s	namespace:Eigen::internal
scalar_log10_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_log10_op {$/;"	s	namespace:Eigen::internal
scalar_log1p_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_log1p_op {$/;"	s	namespace:Eigen::internal
scalar_log_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_max_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_min_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_min_op : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_object	lib/stencil/Stencil.h	/^  typedef typename cobj::scalar_object scalar_object;$/;"	t	class:Grid::CartesianStencil
scalar_object	lib/tensors/Tensor_class.h	/^  typedef iMatrix<recurse_scalar_object, N> scalar_object;$/;"	t	class:Grid::iMatrix
scalar_object	lib/tensors/Tensor_class.h	/^  typedef iScalar<recurse_scalar_object> scalar_object;$/;"	t	class:Grid::iScalar
scalar_object	lib/tensors/Tensor_class.h	/^  typedef iVector<recurse_scalar_object, N> scalar_object;$/;"	t	class:Grid::iVector
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef  Integer scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef ComplexD  scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef ComplexD scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef ComplexF  scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef ComplexF scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef Integer scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef RealD  scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef RealD scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef RealF  scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef RealF scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_object	lib/tensors/Tensor_traits.h	/^    typedef typename T::scalar_object scalar_object;$/;"	t	class:Grid::GridTypeMapper
scalar_opposite_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
scalar_pow_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_pow_op  : binary_op_base<Scalar,Exponent>$/;"	s	namespace:Eigen::internal
scalar_product_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_product_op<const std::complex<T>, const std::complex<T> >  : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_product_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_product_op<std::complex<T>, std::complex<T> > : scalar_product_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_product_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_product_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_product_traits	lib/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct scalar_product_traits$/;"	s	namespace:Eigen
scalar_quotient_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_quotient_op<const std::complex<T>, const std::complex<T> > : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_quotient_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_quotient_op<std::complex<T>, std::complex<T> > : scalar_quotient_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_quotient_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_quotient_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_random_op	lib/Eigen/src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
scalar_real_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
scalar_real_ref_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
scalar_round_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_round_op {$/;"	s	namespace:Eigen::internal
scalar_rsqrt_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_rsqrt_op {$/;"	s	namespace:Eigen::internal
scalar_score_coeff_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_score_coeff_op : scalar_abs_op<Scalar>$/;"	s	namespace:Eigen::internal
scalar_sign_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_sign_op<Scalar,false> {$/;"	s	namespace:Eigen::internal
scalar_sign_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_sign_op<Scalar,true> {$/;"	s	namespace:Eigen::internal
scalar_sin_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
scalar_sinh_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_sinh_op {$/;"	s	namespace:Eigen::internal
scalar_sqrt_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
scalar_square_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
scalar_sum_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_sum_op<const std::complex<T>, const std::complex<T> > : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_sum_op	lib/Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_sum_op<std::complex<T>, std::complex<T> > : scalar_sum_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_sum_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  scalar_sum_op() {}$/;"	f	struct:Eigen::internal::scalar_sum_op
scalar_sum_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_sum_op : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_sum_op	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct scalar_sum_op<bool,bool> : scalar_sum_op<int,int> {$/;"	s	namespace:Eigen::internal
scalar_tan_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
scalar_tanh_op	lib/Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_tanh_op {$/;"	s	namespace:Eigen::internal
scalar_type	lib/lattice/Lattice_base.h	/^    typedef typename vobj::scalar_type scalar_type;$/;"	t	class:Grid::Lattice
scalar_type	lib/simd/Grid_vector_types.h	/^  typedef Scalar_type scalar_type;$/;"	t	class:Grid::Grid_simd
scalar_type	lib/stencil/Stencil.h	/^  typedef typename cobj::scalar_type scalar_type;$/;"	t	class:Grid::CartesianStencil
scalar_type	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::scalar_type scalar_type;$/;"	t	class:Grid::iMatrix
scalar_type	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::scalar_type scalar_type;$/;"	t	class:Grid::iScalar
scalar_type	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::scalar_type scalar_type;$/;"	t	class:Grid::iVector
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef  Integer scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef ComplexD  scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef ComplexD scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef ComplexF  scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef ComplexF scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef Integer scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef RealD  scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef RealD scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef RealF  scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef RealF scalar_type;$/;"	t	class:Grid::GridTypeMapper
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef typename GridTypeMapper<vector_obj>::scalar_type scalar_type; \/\/get the associated scalar type. Works on fundamental and tensor types$/;"	t	class:Grid::getPrecision
scalar_type	lib/tensors/Tensor_traits.h	/^    typedef typename T::scalar_type scalar_type;$/;"	t	class:Grid::GridTypeMapper
scale	lib/Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(const Scalar& s)$/;"	f	class:Eigen::Transform
scale	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
scale	lib/qcd/action/fermion/PartialFractionFermion5D.h	/^      RealD scale;$/;"	m	class:Grid::QCD::PartialFractionFermion5D
scale	tests/debug/Test_synthetic_lanczos.cc	/^  LatticeComplex scale;$/;"	m	class:DumbOperator	file:
scale	tests/hmc/Test_multishift_sqrt.cc	/^  LatticeComplex scale;$/;"	m	class:DumbOperator	file:
scaleAndAddTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl_base
scaleAndAddTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static inline void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& a_lhs, const Rhs& a_rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const RhsView& rhsView, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void scaleAndAddTo(Dest& dst, const LhsView& lhsView, const Rhs& rhs, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scalingS	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    const VectorRx& scalingS() const { eigen_assert("m_factorizationIsOk"); return m_scale; }$/;"	f	class:Eigen::IncompleteCholesky
scan	lib/json/json.hpp	/^        token_type scan()$/;"	f	class:nlohmann::basic_json::lexer
scatterPacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void scatterPacket(Index i, Index j, const SubPacket &p) const {$/;"	f	class:Eigen::internal::blas_data_mapper
schedule	extras/Hadrons/Application.cc	/^void Application::schedule(void)$/;"	f	class:Application
schedule	lib/Hadrons/Application.cc	/^void Application::schedule(void)$/;"	f	class:Application
scidacChecksum	lib/parallelIO/IldgIOtypes.h	/^  scidacChecksum() { $/;"	f	struct:Grid::scidacChecksum
scidacChecksum	lib/parallelIO/IldgIOtypes.h	/^struct scidacChecksum : Serializable { $/;"	s	namespace:Grid
scidacChecksumVerify	lib/parallelIO/IldgIO.h	/^ static int scidacChecksumVerify(scidacChecksum &scidacChecksum_,uint32_t scidac_csuma,uint32_t scidac_csumb)$/;"	f	namespace:Grid::QCD
scidacFile	lib/parallelIO/IldgIOtypes.h	/^  scidacFile(GridBase * grid){$/;"	f	struct:Grid::scidacFile
scidacFile	lib/parallelIO/IldgIOtypes.h	/^struct scidacFile : Serializable {$/;"	s	namespace:Grid
scidacRecord	lib/parallelIO/IldgIOtypes.h	/^  scidacRecord() { version =1.0; }$/;"	f	struct:Grid::scidacRecord
scidacRecord	lib/parallelIO/IldgIOtypes.h	/^struct scidacRecord : Serializable {$/;"	s	namespace:Grid
scomplex	lib/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
scomplex	lib/algorithms/iterative/BlockConjugateGradient.h	/^  typedef typename Field::scalar_type scomplex;$/;"	t	class:Grid::BlockConjugateGradient
scoped_array	lib/Eigen/src/Core/util/Memory.h	/^  explicit scoped_array(std::ptrdiff_t size)$/;"	f	class:Eigen::internal::scoped_array
scoped_array	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> class scoped_array : noncopyable$/;"	c	namespace:Eigen::internal
score	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType score ; \/* the score used to maintain heap, if col is alive *\/$/;"	m	union:internal::colamd_col::__anon624
scratch	lib/pugixml/pugixml.cc	/^		} scratch;$/;"	m	class:xml_buffered_writer	typeref:union:xml_buffered_writer::__anon684	file:
search	lib/algorithms/approx/Remez.cc	/^void AlgRemez::search(bigfloat *step) {$/;"	f	class:AlgRemez
searchLowerIndex	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
searchLowerIndex	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index start, Index end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
second	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  Packet second;$/;"	m	struct:Eigen::internal::DoublePacket
second_argument_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef Arg2 second_argument_type;$/;"	t	struct:Eigen::internal::binary_op_base
second_argument_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::second_argument_type second_argument_type;$/;"	t	struct:Eigen::internal::bind1st_op
second_argument_type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::second_argument_type second_argument_type;$/;"	t	struct:Eigen::internal::bind2nd_op
section_name	lib/qcd/modules/Modules.h	/^  std::string section_name;$/;"	m	class:Grid::Parametrized
secularEq	lib/Eigen/src/SVD/BDCSVD.h	/^typename BDCSVD<MatrixType>::RealScalar BDCSVD<MatrixType>::secularEq(RealScalar mu, const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm, const ArrayRef& diagShifted, RealScalar shift)$/;"	f	class:Eigen::BDCSVD
seed	extras/Hadrons/GeneticScheduler.hpp	/^        unsigned int popSize, seed;$/;"	m	struct:GeneticScheduler::Parameters
seed	lib/Hadrons/GeneticScheduler.hpp	/^        unsigned int popSize, seed;$/;"	m	struct:GeneticScheduler::Parameters
seed	lib/qcd/hmc/HMCModules.h	/^  void seed() {$/;"	f	class:Grid::QCD::RNGModule
seed	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void seed()$/;"	f	class:sitmo::prng_engine
seed	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void seed(Seq& q, typename sitmo_enable_if< has_generate_template<Seq>::value >::type* = 0 )$/;"	f	class:sitmo::prng_engine
seed	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void seed(uint32_t s)$/;"	f	class:sitmo::prng_engine
segment	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType segment(Index start, Index n) const$/;"	f
segment	lib/Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType segment(Index start, Index n)$/;"	f
segment	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type segment(Index start, Index n = N) const$/;"	f
segment	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type segment(Index start, Index n = N)$/;"	f
select	lib/Eigen/src/Core/GenericPacketMath.h	/^  bool select[N];$/;"	m	struct:Eigen::internal::Selector
select	lib/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase
select	lib/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const typename ElseDerived::Scalar& thenScalar,$/;"	f	class:Eigen::DenseBase
selectPair	extras/Hadrons/GeneticScheduler.hpp	/^typename GeneticScheduler<T>::GenePair GeneticScheduler<T>::selectPair(void)$/;"	f	class:GeneticScheduler
selectPair	lib/Hadrons/GeneticScheduler.hpp	/^typename GeneticScheduler<T>::GenePair GeneticScheduler<T>::selectPair(void)$/;"	f	class:GeneticScheduler
select_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node xml_node::select_node(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node
select_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node xml_node::select_node(const xpath_query& query) const$/;"	f	class:pugi::xml_node
select_nodes	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set xml_node::select_nodes(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node
select_nodes	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set xml_node::select_nodes(const xpath_query& query) const$/;"	f	class:pugi::xml_node
select_single_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node xml_node::select_single_node(const char_t* query, xpath_variable_set* variables) const$/;"	f	class:pugi::xml_node
select_single_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node xml_node::select_single_node(const xpath_query& query) const$/;"	f	class:pugi::xml_node
selector	lib/Eigen/src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type
selfadjointView	lib/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase
selfadjointView	lib/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase
selfadjointView	lib/Eigen/src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView
selfadjointView	lib/Eigen/src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView
selfadjointView	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^typename SparseMatrixBase<Derived>::template ConstSelfAdjointViewReturnType<UpLo>::Type SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase
selfadjointView	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^typename SparseMatrixBase<Derived>::template SelfAdjointViewReturnType<UpLo>::Type SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase
selfadjoint_matrix_vector_product	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
selfadjoint_matrix_vector_product_symv	lib/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal
selfadjoint_product_impl	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct selfadjoint_product_impl<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen::internal
selfadjoint_product_impl	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_product_impl<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen::internal
selfadjoint_product_impl	lib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_product_impl<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen::internal
selfadjoint_product_selector	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
selfadjoint_product_selector	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	lib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank2_update_selector	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
selfadjoint_rank2_update_selector	lib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
sem_head	lib/communicator/Communicator_mpi3_leader.cc	/^  Grid_semaphore  sem_head;$/;"	m	class:Grid::Slave	file:
sem_name	lib/communicator/Communicator_mpi3_leader.cc	/^  char sem_name [NAME_MAX];$/;"	m	class:Grid::Slave	file:
sem_tail	lib/communicator/Communicator_mpi3_leader.cc	/^  Grid_semaphore  sem_tail;$/;"	m	class:Grid::Slave	file:
send_buf	lib/stencil/Stencil.h	/^    void * send_buf;$/;"	m	struct:Grid::CartesianStencil::Packet
seq	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class seq {$/;"	c	namespace:Grid
seq_local	lib/communicator/Communicator_shmem.cc	/^  uint64_t seq_local;$/;"	m	struct:Grid::HandShake_t	file:
seq_remote	lib/communicator/Communicator_shmem.cc	/^  uint64_t seq_remote;$/;"	m	struct:Grid::HandShake_t	file:
set	lib/Eigen/src/Core/ProductEvaluators.h	/^  struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	s	struct:Eigen::internal::generic_product_impl
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool get_variable_scratch(char_t (&buffer)[32], xpath_variable_set* set, const char_t* begin, const char_t* end, xpath_variable** out_result)$/;"	v
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(bool rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(const char_t* rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(double rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(float rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(int rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(long long rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(unsigned int rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_text::set(unsigned long long rhs)$/;"	f	class:pugi::xml_text
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable::set(bool value)$/;"	f	class:pugi::xpath_variable
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable::set(const char_t* value)$/;"	f	class:pugi::xpath_variable
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable::set(const xpath_node_set& value)$/;"	f	class:pugi::xpath_variable
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable::set(double value)$/;"	f	class:pugi::xpath_variable
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, bool value)$/;"	f	class:pugi::xpath_variable_set
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, const char_t* value)$/;"	f	class:pugi::xpath_variable_set
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, const xpath_node_set& value)$/;"	f	class:pugi::xpath_variable_set
set	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xpath_variable_set::set(const char_t* name, double value)$/;"	f	class:pugi::xpath_variable_set
setBounds	lib/Eigen/src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = convert_index(start); m_end = convert_index(end); }$/;"	f	class:Eigen::internal::AmbiVector
setBounds	lib/algorithms/approx/Remez.cc	/^void AlgRemez::setBounds(double lower, double upper)$/;"	f	class:AlgRemez
setCheckerboard	lib/lattice/Lattice_transfer.h	/^  template<class vobj> inline void setCheckerboard(Lattice<vobj> &full,const Lattice<vobj> &half){$/;"	f	namespace:Grid
setConstant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& val)$/;"	f	class:Eigen::DenseBase
setConstant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index rows, Index cols, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase
setConstant	lib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase
setConstant	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularViewImpl
setCpuCacheSizes	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2, std::ptrdiff_t l3)$/;"	f	namespace:Eigen
setDefaultPrecision	lib/algorithms/approx/bigfloat.h	/^  static void setDefaultPrecision(unsigned long dprec) {$/;"	f	class:bigfloat
setDefaultPrecision	lib/algorithms/approx/bigfloat_double.h	/^  static void setDefaultPrecision(unsigned long dprec) {$/;"	f	class:bigfloat
setDimensions	lib/parallelIO/IldgIOtypes.h	/^  void setDimensions(std::vector<int> dimensions) { $/;"	f	struct:Grid::scidacFile
setDroptol	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::setDroptol(const RealScalar& droptol)$/;"	f	class:Eigen::IncompleteLUT
setEmpty	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline void setEmpty()$/;"	f	class:Eigen::AlignedBox
setFillfactor	lib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT
setFromTriplets	lib/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_StorageIndex>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix
setFromTriplets	lib/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_StorageIndex>::setFromTriplets(const InputIterators& begin, const InputIterators& end, DupFunctor dup_func)$/;"	f	class:Eigen::SparseMatrix
setFromTwoVectors	lib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase
setIdentity	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase
setIdentity	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase
setIdentity	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	lib/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase
setIdentity	lib/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity(Index newSize)$/;"	f	class:Eigen::PermutationBase
setIdentity	lib/Eigen/src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase
setIdentity	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline QuaternionBase& setIdentity() { coeffs() << Scalar(0), Scalar(0), Scalar(0), Scalar(1); return *this; }$/;"	f	class:Eigen::QuaternionBase
setIdentity	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform
setIdentity	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setIdentity()$/;"	f	class:Eigen::SparseMatrix
setIdentity_impl	lib/Eigen/src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
setInfos	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    void setInfos(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind,$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
setInitialShift	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void setInitialShift(RealScalar shift) { m_initialShift = shift; }$/;"	f	class:Eigen::IncompleteCholesky
setLength	lib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence
setLinSpaced	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index newSize, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setLinSpaced	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setMaxIterations	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexEigenSolver
setMaxIterations	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexSchur
setMaxIterations	lib/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::EigenSolver
setMaxIterations	lib/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::GeneralizedEigenSolver
setMaxIterations	lib/Eigen/src/Eigenvalues/RealQZ.h	/^      RealQZ& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealQZ
setMaxIterations	lib/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealSchur
setMaxIterations	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::IterativeSolverBase
setMode	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition
setMode	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky
setNbThreads	lib/Eigen/src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen
setNull	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox
setObject	extras/Hadrons/Environment.hpp	/^void Environment::setObject(const std::string name, T *object)$/;"	f	class:Environment
setObject	extras/Hadrons/Environment.hpp	/^void Environment::setObject(const unsigned int address, T *object)$/;"	f	class:Environment
setObject	lib/Hadrons/Environment.hpp	/^void Environment::setObject(const std::string name, T *object)$/;"	f	class:Environment
setObject	lib/Hadrons/Environment.hpp	/^void Environment::setObject(const unsigned int address, T *object)$/;"	f	class:Environment
setOnes	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase
setOnes	lib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setOnes	lib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setOnes	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularViewImpl
setPar	extras/Hadrons/Application.cc	/^void Application::setPar(const Application::GlobalPar &par)$/;"	f	class:Application
setPar	extras/Hadrons/Module.hpp	/^void Module<P>::setPar(const P &par)$/;"	f	class:Module
setPar	lib/Hadrons/Application.cc	/^void Application::setPar(const Application::GlobalPar &par)$/;"	f	class:Application
setPar	lib/Hadrons/Module.hpp	/^void Module<P>::setPar(const P &par)$/;"	f	class:Module
setPivotThreshold	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setPivotThreshold(const RealScalar& tol)$/;"	f	class:Eigen::SPQR
setPivotThreshold	lib/Eigen/src/SparseLU/SparseLU.h	/^    void setPivotThreshold(const RealScalar& thresh)$/;"	f	class:Eigen::SparseLU
setPivotThreshold	lib/Eigen/src/SparseQR/SparseQR.h	/^    void setPivotThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::SparseQR
setPrecision	lib/algorithms/approx/bigfloat.h	/^  void setPrecision(unsigned long dprec) {$/;"	f	class:bigfloat
setPrecision	lib/algorithms/approx/bigfloat_double.h	/^  void setPrecision(unsigned long dprec) {$/;"	f	class:bigfloat
setRandom	lib/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setRandom	lib/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setRandom	lib/Eigen/src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase
setSPQROrdering	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setSPQROrdering(int ord) { m_ordering = ord;}$/;"	f	class:Eigen::SPQR
setScalarType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix
setSeed	extras/Hadrons/Environment.cc	/^void Environment::setSeed(const std::vector<int> &seed)$/;"	f	class:Environment
setSeed	lib/Hadrons/Environment.cc	/^void Environment::setSeed(const std::vector<int> &seed)$/;"	f	class:Environment
setShift	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& setShift(const RealScalar& offset)$/;"	f	class:Eigen::CholmodBase
setShift	lib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence
setShift	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase
setStorageType	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix
setSwitchSize	lib/Eigen/src/SVD/BDCSVD.h	/^  void setSwitchSize(int s) $/;"	f	class:Eigen::BDCSVD
setThreshold	lib/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU
setThreshold	lib/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU
setThreshold	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition& setThreshold(Default_t) {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
setThreshold	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition& setThreshold(const RealScalar& threshold) {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
setThreshold	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR
setThreshold	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR
setThreshold	lib/Eigen/src/SVD/SVDBase.h	/^  Derived& setThreshold(Default_t)$/;"	f	class:Eigen::SVDBase
setThreshold	lib/Eigen/src/SVD/SVDBase.h	/^  Derived& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::SVDBase
setTolerance	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(const RealScalar& tolerance)$/;"	f	class:Eigen::IterativeSolverBase
setTrajectory	extras/Hadrons/Environment.cc	/^void Environment::setTrajectory(const unsigned int traj)$/;"	f	class:Environment
setTrajectory	lib/Hadrons/Environment.cc	/^void Environment::setTrajectory(const unsigned int traj)$/;"	f	class:Environment
setTrans	lib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence
setZero	lib/Eigen/src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT
setZero	lib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase
setZero	lib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setZero	lib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setZero	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	lib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	lib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularViewImpl
setZero	lib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::setZero()$/;"	f	class:Eigen::internal::AmbiVector
setZero	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix
setZero	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector
set_Field	lib/qcd/smearing/GaugeConfiguration.h	/^  void set_Field(Field& U) { ThinField = &U; }$/;"	f	class:Grid::QCD::NoSmearing
set_Field	lib/qcd/smearing/GaugeConfiguration.h	/^  void set_Field(GaugeField& U) { fill_smearedSet(U); }$/;"	f	class:Grid::QCD::SmearedConfiguration
set_RNGSeeds	lib/qcd/hmc/HMCModules.h	/^  void set_RNGSeeds(RNGModuleParameters& Params) {$/;"	f	class:Grid::QCD::RNGModule
set_base_from	depcomp	/^set_base_from ()$/;"	f
set_counter	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void set_counter(uint64_t s0=0, uint64_t s1=0, uint64_t s2=0, uint64_t s3=0, unsigned short o_counter=0)$/;"	f	class:sitmo::prng_engine
set_dir_from	depcomp	/^set_dir_from ()$/;"	f
set_fj	lib/qcd/smearing/StoutSmearing.h	/^  void set_fj(LatticeComplex& f0, LatticeComplex& f1, LatticeComplex& f2,$/;"	f	class:Grid::QCD::Smear_Stout
set_from_triplets	lib/Eigen/src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, DupFunctor dup_func)$/;"	f	namespace:Eigen::internal
set_full	lib/qcd/hmc/HMC_GridModules.h	/^  void set_full(GridCartesian* grid) { grid_.reset(grid); }$/;"	f	class:Grid::GridModule
set_iLambda	lib/qcd/smearing/GaugeConfiguration.h	/^  void set_iLambda(GaugeLinkField& iLambda, GaugeLinkField& e_iQ,$/;"	f	class:Grid::QCD::SmearedConfiguration
set_is_malloc_allowed	lib/Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal
set_key	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    void set_key(uint64_t k0=0, uint64_t k1=0, uint64_t k2=0, uint64_t k3=0)$/;"	f	class:sitmo::prng_engine
set_memory_management_functions	lib/pugixml/pugixml.cc	/^	PUGI__FN void PUGIXML_FUNCTION set_memory_management_functions(allocation_function allocate, deallocation_function deallocate)$/;"	f	namespace:pugi
set_name	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_name(const char_t* rhs)$/;"	f	class:pugi::xml_attribute
set_name	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::set_name(const char_t* rhs)$/;"	f	class:pugi::xml_node
set_next	lib/pugixml/pugixml.cc	/^		void set_next(xpath_ast_node* value)$/;"	f	class:xpath_ast_node
set_pRNG	lib/qcd/hmc/HMCModules.h	/^  void set_pRNG(GridParallelRNG* pRNG){$/;"	f	class:Grid::QCD::RNGModule
set_parameters	lib/qcd/modules/Modules.h	/^  void set_parameters(Parameters Par){$/;"	f	class:Grid::Parametrized
set_parameters	lib/qcd/modules/Modules.h	/^  void set_parameters(Parameters Par){}$/;"	f	class:Grid::Parametrized
set_rb	lib/qcd/hmc/HMC_GridModules.h	/^  void set_rb(GridRedBlackCartesian* rbgrid) { rbgrid_.reset(rbgrid); }$/;"	f	class:Grid::GridModule
set_rho	lib/qcd/smearing/APEsmearing.h	/^  			std::vector<double> set_rho(const double common_rho) const {$/;"	f	class:Grid::QCD::Smear_APE
set_right	lib/pugixml/pugixml.cc	/^		void set_right(xpath_ast_node* value)$/;"	f	class:xpath_ast_node
set_type	lib/pugixml/pugixml.cc	/^		void set_type(xpath_node_set::type_t value)$/;"	f	class:xpath_node_set_raw
set_uw	lib/qcd/smearing/StoutSmearing.h	/^  void set_uw(LatticeComplex& u, LatticeComplex& w, GaugeLinkField& iQ2,$/;"	f	class:Grid::QCD::Smear_Stout
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(bool rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(const char_t* rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(double rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(float rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(int rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(long long rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(unsigned int rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_attribute::set_value(unsigned long long rhs)$/;"	f	class:pugi::xml_attribute
set_value	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::set_value(const char_t* rhs)$/;"	f	class:pugi::xml_node
set_value_buffer	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_buffer(String& dest, Header& header, uintptr_t header_mask, char (&buf)[128])$/;"	f
set_value_convert	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, bool value)$/;"	f
set_value_convert	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, double value)$/;"	f
set_value_convert	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, float value)$/;"	f
set_value_convert	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, int value)$/;"	f
set_value_convert	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, long long value)$/;"	f
set_value_convert	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, unsigned int value)$/;"	f
set_value_convert	lib/pugixml/pugixml.cc	/^	PUGI__FN bool set_value_convert(String& dest, Header& header, uintptr_t header_mask, unsigned long long value)$/;"	f
setup	extras/Hadrons/Module.hpp	/^    virtual void setup(void) {};$/;"	f	class:ModuleBase
setup	extras/Hadrons/Modules/MAction/DWF.hpp	/^void TDWF<FImpl>::setup(void)$/;"	f	class:TDWF
setup	extras/Hadrons/Modules/MAction/Wilson.hpp	/^void TWilson<FImpl>::setup(void)$/;"	f	class:TWilson
setup	extras/Hadrons/Modules/MContraction/DiscLoop.hpp	/^void TDiscLoop<FImpl>::setup(void)$/;"	f	class:TDiscLoop
setup	extras/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^void TGamma3pt<FImpl1, FImpl2, FImpl3>::setup(void)$/;"	f	class:TGamma3pt
setup	extras/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^void TWeakHamiltonianEye::setup(void)$/;"	f	class:TWeakHamiltonianEye
setup	extras/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^void TWeakHamiltonianNonEye::setup(void)$/;"	f	class:TWeakHamiltonianNonEye
setup	extras/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^void TWeakNeutral4ptDisc::setup(void)$/;"	f	class:TWeakNeutral4ptDisc
setup	extras/Hadrons/Modules/MFermion/GaugeProp.hpp	/^void TGaugeProp<FImpl>::setup(void)$/;"	f	class:TGaugeProp
setup	extras/Hadrons/Modules/MGauge/Load.cc	/^void TLoad::setup(void)$/;"	f	class:TLoad
setup	extras/Hadrons/Modules/MGauge/Random.cc	/^void TRandom::setup(void)$/;"	f	class:TRandom
setup	extras/Hadrons/Modules/MGauge/StochEm.cc	/^void TStochEm::setup(void)$/;"	f	class:TStochEm
setup	extras/Hadrons/Modules/MGauge/Unit.cc	/^void TUnit::setup(void)$/;"	f	class:TUnit
setup	extras/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^void TNoiseLoop<FImpl>::setup(void)$/;"	f	class:TNoiseLoop
setup	extras/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::setup(void)$/;"	f	class:TChargedProp
setup	extras/Hadrons/Modules/MScalar/FreeProp.cc	/^void TFreeProp::setup(void)$/;"	f	class:TFreeProp
setup	extras/Hadrons/Modules/MSink/Point.hpp	/^void TPoint<FImpl>::setup(void)$/;"	f	class:TPoint
setup	extras/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^void TRBPrecCG<FImpl>::setup(void)$/;"	f	class:TRBPrecCG
setup	extras/Hadrons/Modules/MSource/Point.hpp	/^void TPoint<FImpl>::setup(void)$/;"	f	class:TPoint
setup	extras/Hadrons/Modules/MSource/SeqGamma.hpp	/^void TSeqGamma<FImpl>::setup(void)$/;"	f	class:TSeqGamma
setup	extras/Hadrons/Modules/MSource/Wall.hpp	/^void TWall<FImpl>::setup(void)$/;"	f	class:TWall
setup	extras/Hadrons/Modules/MSource/Z2.hpp	/^void TZ2<FImpl>::setup(void)$/;"	f	class:TZ2
setup	lib/Hadrons/Module.hpp	/^    virtual void setup(void) {};$/;"	f	class:ModuleBase
setup	lib/Hadrons/Modules/MAction/DWF.hpp	/^void TDWF<FImpl>::setup(void)$/;"	f	class:TDWF
setup	lib/Hadrons/Modules/MAction/Wilson.hpp	/^void TWilson<FImpl>::setup(void)$/;"	f	class:TWilson
setup	lib/Hadrons/Modules/MContraction/DiscLoop.hpp	/^void TDiscLoop<FImpl>::setup(void)$/;"	f	class:TDiscLoop
setup	lib/Hadrons/Modules/MContraction/Gamma3pt.hpp	/^void TGamma3pt<FImpl1, FImpl2, FImpl3>::setup(void)$/;"	f	class:TGamma3pt
setup	lib/Hadrons/Modules/MContraction/WeakHamiltonianEye.cc	/^void TWeakHamiltonianEye::setup(void)$/;"	f	class:TWeakHamiltonianEye
setup	lib/Hadrons/Modules/MContraction/WeakHamiltonianNonEye.cc	/^void TWeakHamiltonianNonEye::setup(void)$/;"	f	class:TWeakHamiltonianNonEye
setup	lib/Hadrons/Modules/MContraction/WeakNeutral4ptDisc.cc	/^void TWeakNeutral4ptDisc::setup(void)$/;"	f	class:TWeakNeutral4ptDisc
setup	lib/Hadrons/Modules/MFermion/GaugeProp.hpp	/^void TGaugeProp<FImpl>::setup(void)$/;"	f	class:TGaugeProp
setup	lib/Hadrons/Modules/MGauge/Load.cc	/^void TLoad::setup(void)$/;"	f	class:TLoad
setup	lib/Hadrons/Modules/MGauge/Random.cc	/^void TRandom::setup(void)$/;"	f	class:TRandom
setup	lib/Hadrons/Modules/MGauge/StochEm.cc	/^void TStochEm::setup(void)$/;"	f	class:TStochEm
setup	lib/Hadrons/Modules/MGauge/Unit.cc	/^void TUnit::setup(void)$/;"	f	class:TUnit
setup	lib/Hadrons/Modules/MLoop/NoiseLoop.hpp	/^void TNoiseLoop<FImpl>::setup(void)$/;"	f	class:TNoiseLoop
setup	lib/Hadrons/Modules/MScalar/ChargedProp.cc	/^void TChargedProp::setup(void)$/;"	f	class:TChargedProp
setup	lib/Hadrons/Modules/MScalar/FreeProp.cc	/^void TFreeProp::setup(void)$/;"	f	class:TFreeProp
setup	lib/Hadrons/Modules/MSink/Point.hpp	/^void TPoint<FImpl>::setup(void)$/;"	f	class:TPoint
setup	lib/Hadrons/Modules/MSolver/RBPrecCG.hpp	/^void TRBPrecCG<FImpl>::setup(void)$/;"	f	class:TRBPrecCG
setup	lib/Hadrons/Modules/MSource/Point.hpp	/^void TPoint<FImpl>::setup(void)$/;"	f	class:TPoint
setup	lib/Hadrons/Modules/MSource/SeqGamma.hpp	/^void TSeqGamma<FImpl>::setup(void)$/;"	f	class:TSeqGamma
setup	lib/Hadrons/Modules/MSource/Wall.hpp	/^void TWall<FImpl>::setup(void)$/;"	f	class:TWall
setup	lib/Hadrons/Modules/MSource/Z2.hpp	/^void TZ2<FImpl>::setup(void)$/;"	f	class:TZ2
setupSigns	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	/^  int setupSigns(Vector<vtype>& signs ){$/;"	f
sfunc	tests/Test_simd.cc	/^template<class reduce,class scal>   void sfunc(reduce &rr,scal &i1,scal &i2) const { rr = i1;}$/;"	f	class:funcReduce
sfw_float_to_half	lib/simd/Grid_sse4.h	/^  inline Grid_half sfw_float_to_half(float ff) {$/;"	f	namespace:Grid::Optimization
sfw_half_to_float	lib/simd/Grid_sse4.h	/^  inline float sfw_half_to_float(Grid_half h) {$/;"	f	namespace:Grid::Optimization
sge	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class sge {$/;"	c	namespace:Grid
sgn	lib/algorithms/approx/bigfloat_double.h	/^  friend int sgn(const bigfloat& x) {$/;"	f	class:bigfloat
sgrid	lib/algorithms/FFT.h	/^    GridCartesian *sgrid;$/;"	m	class:Grid::FFT
sgt	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class sgt {$/;"	c	namespace:Grid
shared1	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon627
shared1	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon623
shared2	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon628
shared2	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon624
shared3	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared3 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon625
shared4	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared4 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon626
shear	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform
shift	lib/Eigen/src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
shifts	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^    MultiShiftFunction shifts;$/;"	m	class:Grid::ConjugateGradientMultiShift
show_decomposition	lib/cartesian/Cartesian_base.h	/^    void show_decomposition(){$/;"	f	class:Grid::GridBase
sign	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sign() const$/;"	f
signDeterminant	lib/Eigen/src/SparseLU/SparseLU.h	/^    Scalar signDeterminant()$/;"	f	class:Eigen::SparseLU
signInitD	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	/^static int signInitD = setupSigns(signsD);$/;"	v
signInitF	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	/^  static int signInitF = setupSigns(signsF);$/;"	v
signedDistance	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane
significant_decimals_impl	lib/Eigen/src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal
signs	lib/simd/BGQQPX.h	/^int signs[4];$/;"	v
signsD	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	/^static Vector<vComplexD> signsD;$/;"	v
signsF	lib/qcd/action/fermion/WilsonKernelsAsmAvx512.h	/^static Vector<vComplexF> signsF;$/;"	v
simplicial_cholesky_grab_input	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  struct simplicial_cholesky_grab_input {$/;"	s	namespace:Eigen::internal
simplicial_cholesky_grab_input	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  struct simplicial_cholesky_grab_input<MatrixType,MatrixType> {$/;"	s	namespace:Eigen::internal
simq	lib/algorithms/approx/Remez.cc	/^int AlgRemez::simq(bigfloat A[], bigfloat B[], bigfloat X[], int n) {$/;"	f	class:AlgRemez
sin	lib/Eigen/src/Core/MathFunctions.h	/^T sin(const T &x) {$/;"	f	namespace:Eigen::numext
sin	lib/Eigen/src/Core/MathFunctions.h	/^double sin(const double &x) { return ::sin(x); }$/;"	f	namespace:Eigen::numext
sin	lib/Eigen/src/Core/MathFunctions.h	/^float sin(const float &x) { return ::sinf(x); }$/;"	f	namespace:Eigen::numext
sin	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half sin(const half& a) {$/;"	f	namespace:Eigen::half_impl
sin	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sin() const$/;"	f
sin	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> sin(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
singularValues	lib/Eigen/src/SVD/SVDBase.h	/^  const SingularValuesType& singularValues() const$/;"	f	class:Eigen::SVDBase
sinh	lib/Eigen/src/Core/MathFunctions.h	/^T sinh(const T &x) {$/;"	f	namespace:Eigen::numext
sinh	lib/Eigen/src/Core/MathFunctions.h	/^double sinh(const double &x) { return ::sinh(x); }$/;"	f	namespace:Eigen::numext
sinh	lib/Eigen/src/Core/MathFunctions.h	/^float sinh(const float &x) { return ::sinhf(x); }$/;"	f	namespace:Eigen::numext
sinh	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sinh() const$/;"	f
site	tests/testu01/Test_smallcrush.cc	/^  static uint64_t site;$/;"	m	struct:TestRNG	file:
site	tests/testu01/Test_smallcrush.cc	/^uint64_t         TestRNG::site;$/;"	m	class:TestRNG	file:
sitePlaquette	extras/qed-fvol/WilsonLoops.h	/^  static void sitePlaquette(LatticeComplex &Plaq,$/;"	f	class:NewWilsonLoops
sitePlaquette	lib/qcd/utils/WilsonLoops.h	/^  static void sitePlaquette(ComplexField &Plaq,$/;"	f	class:Grid::QCD::WilsonLoops
siteRectangle	lib/qcd/utils/WilsonLoops.h	/^  static void siteRectangle(ComplexField &Rect,$/;"	f	class:Grid::QCD::WilsonLoops
siteSpatialWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static void siteSpatialWilsonLoop(LatticeComplex &Wl,$/;"	f	class:NewWilsonLoops
siteTimelikeWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static void siteTimelikeWilsonLoop(LatticeComplex &Wl,$/;"	f	class:NewWilsonLoops
siteVector	lib/algorithms/CoarsenedMatrix.h	/^    typedef iVector<CComplex,nbasis >             siteVector;$/;"	t	class:Grid::Aggregation
siteVector	lib/algorithms/CoarsenedMatrix.h	/^    typedef iVector<CComplex,nbasis >             siteVector;$/;"	t	class:Grid::CoarsenedMatrix
siteVector	tests/solver/Test_dwf_hdcr.cc	/^  typedef typename Aggregation<Fobj,CComplex,nbasis>::siteVector     siteVector;$/;"	t	class:MultiGridPreconditioner	file:
siteWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static void siteWilsonLoop(LatticeComplex &Wl,$/;"	f	class:NewWilsonLoops
sitmo	lib/sitmo_rng/sitmo_prng_engine.hpp	/^namespace sitmo {$/;"	n
sitmo_enable_if	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    struct sitmo_enable_if { typedef T type; };$/;"	s	namespace:sitmo
sitmo_enable_if	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    struct sitmo_enable_if<false, T> { };$/;"	s	namespace:sitmo
size	extras/Hadrons/Graph.hpp	/^unsigned int Graph<T>::size(void) const$/;"	f	class:Graph
size	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index size() const        { return m_dstExpr.size(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
size	lib/Eigen/src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase
size	lib/Eigen/src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon507
size	lib/Eigen/src/Core/Matrix.h	/^  enum { size = internal::size_at_compile_time<_Rows,_Cols>::ret };$/;"	e	enum:Eigen::internal::traits::__anon170
size	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline Index size() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
size	lib/Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index size() const { return m_xpr.size(); }$/;"	f	class:Eigen::internal::redux_evaluator
size	lib/Eigen/src/Core/Transpositions.h	/^    Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
size	lib/Eigen/src/Core/Transpositions.h	/^    Index size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
size	lib/Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC Index size() const { return m_xpr.size(); }$/;"	f	class:Eigen::internal::visitor_evaluator
size	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon305
size	lib/Eigen/src/Core/arch/AVX/Complex.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon303
size	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon306
size	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon304
size	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon295
size	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^    size=8,$/;"	e	enum:Eigen::internal::packet_traits::__anon294
size	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon299
size	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon298
size	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon300
size	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    size = 16,$/;"	e	enum:Eigen::internal::packet_traits::__anon352
size	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^    size = 8,$/;"	e	enum:Eigen::internal::packet_traits::__anon353
size	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon354
size	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon356
size	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 8, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon355
size	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon328
size	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon326
size	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon329
size	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon327
size	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon321
size	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon324
size	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon320
size	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon325
size	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon322
size	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon323
size	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
size	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
size	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon266
size	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon265
size	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon259
size	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon260
size	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon289
size	lib/Eigen/src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon287
size	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon290
size	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon288
size	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon285
size	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon281
size	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon282
size	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon286
size	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon283
size	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon284
size	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon347
size	lib/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon345
size	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon348
size	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon346
size	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon334
size	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon333
size	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon335
size	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon337
size	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon336
size	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon338
size	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon317
size	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon316
size	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon319
size	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon318
size	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon309
size	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon311
size	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon310
size	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon314
size	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon313
size	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon312
size	lib/Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector
size	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage
size	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase
size	lib/Hadrons/Graph.hpp	/^unsigned int Graph<T>::size(void) const$/;"	f	class:Graph
size	lib/pugixml/pugixml.cc	/^		size_t position, size;$/;"	m	struct:xpath_context	file:
size	lib/pugixml/pugixml.cc	/^		size_t size() const$/;"	f	class:xpath_node_set_raw
size	lib/pugixml/pugixml.cc	/^		size_t size;$/;"	m	struct:gap	file:
size	lib/pugixml/pugixml.cc	/^		size_t size;$/;"	m	struct:xml_stream_chunk	file:
size	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t xpath_node_set::size() const$/;"	f	class:pugi::xpath_node_set
size	lib/qcd/representations/hmc_types.h	/^  int size() { return tuple_size; }$/;"	f	class:Grid::QCD::Representations
sizeString	extras/Hadrons/Global.cc	/^std::string Hadrons::sizeString(long unsigned int bytes)$/;"	f	class:Hadrons
sizeString	lib/Hadrons/Global.cc	/^std::string Hadrons::sizeString(long unsigned int bytes)$/;"	f	class:Hadrons
size_type	lib/Eigen/src/Core/util/Memory.h	/^  typedef std::size_t     size_type;$/;"	t	class:Eigen::aligned_allocator
size_type	lib/Eigen/src/StlSupport/details.h	/^    typedef std::size_t     size_type;$/;"	t	class:Eigen::aligned_allocator_indirection
size_type	lib/allocator/AlignedAllocator.h	/^    typedef std::size_t size_type;$/;"	t	class:Grid::alignedAllocator
size_type	lib/allocator/AlignedAllocator.h	/^  typedef std::size_t     size_type;$/;"	t	class:Grid::commAllocator
sizeof	lib/simd/Grid_vector_types.h	/^static_assert(sizeof(SIMD_Ftype) == sizeof(SIMD_Dtype), "SIMD vector lengths incorrect");$/;"	m	namespace:Grid
sizeof	lib/simd/Grid_vector_types.h	/^static_assert(sizeof(SIMD_Ftype) == sizeof(SIMD_Itype), "SIMD vector lengths incorrect");$/;"	m	namespace:Grid
sizes	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar,Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox
sle	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class sle {$/;"	c	namespace:Grid
slerp	lib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
slerp	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D slerp(const Scalar& t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
sliceInnerProductMatrix	lib/lattice/Lattice_reduction.h	/^static void sliceInnerProductMatrix(  Eigen::MatrixXcd &mat, const Lattice<vobj> &lhs,const Lattice<vobj> &rhs,int Orthog) $/;"	f	namespace:Grid
sliceInnerProductVector	lib/lattice/Lattice_reduction.h	/^static void sliceInnerProductVector( std::vector<ComplexD> & result, const Lattice<vobj> &lhs,const Lattice<vobj> &rhs,int orthogdim) $/;"	f	namespace:Grid
sliceMaddMatrix	lib/lattice/Lattice_reduction.h	/^static void sliceMaddMatrix (Lattice<vobj> &R,Eigen::MatrixXcd &aa,const Lattice<vobj> &X,const Lattice<vobj> &Y,int Orthog,RealD scale=1.0) $/;"	f	namespace:Grid
sliceMaddVector	lib/lattice/Lattice_reduction.h	/^static void sliceMaddVector(Lattice<vobj> &R,std::vector<RealD> &a,const Lattice<vobj> &X,const Lattice<vobj> &Y,$/;"	f	namespace:Grid
sliceMulMatrix	lib/lattice/Lattice_reduction.h	/^static void sliceMulMatrix (Lattice<vobj> &R,Eigen::MatrixXcd &aa,const Lattice<vobj> &X,int Orthog,RealD scale=1.0) $/;"	f	namespace:Grid
sliceNorm	lib/lattice/Lattice_reduction.h	/^static void sliceNorm (std::vector<RealD> &sn,const Lattice<vobj> &rhs,int Orthog) $/;"	f	namespace:Grid
sliceSum	lib/lattice/Lattice_reduction.h	/^template<class vobj> inline void sliceSum(const Lattice<vobj> &Data,std::vector<typename vobj::scalar_object> &result,int orthogdim)$/;"	f	namespace:Grid
slt	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class slt {$/;"	c	namespace:Grid
smallestAngle	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar smallestAngle() const {$/;"	f	class:Eigen::Rotation2D
smallestPositiveAngle	lib/Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar smallestPositiveAngle() const {$/;"	f	class:Eigen::Rotation2D
smart_copy	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal
smart_copy_helper	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_copy_helper	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
smart_memmove	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> void smart_memmove(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal
smart_memmove_helper	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_memmove_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_memmove_helper	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_memmove_helper<T,true> {$/;"	s	namespace:Eigen::internal
smear	lib/qcd/smearing/APEsmearing.h	/^  				void smear(GaugeField& u_smr, const GaugeField& U)const{$/;"	f	class:Grid::QCD::Smear_APE
smear	lib/qcd/smearing/StoutSmearing.h	/^  void smear(GaugeField& u_smr, const GaugeField& U) const {$/;"	f	class:Grid::QCD::Smear_Stout
smear	lib/qcd/smearing/WilsonFlow.h	/^void WilsonFlow<Gimpl>::smear(GaugeField& out, const GaugeField& in) const {$/;"	f	class:Grid::QCD::WilsonFlow
smear_adaptive	lib/qcd/smearing/WilsonFlow.h	/^void WilsonFlow<Gimpl>::smear_adaptive(GaugeField& out, const GaugeField& in, RealD maxTau){$/;"	f	class:Grid::QCD::WilsonFlow
smeared_force	lib/qcd/smearing/GaugeConfiguration.h	/^  void smeared_force(Field&) const {}$/;"	f	class:Grid::QCD::NoSmearing
smeared_force	lib/qcd/smearing/GaugeConfiguration.h	/^  void smeared_force(GaugeField& SigmaTilde) const {$/;"	f	class:Grid::QCD::SmearedConfiguration
smearingLevels	lib/qcd/smearing/GaugeConfiguration.h	/^  const unsigned int smearingLevels;$/;"	m	class:Grid::QCD::SmearedConfiguration
sncndnFK	lib/algorithms/approx/Zolotarev.cc	/^static void sncndnFK(INTERNAL_PRECISION u, INTERNAL_PRECISION k,$/;"	f	namespace:Grid::Approx
sne	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class sne {$/;"	c	namespace:Grid
sobj	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  typedef typename vobj::scalar_object sobj;$/;"	t	class:Grid::QCD::BinaryHmcCheckpointer
sobj_double	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  typedef typename sobj::DoublePrecision sobj_double;$/;"	t	class:Grid::QCD::BinaryHmcCheckpointer
sobj_stype	lib/parallelIO/MetaData.h	/^  typedef typename getPrecision<sobj>::real_scalar_type sobj_stype;$/;"	t	struct:Grid::QCD::BinarySimpleMunger
sobj_stype	lib/parallelIO/MetaData.h	/^  typedef typename getPrecision<sobj>::real_scalar_type sobj_stype;$/;"	t	struct:Grid::QCD::BinarySimpleUnmunger
sobj_stype	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  typedef typename getPrecision<sobj>::real_scalar_type sobj_stype;$/;"	t	class:Grid::QCD::BinaryHmcCheckpointer
solve	lib/Eigen/src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT
solve	lib/Eigen/src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT
solve	lib/Eigen/src/Core/SolveTriangular.h	/^TriangularViewImpl<Derived,Mode,Dense>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solve	lib/Eigen/src/Core/SolverBase.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SolverBase
solve	lib/Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView
solve	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner
solve	lib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner
solve	lib/Eigen/src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU
solve	lib/Eigen/src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU
solve	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR
solve	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline const Solve<CompleteOrthogonalDecomposition, Rhs> solve($/;"	f	class:Eigen::CompleteOrthogonalDecomposition
solve	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR
solve	lib/Eigen/src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR
solve	lib/Eigen/src/SVD/SVDBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SVDBase
solve	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SparseSolverBase
solve	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SparseSolverBase
solve	lib/Eigen/src/SparseQR/SparseQR.h	/^    inline const Solve<SparseQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseQR
solve	lib/Eigen/src/SparseQR/SparseQR.h	/^    inline const Solve<SparseQR, Rhs> solve(const SparseMatrixBase<Rhs>& B) const$/;"	f	class:Eigen::SparseQR
solveInPlace	lib/Eigen/src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT
solveInPlace	lib/Eigen/src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT
solveInPlace	lib/Eigen/src/Core/SolveTriangular.h	/^void TriangularViewImpl<MatrixType,Mode,Dense>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	lib/Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	lib/Eigen/src/SparseCore/TriangularSolver.h	/^void TriangularViewImpl<ExpressionType,Mode,Sparse>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	lib/Eigen/src/SparseCore/TriangularSolver.h	/^void TriangularViewImpl<ExpressionType,Mode,Sparse>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	lib/Eigen/src/SparseLU/SparseLU.h	/^  template<typename Dest>   void solveInPlace(MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
solveInPlace	lib/Eigen/src/SparseLU/SparseLU.h	/^  void solveInPlace( MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
solveInPlace	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^void MappedSuperNodalMatrix<Scalar,Index_>::solveInPlace( MatrixBase<Dest>&X) const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
solveWithGuess	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::IterativeSolverBase
solve_sparse_through_dense_panels	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^solve_sparse_through_dense_panels(const Decomposition &dec, const Rhs& rhs, Dest &dest)$/;"	f	namespace:Eigen::internal
solve_traits	lib/Eigen/src/Core/Solve.h	/^struct solve_traits<Decomposition,RhsType,Dense>$/;"	s	namespace:Eigen::internal
solve_traits	lib/Eigen/src/SparseCore/SparseUtil.h	/^struct solve_traits<Decomposition,RhsType,Sparse>$/;"	s	namespace:Eigen::internal
solver_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::solver_type   solver_mod;$/;"	m	class:Grid::QCD::TwoFlavourEOFModule
solver_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::solver_type   solver_mod;$/;"	m	class:Grid::QCD::TwoFlavourFModule
solver_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::solver_type   solver_mod;$/;"	m	class:Grid::QCD::TwoFlavourRatioEOFModule
solver_mod	lib/qcd/modules/ActionModules.h	/^  typename Base::solver_type   solver_mod;$/;"	m	class:Grid::QCD::TwoFlavourRatioFModule
solver_string	lib/qcd/modules/Modules.cc	/^char solver_string[]     = "Solver";$/;"	m	namespace:Grid	file:
solver_type	lib/qcd/modules/ActionModules.h	/^  typedef std::unique_ptr<HMCModuleBase<OperatorFunction<typename Impl::FermionField> > > solver_type;$/;"	t	class:Grid::QCD::PseudoFermionModuleBase
sort	lib/pugixml/pugixml.cc	/^	PUGI__FN void xpath_node_set::sort(bool reverse)$/;"	f	class:pugi::xpath_node_set
sort	lib/pugixml/pugixml.cc	/^	template <typename I, typename Pred> void sort(I begin, I end, const Pred& pred)$/;"	f
sortEigenvalues	lib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
sort_do	lib/pugixml/pugixml.cc	/^		void sort_do()$/;"	f	class:xpath_node_set_raw
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<rtype,N> > = 0> strong_inline void spProj5m (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProj5m (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProj5m (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProj5m (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProj5m (iVector<vtype,Ns> &rfspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProj5m (iVector<vtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,int N> strong_inline void spProj5m (iMatrix<vtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5m	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype> strong_inline void spProj5m (iScalar<vtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProj5p (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProj5p (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProj5p (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProj5p (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProj5p (iVector<vtype,Ns> &rfspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProj5p (iVector<vtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,int N> strong_inline void spProj5p (iMatrix<vtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProj5p	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype> strong_inline void spProj5p (iScalar<vtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjTm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjTm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjTm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjTm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjTm (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProjTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjTp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjTp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjTp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjTp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjTp (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProjXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjXm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjXm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjXm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjXm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjXm (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProjXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjXp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjXp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjXp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjXp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjXp (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProjYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjYm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjYm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjYm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjYm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjYm (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProjYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjYp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjYp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjYp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjYp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjYp (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProjZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjZm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjZm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjZm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjZm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjZm (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spProjZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spProjZp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spProjZp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spProjZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spProjZp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spProjZp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spProjZp (iVector<vtype,Nhs> &hspin,const iVector<vtype,Ns> &fspin)$/;"	f	namespace:Grid::QCD
spRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spRecon5m (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spRecon5m (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spRecon5m (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spRecon5m	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spRecon5m (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spRecon5p (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spRecon5p (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spRecon5p (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spRecon5p	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spRecon5p (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconTm (iVector<rtype,N> &hspin, const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconTm (iMatrix<rtype,N> &hspin, const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconTm (iScalar<rtype> &hspin, const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconTm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconTm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconTp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconTp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconTp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconTp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconTp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconXm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconXm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconXm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconXm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconXm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconXp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconXp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconXp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconXp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconXp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconYm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconYm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconYm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconYm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconYm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconYp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconYp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconYp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconYp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconYp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconZm (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconZm (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconZm (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconZm	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconZm (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
spReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N,IfNotSpinor<iVector<vtype,N> > = 0> strong_inline void spReconZp (iVector<rtype,N> &hspin,const iVector<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype,int N> strong_inline void spReconZp (iMatrix<rtype,N> &hspin,const iMatrix<vtype,N> &fspin)$/;"	f	namespace:Grid::QCD
spReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class rtype,class vtype> strong_inline void spReconZp (iScalar<rtype> &hspin,const iScalar<vtype> &fspin)$/;"	f	namespace:Grid::QCD
spReconZp	lib/qcd/spin/TwoSpinor.h	/^  template<class vtype,IfSpinor<iVector<vtype,Ns> > = 0> strong_inline void spReconZp (iVector<vtype,Ns> &fspin,const iVector<vtype,Nhs> &hspin)$/;"	f	namespace:Grid::QCD
sparseView	lib/Eigen/src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& reference,$/;"	f	class:Eigen::MatrixBase
sparse_conjunction_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  explicit sparse_conjunction_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::sparse_conjunction_evaluator
sparse_conjunction_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct sparse_conjunction_evaluator<XprType, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
sparse_conjunction_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct sparse_conjunction_evaluator<XprType, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
sparse_conjunction_evaluator	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct sparse_conjunction_evaluator<XprType, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
sparse_dense_outer_product_evaluator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  sparse_dense_outer_product_evaluator(const ActualRhs &rhs, const Lhs1 &lhs)$/;"	f	struct:Eigen::internal::sparse_dense_outer_product_evaluator
sparse_dense_outer_product_evaluator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  sparse_dense_outer_product_evaluator(const Lhs1 &lhs, const ActualRhs &rhs)$/;"	f	struct:Eigen::internal::sparse_dense_outer_product_evaluator
sparse_dense_outer_product_evaluator	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_dense_outer_product_evaluator$/;"	s	namespace:Eigen::internal
sparse_diagonal_product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  sparse_diagonal_product_evaluator(const SparseXprType &sparseXpr, const DiagCoeffType &diagCoeff)$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
sparse_diagonal_product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  sparse_diagonal_product_evaluator(const SparseXprType &sparseXpr, const DiagonalCoeffType &diagCoeff)$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
sparse_diagonal_product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct sparse_diagonal_product_evaluator<SparseXprType, DiagCoeffType, SDP_AsCwiseProduct>$/;"	s	namespace:Eigen::internal
sparse_diagonal_product_evaluator	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct sparse_diagonal_product_evaluator<SparseXprType, DiagonalCoeffType, SDP_AsScalarProduct>$/;"	s	namespace:Eigen::internal
sparse_eval	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Cols,int Flags> struct sparse_eval<T,1,Cols,Flags> {$/;"	s	namespace:Eigen::internal
sparse_eval	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Flags> struct sparse_eval<T,1,1,Flags> {$/;"	s	namespace:Eigen::internal
sparse_eval	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols,int Flags> struct sparse_eval {$/;"	s	namespace:Eigen::internal
sparse_eval	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Flags> struct sparse_eval<T,Rows,1,Flags> {$/;"	s	namespace:Eigen::internal
sparse_matrix_block_impl	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline sparse_matrix_block_impl(SparseMatrixType& xpr, Index i)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
sparse_matrix_block_impl	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline sparse_matrix_block_impl(SparseMatrixType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
sparse_matrix_block_impl	lib/Eigen/src/SparseCore/SparseBlock.h	/^class sparse_matrix_block_impl$/;"	c	namespace:Eigen::internal
sparse_selfadjoint_time_dense_product	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^inline void sparse_selfadjoint_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal
sparse_solve_triangular_selector	lib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	lib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	lib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	lib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_sparse_selector	lib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_impl	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, const typename ResultType::RealScalar& tolerance)$/;"	f	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	lib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_impl	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void sparse_sparse_to_dense_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	lib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal
sparse_time_dense_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, AlphaType, ColMajor, true>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, ColMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, RowMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, RowMajor, true>$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	lib/Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Inner> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	lib/Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Outer> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	lib/Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_RuntimeSwitch> {$/;"	s	namespace:Eigen::internal
sparselu_gemm	lib/Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^void sparselu_gemm(Index m, Index n, Index d, const Scalar* A, Index lda, const Scalar* B, Index ldb, Scalar* C, Index ldc)$/;"	f	namespace:Eigen::internal
splicetime	lib/stencil/Stencil.h	/^  double splicetime;$/;"	m	class:Grid::CartesianStencil
split	lib/json/json.hpp	/^        static std::vector<std::string> split(const std::string& reference_string)$/;"	f	class:nlohmann::basic_json::json_pointer
splitOffTwoRows	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::splitOffTwoRows(Index i)$/;"	f	class:Eigen::RealQZ
splitOffTwoRows	lib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift)$/;"	f	class:Eigen::RealSchur
spread	lib/algorithms/approx/Remez.h	/^  bigfloat delta, spread, tolerance;$/;"	m	class:AlgRemez
sqrt	lib/Eigen/src/Core/MathFunctions.h	/^T sqrt(const T &x)$/;"	f	namespace:Eigen::numext
sqrt	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half sqrt(const half& a) {$/;"	f	namespace:Eigen::half_impl
sqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^double sqrt(const double &x)$/;"	f	namespace:Eigen::numext
sqrt	lib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^float sqrt(const float &x)$/;"	f	namespace:Eigen::numext
sqrt	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sqrt() const$/;"	f
sqrt	lib/simd/Grid_vector_unops.h	/^inline Grid_simd<S, V> sqrt(const Grid_simd<S, V> &r) {$/;"	f	namespace:Grid
sqrt	lib/simd/Simd.h	/^  inline RealD sqrt(const RealD  & r){ return std::sqrt(r); }$/;"	f	namespace:Grid
sqrt_bf	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat sqrt_bf(const bigfloat& x){$/;"	f	class:bigfloat
sqrt_bf	lib/algorithms/approx/bigfloat.h	/^  friend bigfloat sqrt_bf(const unsigned long x){$/;"	f	class:bigfloat
sqrt_bf	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat sqrt_bf(const bigfloat& x){$/;"	f	class:bigfloat
sqrt_bf	lib/algorithms/approx/bigfloat_double.h	/^  friend bigfloat sqrt_bf(const unsigned long x){$/;"	f	class:bigfloat
sqrt_cc	lib/qcd/action/fermion/ContinuedFractionFermion5D.h	/^      std::vector<double> sqrt_cc;$/;"	m	class:Grid::QCD::ContinuedFractionFermion5D
sqrth	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half sqrth(const Eigen::half& a) {$/;"	f
sqrtscale	tests/hmc/Test_multishift_sqrt.cc	/^  LatticeComplex sqrtscale;$/;"	m	class:DumbOperator	file:
squadron	lib/communicator/Communicator_mpi3_leader.cc	/^  MPI_Comm squadron;$/;"	m	class:Grid::Slave	file:
square	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^square() const$/;"	f
squaredDistance	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
squaredExteriorDistance	lib/Eigen/src/Geometry/AlignedBox.h	/^EIGEN_DEVICE_FUNC inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
squaredExteriorDistance	lib/Eigen/src/Geometry/AlignedBox.h	/^EIGEN_DEVICE_FUNC inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox
squaredNorm	lib/Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase
squaredNorm	lib/Eigen/src/Core/VectorwiseOp.h	/^    const SquaredNormReturnType squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp
squaredNorm	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase
squaredNorm	lib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase
squeeze	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage
src	lib/communicator/Communicator_mpi3_leader.cc	/^  int src;$/;"	m	struct:Grid::Descriptor	file:
srcEvaluator	lib/Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC const SrcEvaluatorType& srcEvaluator() const { return m_src; }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
ss_	lib/serialisation/JSON_IO.h	/^    std::ostringstream  ss_;$/;"	m	class:Grid::JSONWriter
sscale	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^    void sscale(const Lattice<vobj>& in, Lattice<vobj>& out, Coeff_t* s) {$/;"	f	class:Grid::KappaSimilarityTransform
sscale_norm	lib/qcd/action/fermion/SchurDiagTwoKappa.h	/^  RealD sscale_norm(const Field& in, Field& out, Coeff_t* s) {$/;"	f	class:Grid::KappaSimilarityTransform
stableNorm	lib/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase
stableNorm	lib/Eigen/src/Core/VectorwiseOp.h	/^    const StableNormReturnType stableNorm() const$/;"	f	class:Eigen::VectorwiseOp
stableNormalize	lib/Eigen/src/Core/Dot.h	/^inline void MatrixBase<Derived>::stableNormalize()$/;"	f	class:Eigen::MatrixBase
stableNormalized	lib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::stableNormalized() const$/;"	f	class:Eigen::MatrixBase
stable_norm_kernel	lib/Eigen/src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal
stack	lib/pugixml/pugixml.cc	/^		xpath_stack stack;$/;"	m	struct:xpath_stack_data	file:
start	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType start ;   \/* index for A of first col in this row *\/$/;"	m	struct:internal::Colamd_Row
start	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType start ;   \/* index for A of first row in this column, or DEAD *\/$/;"	m	struct:internal::colamd_col
start	lib/communicator/Communicator_mpi3_leader.cc	/^  volatile int start;$/;"	m	class:Grid::SlaveState	file:
start	lib/perfmon/Stat.cc	/^void PmuStat::start(void)$/;"	f	class:Grid::PmuStat
start	lib/perfmon/Timer.h	/^  GridTimePoint start;$/;"	m	class:Grid::GridStopWatch
startCol	lib/Eigen/src/Core/Block.h	/^    StorageIndex startCol() const$/;"	f	class:Eigen::internal::BlockImpl_dense
startCol	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index startCol() const { return IsRowMajor ? 0 : m_outerStart; }$/;"	f	class:Eigen::BlockImpl
startCol	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index startCol() const { return IsRowMajor ? 0 : m_outerStart; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
startCol	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index startCol() const { return m_startCol.value(); }$/;"	f	class:Eigen::BlockImpl
startFill	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector
startRow	lib/Eigen/src/Core/Block.h	/^    StorageIndex startRow() const$/;"	f	class:Eigen::internal::BlockImpl_dense
startRow	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index startRow() const { return IsRowMajor ? m_outerStart : 0; }$/;"	f	class:Eigen::BlockImpl
startRow	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index startRow() const { return IsRowMajor ? m_outerStart : 0; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
startRow	lib/Eigen/src/SparseCore/SparseBlock.h	/^    Index startRow() const { return m_startRow.value(); }$/;"	f	class:Eigen::BlockImpl
startVec	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix
startVec	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector
starts_with	lib/pugixml/pugixml.cc	/^	PUGI__FN bool starts_with(const char_t* string, const char_t* pattern)$/;"	f
stat	lib/qcd/action/fermion/WilsonFermion5D.h	/^     PmuStat stat;$/;"	m	class:Grid::QCD::WilsonFermion5D
state	lib/communicator/Communicator_mpi3_leader.cc	/^  SlaveState *state;$/;"	m	class:Grid::Slave	file:
state	lib/pugixml/pugixml.cc	/^		const char_t* state() const$/;"	f	class:xpath_lexer
static_assertion	lib/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
static_assertion	lib/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
static_cast	lib/json/json.hpp	/^          m_value(static_cast<number_integer_t>(val))$/;"	f	class:nlohmann::basic_json
static_cast	lib/json/json.hpp	/^          m_value(static_cast<number_unsigned_t>(val))$/;"	f	class:nlohmann::basic_json
statistics	benchmarks/Benchmark_comms.cc	/^  void statistics(std::vector<double> v){$/;"	f	struct:time_statistics
status	lib/pugixml/pugixml.h	/^		xml_parse_status status;$/;"	m	struct:pugi::xml_parse_result
status_append_invalid_root	lib/pugixml/pugixml.h	/^		status_append_invalid_root,	\/\/ Unable to append nodes since root type is not node_element or node_document (exclusive to xml_node::append_buffer)$/;"	e	enum:pugi::xml_parse_status
status_bad_attribute	lib/pugixml/pugixml.h	/^		status_bad_attribute,		\/\/ Parsing error occurred while parsing element attribute$/;"	e	enum:pugi::xml_parse_status
status_bad_cdata	lib/pugixml/pugixml.h	/^		status_bad_cdata,			\/\/ Parsing error occurred while parsing CDATA section$/;"	e	enum:pugi::xml_parse_status
status_bad_comment	lib/pugixml/pugixml.h	/^		status_bad_comment,			\/\/ Parsing error occurred while parsing comment$/;"	e	enum:pugi::xml_parse_status
status_bad_doctype	lib/pugixml/pugixml.h	/^		status_bad_doctype,			\/\/ Parsing error occurred while parsing document type declaration$/;"	e	enum:pugi::xml_parse_status
status_bad_end_element	lib/pugixml/pugixml.h	/^		status_bad_end_element,		\/\/ Parsing error occurred while parsing end element tag$/;"	e	enum:pugi::xml_parse_status
status_bad_pcdata	lib/pugixml/pugixml.h	/^		status_bad_pcdata,			\/\/ Parsing error occurred while parsing PCDATA section$/;"	e	enum:pugi::xml_parse_status
status_bad_pi	lib/pugixml/pugixml.h	/^		status_bad_pi,				\/\/ Parsing error occurred while parsing document declaration\/processing instruction$/;"	e	enum:pugi::xml_parse_status
status_bad_start_element	lib/pugixml/pugixml.h	/^		status_bad_start_element,	\/\/ Parsing error occurred while parsing start element tag$/;"	e	enum:pugi::xml_parse_status
status_end_element_mismatch	lib/pugixml/pugixml.h	/^		status_end_element_mismatch,\/\/ There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)$/;"	e	enum:pugi::xml_parse_status
status_file_not_found	lib/pugixml/pugixml.h	/^		status_file_not_found,		\/\/ File was not found during load_file()$/;"	e	enum:pugi::xml_parse_status
status_internal_error	lib/pugixml/pugixml.h	/^		status_internal_error,		\/\/ Internal error occurred$/;"	e	enum:pugi::xml_parse_status
status_io_error	lib/pugixml/pugixml.h	/^		status_io_error,			\/\/ Error reading from file\/stream$/;"	e	enum:pugi::xml_parse_status
status_no_document_element	lib/pugixml/pugixml.h	/^		status_no_document_element	\/\/ Parsing resulted in a document without element nodes$/;"	e	enum:pugi::xml_parse_status
status_ok	lib/pugixml/pugixml.h	/^		status_ok = 0,				\/\/ No error$/;"	e	enum:pugi::xml_parse_status
status_out_of_memory	lib/pugixml/pugixml.h	/^		status_out_of_memory,		\/\/ Could not allocate memory$/;"	e	enum:pugi::xml_parse_status
status_unrecognized_tag	lib/pugixml/pugixml.h	/^		status_unrecognized_tag,	\/\/ Parser could not determine tag type$/;"	e	enum:pugi::xml_parse_status
std	lib/Eigen/src/Core/arch/CUDA/Half.h	/^namespace std {$/;"	n
std	lib/Eigen/src/StlSupport/StdDeque.h	/^namespace std {$/;"	n
std	lib/Eigen/src/StlSupport/StdList.h	/^namespace std$/;"	n
std	lib/Eigen/src/StlSupport/StdVector.h	/^namespace std {$/;"	n
std	lib/json/json.hpp	/^namespace std$/;"	n
std	lib/pugixml/pugixml.cc	/^namespace std$/;"	n	file:
std	lib/pugixml/pugixml.h	/^namespace std$/;"	n
std_fallback	lib/Eigen/src/Core/MathFunctions.h	/^namespace std_fallback {$/;"	n	namespace:Eigen::internal
stem_function	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
step	lib/Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::step(Index f, Index l, Index iter)$/;"	f	class:Eigen::RealQZ
step	lib/algorithms/approx/Remez.h	/^  bigfloat *xx, *mm, *step;$/;"	m	class:AlgRemez
step	lib/algorithms/iterative/ImplicitlyRestartedLanczos.h	/^  void step(std::vector<RealD>& lmd,$/;"	f	class:Grid::ImplicitlyRestartedLanczos
step	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  void step(Field& U, int level, int _first, int _last) {$/;"	f	class:Grid::QCD::ForceGradient
step	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  void step(Field& U, int level, int _first, int _last) {$/;"	f	class:Grid::QCD::ImplicitLeapFrog
step	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  void step(Field& U, int level, int _first, int _last) {$/;"	f	class:Grid::QCD::ImplicitMinimumNorm2
step	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  void step(Field& U, int level, int _first, int _last) {$/;"	f	class:Grid::QCD::LeapFrog
step	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  void step(Field& U, int level, int _first, int _last) {$/;"	f	class:Grid::QCD::MinimumNorm2
step_do	lib/pugixml/pugixml.cc	/^		template <class T> xpath_node_set_raw step_do(const xpath_context& c, const xpath_stack& stack, nodeset_eval_t eval, T v)$/;"	f	class:xpath_ast_node	file:
step_fill	lib/pugixml/pugixml.cc	/^		template <class T> void step_fill(xpath_node_set_raw& ns, const xpath_node& xn, xpath_allocator* alloc, bool once, T v)$/;"	f	class:xpath_ast_node	file:
step_fill	lib/pugixml/pugixml.cc	/^		template <class T> void step_fill(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* p, xpath_allocator* alloc, bool once, T v)$/;"	f	class:xpath_ast_node	file:
step_fill	lib/pugixml/pugixml.cc	/^		template <class T> void step_fill(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc, bool once, T)$/;"	f	class:xpath_ast_node	file:
step_push	lib/pugixml/pugixml.cc	/^		bool step_push(xpath_node_set_raw& ns, xml_attribute_struct* a, xml_node_struct* parent, xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	file:
step_push	lib/pugixml/pugixml.cc	/^		bool step_push(xpath_node_set_raw& ns, xml_node_struct* n, xpath_allocator* alloc)$/;"	f	class:xpath_ast_node	file:
steps	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    int steps;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
storage	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon15
storage_kind_to_evaluator_kind	lib/Eigen/src/Core/CoreEvaluators.h	/^struct storage_kind_to_evaluator_kind {$/;"	s	namespace:Eigen::internal
storage_kind_to_evaluator_kind	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct storage_kind_to_evaluator_kind<Sparse> {$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<Dense>                  { typedef DenseShape Shape;           };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<PermutationStorage>     { typedef PermutationShape Shape;     };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<SolverStorage>          { typedef SolverShape Shape;           };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	lib/Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<TranspositionsStorage>  { typedef TranspositionsShape Shape;  };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	lib/Eigen/src/Core/DiagonalMatrix.h	/^template<> struct storage_kind_to_shape<DiagonalShape> { typedef DiagonalShape Shape; };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	lib/Eigen/src/SparseCore/SparseAssign.h	/^struct storage_kind_to_shape<Sparse> {$/;"	s	namespace:Eigen::internal
storePacket	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, const Packet &p) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
stpini	lib/algorithms/approx/Remez.cc	/^void AlgRemez::stpini(bigfloat *step) {$/;"	f	class:AlgRemez
strToVec	lib/serialisation/BaseIO.h	/^  std::vector<T> strToVec(const std::string s)$/;"	f	namespace:Grid
str_to_float_t	lib/json/json.hpp	/^        double str_to_float_t(double* \/* type *\/, char** endptr) const$/;"	f	class:nlohmann::basic_json::lexer
str_to_float_t	lib/json/json.hpp	/^        float str_to_float_t(float* \/* type *\/, char** endptr) const$/;"	f	class:nlohmann::basic_json::lexer
str_to_float_t	lib/json/json.hpp	/^        long double str_to_float_t(long double* \/* type *\/, char** endptr) const$/;"	f	class:nlohmann::basic_json::lexer
strconv_attribute_impl	lib/pugixml/pugixml.cc	/^	template <typename opt_escape> struct strconv_attribute_impl$/;"	s	file:
strconv_attribute_t	lib/pugixml/pugixml.cc	/^	typedef char_t* (*strconv_attribute_t)(char_t*, char_t);$/;"	t	file:
strconv_cdata	lib/pugixml/pugixml.cc	/^	PUGI__FN char_t* strconv_cdata(char_t* s, char_t endch)$/;"	f
strconv_comment	lib/pugixml/pugixml.cc	/^	PUGI__FN char_t* strconv_comment(char_t* s, char_t endch)$/;"	f
strconv_escape	lib/pugixml/pugixml.cc	/^	PUGI__FN char_t* strconv_escape(char_t* s, gap& g)$/;"	f
strconv_pcdata_impl	lib/pugixml/pugixml.cc	/^	template <typename opt_trim, typename opt_eol, typename opt_escape> struct strconv_pcdata_impl$/;"	s	file:
strconv_pcdata_t	lib/pugixml/pugixml.cc	/^	typedef char_t* (*strconv_pcdata_t)(char_t*);$/;"	t	file:
strcpy_insitu	lib/pugixml/pugixml.cc	/^	PUGI__FN bool strcpy_insitu(String& dest, Header& header, uintptr_t header_mask, const char_t* source)$/;"	f
strcpy_insitu_allow	lib/pugixml/pugixml.cc	/^	inline bool strcpy_insitu_allow(size_t length, const Header& header, uintptr_t header_mask, char_t* target)$/;"	f
strequal	lib/pugixml/pugixml.cc	/^	PUGI__FN bool strequal(const char_t* src, const char_t* dst)$/;"	f
strequalrange	lib/pugixml/pugixml.cc	/^	PUGI__FN bool strequalrange(const char_t* lhs, const char_t* rhs, size_t count)$/;"	f
stride	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase
stride	lib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC const Index stride() const { return m_stride; }$/;"	f	class:Eigen::internal::blas_data_mapper
string	lib/json/json.hpp	/^        string,          \/\/\/< string value$/;"	m	class:nlohmann::basic_json::value_t
string	lib/json/json.hpp	/^        string_t* string;$/;"	m	union:nlohmann::basic_json::json_value
string	lib/pugixml/pugixml.cc	/^			const char_t* string;$/;"	m	union:xpath_ast_node::__anon686	file:
string_t	lib/pugixml/pugixml.h	/^	typedef std::basic_string<PUGIXML_CHAR, std::char_traits<PUGIXML_CHAR>, std::allocator<PUGIXML_CHAR> > string_t;$/;"	t	namespace:pugi
string_value	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_string string_value(const xpath_node& na, xpath_allocator* alloc)$/;"	f
strlength	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t strlength(const char_t* s)$/;"	f
strlength_wide	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t strlength_wide(const wchar_t* s)$/;"	f
strong_inline	lib/serialisation/MacroMagic.h	45;"	d
structured_update	lib/Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::structured_update(Block<MatrixXr,Dynamic,Dynamic> A, const MatrixXr &B, Index n1)$/;"	f	class:Eigen::BDCSVD
su2Extract	lib/qcd/utils/SUn.h	/^  static void su2Extract(Lattice<iSinglet<vcplx> > &Determinant,$/;"	f	class:Grid::QCD::SU
su2Insert	lib/qcd/utils/SUn.h	/^  static void su2Insert(const Lattice<iSU2Matrix<vcplx> > &subgroup,$/;"	f	class:Grid::QCD::SU
su2SubGroupIndex	lib/qcd/utils/SUn.h	/^  static void su2SubGroupIndex(int &i1, int &i2, int su2_index) {$/;"	f	class:Grid::QCD::SU
su2subgroups	lib/qcd/utils/SUn.h	/^  static int su2subgroups(void) { return (ncolour * (ncolour - 1)) \/ 2; }$/;"	f	class:Grid::QCD::SU
su3_test_mult_expression	benchmarks/simple_su3_expr.cc	/^void su3_test_mult_expression(LatticeColourMatrix &z, LatticeColourMatrix &x,LatticeColourMatrix &y)$/;"	f
su3_test_mult_routine	benchmarks/simple_su3_test.cc	/^void su3_test_mult_routine(LatticeColourMatrix &z, LatticeColourMatrix &x,LatticeColourMatrix &y)$/;"	f
sub	benchmarks/simple_simd_test.cc	/^Grid::vRealD sub(const Grid::vRealD &x, const Grid::vRealD &y)$/;"	f
sub	lib/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
sub	lib/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix
sub	lib/Eigen/src/Core/ProductEvaluators.h	/^  struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	s	struct:Eigen::internal::generic_product_impl
sub	lib/lattice/Lattice_arith.h	/^    void sub(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
sub	lib/lattice/Lattice_arith.h	/^    void sub(Lattice<obj1> &ret,const Lattice<obj2> &lhs,const obj3 &rhs){$/;"	f	namespace:Grid
sub	lib/lattice/Lattice_arith.h	/^    void sub(Lattice<obj1> &ret,const obj2 &lhs,const Lattice<obj3> &rhs){$/;"	f	namespace:Grid
sub	lib/simd/Grid_vector_types.h	/^  friend inline void sub(Grid_simd *__restrict__ y,$/;"	f	class:Grid::Grid_simd
sub	lib/simd/Simd.h	/^  inline void sub (ComplexD * __restrict__ y,const ComplexD * __restrict__ l,const ComplexD *__restrict__ r){ *y = (*l) - (*r);}$/;"	f	namespace:Grid
sub	lib/simd/Simd.h	/^  inline void sub (ComplexF * __restrict__ y,const ComplexF * __restrict__ l,const ComplexF *__restrict__ r){ *y = (*l) - (*r); }$/;"	f	namespace:Grid
sub	lib/simd/Simd.h	/^  inline void sub (RealD * __restrict__ y,const RealD * __restrict__ l,const RealD *__restrict__ r){ *y = (*l) - (*r);}$/;"	f	namespace:Grid
sub	lib/simd/Simd.h	/^  inline void sub (RealF * __restrict__ y,const RealF * __restrict__ l,const RealF *__restrict__ r){ *y = (*l) - (*r); }$/;"	f	namespace:Grid
sub	lib/tensors/Tensor_arith_sub.h	/^template<class vtype,class ltype,class rtype, int N> strong_inline void sub(iMatrix<vtype,N> * __restrict__ ret,$/;"	f	namespace:Grid
sub	lib/tensors/Tensor_arith_sub.h	/^template<class vtype,class ltype,class rtype,int N> strong_inline void sub(iVector<vtype,N> * __restrict__ ret,$/;"	f	namespace:Grid
sub	lib/tensors/Tensor_arith_sub.h	/^template<class vtype,class ltype,class rtype> strong_inline void sub(iScalar<vtype> * __restrict__ ret,$/;"	f	namespace:Grid
subDiagonal	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization
subTo	lib/Eigen/src/Core/EigenBase.h	/^  inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
subTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
subTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl_base
subTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static inline void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
subTo	lib/Eigen/src/Core/ProductEvaluators.h	/^  static void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
subTo	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
subTo	lib/Eigen/src/SparseCore/SparseProduct.h	/^  static void subTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, typename enable_if<is_same<typename evaluator_traits<Dest>::Shape,DenseShape>::value,int*>::type* = 0)$/;"	f	struct:Eigen::internal::generic_product_impl
subVector	lib/Eigen/src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp
subVectors	lib/Eigen/src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp
sub_assign_op	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar,typename SrcScalar> struct sub_assign_op {$/;"	s	namespace:Eigen::internal
subdiagonalEntryIsNeglegible	lib/Eigen/src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur
subdivides	lib/lattice/Lattice_transfer.h	/^inline void subdivides(GridBase *coarse,GridBase *fine)$/;"	f	namespace:Grid
subs	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
subs	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix
subs	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
subspace	lib/algorithms/CoarsenedMatrix.h	/^    std::vector<Lattice<Fobj> > subspace;$/;"	m	class:Grid::Aggregation
sum	lib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase
sum	lib/Eigen/src/Core/VectorwiseOp.h	/^    const SumReturnType sum() const$/;"	f	class:Eigen::VectorwiseOp
sum	lib/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix
sum	lib/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase
sum	lib/Eigen/src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector
sum	lib/lattice/Lattice_reduction.h	/^inline typename vobj::scalar_object sum(const Lattice<vobj> &arg)$/;"	f	namespace:Grid
sumPlaquette	extras/qed-fvol/WilsonLoops.h	/^  static Real sumPlaquette(const GaugeLorentz &Umu) {$/;"	f	class:NewWilsonLoops
sumPlaquette	lib/qcd/utils/WilsonLoops.h	/^  static RealD sumPlaquette(const GaugeLorentz &Umu) {$/;"	f	class:Grid::QCD::WilsonLoops
sumRectangle	lib/qcd/utils/WilsonLoops.h	/^  static RealD sumRectangle(const GaugeLorentz &Umu) {$/;"	f	class:Grid::QCD::WilsonLoops
sumSpatialWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static Real sumSpatialWilsonLoop(const GaugeLorentz &Umu,$/;"	f	class:NewWilsonLoops
sumTimelikeWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static Real sumTimelikeWilsonLoop(const GaugeLorentz &Umu,$/;"	f	class:NewWilsonLoops
sumWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static Real sumWilsonLoop(const GaugeLorentz &Umu,$/;"	f	class:NewWilsonLoops
sumphider	lib/qcd/utils/ScalarObjs.h	/^  static RealD sumphider(const typename Impl::Field &f) {$/;"	f	class:Grid::ScalarObs
sumphifourth	lib/qcd/utils/ScalarObjs.h	/^  static RealD sumphifourth(const typename Impl::Field &f) {$/;"	f	class:Grid::ScalarObs
sumphisquared	lib/qcd/utils/ScalarObjs.h	/^  static RealD sumphisquared(const typename Impl::Field &f) {$/;"	f	class:Grid::ScalarObs
sumupDuplicates	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void sumupDuplicates() { collapseDuplicates(internal::scalar_sum_op<Scalar,Scalar>()); }$/;"	f	class:Eigen::SparseMatrix
supIndex	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index supIndex() const { return m_supno; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
supToCol	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* supToCol() { return m_sup_to_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
supToCol	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* supToCol() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
super	lib/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
super	lib/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix
supers	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase
supers	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix
supers	lib/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
supno	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector supno; \/\/ Supernode number corresponding to this column (column to supernode mapping)$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
surface_list	lib/qcd/action/fermion/WilsonCompressor.h	/^  std::vector<int> surface_list;$/;"	m	class:Grid::QCD::WilsonStencil
svd_precondition_2x2_block_to_be_real	lib/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	lib/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	lib/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
swap	lib/Eigen/src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
swap	lib/Eigen/src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
swap	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage
swap	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage
swap	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage
swap	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage
swap	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
swap	lib/Eigen/src/Core/PlainObjectBase.h	/^    void swap(DenseBase<OtherDerived> & other)$/;"	f	class:Eigen::PlainObjectBase
swap	lib/Eigen/src/Core/PlainObjectBase.h	/^    void swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase
swap	lib/Eigen/src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularViewImpl
swap	lib/Eigen/src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> &other)$/;"	f	class:Eigen::TriangularViewImpl
swap	lib/Eigen/src/Core/util/Memory.h	/^template<typename T> void swap(scoped_array<T> &a,scoped_array<T> &b)$/;"	f	namespace:Eigen::internal
swap	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> EIGEN_DEVICE_FUNC   void swap(T &a, T &b) { T tmp = b; b = a; a = tmp; }$/;"	f	namespace:numext
swap	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
swap	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
swap	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseMatrix<Scalar,OtherOptions,StorageIndex>& other)$/;"	f	class:Eigen::SparseVector
swap	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector
swap	lib/json/json.hpp	/^    void swap(array_t& other)$/;"	f	class:nlohmann::basic_json
swap	lib/json/json.hpp	/^    void swap(object_t& other)$/;"	f	class:nlohmann::basic_json
swap	lib/json/json.hpp	/^    void swap(string_t& other)$/;"	f	class:nlohmann::basic_json
swap	lib/pugixml/pugixml.cc	/^	template <typename T> void swap(T& lhs, T& rhs)$/;"	f
swap_assign_op	lib/Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename Scalar> struct swap_assign_op {$/;"	s	namespace:Eigen::internal
switcheroo	lib/qcd/action/fermion/CayleyFermion5D.h	/^     template<> struct switcheroo<ComplexD> {  $/;"	s	namespace:Grid::QCD
switcheroo	lib/qcd/action/fermion/CayleyFermion5D.h	/^     template<> struct switcheroo<ComplexF> {  $/;"	s	namespace:Grid::QCD
switcheroo	lib/qcd/action/fermion/CayleyFermion5D.h	/^     template<typename T> struct switcheroo   {  $/;"	s	namespace:Grid::QCD
symm_pack_lhs	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
symm_pack_rhs	lib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
sync	lib/Eigen/src/Core/products/Parallelizer.h	/^  Index volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo
tRotate	lib/simd/Grid_avx.h	/^    static inline __m256 tRotate(__m256 in){$/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_avx.h	/^    static inline __m256d tRotate(__m256d in){$/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_avx512.h	/^    template<int n> static inline __m512 tRotate(__m512 in){ $/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_avx512.h	/^    template<int n> static inline __m512d tRotate(__m512d in){ $/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_generic.h	/^    template <int n, typename T> static inline vec<T> tRotate(vec<T> in){$/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_imci.h	/^    template<int n> static inline __m512 tRotate(__m512 in){ $/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_imci.h	/^    template<int n> static inline __m512d tRotate(__m512d in){ $/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_neon.h	/^    template<int n> static inline float32x4_t tRotate(float32x4_t in){ return vextq_f32(in,in,n%4); };$/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_neon.h	/^    template<int n> static inline float64x2_t tRotate(float64x2_t in){ return vextq_f64(in,in,n%2); };$/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_qpx.h	/^    template<int n> static inline vector4double tRotate(vector4double v){ $/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_qpx.h	/^    template<int n> static inline vector4float tRotate(vector4float a)	$/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_sse4.h	/^    template<int n> static inline __m128  tRotate(__m128  in){ return (__m128)_my_alignr_epi32((__m128i)in,(__m128i)in,n); };$/;"	f	struct:Grid::Optimization::Rotate
tRotate	lib/simd/Grid_sse4.h	/^    template<int n> static inline __m128d tRotate(__m128d in){ return (__m128d)_my_alignr_epi64((__m128i)in,(__m128i)in,n); };$/;"	f	struct:Grid::Optimization::Rotate
t_P	lib/qcd/hmc/integrators/Integrator.h	/^  std::vector<double> t_P;  $/;"	m	class:Grid::QCD::Integrator
t_U	lib/qcd/hmc/integrators/Integrator.h	/^  double t_U;  \/\/ Track time passing on each level and for U and for P$/;"	m	class:Grid::QCD::Integrator
taExp	lib/qcd/utils/SUn.h	/^  static void taExp(const LatticeMatrixType &x, LatticeMatrixType &ex) {$/;"	f	class:Grid::QCD::SU
taProj	lib/qcd/utils/SUn.h	/^  static void taProj( const LatticeMatrixType &in,  LatticeMatrixType &out){$/;"	f	class:Grid::QCD::SU
table	lib/pugixml/pugixml.cc	/^			const unsigned char* table;$/;"	m	union:xpath_ast_node::__anon686	file:
tag	lib/communicator/Communicator_mpi3_leader.cc	/^  int tag;$/;"	m	struct:Grid::Descriptor	file:
tail	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType tail(Index n) const$/;"	f
tail	lib/Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType tail(Index n)$/;"	f
tail	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type tail(Index n = N) const$/;"	f
tail	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type tail(Index n = N)$/;"	f
tail	lib/communicator/Communicator_mpi3_leader.cc	/^  volatile int tail;$/;"	m	class:Grid::SlaveState	file:
take_affine_part	lib/Eigen/src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform
take_matrix_for_product	lib/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
take_matrix_for_product	lib/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
take_matrix_for_product	lib/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
tan	lib/Eigen/src/Core/MathFunctions.h	/^T tan(const T &x) {$/;"	f	namespace:Eigen::numext
tan	lib/Eigen/src/Core/MathFunctions.h	/^double tan(const double &x) { return ::tan(x); }$/;"	f	namespace:Eigen::numext
tan	lib/Eigen/src/Core/MathFunctions.h	/^float tan(const float &x) { return ::tanf(x); }$/;"	f	namespace:Eigen::numext
tan	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half tan(const half& a) {$/;"	f	namespace:Eigen::half_impl
tan	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^tan() const$/;"	f
tanh	lib/Eigen/src/Core/MathFunctions.h	/^T tanh(const T &x) {$/;"	f	namespace:Eigen::numext
tanh	lib/Eigen/src/Core/MathFunctions.h	/^double tanh(const double &x) { return ::tanh(x); }$/;"	f	namespace:Eigen::numext
tanh	lib/Eigen/src/Core/MathFunctions.h	/^float tanh(const float &x) { return ::tanhf(x); }$/;"	f	namespace:Eigen::numext
tanh	lib/Eigen/src/Core/MathFunctions.h	/^float tanh(float x) { return internal::generic_fast_tanh_float(x); }$/;"	f	namespace:Eigen::numext
tanh	lib/Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half tanh(const half& a) {$/;"	f	namespace:Eigen::half_impl
tanh	lib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^tanh() const$/;"	f
tau	lib/qcd/smearing/WilsonFlow.h	/^    RealD tau(unsigned int t)const {return epsilon*(t+1.0); }$/;"	f	class:Grid::QCD::WilsonFlow
taus	lib/qcd/smearing/WilsonFlow.h	/^    mutable RealD epsilon, taus;$/;"	m	class:Grid::QCD::WilsonFlow
tcycles	lib/perfmon/Stat.h	/^    uint64_t tcycles;   \/\/ total cycles inside parallel region$/;"	m	class:Grid::PmuStat
temp	lib/pugixml/pugixml.cc	/^		xpath_allocator temp;$/;"	m	struct:xpath_stack_data	file:
temp	lib/pugixml/pugixml.cc	/^		xpath_allocator* temp;$/;"	m	struct:xpath_stack	file:
tend	lib/perfmon/Stat.h	/^    uint64_t tend;      \/\/ tsc at end of parallel region$/;"	m	class:Grid::PmuStat
tensor_reduced	lib/tensors/Tensor_class.h	/^  typedef iScalar<tensor_reduced_v> tensor_reduced;$/;"	t	class:Grid::iMatrix
tensor_reduced	lib/tensors/Tensor_class.h	/^  typedef iScalar<tensor_reduced_v> tensor_reduced;$/;"	t	class:Grid::iScalar
tensor_reduced	lib/tensors/Tensor_class.h	/^  typedef iScalar<tensor_reduced_v> tensor_reduced;$/;"	t	class:Grid::iVector
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef ComplexD tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef ComplexF tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef Integer tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef RealD tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef RealF tensor_reduced ;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef typename T::tensor_reduced tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef vComplexD tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef vComplexF tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef vComplexH tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef vInteger tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef vRealD tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced	lib/tensors/Tensor_traits.h	/^    typedef vRealF tensor_reduced;$/;"	t	class:Grid::GridTypeMapper
tensor_reduced_v	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::tensor_reduced tensor_reduced_v;$/;"	t	class:Grid::iMatrix
tensor_reduced_v	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::tensor_reduced tensor_reduced_v;$/;"	t	class:Grid::iScalar
tensor_reduced_v	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::tensor_reduced tensor_reduced_v;$/;"	t	class:Grid::iVector
ternary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit ternary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::ternary_evaluator
ternary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct ternary_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3>, IndexBased, IndexBased>$/;"	s	namespace:Eigen::internal
ternary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	s	namespace:Eigen::internal
ternary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
ternary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
test	tests/core/Test_gamma.cc	/^void test(const Expr &a, const Expr &b)$/;"	f
testAlgebra	tests/core/Test_gamma.cc	/^static std::array<SpinMatrix, Gamma::nGamma> testAlgebra;$/;"	v	file:
testGenerators	lib/qcd/utils/SUn.h	/^  static void testGenerators(void) {$/;"	f	class:Grid::QCD::SU
testGenerators	lib/qcd/utils/SUnAdjoint.h	/^  static void testGenerators(void) {$/;"	f	class:Grid::QCD::SU_Adjoint
testGenerators	lib/qcd/utils/SUnTwoIndex.h	/^  static void testGenerators(void) {$/;"	f	class:Grid::QCD::SU_TwoIndex
testme	lib/simd/BGQQPX.h	/^void testme(int osites,int ssU)$/;"	f
text	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text xml_node::text() const$/;"	f	class:pugi::xml_node
text_output	lib/pugixml/pugixml.cc	/^	PUGI__FN void text_output(xml_buffered_writer& writer, const char_t* s, chartypex_t type, unsigned int flags)$/;"	f
text_output_cdata	lib/pugixml/pugixml.cc	/^	PUGI__FN void text_output_cdata(xml_buffered_writer& writer, const char_t* s)$/;"	f
text_output_escaped	lib/pugixml/pugixml.cc	/^	PUGI__FN void text_output_escaped(xml_buffered_writer& writer, const char_t* s, chartypex_t type)$/;"	f
text_output_indent	lib/pugixml/pugixml.cc	/^	PUGI__FN void text_output_indent(xml_buffered_writer& writer, const char_t* indent, size_t indent_length, unsigned int depth)$/;"	f
thenMatrix	lib/Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select
theta	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  const RealD theta = 0.0;$/;"	m	class:Grid::QCD::ForceGradient
thickness	lib/Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType thickness ; \/* number of original columns represented by this *\/$/;"	m	union:internal::colamd_col::__anon623
threshold	lib/Eigen/src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU
threshold	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR
threshold	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  RealScalar threshold() const { return m_cpqr.threshold(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
threshold	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR
threshold	lib/Eigen/src/SVD/SVDBase.h	/^  RealScalar threshold() const$/;"	f	class:Eigen::SVDBase
throw_error	lib/pugixml/pugixml.cc	/^		void throw_error(const char* message)$/;"	f	struct:xpath_parser
throw_error_oom	lib/pugixml/pugixml.cc	/^		void throw_error_oom()$/;"	f	struct:xpath_parser
throw_std_bad_alloc	lib/Eigen/src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal
time_statistics	benchmarks/Benchmark_comms.cc	/^struct time_statistics{$/;"	s	file:
timesI	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> timesI(const Grid_simd<S, V> &in) {$/;"	f	namespace:Grid
timesI	lib/simd/Grid_vector_types.h	/^inline void timesI(Grid_simd<S, V> &ret, const Grid_simd<S, V> &in) {$/;"	f	namespace:Grid
timesI	lib/simd/Simd.h	/^  inline ComplexD timesI(const ComplexD &r)     { return(r*ComplexD(0.0,1.0));}$/;"	f	namespace:Grid
timesI	lib/simd/Simd.h	/^  inline ComplexF timesI(const ComplexF &r)     { return(r*ComplexF(0.0,1.0));}$/;"	f	namespace:Grid
timesI	lib/simd/Simd.h	/^  inline void timesI(ComplexD &ret,const ComplexD &r)     { ret = timesI(r);}$/;"	f	namespace:Grid
timesI	lib/simd/Simd.h	/^  inline void timesI(ComplexF &ret,const ComplexF &r)     { ret = timesI(r);}$/;"	f	namespace:Grid
timesI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iMatrix<vtype,N> timesI(const iMatrix<vtype,N>&r)$/;"	f	namespace:Grid
timesI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iVector<vtype,N> timesI(const iVector<vtype,N>&r) $/;"	f	namespace:Grid
timesI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline void  timesI(iMatrix<vtype,N> &ret,const iMatrix<vtype,N>&r)$/;"	f	namespace:Grid
timesI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline void timesI(iVector<vtype,N> &ret,const iVector<vtype,N>&r) $/;"	f	namespace:Grid
timesI	lib/tensors/Tensor_reality.h	/^template<class vtype> inline iScalar<vtype> timesI(const iScalar<vtype>&r) $/;"	f	namespace:Grid
timesI	lib/tensors/Tensor_reality.h	/^template<class vtype> inline void timesI(iScalar<vtype> &ret,const iScalar<vtype>&r) $/;"	f	namespace:Grid
timesMinusI	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> timesMinusI(const Grid_simd<S, V> &in) {$/;"	f	namespace:Grid
timesMinusI	lib/simd/Grid_vector_types.h	/^inline void timesMinusI(Grid_simd<S, V> &ret, const Grid_simd<S, V> &in) {$/;"	f	namespace:Grid
timesMinusI	lib/simd/Simd.h	/^  inline ComplexD timesMinusI(const ComplexD &r){ return(r*ComplexD(0.0,-1.0));}$/;"	f	namespace:Grid
timesMinusI	lib/simd/Simd.h	/^  inline ComplexF timesMinusI(const ComplexF &r){ return(r*ComplexF(0.0,-1.0));}$/;"	f	namespace:Grid
timesMinusI	lib/simd/Simd.h	/^  inline void timesMinusI(ComplexD &ret,const ComplexD &r){ ret = timesMinusI(r);}$/;"	f	namespace:Grid
timesMinusI	lib/simd/Simd.h	/^  inline void timesMinusI(ComplexF &ret,const ComplexF &r){ ret = timesMinusI(r);}$/;"	f	namespace:Grid
timesMinusI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iMatrix<vtype,N> timesMinusI(const iMatrix<vtype,N>&r)$/;"	f	namespace:Grid
timesMinusI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline iVector<vtype,N> timesMinusI(const iVector<vtype,N>&r) $/;"	f	namespace:Grid
timesMinusI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline void  timesMinusI(iMatrix<vtype,N> &ret,const iMatrix<vtype,N>&r)$/;"	f	namespace:Grid
timesMinusI	lib/tensors/Tensor_reality.h	/^template<class vtype,int N> inline void timesMinusI(iVector<vtype,N> &ret,const iVector<vtype,N>&r) $/;"	f	namespace:Grid
timesMinusI	lib/tensors/Tensor_reality.h	/^template<class vtype>  inline void timesMinusI(iScalar<vtype> &ret,const iScalar<vtype>&r) $/;"	f	namespace:Grid
timesMinusI	lib/tensors/Tensor_reality.h	/^template<class vtype> inline iScalar<vtype> timesMinusI(const iScalar<vtype>&r) $/;"	f	namespace:Grid
timesi	lib/simd/Grid_generic.h	261;"	d
timesi	lib/simd/Grid_generic.h	280;"	d
timesmi	lib/simd/Grid_generic.h	240;"	d
timesmi	lib/simd/Grid_generic.h	259;"	d
timestamp	lib/log/Log.cc	/^int Logger::timestamp;$/;"	m	class:Grid::Logger	file:
timestamp	lib/log/Log.h	/^  static int timestamp;$/;"	m	class:Grid::Logger
tmp	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  FermionField &tmp(void) { return _tmp; }$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion
tmp	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^      FermionField &tmp(void) { return _tmp; }$/;"	f	class:Grid::QCD::ImprovedStaggeredFermion5D
tmp	lib/qcd/action/fermion/WilsonFermion.h	/^  FermionField &tmp(void) { return _tmp; }$/;"	f	class:Grid::QCD::WilsonFermion
tmp	lib/qcd/action/fermion/WilsonFermion5D.h	/^     FermionField &tmp(void) { return _tmp; }$/;"	f	class:Grid::QCD::WilsonFermion5D
toComplex	lib/simd/Grid_vector_types.h	/^inline Grid_simd<std::complex<R>, V> toComplex(const Grid_simd<R, V> &in) {$/;"	f	namespace:Grid
toDense	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    DenseMatrixType toDense() const$/;"	f	class:Eigen::SparseMatrixBase
toDenseMatrix	lib/Eigen/src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase
toDenseMatrix	lib/Eigen/src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase
toDenseMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::InverseImpl
toDenseMatrix	lib/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase
toDenseMatrix	lib/Eigen/src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase
toQMatrix	lib/Eigen/src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform
toQTransform	lib/Eigen/src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform
toReal	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> toReal(const Grid_simd<std::complex<S>, V> &in) {$/;"	f	namespace:Grid
toReal	lib/simd/Simd.h	/^  inline RealD toReal(const ComplexD& r){ return real(r); }$/;"	f	namespace:Grid
toReal	lib/simd/Simd.h	/^  inline RealD toReal(const RealD& r){ return r; }$/;"	f	namespace:Grid
toReal	lib/simd/Simd.h	/^  inline RealF toReal(const ComplexF& r){ return real(r); }$/;"	f	namespace:Grid
toReal	lib/simd/Simd.h	/^  inline RealF toReal(const RealF& r){ return r; }$/;"	f	namespace:Grid
toRotationMatrix	lib/Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis
toRotationMatrix	lib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase
toRotationMatrix	lib/Eigen/src/Geometry/Rotation2D.h	/^EIGEN_DEVICE_FUNC Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D
toRotationMatrix	lib/Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
toRotationMatrix	lib/Eigen/src/Geometry/RotationBase.h	/^EIGEN_DEVICE_FUNC static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal
toRotationMatrix	lib/Eigen/src/Geometry/RotationBase.h	/^EIGEN_DEVICE_FUNC static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal
toRotationMatrix	lib/Eigen/src/Geometry/RotationBase.h	/^EIGEN_DEVICE_FUNC static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal
to_rank	lib/stencil/Stencil.h	/^    Integer to_rank;$/;"	m	struct:Grid::CartesianStencil::Packet
to_unicode	lib/json/json.hpp	/^        static string_t to_unicode(const std::size_t codepoint1,$/;"	f	class:nlohmann::basic_json::lexer
toint	tests/core/Test_checker.cc	/^int toint(const char* str){$/;"	f
token_type	lib/json/json.hpp	/^        enum class token_type$/;"	c	class:nlohmann::basic_json::lexer
token_type_name	lib/json/json.hpp	/^        static std::string token_type_name(const token_type t)$/;"	f	class:nlohmann::basic_json::lexer
tolerance	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase
tolerance	lib/algorithms/approx/Remez.h	/^  bigfloat delta, spread, tolerance;$/;"	m	class:AlgRemez
tolerance	tests/core/Test_gamma.cc	/^static constexpr double                      tolerance = 1.0e-6;$/;"	v	file:
tolerances	lib/algorithms/approx/MultiShiftFunction.h	/^  std::vector<RealD> tolerances;$/;"	m	class:Grid::MultiShiftFunction
tolower_ascii	lib/pugixml/pugixml.cc	/^	PUGI__FN char_t tolower_ascii(char_t ch)$/;"	f
top	lib/json/json.hpp	/^        json_pointer top() const$/;"	f	class:nlohmann::basic_json::json_pointer
topLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr topLeftCorner(Index cRows, Index cCols)$/;"	f
topLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr topLeftCorner(Index cRows, Index cCols) const$/;"	f
topLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topLeftCorner() const$/;"	f
topLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topLeftCorner(Index cRows, Index cCols) const$/;"	f
topLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topLeftCorner()$/;"	f
topLeftCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topLeftCorner(Index cRows, Index cCols)$/;"	f
topName	lib/log/Log.h	/^  std::string name, topName;$/;"	m	class:Grid::Logger
topRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr topRightCorner(Index cRows, Index cCols)$/;"	f
topRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr topRightCorner(Index cRows, Index cCols) const$/;"	f
topRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topRightCorner() const$/;"	f
topRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topRightCorner(Index cRows, Index cCols) const$/;"	f
topRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topRightCorner()$/;"	f
topRightCorner	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topRightCorner(Index cRows, Index cCols)$/;"	f
topRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr topRows(Index n) const$/;"	f
topRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr topRows(Index n)$/;"	f
topRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type topRows(Index n = N) const$/;"	f
topRows	lib/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type topRows(Index n = N)$/;"	f
topoSort	extras/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::topoSort(Gen &gen)$/;"	f	class:Graph
topoSort	extras/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::topoSort(void)$/;"	f	class:Graph
topoSort	lib/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::topoSort(Gen &gen)$/;"	f	class:Graph
topoSort	lib/Hadrons/Graph.hpp	/^std::vector<T> Graph<T>::topoSort(void)$/;"	f	class:Graph
trace	lib/Eigen/src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase
trace	lib/simd/Grid_vector_types.h	/^inline Grid_simd<S, V> trace(const Grid_simd<S, V> &arg) {$/;"	f	namespace:Grid
trace	lib/tensors/Tensor_trace.h	/^inline ComplexD trace( const ComplexD &arg){    return arg;}$/;"	f	namespace:Grid
trace	lib/tensors/Tensor_trace.h	/^inline ComplexF trace( const ComplexF &arg){    return arg;}$/;"	f	namespace:Grid
trace	lib/tensors/Tensor_trace.h	/^inline RealD trace( const RealD &arg){    return arg;}$/;"	f	namespace:Grid
trace	lib/tensors/Tensor_trace.h	/^inline RealF trace( const RealF &arg){    return arg;}$/;"	f	namespace:Grid
traceDirPlaquette	extras/qed-fvol/WilsonLoops.h	/^  static void traceDirPlaquette(LatticeComplex &plaq,$/;"	f	class:NewWilsonLoops
traceDirPlaquette	lib/qcd/utils/WilsonLoops.h	/^  static void traceDirPlaquette(ComplexField &plaq,$/;"	f	class:Grid::QCD::WilsonLoops
traceDirRectangle	lib/qcd/utils/WilsonLoops.h	/^  static void traceDirRectangle(ComplexField &rect,$/;"	f	class:Grid::QCD::WilsonLoops
traceIndex	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline auto traceIndex (const vtype &arg) -> RemoveCRV(TensorIndexRecursion<Level>::traceIndex(arg))$/;"	f	namespace:Grid
traceWilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static void traceWilsonLoop(LatticeComplex &wl,$/;"	f	class:NewWilsonLoops
traits	lib/Eigen/src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel> > : traits<XprType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/CoreEvaluators.h	/^struct traits<EvalToTemp<ArgType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/CwiseTernaryOp.h	/^struct traits<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> > {$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Inverse.h	/^struct traits<Inverse<XprType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Product.h	/^struct traits<Product<Lhs, Rhs, Option> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Ref.h	/^struct traits<Ref<_PlainObjectType, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Ref.h	/^struct traits<RefBase<Derived> > : public traits<Derived> {};$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Solve.h	/^struct traits<Solve<Decomposition, RhsType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : public traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Transpositions.h	/^struct traits<Transpose<TranspositionsBase<Derived> > >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Geometry/Transform.h	/^struct traits<Transform<_Scalar,_Dim,_Mode,_Options> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^struct traits<LeastSquaresConjugateGradient<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^struct traits<SolveWithGuess<Decomposition, RhsType, GuessType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> struct traits<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> struct traits<PartialPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> struct traits<ColPivHouseholderQR<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^struct traits<CompleteOrthogonalDecomposition<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> struct traits<FullPivHouseholderQR<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType, typename Derived> struct traits<SPQR_QProduct<SPQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQTransposeReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SVD/BDCSVD.h	/^struct traits<BDCSVD<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SVD/JacobiSVD.h	/^struct traits<JacobiSVD<_MatrixType,QRPreconditioner> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo, typename _Ordering> struct traits<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _StorageIndex> > : traits<SparseMatrix<_Scalar, _Flags, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^struct traits<SparseCompressedBase<Derived> > : traits<Derived>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseMap.h	/^struct traits<Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseMap.h	/^struct traits<Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<SparseMatrix<_Scalar, _Options, _StorageIndex>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _StorageIndex>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<SparseVector<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseRef.h	/^struct traits<SparseRefBase<Derived> > : public traits<Derived> {};$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,Mode> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,Mode> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType, typename Derived> struct traits<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQTransposeReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	lib/Eigen/src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traj_	extras/Hadrons/Environment.hpp	/^    unsigned int                           traj_, locVol_;$/;"	m	class:Environment
traj_	lib/Hadrons/Environment.hpp	/^    unsigned int                           traj_, locVol_;$/;"	m	class:Environment
trans	lib/Eigen/src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence
transform	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane
transform	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane
transform_construct_from_matrix	lib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	lib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	lib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	lib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_make_affine	lib/Eigen/src/Geometry/Transform.h	/^struct transform_make_affine$/;"	s	namespace:Eigen::internal
transform_make_affine	lib/Eigen/src/Geometry/Transform.h	/^struct transform_make_affine<AffineCompact>$/;"	s	namespace:Eigen::internal
transform_product_result	lib/Eigen/src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
transform_right_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0, RhsCols>$/;"	s	namespace:Eigen::internal
transform_right_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1, RhsCols>$/;"	s	namespace:Eigen::internal
transform_right_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2, 1> \/\/ rhs is a vector of size Dim$/;"	s	namespace:Eigen::internal
transform_right_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2, RhsCols>$/;"	s	namespace:Eigen::internal
transform_take_affine_part	lib/Eigen/src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
transform_take_affine_part	lib/Eigen/src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
transform_traits	lib/Eigen/src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	lib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
translate	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox
translate	lib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
translate	lib/pugixml/pugixml.cc	/^	PUGI__FN char_t* translate(char_t* buffer, const char_t* from, const char_t* to, size_t to_length)$/;"	f
translate_table	lib/pugixml/pugixml.cc	/^	PUGI__FN char_t* translate_table(char_t* buffer, const unsigned char* table)$/;"	f
translate_table_generate	lib/pugixml/pugixml.cc	/^	PUGI__FN unsigned char* translate_table_generate(xpath_allocator* alloc, const char_t* from, const char_t* to)$/;"	f
translation	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation
translation	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
translationExt	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform
translationExt	lib/Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform
transpose	lib/Eigen/src/Core/PermutationMatrix.h	/^    inline InverseReturnType transpose() const$/;"	f	class:Eigen::PermutationBase
transpose	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline TransposeReturnType transpose()$/;"	f	class:Eigen::SelfAdjointView
transpose	lib/Eigen/src/Core/SelfAdjointView.h	/^    inline const ConstTransposeReturnType transpose() const$/;"	f	class:Eigen::SelfAdjointView
transpose	lib/Eigen/src/Core/SolverBase.h	/^    inline ConstTransposeReturnType transpose() const$/;"	f	class:Eigen::SolverBase
transpose	lib/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase
transpose	lib/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase
transpose	lib/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase
transpose	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline TransposeReturnType transpose()$/;"	f	class:Eigen::TriangularView
transpose	lib/Eigen/src/Core/TriangularMatrix.h	/^    inline const ConstTransposeReturnType transpose() const$/;"	f	class:Eigen::TriangularView
transpose	lib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence
transpose	lib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation
transpose	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> transpose() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType
transpose	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    TransposeReturnType transpose() { return TransposeReturnType(derived()); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const ConstTransposeReturnType transpose() const { return ConstTransposeReturnType(derived()); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	lib/Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> transpose() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
transpose	lib/lattice/Lattice_transpose.h	/^    inline Lattice<vobj> transpose(const Lattice<vobj> &lhs){$/;"	f	namespace:Grid
transpose	lib/tensors/Tensor_transpose.h	/^  transpose(iMatrix<vtype,N> arg)$/;"	f	namespace:Grid
transpose	lib/tensors/Tensor_transpose.h	/^  transpose(iScalar<vtype> arg)$/;"	f	namespace:Grid
transpose	lib/tensors/Tensor_transpose.h	/^inline ComplexD transpose(ComplexD &rhs){  return rhs;}$/;"	f	namespace:Grid
transpose	lib/tensors/Tensor_transpose.h	/^inline ComplexF transpose(ComplexF &rhs){  return rhs;}$/;"	f	namespace:Grid
transpose	lib/tensors/Tensor_transpose.h	/^inline RealD transpose(RealD &rhs){  return rhs;}$/;"	f	namespace:Grid
transpose	lib/tensors/Tensor_transpose.h	/^inline RealF transpose(RealF &rhs){  return rhs;}$/;"	f	namespace:Grid
transposeColour	lib/qcd/QCD.h	/^    template<int Index,class vobj> inline Lattice<vobj> transposeColour(const Lattice<vobj> &lhs){$/;"	f	namespace:Grid::QCD
transposeColour	lib/qcd/QCD.h	/^    template<int Index,class vobj> inline vobj transposeColour(const vobj &lhs){$/;"	f	namespace:Grid::QCD
transposeInPlace	lib/Eigen/src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase
transposeIndex	lib/tensors/Tensor_index.h	/^template<int Level,class vtype> inline auto transposeIndex (const vtype &arg) -> RemoveCRV(TensorIndexRecursion<Level>::transposeIndex(arg))$/;"	f	namespace:Grid
transposeSpin	lib/qcd/QCD.h	/^    template<int Index,class vobj> inline Lattice<vobj> transposeSpin(const Lattice<vobj> &lhs){$/;"	f	namespace:Grid::QCD
transposeSpin	lib/qcd/QCD.h	/^    template<int Index,class vobj> inline vobj transposeSpin(const vobj &lhs){$/;"	f	namespace:Grid::QCD
transposition_matrix_product	lib/Eigen/src/Core/ProductEvaluators.h	/^struct transposition_matrix_product$/;"	s	namespace:Eigen::internal
transpositionsP	lib/Eigen/src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT
traverse	lib/pugixml/pugixml.cc	/^	PUGI__FN bool xml_node::traverse(xml_tree_walker& walker)$/;"	f	class:pugi::xml_node
treePostorder	lib/Eigen/src/SparseCore/SparseColEtree.h	/^void treePostorder(typename IndexVector::Scalar n, IndexVector& parent, IndexVector& post)$/;"	f	namespace:Eigen::internal
tregion	lib/perfmon/Stat.h	/^    uint64_t tregion;   \/\/ total time in parallel region (from thread 0)$/;"	m	class:Grid::PmuStat
triangularView	lib/Eigen/src/Core/SelfAdjointView.h	/^    triangularView() const$/;"	f	class:Eigen::SelfAdjointView
triangularView	lib/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase
triangularView	lib/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase
triangularView	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase
triangular_assignment_loop	lib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_loop$/;"	s	namespace:Eigen::internal
triangular_assignment_loop	lib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_loop<Kernel, Mode, 0, SetOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_loop	lib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_loop<Kernel, Mode, Dynamic, SetOpposite>$/;"	s	namespace:Eigen::internal
triangular_dense_assignment_kernel	lib/Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC triangular_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
triangular_dense_assignment_kernel	lib/Eigen/src/Core/SelfAdjointView.h	/^class triangular_dense_assignment_kernel<UpLo,SelfAdjoint,SetOpposite,DstEvaluatorTypeT,SrcEvaluatorTypeT,Functor,Version>$/;"	c	namespace:Eigen::internal
triangular_dense_assignment_kernel	lib/Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC triangular_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
triangular_dense_assignment_kernel	lib/Eigen/src/Core/TriangularMatrix.h	/^class triangular_dense_assignment_kernel : public generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version>$/;"	c	namespace:Eigen::internal
triangular_matrix_vector_product	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product_trmv	lib/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal
triangular_product_impl	lib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct triangular_product_impl<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen::internal
triangular_product_impl	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_product_impl<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen::internal
triangular_product_impl	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_product_impl<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	lib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_retval	lib/Eigen/src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval
triangular_solve_retval	lib/Eigen/src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal
triangular_solve_vector	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	lib/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	lib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	lib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	lib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	lib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	lib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,false> {$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	lib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,true> {$/;"	s	namespace:Eigen::internal
tribb_kernel	lib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
tridiagonal_qr_step	lib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace_selector	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	lib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
trinary	lib/simd/Grid_vector_types.h	/^Out trinary(Input1 src_1, Input2 src_2, Input3 src_3, Operation op) {$/;"	f	namespace:Grid
trmv_selector	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<int Mode> struct trmv_selector<Mode,ColMajor>$/;"	s	namespace:Eigen::internal
trmv_selector	lib/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<int Mode> struct trmv_selector<Mode,RowMajor>$/;"	s	namespace:Eigen::internal
trsolve_traits	lib/Eigen/src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
true_type	lib/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
truncate	lib/parallelIO/NerscIO.h	/^      static inline void truncate(std::string file){$/;"	f	class:Grid::QCD::NerscIO
truncate	lib/pugixml/pugixml.cc	/^		void truncate(xpath_node* pos)$/;"	f	class:xpath_node_set_raw
truncate	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  void truncate(std::string file) {$/;"	f	class:Grid::QCD::BinaryHmcCheckpointer
truncate_zeros	lib/pugixml/pugixml.cc	/^	PUGI__FN void truncate_zeros(char* begin, char* end)$/;"	f
tstart	lib/perfmon/Stat.h	/^    uint64_t tstart;    \/\/ tsc at start of parallel region$/;"	m	class:Grid::PmuStat
tuple_size	lib/qcd/representations/hmc_types.h	/^  static const int tuple_size = sizeof...(Reptypes);$/;"	m	class:Grid::QCD::Representations
twistedBy	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm) const$/;"	f	class:Eigen::SparseMatrixBase
twistedBy	lib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,Mode> twistedBy(const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView
twists	lib/qcd/action/ActionParams.h	/^    std::vector<int> twists;$/;"	m	struct:Grid::QCD::GparityWilsonImplParams
type	lib/Eigen/src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic
type	lib/Eigen/src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::log1p_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::round_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::arg_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval
type	lib/Eigen/src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	lib/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void
type	lib/Eigen/src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
type	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType
type	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType
type	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType
type	lib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType
type	lib/Eigen/src/Core/Ref.h	/^    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;$/;"	t	struct:Eigen::internal::traits::match
type	lib/Eigen/src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested_eval
type	lib/Eigen/src/Core/SolverBase.h	/^  typedef SolverBase<Derived> type;$/;"	t	struct:Eigen::internal::generic_xpr_base
type	lib/Eigen/src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base
type	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet2cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet4cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet4d type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet8f type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet16f type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8d type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef double type;$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef float type;$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef int type;$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef double2 type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef float4 type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^  typedef half2 type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	lib/Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef bool type;$/;"	t	struct:Eigen::internal::result_of
type	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function
type	lib/Eigen/src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	lib/Eigen/src/Core/util/Meta.h	/^    typedef typename ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	lib/Eigen/src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	lib/Eigen/src/Core/util/Meta.h	/^  typedef typename remove_all<type1>::type type;$/;"	t	struct:Eigen::internal::result_of
type	lib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional
type	lib/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional
type	lib/Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	t	struct:Eigen::internal::ternary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef typename internal::remove_all<ArgType>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const
type	lib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	lib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	lib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const
type	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const
type	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	lib/Eigen/src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if
type	lib/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::ternary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	lib/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1,ArgType2)>::type type;};$/;"	t	struct:Eigen::internal::ternary_result_of_select
type	lib/Eigen/src/Core/util/XprHelper.h	/^  typedef PromotedType type;$/;"	t	struct:Eigen::internal::promote_scalar_arg_unsupported
type	lib/Eigen/src/Core/util/XprHelper.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::promote_scalar_arg
type	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	lib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	lib/Eigen/src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type
type	lib/Eigen/src/LU/PartialPivLU.h	/^  typedef Derived type;$/;"	t	struct:Eigen::internal::enable_if_ref
type	lib/Eigen/src/SparseCore/SparseRef.h	/^    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;$/;"	t	struct:Eigen::internal::traits::match
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _StorageIndex> type;$/;"	t	struct:Eigen::internal::plain_matrix_type
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _StorageIndex> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, ColMajor, _StorageIndex> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, RowMajor, _StorageIndex> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^  typedef SparseMatrixBase<Derived> type;$/;"	t	struct:Eigen::internal::generic_xpr_base
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,SelfAdjointShape> { typedef SparseSelfAdjointShape type;  };$/;"	t	struct:Eigen::internal::glue_shapes
type	lib/Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,TriangularShape > { typedef SparseTriangularShape  type;  };$/;"	t	struct:Eigen::internal::glue_shapes
type	lib/algorithms/approx/Zolotarev.h	/^    type,	      \/* 0: R(0) = 0, 1: R(0) = infinity *\/$/;"	m	struct:Grid::Approx::__anon695
type	lib/lattice/Lattice_ET.h	/^  typedef typename Lattice<T>::vector_object type;$/;"	t	struct:Grid::getVectorType
type	lib/perfmon/PerfCount.h	/^    uint32_t type;$/;"	m	struct:Grid::PerformanceCounter::__anon691
type	lib/pugixml/pugixml.cc	/^		typedef uint16_t type;$/;"	t	struct:wchar_selector	file:
type	lib/pugixml/pugixml.cc	/^		typedef uint32_t type;$/;"	t	struct:wchar_selector	file:
type	lib/pugixml/pugixml.cc	/^		xpath_node_set::type_t type() const$/;"	f	class:xpath_node_set_raw
type	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_type xml_node::type() const$/;"	f	class:pugi::xml_node
type	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::type_t xpath_node_set::type() const$/;"	f	class:pugi::xpath_node_set
type	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_value_type xpath_variable::type() const$/;"	f	class:pugi::xpath_variable
type	lib/serialisation/BaseIO.h	/^    typedef T type;$/;"	t	struct:Grid::element
type	lib/serialisation/BaseIO.h	/^    typedef typename element<T>::type type;$/;"	t	struct:Grid::element
type	lib/serialisation/Hdf5Type.h	/^    static inline const H5NS::DataType & type(void)$/;"	f	class:Grid::Hdf5Type
type	lib/simd/Grid_vector_types.h	/^  typedef T type;$/;"	t	struct:Grid::RealPart
type	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    struct sitmo_enable_if { typedef T type; };$/;"	t	struct:sitmo::sitmo_enable_if
type	lib/stencil/Stencil.h	/^    Integer type;$/;"	m	struct:Grid::CartesianStencil::Merge
type	lib/tensors/Tensor_traits.h	/^    typedef T type;$/;"	t	struct:Grid::getVectorType
type1	lib/Eigen/src/Core/util/Meta.h	/^  typedef typename std::result_of<T>::type type1;$/;"	t	struct:Eigen::internal::result_of
typeIdPt	extras/Hadrons/Global.hpp	/^const std::type_info * typeIdPt(const T &x)$/;"	f
typeIdPt	extras/Hadrons/Global.hpp	/^const std::type_info * typeIdPt(void)$/;"	f
typeIdPt	lib/Hadrons/Global.hpp	/^const std::type_info * typeIdPt(const T &x)$/;"	f
typeIdPt	lib/Hadrons/Global.hpp	/^const std::type_info * typeIdPt(void)$/;"	f
typeName	extras/Hadrons/Global.cc	/^std::string Hadrons::typeName(const std::type_info *info)$/;"	f	class:Hadrons
typeName	extras/Hadrons/Global.hpp	/^std::string typeName(const T &x)$/;"	f
typeName	extras/Hadrons/Global.hpp	/^std::string typeName(void)$/;"	f
typeName	lib/Hadrons/Global.cc	/^std::string Hadrons::typeName(const std::type_info *info)$/;"	f	class:Hadrons
typeName	lib/Hadrons/Global.hpp	/^std::string typeName(const T &x)$/;"	f
typeName	lib/Hadrons/Global.hpp	/^std::string typeName(void)$/;"	f
typePtr_	lib/serialisation/Hdf5Type.h	/^    static std::unique_ptr<H5NS::CompType> typePtr_;$/;"	m	class:Grid::Hdf5Type
typePtr_	lib/serialisation/Hdf5Type.h	/^  std::unique_ptr<H5NS::CompType> Hdf5Type<std::complex<R>>::typePtr_ = nullptr;$/;"	m	class:Grid::Hdf5Type
type_casting_traits	lib/Eigen/src/Core/GenericPacketMath.h	/^template <typename Src, typename Tgt> struct type_casting_traits {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^struct type_casting_traits<float, int> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/AVX/TypeCasting.h	/^struct type_casting_traits<int, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<Eigen::half, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<float, Eigen::half> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<float, half> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<half, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<double, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<float, double> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<float, int> {$/;"	s	namespace:Eigen::internal
type_casting_traits	lib/Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<int, float> {$/;"	s	namespace:Eigen::internal
type_sorted	lib/pugixml/pugixml.h	/^			type_sorted,			\/\/ Sorted by document order (ascending)$/;"	e	enum:pugi::xpath_node_set::type_t
type_sorted_reverse	lib/pugixml/pugixml.h	/^			type_sorted_reverse		\/\/ Sorted by document order (descending)$/;"	e	enum:pugi::xpath_node_set::type_t
type_t	lib/pugixml/pugixml.h	/^		enum type_t$/;"	g	class:pugi::xpath_node_set
type_unsorted	lib/pugixml/pugixml.h	/^			type_unsorted,			\/\/ Not ordered$/;"	e	enum:pugi::xpath_node_set::type_t
u	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  unsigned int u;$/;"	m	union:Eigen::half_impl::FP32
u	lib/simd/Grid_sse4.h	/^    unsigned int u;$/;"	m	union:Grid::Optimization::FP32
u0	lib/qcd/action/fermion/ImprovedStaggeredFermion.h	/^  RealD u0;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion
u0	lib/qcd/action/fermion/ImprovedStaggeredFermion5D.h	/^    RealD u0;$/;"	m	class:Grid::QCD::ImprovedStaggeredFermion5D
u128d	lib/simd/Grid_neon.h	/^  union u128d {$/;"	u	namespace:Grid::Optimization
u128d	lib/simd/Grid_sse4.h	/^  union u128d {$/;"	u	namespace:Grid::Optimization
u128f	lib/simd/Grid_neon.h	/^  union u128f {$/;"	u	namespace:Grid::Optimization
u128f	lib/simd/Grid_sse4.h	/^  union u128f {$/;"	u	namespace:Grid::Optimization
u128h	lib/simd/Grid_neon.h	/^  union u128h {$/;"	u	namespace:Grid::Optimization
u16	tests/IO/Test_serialisation.cc	/^uint16_t u16 = 2;$/;"	v
u256d	lib/simd/Grid_avx.h	/^  union u256d {$/;"	u	namespace:Grid::Optimization
u256f	lib/simd/Grid_avx.h	/^  union u256f {$/;"	u	namespace:Grid::Optimization
u32	tests/IO/Test_serialisation.cc	/^uint32_t u32 = 4;$/;"	v
u512d	lib/simd/Grid_avx512.h	/^  union u512d {$/;"	u	namespace:Grid::Optimization
u512f	lib/simd/Grid_avx512.h	/^  union u512f {$/;"	u	namespace:Grid::Optimization
u64	tests/IO/Test_serialisation.cc	/^uint64_t u64 = 6;$/;"	v
u_comm_offset	lib/stencil/Stencil.h	/^  int u_comm_offset;$/;"	m	class:Grid::CartesianStencil
u_recv_buf_p	lib/stencil/Stencil.h	/^  cobj* u_recv_buf_p;$/;"	m	class:Grid::CartesianStencil
u_send_buf_p	lib/stencil/Stencil.h	/^  cobj* u_send_buf_p;$/;"	m	class:Grid::CartesianStencil
u_simd_recv_buf	lib/stencil/Stencil.h	/^  std::vector<cobj *> u_simd_recv_buf;$/;"	m	class:Grid::CartesianStencil
u_simd_send_buf	lib/stencil/Stencil.h	/^  std::vector<cobj *> u_simd_send_buf;$/;"	m	class:Grid::CartesianStencil
ucol	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  ucol; \/\/ nonzero values of U ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
uconv	lib/simd/Grid_avx.h	/^  union uconv {$/;"	u	namespace:Grid::Optimization
uconv	lib/simd/Grid_neon.h	/^  union uconv {$/;"	u	namespace:Grid::Optimization
uconv	lib/simd/Grid_sse4.h	/^  union uconv {$/;"	u	namespace:Grid::Optimization
uee	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> uee;    $/;"	m	class:Grid::QCD::CayleyFermion5D
ueem	lib/qcd/action/fermion/CayleyFermion5D.h	/^      std::vector<Coeff_t> ueem;    $/;"	m	class:Grid::QCD::CayleyFermion5D
ui	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  uint32_t ui[4];$/;"	m	union:Eigen::internal::__anon308
uid	tests/testu01/Test_smallcrush.cc	/^std::uniform_int_distribution<uint32_t> uid;$/;"	v
uint32_t	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    typedef unsigned __int32 uint32_t;$/;"	t
uint64_t	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    typedef unsigned __int64 uint64_t;  \/\/ Visual Studio 6.0(VC6) and newer..$/;"	t
ul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  uint64_t ul[2];$/;"	m	union:Eigen::internal::__anon308
umeyama	lib/Eigen/src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen
umeyama_transform_matrix_type	lib/Eigen/src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
umfpackControl	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline UmfpackControl& umfpackControl()$/;"	f	class:Eigen::UmfPackLU
umfpackControl	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const UmfpackControl& umfpackControl() const$/;"	f	class:Eigen::UmfPackLU
umfpackFactorizeReturncode	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline int umfpackFactorizeReturncode() const$/;"	f	class:Eigen::UmfPackLU
umfpack_defaults	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_defaults(double control[UMFPACK_CONTROL], double) $/;"	f	namespace:Eigen
umfpack_defaults	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_defaults(double control[UMFPACK_CONTROL], std::complex<double>) $/;"	f	namespace:Eigen
umfpack_free_numeric	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen
umfpack_free_numeric	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_free_symbolic	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen
umfpack_free_symbolic	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_determinant	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_determinant	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_lunz	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen
umfpack_get_lunz	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_numeric	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen
umfpack_get_numeric	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen
umfpack_numeric	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_numeric	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_solve	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_solve	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_symbolic	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen
unaligned_dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct unaligned_dense_assignment_loop$/;"	s	namespace:Eigen::internal
unaligned_dense_assignment_loop	lib/Eigen/src/Core/AssignEvaluator.h	/^struct unaligned_dense_assignment_loop<false>$/;"	s	namespace:Eigen::internal
unary	lib/simd/Grid_vector_types.h	/^Out unary(Input src, Operation op) {$/;"	f	namespace:Grid
unaryExpr	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const$/;"	f
unaryViewExpr	lib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const$/;"	f
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& block)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& replicate)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& reverse)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& wrapper)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^  explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<ArrayWrapper<TArgType> >$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<CwiseUnaryOp<UnaryOp, ArgType>, IndexBased >$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<CwiseUnaryView<UnaryOp, ArgType>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<MatrixWrapper<TArgType> >$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Replicate<ArgType, RowFactor, ColFactor> >$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Reverse<ArgType, Direction> >$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Transpose<ArgType>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/Inverse.h	/^  unary_evaluator(const InverseType& inv_xpr)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/Inverse.h	/^struct unary_evaluator<Inverse<ArgType> >$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Core/TriangularMatrix.h	/^  unary_evaluator(const XprType &xpr) : Base(xpr.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Core/TriangularMatrix.h	/^struct unary_evaluator<TriangularView<MatrixType,Mode>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/Geometry/Homogeneous.h	/^struct unary_evaluator<Homogeneous<ArgType,Direction>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseBlock.h	/^    explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/SparseCore/SparseBlock.h	/^  explicit unary_evaluator(const XprType &xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/SparseCore/SparseBlock.h	/^struct unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased >$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseBlock.h	/^struct unary_evaluator<Block<SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseBlock.h	/^struct unary_evaluator<Block<const SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    explicit unary_evaluator(const XprType& op) : m_functor(op.functor()), m_argImpl(op.nestedExpression())$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^struct unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^struct unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseProduct.h	/^  explicit unary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/SparseCore/SparseProduct.h	/^struct unary_evaluator<SparseView<Product<Lhs, Rhs, Options> >, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    explicit unary_evaluator(const XprType& op) :m_argImpl(op.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/SparseCore/SparseTranspose.h	/^struct unary_evaluator<Transpose<ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^  explicit unary_evaluator(const XprType &xpr) : m_argImpl(xpr.nestedExpression()), m_arg(xpr.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^struct unary_evaluator<TriangularView<ArgType,Mode>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseView.h	/^    explicit unary_evaluator(const XprType& xpr) : m_argImpl(xpr.nestedExpression()), m_view(xpr) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	lib/Eigen/src/SparseCore/SparseView.h	/^struct unary_evaluator<SparseView<ArgType>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	lib/Eigen/src/SparseCore/SparseView.h	/^struct unary_evaluator<SparseView<ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef typename internal::remove_all<ArgType>::type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	lib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
unblocked	lib/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	lib/Eigen/src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	lib/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked	lib/Eigen/src/Cholesky/LLT.h	/^  static Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked_lu	lib/Eigen/src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl
uncompress	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    void uncompress()$/;"	f	class:Eigen::SparseMatrix
unescape	lib/json/json.hpp	/^        static void unescape(std::string& s)$/;"	f	class:nlohmann::basic_json::json_pointer
unexpect	lib/json/json.hpp	/^        void unexpect(typename lexer::token_type t) const$/;"	f	class:nlohmann::basic_json::parser
unflatten	lib/json/json.hpp	/^        static basic_json unflatten(const basic_json& value)$/;"	f	class:nlohmann::basic_json::json_pointer
unflatten	lib/json/json.hpp	/^    basic_json unflatten() const$/;"	f	class:nlohmann::basic_json
uninitialized	lib/json/json.hpp	/^            uninitialized,   \/\/\/< indicating the scanner is uninitialized$/;"	m	class:nlohmann::basic_json::lexer::token_type
unique	lib/pugixml/pugixml.cc	/^	template <typename I> I unique(I begin, I end)$/;"	f
unitOrthogonal	lib/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase
unitOrthogonal_selector	lib/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	lib/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	lib/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
universe_rank	lib/communicator/Communicator_mpi3_leader.cc	/^  int universe_rank;$/;"	m	class:Grid::Slave	file:
unmark	extras/Hadrons/Graph.hpp	/^void Graph<T>::unmark(const T &value)$/;"	f	class:Graph
unmark	lib/Hadrons/Graph.hpp	/^void Graph<T>::unmark(const T &value)$/;"	f	class:Graph
unmarkAll	extras/Hadrons/Graph.hpp	/^void Graph<T>::unmarkAll(void)$/;"	f	class:Graph
unmarkAll	lib/Hadrons/Graph.hpp	/^void Graph<T>::unmarkAll(void)$/;"	f	class:Graph
unpacket_traits	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct unpacket_traits<Packet16f> {$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct unpacket_traits<Packet16i> {$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct unpacket_traits<Packet8d> {$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^template<typename Packet> struct unpacket_traits<DoublePacket<Packet> > { typedef DoublePacket<Packet> half; };$/;"	s	namespace:Eigen::internal
unspecified_bool_type	lib/pugixml/pugixml.h	/^		typedef void (*unspecified_bool_type)(xml_attribute***);$/;"	t	class:pugi::xml_attribute
unspecified_bool_type	lib/pugixml/pugixml.h	/^		typedef void (*unspecified_bool_type)(xml_node***);$/;"	t	class:pugi::xml_node
unspecified_bool_type	lib/pugixml/pugixml.h	/^		typedef void (*unspecified_bool_type)(xml_text***);$/;"	t	class:pugi::xml_text
unspecified_bool_type	lib/pugixml/pugixml.h	/^		typedef void (*unspecified_bool_type)(xpath_node***);$/;"	t	class:pugi::xpath_node
unspecified_bool_type	lib/pugixml/pugixml.h	/^		typedef void (*unspecified_bool_type)(xpath_query***);$/;"	t	class:pugi::xpath_query
unspecified_bool_xml_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN static void unspecified_bool_xml_attribute(xml_attribute***)$/;"	f	namespace:pugi
unspecified_bool_xml_node	lib/pugixml/pugixml.cc	/^	PUGI__FN static void unspecified_bool_xml_node(xml_node***)$/;"	f	namespace:pugi
unspecified_bool_xml_text	lib/pugixml/pugixml.cc	/^	PUGI__FN static void unspecified_bool_xml_text(xml_text***)$/;"	f	namespace:pugi
unspecified_bool_xpath_node	lib/pugixml/pugixml.cc	/^	PUGI__FN static void unspecified_bool_xpath_node(xpath_node***)$/;"	f	namespace:pugi
unspecified_bool_xpath_query	lib/pugixml/pugixml.cc	/^	PUGI__FN static void unspecified_bool_xpath_query(xpath_query***)$/;"	f	namespace:pugi
unvectorizeToLexOrdArray	lib/lattice/Lattice_transfer.h	/^unvectorizeToLexOrdArray(std::vector<sobj> &out, const Lattice<vobj> &in)$/;"	f	namespace:Grid
upcast	lib/serialisation/BaseIO.h	/^    T *upcast;$/;"	m	class:Grid::Reader
upcast	lib/serialisation/BaseIO.h	/^    T *upcast;$/;"	m	class:Grid::Writer
update	lib/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	lib/Eigen/src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	lib/qcd/representations/hmc_types.h	/^  inline typename std::enable_if<(I == tuple_size), void>::type update($/;"	f	class:Grid::QCD::Representations
updateInPlace	lib/Eigen/src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
updateList	lib/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^inline void IncompleteCholesky<Scalar,_UpLo, OrderingType>::updateList(Ref<const VectorIx> colPtr, Ref<VectorIx> rowIdx, Ref<VectorSx> vals, const Index& col, const Index& jk, VectorIx& firstElt, VectorList& listCol)$/;"	f	class:Eigen::IncompleteCholesky
update_P	lib/qcd/hmc/integrators/Integrator.h	/^  void update_P(Field& U, int level, double ep) {$/;"	f	class:Grid::QCD::Integrator
update_P	lib/qcd/hmc/integrators/Integrator.h	/^  void update_P(MomentaField& Mom, Field& U, int level, double ep) {$/;"	f	class:Grid::QCD::Integrator
update_P_hireps	lib/qcd/hmc/integrators/Integrator.h	/^  } update_P_hireps{};$/;"	s	class:Grid::QCD::Integrator
update_U	lib/qcd/hmc/integrators/Integrator.h	/^  void update_U(Field& U, double ep) {$/;"	f	class:Grid::QCD::Integrator
update_U	lib/qcd/hmc/integrators/Integrator.h	/^  void update_U(MomentaField& Mom, Field& U, double ep) {$/;"	f	class:Grid::QCD::Integrator
update_auxiliary_fields	lib/qcd/utils/Metric.h	/^  void update_auxiliary_fields(RealD ep){$/;"	f	class:Grid::QCD::GeneralisedMomenta
update_auxiliary_momenta	lib/qcd/utils/Metric.h	/^  void update_auxiliary_momenta(RealD ep){$/;"	f	class:Grid::QCD::GeneralisedMomenta
update_field	lib/qcd/action/gauge/GaugeImplTypes.h	/^  static inline void update_field(Field& P, Field& U, double ep){$/;"	f	class:Grid::QCD::GaugeImplTypes
update_field	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void update_field(Field& P, Field& U, double ep) {$/;"	f	class:Grid::ScalarAdjMatrixImplTypes
update_field	lib/qcd/action/scalar/ScalarImpl.h	/^    static inline void update_field(Field& P, Field& U, double ep) {$/;"	f	class:Grid::ScalarImplTypes
update_representation	lib/qcd/representations/adjoint.h	/^  void update_representation(const LatticeGaugeField &Uin) {$/;"	f	class:Grid::QCD::AdjointRep
update_representation	lib/qcd/representations/fundamental.h	/^    void update_representation(const LatticeField& Uin) {} \/\/ do nothing$/;"	f	class:Grid::QCD::EmptyRep
update_representation	lib/qcd/representations/fundamental.h	/^  void update_representation(const LatticeGaugeField& Uin) {} \/\/ do nothing$/;"	f	class:Grid::QCD::FundamentalRep
update_representation	lib/qcd/representations/two_index.h	/^  void update_representation(const LatticeGaugeField &Uin) {$/;"	f	class:Grid::QCD::TwoIndexRep
update_segrep	lib/Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  bool update_segrep(Index \/*krep*\/, Index \/*jj*\/)$/;"	f	struct:Eigen::internal::column_dfs_traits
update_segrep	lib/Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  bool update_segrep(Index krep, StorageIndex jj)$/;"	f	struct:Eigen::internal::panel_dfs_traits
upperbidiagonalization_blocked_helper	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^void upperbidiagonalization_blocked_helper(MatrixType& A,$/;"	f	namespace:Eigen::internal
upperbidiagonalization_inplace_blocked	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^void upperbidiagonalization_inplace_blocked(MatrixType& A, BidiagType& bidiagonal,$/;"	f	namespace:Eigen::internal
upperbidiagonalization_inplace_unblocked	lib/Eigen/src/SVD/UpperBidiagonalization.h	/^void upperbidiagonalization_inplace_unblocked(MatrixType& mat,$/;"	f	namespace:Eigen::internal
usage	grid-config.in	/^usage()$/;"	f
useGuesser	lib/algorithms/iterative/ConjugateGradientMixedPrec.h	/^    void useGuesser(LinearFunction<FieldF> &g){$/;"	f	class:Grid::MixedPrecisionConjugateGradient
useSpecificBlockingSizes	lib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline bool useSpecificBlockingSizes(Index& k, Index& m, Index& n)$/;"	f	namespace:Eigen::internal
usec	lib/algorithms/FFT.h	/^    uint64_t usec;$/;"	m	class:Grid::FFT
usecond	lib/perfmon/Timer.h	/^inline double usecond(void) {$/;"	f	namespace:Grid
useconds	lib/perfmon/Timer.h	/^  uint64_t useconds(void){$/;"	f	class:Grid::GridStopWatch
users	lib/Eigen/src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo
uses_heap	lib/pugixml/pugixml.cc	/^		bool uses_heap() const$/;"	f	class:xpath_string
usqcdInfo	lib/parallelIO/IldgIOtypes.h	/^  usqcdInfo() { $/;"	f	struct:Grid::usqcdInfo
usqcdInfo	lib/parallelIO/IldgIOtypes.h	/^struct usqcdInfo : Serializable { $/;"	s	namespace:Grid
usub	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector usub; \/\/ row indices of U columns in ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
utf16_counter	lib/pugixml/pugixml.cc	/^	struct utf16_counter$/;"	s	file:
utf16_writer	lib/pugixml/pugixml.cc	/^	struct utf16_writer$/;"	s	file:
utf32_counter	lib/pugixml/pugixml.cc	/^	struct utf32_counter$/;"	s	file:
utf32_writer	lib/pugixml/pugixml.cc	/^	struct utf32_writer$/;"	s	file:
utf8_counter	lib/pugixml/pugixml.cc	/^	struct utf8_counter$/;"	s	file:
utf8_writer	lib/pugixml/pugixml.cc	/^	struct utf8_writer$/;"	s	file:
utf_decoder	lib/pugixml/pugixml.cc	/^	template <typename Traits, typename opt_swap = opt_false> struct utf_decoder$/;"	s	file:
v	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  __m256  v;$/;"	m	struct:Eigen::internal::Packet4cf
v	lib/Eigen/src/Core/arch/AVX/Complex.h	/^  __m256d  v;$/;"	m	struct:Eigen::internal::Packet2cd
v	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet2d v;$/;"	m	struct:Eigen::internal::Packet1cd
v	lib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  Packet2d v;$/;"	m	struct:Eigen::internal::Packet1cd
v	lib/Eigen/src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	lib/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd
v	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^    Packet4f v;$/;"	m	union:Eigen::internal::Packet2cf::__anon315
v	lib/Eigen/src/Core/arch/ZVector/Complex.h	/^  Packet2d v;$/;"	m	struct:Eigen::internal::Packet1cd
v	lib/simd/Grid_avx.h	/^    __m256 v;$/;"	m	union:Grid::Optimization::u256f
v	lib/simd/Grid_avx.h	/^    __m256d v;$/;"	m	union:Grid::Optimization::u256d
v	lib/simd/Grid_avx.h	/^    vtype v;$/;"	m	union:Grid::Optimization::uconv
v	lib/simd/Grid_avx512.h	/^    __m512 v;$/;"	m	union:Grid::Optimization::u512f
v	lib/simd/Grid_avx512.h	/^    __m512d v;$/;"	m	union:Grid::Optimization::u512d
v	lib/simd/Grid_generic_types.h	/^    alignas(GEN_SIMD_WIDTH) T v[W<T>::r];$/;"	m	struct:Grid::Optimization::vec
v	lib/simd/Grid_neon.h	/^    float16x8_t v;$/;"	m	union:Grid::Optimization::u128h
v	lib/simd/Grid_neon.h	/^    float32x4_t v;$/;"	m	union:Grid::Optimization::u128f
v	lib/simd/Grid_neon.h	/^    float64x2_t v;$/;"	m	union:Grid::Optimization::u128d
v	lib/simd/Grid_neon.h	/^    vtype v;$/;"	m	union:Grid::Optimization::uconv
v	lib/simd/Grid_sse4.h	/^    __m128 v;$/;"	m	union:Grid::Optimization::u128f
v	lib/simd/Grid_sse4.h	/^    __m128d v;$/;"	m	union:Grid::Optimization::u128d
v	lib/simd/Grid_sse4.h	/^    vtype v;$/;"	m	union:Grid::Optimization::uconv
v	lib/simd/Grid_vector_types.h	/^    Vector_type v;$/;"	m	union:Grid::Grid_simd::conv_t_union
v	lib/simd/Grid_vector_types.h	/^  Vector_type v;$/;"	m	class:Grid::Grid_simd
v0	lib/simd/Grid_qpx.h	/^    float v0,v1,v2,v3;$/;"	m	struct:Grid::Optimization::__anon692
v1	lib/simd/Grid_qpx.h	/^    float v0,v1,v2,v3;$/;"	m	struct:Grid::Optimization::__anon692
v2	lib/simd/Grid_qpx.h	/^    float v0,v1,v2,v3;$/;"	m	struct:Grid::Optimization::__anon692
v2d	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet2d  v2d;$/;"	m	union:Eigen::internal::__anon308
v2l	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet2l  v2l;$/;"	m	union:Eigen::internal::__anon308
v2ul	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet2ul v2ul;$/;"	m	union:Eigen::internal::__anon308
v3	lib/simd/Grid_qpx.h	/^    float v0,v1,v2,v3;$/;"	m	struct:Grid::Optimization::__anon692
v4f	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^	Packet2d  v4f[2];$/;"	m	struct:Eigen::internal::__anon307
v4i	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet4i  v4i;$/;"	m	union:Eigen::internal::__anon308
v4ui	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet4ui v4ui;$/;"	m	union:Eigen::internal::__anon308
vAMatrix	lib/qcd/utils/SUnAdjoint.h	/^  typedef iSUnAdjointMatrix<vComplex> vAMatrix;$/;"	t	class:Grid::QCD::SU_Adjoint
vAMatrixD	lib/qcd/utils/SUnAdjoint.h	/^  typedef iSUnAdjointMatrix<vComplexD> vAMatrixD;$/;"	t	class:Grid::QCD::SU_Adjoint
vAMatrixF	lib/qcd/utils/SUnAdjoint.h	/^  typedef iSUnAdjointMatrix<vComplexF> vAMatrixF;$/;"	t	class:Grid::QCD::SU_Adjoint
vAlgebraVector	lib/qcd/utils/SUn.h	/^  typedef iSUnAlgebraVector<vComplex> vAlgebraVector;$/;"	t	class:Grid::QCD::SU
vAlgebraVectorD	lib/qcd/utils/SUn.h	/^  typedef iSUnAlgebraVector<vComplexD> vAlgebraVectorD;$/;"	t	class:Grid::QCD::SU
vAlgebraVectorF	lib/qcd/utils/SUn.h	/^  typedef iSUnAlgebraVector<vComplexF> vAlgebraVectorF;$/;"	t	class:Grid::QCD::SU
vColourMatrix	lib/qcd/QCD.h	/^    typedef iColourMatrix<vComplex >        vColourMatrix;$/;"	t	namespace:Grid::QCD
vColourMatrixD	lib/qcd/QCD.h	/^    typedef iColourMatrix<vComplexD>        vColourMatrixD;$/;"	t	namespace:Grid::QCD
vColourMatrixF	lib/qcd/QCD.h	/^    typedef iColourMatrix<vComplexF>        vColourMatrixF;$/;"	t	namespace:Grid::QCD
vColourVector	lib/qcd/QCD.h	/^    typedef iColourVector<vComplex >         vColourVector;$/;"	t	namespace:Grid::QCD
vColourVectorD	lib/qcd/QCD.h	/^    typedef iColourVector<vComplexD>         vColourVectorD;$/;"	t	namespace:Grid::QCD
vColourVectorF	lib/qcd/QCD.h	/^    typedef iColourVector<vComplexF>         vColourVectorF;$/;"	t	namespace:Grid::QCD
vComplex	lib/simd/Simd.h	/^  typedef vComplexD vComplex;$/;"	t	namespace:Grid
vComplexD	lib/simd/Grid_vector_types.h	/^typedef Grid_simd<std::complex<double>, SIMD_Dtype> vComplexD;$/;"	t	namespace:Grid
vComplexF	lib/simd/Grid_vector_types.h	/^typedef Grid_simd<std::complex<float>, SIMD_Ftype> vComplexF;$/;"	t	namespace:Grid
vComplexH	lib/simd/Grid_vector_types.h	/^typedef Grid_simd<std::complex<uint16_t>, SIMD_Htype> vComplexH;$/;"	t	namespace:Grid
vComplexHigh	lib/qcd/action/fermion/WilsonCompressor.h	/^  typedef typename SiteHalfSpinor::vector_type     vComplexHigh;$/;"	t	class:Grid::QCD::WilsonCompressorTemplate
vComplexLow	lib/qcd/action/fermion/WilsonCompressor.h	/^  typedef typename SiteHalfCommSpinor::vector_type vComplexLow;$/;"	t	class:Grid::QCD::WilsonCompressorTemplate
vDoubleStoredColourMatrix	lib/qcd/QCD.h	/^    typedef iDoubleStoredColourMatrix<vComplex > vDoubleStoredColourMatrix;$/;"	t	namespace:Grid::QCD
vDoubleStoredColourMatrixD	lib/qcd/QCD.h	/^    typedef iDoubleStoredColourMatrix<vComplexD> vDoubleStoredColourMatrixD;$/;"	t	namespace:Grid::QCD
vDoubleStoredColourMatrixF	lib/qcd/QCD.h	/^    typedef iDoubleStoredColourMatrix<vComplexF> vDoubleStoredColourMatrixF;$/;"	t	namespace:Grid::QCD
vHalfSpinColourVector	lib/qcd/QCD.h	/^    typedef iHalfSpinColourVector<vComplex > vHalfSpinColourVector;$/;"	t	namespace:Grid::QCD
vHalfSpinColourVectorD	lib/qcd/QCD.h	/^    typedef iHalfSpinColourVector<vComplexD> vHalfSpinColourVectorD;$/;"	t	namespace:Grid::QCD
vHalfSpinColourVectorF	lib/qcd/QCD.h	/^    typedef iHalfSpinColourVector<vComplexF> vHalfSpinColourVectorF;$/;"	t	namespace:Grid::QCD
vHalfSpinVector	lib/qcd/QCD.h	/^    typedef iHalfSpinVector<vComplex >       vHalfSpinVector;$/;"	t	namespace:Grid::QCD
vHalfSpinVectorD	lib/qcd/QCD.h	/^    typedef iHalfSpinVector<vComplexD>       vHalfSpinVectorD;$/;"	t	namespace:Grid::QCD
vHalfSpinVectorF	lib/qcd/QCD.h	/^    typedef iHalfSpinVector<vComplexF>       vHalfSpinVectorF;$/;"	t	namespace:Grid::QCD
vInteger	lib/simd/Grid_vector_types.h	/^typedef Grid_simd<Integer, SIMD_Itype> vInteger;$/;"	t	namespace:Grid
vLorentzColourMatrix	lib/qcd/QCD.h	/^    typedef iLorentzColourMatrix<vComplex > vLorentzColourMatrix;$/;"	t	namespace:Grid::QCD
vLorentzColourMatrixD	lib/qcd/QCD.h	/^    typedef iLorentzColourMatrix<vComplexD> vLorentzColourMatrixD;$/;"	t	namespace:Grid::QCD
vLorentzColourMatrixF	lib/qcd/QCD.h	/^    typedef iLorentzColourMatrix<vComplexF> vLorentzColourMatrixF;$/;"	t	namespace:Grid::QCD
vMatrix	lib/qcd/utils/SUn.h	/^  typedef iSUnMatrix<vComplex> vMatrix;$/;"	t	class:Grid::QCD::SU
vMatrixD	lib/qcd/utils/SUn.h	/^  typedef iSUnMatrix<vComplexD> vMatrixD;$/;"	t	class:Grid::QCD::SU
vMatrixF	lib/qcd/utils/SUn.h	/^  typedef iSUnMatrix<vComplexF> vMatrixF;$/;"	t	class:Grid::QCD::SU
vReal	lib/simd/Simd.h	/^  typedef vRealD vReal;$/;"	t	namespace:Grid
vRealD	lib/simd/Grid_vector_types.h	/^typedef Grid_simd<double, SIMD_Dtype> vRealD;$/;"	t	namespace:Grid
vRealF	lib/simd/Grid_vector_types.h	/^typedef Grid_simd<float, SIMD_Ftype> vRealF;$/;"	t	namespace:Grid
vRealH	lib/simd/Grid_vector_types.h	/^typedef Grid_simd<uint16_t, SIMD_Htype>               vRealH;$/;"	t	namespace:Grid
vSU2Matrix	lib/qcd/utils/SUn.h	/^  typedef iSU2Matrix<vComplex> vSU2Matrix;$/;"	t	class:Grid::QCD::SU
vSU2MatrixD	lib/qcd/utils/SUn.h	/^  typedef iSU2Matrix<vComplexD> vSU2MatrixD;$/;"	t	class:Grid::QCD::SU
vSU2MatrixF	lib/qcd/utils/SUn.h	/^  typedef iSU2Matrix<vComplexF> vSU2MatrixF;$/;"	t	class:Grid::QCD::SU
vSpinColourMatrix	lib/qcd/QCD.h	/^    typedef iSpinColourMatrix<vComplex >    vSpinColourMatrix;$/;"	t	namespace:Grid::QCD
vSpinColourMatrixD	lib/qcd/QCD.h	/^    typedef iSpinColourMatrix<vComplexD>    vSpinColourMatrixD;$/;"	t	namespace:Grid::QCD
vSpinColourMatrixF	lib/qcd/QCD.h	/^    typedef iSpinColourMatrix<vComplexF>    vSpinColourMatrixF;$/;"	t	namespace:Grid::QCD
vSpinColourVector	lib/qcd/QCD.h	/^    typedef iSpinColourVector<vComplex >     vSpinColourVector;$/;"	t	namespace:Grid::QCD
vSpinColourVectorD	lib/qcd/QCD.h	/^    typedef iSpinColourVector<vComplexD>     vSpinColourVectorD;$/;"	t	namespace:Grid::QCD
vSpinColourVectorF	lib/qcd/QCD.h	/^    typedef iSpinColourVector<vComplexF>     vSpinColourVectorF;$/;"	t	namespace:Grid::QCD
vSpinMatrix	lib/qcd/QCD.h	/^    typedef iSpinMatrix<vComplex >          vSpinMatrix;$/;"	t	namespace:Grid::QCD
vSpinMatrixD	lib/qcd/QCD.h	/^    typedef iSpinMatrix<vComplexD>          vSpinMatrixD;$/;"	t	namespace:Grid::QCD
vSpinMatrixF	lib/qcd/QCD.h	/^    typedef iSpinMatrix<vComplexF>          vSpinMatrixF;$/;"	t	namespace:Grid::QCD
vSpinVector	lib/qcd/QCD.h	/^    typedef iSpinVector<vComplex >           vSpinVector;$/;"	t	namespace:Grid::QCD
vSpinVectorD	lib/qcd/QCD.h	/^    typedef iSpinVector<vComplexD>           vSpinVectorD;$/;"	t	namespace:Grid::QCD
vSpinVectorF	lib/qcd/QCD.h	/^    typedef iSpinVector<vComplexF>           vSpinVectorF;$/;"	t	namespace:Grid::QCD
vTComplex	lib/qcd/QCD.h	/^    typedef iSinglet<vComplex >        vTComplex ;   \/\/ what if we don't know the tensor structure$/;"	t	namespace:Grid::QCD
vTComplexD	lib/qcd/QCD.h	/^    typedef iSinglet<vComplexD>        vTComplexD;   \/\/ what if we don't know the tensor structure$/;"	t	namespace:Grid::QCD
vTComplexF	lib/qcd/QCD.h	/^    typedef iSinglet<vComplexF>        vTComplexF;   \/\/ what if we don't know the tensor structure$/;"	t	namespace:Grid::QCD
vTIMatrix	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnTwoIndexMatrix<vComplex> vTIMatrix;$/;"	t	class:Grid::QCD::SU_TwoIndex
vTIMatrixD	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnTwoIndexMatrix<vComplexD> vTIMatrixD;$/;"	t	class:Grid::QCD::SU_TwoIndex
vTIMatrixF	lib/qcd/utils/SUnTwoIndex.h	/^  typedef iSUnTwoIndexMatrix<vComplexF> vTIMatrixF;$/;"	t	class:Grid::QCD::SU_TwoIndex
vTInteger	lib/qcd/QCD.h	/^    typedef iSinglet<vInteger>         vTInteger;$/;"	t	namespace:Grid::QCD
vTReal	lib/qcd/QCD.h	/^    typedef iSinglet<vReal >           vTReal;      $/;"	t	namespace:Grid::QCD
vTRealD	lib/qcd/QCD.h	/^    typedef iSinglet<vRealD>           vTRealD;      $/;"	t	namespace:Grid::QCD
vTRealF	lib/qcd/QCD.h	/^    typedef iSinglet<vRealF>           vTRealF;      $/;"	t	namespace:Grid::QCD
v_prefetch0	lib/simd/Grid_avx.h	/^  inline void v_prefetch0(int size, const char *ptr){$/;"	f	namespace:Grid
v_prefetch0	lib/simd/Grid_avx512.h	/^  inline void v_prefetch0(int size, const char *ptr){$/;"	f	namespace:Grid
v_prefetch0	lib/simd/Grid_generic.h	/^  inline void v_prefetch0(int size, const char *ptr){};$/;"	f	namespace:Grid
v_prefetch0	lib/simd/Grid_imci.h	/^  inline void v_prefetch0(int size, const char *ptr){$/;"	f	namespace:Grid
v_prefetch0	lib/simd/Grid_neon.h	/^  inline void v_prefetch0(int size, const char *ptr){};  \/\/ prefetch utilities$/;"	f	namespace:Grid
v_prefetch0	lib/simd/Grid_qpx.h	/^inline void v_prefetch0(int size, const char *ptr){};$/;"	f	namespace:Grid
v_prefetch0	lib/simd/Grid_sse4.h	/^  inline void v_prefetch0(int size, const char *ptr){};$/;"	f	namespace:Grid
valid	lib/allocator/AlignedAllocator.h	/^      bool valid;$/;"	m	struct:Grid::PointerCache::__anon11
value	lib/Eigen/src/Core/CoreEvaluators.h	/^  static const bool value = false;$/;"	m	struct:Eigen::internal::evaluator_assume_aliasing
value	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Scalar value() const          { return m_iter.value(); }$/;"	f	class:Eigen::InnerIterator
value	lib/Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::inner_iterator_selector
value	lib/Eigen/src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase
value	lib/Eigen/src/Core/GeneralProduct.h	/^         value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon184
value	lib/Eigen/src/Core/GeneralProduct.h	/^    value = selector::ret,$/;"	e	enum:Eigen::internal::product_type::__anon187
value	lib/Eigen/src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(meta_floor_log2_terminate)$/;"	e	enum:Eigen::internal::meta_floor_log2_selector::__anon252
value	lib/Eigen/src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::meta_floor_log2::__anon255
value	lib/Eigen/src/Core/MathFunctions.h	/^  enum { value = meta_floor_log2<n, lower, meta_floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::meta_floor_log2::__anon253
value	lib/Eigen/src/Core/MathFunctions.h	/^  enum { value = meta_floor_log2<n, meta_floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::meta_floor_log2::__anon254
value	lib/Eigen/src/Core/ProductEvaluators.h	/^  static const bool value = true;$/;"	m	struct:Eigen::internal::evaluator_assume_aliasing
value	lib/Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost }; };$/;"	e	enum:Eigen::internal::member_lpnorm::Cost::__anon157
value	lib/Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon158
value	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon291
value	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon293
value	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon292
value	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 16 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon297
value	lib/Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 14 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon296
value	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { value = true };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon349
value	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { value = true };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon350
value	lib/Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { value = true };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon351
value	lib/Eigen/src/Core/arch/CUDA/Half.h	/^template<> struct is_arithmetic<half> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon267
value	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<double2> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon262
value	lib/Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<float4>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon261
value	lib/Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct is_arithmetic<half2> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon258
value	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon330
value	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon332
value	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon331
value	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 8 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon340
value	lib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 7 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon339
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon495
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon489
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon492
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon498
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon493
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon487
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon490
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon496
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon494
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon488
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon491
value	lib/Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon497
value	lib/Eigen/src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon114
value	lib/Eigen/src/Core/util/Meta.h	/^  enum { value = is_convertible_impl<typename remove_all<From>::type,$/;"	e	enum:Eigen::internal::is_convertible::__anon100
value	lib/Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(test(ms_from, 0))==sizeof(yes) };$/;"	e	enum:Eigen::internal::is_convertible_impl::__anon99
value	lib/Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon107
value	lib/Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon105
value	lib/Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon106
value	lib/Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor<T>(0)) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_ReturnType::__anon104
value	lib/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon69
value	lib/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon68
value	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon97
value	lib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon98
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon76
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon77
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon74
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon73
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon75
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon78
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon82
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon84
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon80
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon79
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon83
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon85
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon81
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<bool>            { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon87
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<char>            { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon88
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed char>     { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon89
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed int>      { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon93
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed long>     { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon95
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed short>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon91
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon90
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon94
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon96
value	lib/Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon92
value	lib/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon70
value	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon72
value	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_integral        { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_integral::__anon86
value	lib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon71
value	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  enum { value = is_ref_compatible_impl<typename remove_all<MatrixType>::type>::value };$/;"	e	enum:Eigen::internal::is_ref_compatible::__anon668
value	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  enum { value = sizeof(test<MatrixType>(ms_from, 0))==sizeof(yes) };$/;"	e	enum:Eigen::internal::is_ref_compatible_impl::__anon667
value	lib/Eigen/src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
value	lib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
value	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(Index i) { eigen_internal_assert(m_values!=0); return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(Index i) const { eigen_internal_assert(m_values!=0); return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Scalar value() const { return m_it.value(); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
value	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
value	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
value	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { eigen_internal_assert(m_id<m_innerSize); return m_value; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return LhsIterator::value() * m_factor; }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_coeff * SparseXprInnerIterator::value(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Scalar value() const { return m_sparseIter.value() * m_diagCoeffNested.coeff(index()); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseTriangularView.h	/^      inline Scalar value() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
value	lib/Eigen/src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet
value	lib/Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
value	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_idval]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
value	lib/json/json.hpp	/^            typename IteratorType::reference value() const$/;"	f	class:nlohmann::basic_json::iteration_proxy::iteration_proxy_internal
value	lib/json/json.hpp	/^        reference value() const$/;"	f	class:nlohmann::basic_json::iter_impl
value	lib/json/json.hpp	/^        reference value() const$/;"	f	class:nlohmann::basic_json::json_reverse_iterator
value	lib/json/json.hpp	/^    ValueType value(const json_pointer& ptr, ValueType default_value) const$/;"	f	class:nlohmann::basic_json
value	lib/json/json.hpp	/^    ValueType value(const typename object_t::key_type& key, ValueType default_value) const$/;"	f	class:nlohmann::basic_json
value	lib/json/json.hpp	/^    static constexpr bool value =$/;"	m	struct:nlohmann::__anon693::has_mapped_type
value	lib/json/json.hpp	/^    string_t value(const json_pointer& ptr, const char* default_value) const$/;"	f	class:nlohmann::basic_json
value	lib/json/json.hpp	/^    string_t value(const typename object_t::key_type& key, const char* default_value) const$/;"	f	class:nlohmann::basic_json
value	lib/pugixml/pugixml.cc	/^			void* value;$/;"	m	struct:compact_hash_table::item_t	file:
value	lib/pugixml/pugixml.cc	/^		bool value;$/;"	m	struct:xpath_variable_boolean	file:
value	lib/pugixml/pugixml.cc	/^		char_t* value;$/;"	m	struct:xpath_variable_string	file:
value	lib/pugixml/pugixml.cc	/^		double value;$/;"	m	struct:xpath_variable_number	file:
value	lib/pugixml/pugixml.cc	/^		enum { value = 0 };$/;"	e	enum:opt_false::__anon681	file:
value	lib/pugixml/pugixml.cc	/^		enum { value = 1 };$/;"	e	enum:opt_true::__anon682	file:
value	lib/pugixml/pugixml.cc	/^		impl::compact_string<5, 3> value;$/;"	m	struct:pugi::xml_attribute_struct	file:
value	lib/pugixml/pugixml.cc	/^		impl::compact_string<5, 3> value;$/;"	m	struct:pugi::xml_node_struct	file:
value	lib/pugixml/pugixml.cc	/^		xpath_node_set value;$/;"	m	struct:xpath_variable_node_set	file:
value	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_attribute::value() const$/;"	f	class:pugi::xml_attribute
value	lib/pugixml/pugixml.cc	/^	PUGI__FN const char_t* xml_node::value() const$/;"	f	class:pugi::xml_node
value	lib/qcd/QCD.h	/^      static const bool value = (SpinorIndex==T::TensorLevel);$/;"	m	struct:Grid::QCD::isSpinor
value	lib/qcd/action/ActionSet.h	/^  static const std::size_t value = 0;$/;"	m	struct:Grid::QCD::Index
value	lib/qcd/action/ActionSet.h	/^  static const std::size_t value = 1 + Index<T, std::tuple<Types...>>::value;$/;"	m	struct:Grid::QCD::Index
value	lib/serialisation/BaseIO.h	/^    static const bool value = false;$/;"	m	struct:Grid::isReader
value	lib/serialisation/BaseIO.h	/^    static const bool value = false;$/;"	m	struct:Grid::isWriter
value	lib/serialisation/JSON_IO.h	/^    static const bool value = true;$/;"	m	struct:Grid::isReader
value	lib/serialisation/JSON_IO.h	/^    static const bool value = true;$/;"	m	struct:Grid::isWriter
value	lib/serialisation/XmlIO.h	/^    static const bool value = true;$/;"	m	struct:Grid::isReader
value	lib/serialisation/XmlIO.h	/^    static const bool value = true;$/;"	m	struct:Grid::isWriter
value	lib/sitmo_rng/sitmo_prng_engine.hpp	/^        static bool const value = sizeof(test<T>(0)) == sizeof(char);$/;"	m	struct:sitmo::has_generate_template
value	lib/tensors/Tensor_traits.h	/^    enum { value = sizeof(real_scalar_type)\/sizeof(float) };$/;"	e	enum:Grid::getPrecision::__anon709
value	lib/tensors/Tensor_traits.h	/^    enum {value = sizeof(test<T>(0)) == sizeof(char) };$/;"	e	enum:Grid::isSIMDvectorized::__anon708
value	lib/tensors/Tensor_traits.h	/^    static const bool value = (Level==T::TensorLevel);$/;"	m	struct:Grid::matchGridTensorIndex
value	lib/tensors/Tensor_traits.h	/^    static const bool value = false;$/;"	m	struct:Grid::isComplex
value	lib/tensors/Tensor_traits.h	/^    static const bool value = false;$/;"	m	struct:Grid::isGridTensor
value	lib/tensors/Tensor_traits.h	/^    static const bool value = true;$/;"	m	struct:Grid::isComplex
value	lib/tensors/Tensor_traits.h	/^    static const bool value = true;$/;"	m	struct:Grid::isGridTensor
valuePtr	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::internal::CompressedStorage
valuePtr	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::internal::CompressedStorage
valuePtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
valuePtr	lib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
valuePtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Scalar* valuePtr() { return derived().valuePtr(); }$/;"	f	class:Eigen::SparseCompressedBase
valuePtr	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const Scalar* valuePtr() const { return derived().valuePtr(); }$/;"	f	class:Eigen::SparseCompressedBase
valuePtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline Scalar* valuePtr()              { return Base::m_values; }$/;"	f	class:Eigen::SparseMapBase
valuePtr	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::SparseMapBase
valuePtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline Scalar* valuePtr() { return derived().nestedExpression().valuePtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
valuePtr	lib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline const Scalar* valuePtr() const { return derived().nestedExpression().valuePtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
valuePtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseVector
valuePtr	lib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseVector
valuePtr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* valuePtr() {  return m_nzval; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
valuePtr	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Scalar* valuePtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
valueRef	lib/Eigen/src/SparseCore/SparseBlock.h	/^  inline Scalar& valueRef() { return m_it.valueRef(); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
valueRef	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
valueRef	lib/Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
valueRef	lib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
valueRef	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_idval]); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
value_number	lib/json/json.hpp	/^            value_number,    \/\/\/< a number -- use get_number() for actual value$/;"	m	class:nlohmann::basic_json::lexer::token_type
value_separator	lib/json/json.hpp	/^            value_separator, \/\/\/< the value separator `,`$/;"	m	class:nlohmann::basic_json::lexer::token_type
value_string	lib/json/json.hpp	/^            value_string,    \/\/\/< a string -- use get_string() for actual value$/;"	m	class:nlohmann::basic_json::lexer::token_type
value_t	lib/json/json.hpp	/^    enum class value_t : uint8_t$/;"	c	class:nlohmann::basic_json
value_type	lib/Eigen/src/Core/DenseBase.h	/^    typedef Scalar value_type;$/;"	t	class:Eigen::DenseBase
value_type	lib/Eigen/src/Core/util/Memory.h	/^  typedef T               value_type;$/;"	t	class:Eigen::aligned_allocator
value_type	lib/Eigen/src/SparseCore/SparseMatrix.h	/^        typedef StorageIndex value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector
value_type	lib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Scalar value_type;$/;"	t	class:Eigen::SparseMatrixBase
value_type	lib/Eigen/src/StlSupport/details.h	/^    typedef T               value_type;$/;"	t	class:Eigen::aligned_allocator_indirection
value_type	lib/allocator/AlignedAllocator.h	/^    typedef _Tp value_type;$/;"	t	class:Grid::alignedAllocator
value_type	lib/allocator/AlignedAllocator.h	/^  typedef _Tp        value_type;$/;"	t	class:Grid::commAllocator
value_type	lib/pugixml/pugixml.cc	/^		typedef size_t value_type;$/;"	t	struct:utf16_counter	file:
value_type	lib/pugixml/pugixml.cc	/^		typedef size_t value_type;$/;"	t	struct:utf32_counter	file:
value_type	lib/pugixml/pugixml.cc	/^		typedef size_t value_type;$/;"	t	struct:utf8_counter	file:
value_type	lib/pugixml/pugixml.cc	/^		typedef uint16_t* value_type;$/;"	t	struct:utf16_writer	file:
value_type	lib/pugixml/pugixml.cc	/^		typedef uint32_t* value_type;$/;"	t	struct:utf32_writer	file:
value_type	lib/pugixml/pugixml.cc	/^		typedef uint8_t* value_type;$/;"	t	struct:latin1_writer	file:
value_type	lib/pugixml/pugixml.cc	/^		typedef uint8_t* value_type;$/;"	t	struct:utf8_writer	file:
value_type	lib/pugixml/pugixml.h	/^		typedef xml_attribute value_type;$/;"	t	class:pugi::xml_attribute_iterator
value_type	lib/pugixml/pugixml.h	/^		typedef xml_node value_type;$/;"	t	class:pugi::xml_named_node_iterator
value_type	lib/pugixml/pugixml.h	/^		typedef xml_node value_type;$/;"	t	class:pugi::xml_node_iterator
values	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon15
variable	lib/pugixml/pugixml.cc	/^			xpath_variable* variable;$/;"	m	union:xpath_ast_node::__anon686	file:
vbroadcast	lib/simd/Grid_vector_types.h	/^inline void vbroadcast(Grid_simd<S,V> &ret,const Grid_simd<S,V> &src,int lane){$/;"	f	namespace:Grid
vbroadcast	lib/tensors/Tensor_class.h	/^  friend strong_inline void vbroadcast(iMatrix<vtype,N> &out,const iMatrix<vtype,N> &in,int lane){$/;"	f	class:Grid::iMatrix
vbroadcast	lib/tensors/Tensor_class.h	/^  friend strong_inline void vbroadcast(iScalar<vtype> &out,const iScalar<vtype> &in,int lane){$/;"	f	class:Grid::iScalar
vbroadcast	lib/tensors/Tensor_class.h	/^  friend strong_inline void vbroadcast(iVector<vtype,N> &out,const iVector<vtype,N> &in,int lane){$/;"	f	class:Grid::iVector
vcomplex_i	lib/simd/Grid_vector_types.h	/^inline void vcomplex_i(Grid_simd<S, V> &ret) {$/;"	f	namespace:Grid
vec	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec	lib/simd/Grid_generic_types.h	/^  struct vec {$/;"	s	namespace:Grid::Optimization
vec2d_swizzle1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	70;"	d
vec4f_swizzle1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	64;"	d
vec4f_swizzle2	lib/Eigen/src/Core/arch/SSE/PacketMath.h	73;"	d
vec4i_swizzle1	lib/Eigen/src/Core/arch/SSE/PacketMath.h	67;"	d
vec4i_swizzle2	lib/Eigen/src/Core/arch/SSE/PacketMath.h	76;"	d
vec_splat_dbl	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d vec_splat_dbl<0>(Packet2d& a)$/;"	f	namespace:Eigen::internal
vec_splat_dbl	lib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d vec_splat_dbl<1>(Packet2d& a)$/;"	f	namespace:Eigen::internal
vec_splat_packet4f	lib/Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<int element> EIGEN_STRONG_INLINE Packet4f vec_splat_packet4f(const Packet4f&   from)$/;"	f	namespace:Eigen::internal
vecd	lib/simd/Grid_generic_types.h	/^  typedef vec<double>    vecd;$/;"	t	namespace:Grid::Optimization
vecf	lib/simd/Grid_generic_types.h	/^  typedef vec<float>     vecf;$/;"	t	namespace:Grid::Optimization
vech	lib/simd/Grid_generic_types.h	/^  typedef vec<uint16_t>  vech; \/\/ half precision comms$/;"	t	namespace:Grid::Optimization
veci	lib/simd/Grid_generic_types.h	/^  typedef vec<Integer>   veci;$/;"	t	namespace:Grid::Optimization
vector	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	lib/Eigen/src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
vector4float	lib/simd/Grid_qpx.h	/^  } vector4float;$/;"	t	namespace:Grid::Optimization	typeref:struct:Grid::Optimization::__anon692
vectorD	lib/Eigen/src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT
vectorD	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky
vectorD	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT
vector_	lib/serialisation/BaseIO.h	/^    V                          vector_;$/;"	m	class:Grid::Reconstruct
vector_	lib/serialisation/BaseIO.h	/^    const V              &vector_;$/;"	m	class:Grid::Flatten
vector_base	lib/Eigen/src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector
vector_obj	lib/tensors/Tensor_traits.h	/^    typedef typename getVectorType<T>::type vector_obj; $/;"	t	class:Grid::getPrecision
vector_object	lib/lattice/Lattice_base.h	/^    typedef vobj vector_object;$/;"	t	class:Grid::Lattice
vector_type	lib/lattice/Lattice_base.h	/^    typedef typename vobj::vector_type vector_type;$/;"	t	class:Grid::Lattice
vector_type	lib/simd/Grid_vector_types.h	/^  typedef Vector_type vector_type;$/;"	t	class:Grid::Grid_simd
vector_type	lib/stencil/Stencil.h	/^  typedef typename cobj::vector_type vector_type;$/;"	t	class:Grid::CartesianStencil
vector_type	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::vector_type vector_type;$/;"	t	class:Grid::iMatrix
vector_type	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::vector_type vector_type;$/;"	t	class:Grid::iScalar
vector_type	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::vector_type vector_type;$/;"	t	class:Grid::iVector
vector_type	lib/tensors/Tensor_traits.h	/^    typedef ComplexD vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef ComplexF vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef Integer vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef RealD vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef RealF vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef typename T::vector_type vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef vComplexD vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef vComplexF vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef vComplexH vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef vInteger vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef vRealD vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_type	lib/tensors/Tensor_traits.h	/^    typedef vRealF vector_type;$/;"	t	class:Grid::GridTypeMapper
vector_typeD	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::vector_typeD vector_typeD;$/;"	t	class:Grid::iMatrix
vector_typeD	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::vector_typeD vector_typeD;$/;"	t	class:Grid::iScalar
vector_typeD	lib/tensors/Tensor_class.h	/^  typedef typename GridTypeMapper<vtype>::vector_typeD vector_typeD;$/;"	t	class:Grid::iVector
vector_typeD	lib/tensors/Tensor_traits.h	/^    typedef ComplexD vector_typeD;$/;"	t	class:Grid::GridTypeMapper
vector_typeD	lib/tensors/Tensor_traits.h	/^    typedef Integer vector_typeD;$/;"	t	class:Grid::GridTypeMapper
vector_typeD	lib/tensors/Tensor_traits.h	/^    typedef RealD vector_typeD;$/;"	t	class:Grid::GridTypeMapper
vector_typeD	lib/tensors/Tensor_traits.h	/^    typedef typename T::vector_typeD vector_typeD;$/;"	t	class:Grid::GridTypeMapper
vector_typeD	lib/tensors/Tensor_traits.h	/^    typedef vComplexD vector_typeD;$/;"	t	class:Grid::GridTypeMapper
vector_typeD	lib/tensors/Tensor_traits.h	/^    typedef vInteger vector_typeD;$/;"	t	class:Grid::GridTypeMapper
vector_typeD	lib/tensors/Tensor_traits.h	/^    typedef vRealD vector_typeD;$/;"	t	class:Grid::GridTypeMapper
vectorizeFromLexOrdArray	lib/lattice/Lattice_transfer.h	/^vectorizeFromLexOrdArray( std::vector<sobj> &in, Lattice<vobj> &out)$/;"	f	namespace:Grid
vectorwise_reverse_inplace_impl	lib/Eigen/src/Core/Reverse.h	/^struct vectorwise_reverse_inplace_impl<Horizontal>$/;"	s	namespace:Eigen::internal
vectorwise_reverse_inplace_impl	lib/Eigen/src/Core/Reverse.h	/^struct vectorwise_reverse_inplace_impl<Vertical>$/;"	s	namespace:Eigen::internal
veq	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class veq {$/;"	c	namespace:Grid
verbose	lib/algorithms/iterative/AdefGeneric.h	/^  int verbose;$/;"	m	class:TwoLevelFlexiblePcg
verbose	lib/algorithms/iterative/ConjugateGradientMultiShift.h	/^    int verbose;$/;"	m	class:Grid::ConjugateGradientMultiShift
verbose	lib/algorithms/iterative/ConjugateResidual.h	/^    int verbose;$/;"	m	class:Grid::ConjugateResidual
verbose	lib/algorithms/iterative/PrecConjugateResidual.h	/^    int verbose;$/;"	m	class:Grid::PrecConjugateResidual
verbose	lib/algorithms/iterative/PrecGeneralisedConjugateResidual.h	/^    int verbose;$/;"	m	class:Grid::PrecGeneralisedConjugateResidual
version	lib/sitmo_rng/sitmo_prng_engine.hpp	/^    uint32_t version()$/;"	f	class:sitmo::prng_engine
vertical_rank	lib/communicator/Communicator_mpi3_leader.cc	/^  int vertical_rank;$/;"	m	class:Grid::Slave	file:
vfalse	lib/simd/Grid_vector_types.h	/^inline void vfalse(Grid_simd<S, V> &ret) {$/;"	f	namespace:Grid
vfunc	tests/Test_simd.cc	/^template<class reduce,class vec>    void vfunc(reduce &rr,vec &i1,vec &i2)   const { rr = Reduce(i1);}$/;"	f	class:funcReduce
vge	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class vge {$/;"	c	namespace:Grid
vgrid	lib/algorithms/FFT.h	/^    GridCartesian *vgrid;$/;"	m	class:Grid::FFT
vgt	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class vgt {$/;"	c	namespace:Grid
victim	lib/allocator/AlignedAllocator.cc	/^int PointerCache::victim = 0;$/;"	m	class:Grid::PointerCache	file:
victim	lib/allocator/AlignedAllocator.h	/^    static int victim;$/;"	m	class:Grid::PointerCache
viewAsCholmod	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(Ref<SparseMatrix<_Scalar,_Options,_StorageIndex> > mat)$/;"	f	namespace:Eigen
viewAsCholmod	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<const SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseVector<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsEigen	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,StorageIndex> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen
visign	lib/simd/Grid_vector_types.h	/^inline void visign(Grid_simd<S, V> &ret) {$/;"	f	namespace:Grid
visit	lib/Eigen/src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase
visitor_evaluator	lib/Eigen/src/Core/Visitor.h	/^  explicit visitor_evaluator(const XprType &xpr) : m_evaluator(xpr), m_xpr(xpr) {}$/;"	f	class:Eigen::internal::visitor_evaluator
visitor_evaluator	lib/Eigen/src/Core/Visitor.h	/^class visitor_evaluator$/;"	c	namespace:Eigen::internal
visitor_impl	lib/Eigen/src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
visitor_impl	lib/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
visitor_impl	lib/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
vld1_dup_f32	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_dup_f32 (const float* x) { return ::vld1_dup_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vld1_f32	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vld1q_f32	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vle	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class vle {$/;"	c	namespace:Grid
vlt	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class vlt {$/;"	c	namespace:Grid
vml_assign_traits	lib/Eigen/src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
vne	lib/lattice/Lattice_comparison_utils.h	/^  template<class lobj,class robj> class vne {$/;"	c	namespace:Grid
vobj	lib/qcd/action/scalar/ScalarInteractionAction.h	/^    typedef typename Field::vector_object vobj;$/;"	t	class:Grid::ScalarInteractionAction
vobj	lib/qcd/hmc/checkpointers/BinaryCheckpointer.h	/^  typedef typename Field::vector_object vobj;$/;"	t	class:Grid::QCD::BinaryHmcCheckpointer
vobj	lib/qcd/utils/CovariantLaplacian.h	/^  typedef typename Impl::Field::vector_object vobj;$/;"	t	class:Grid::QCD::LaplacianAdjointField
volume	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox
vone	lib/simd/Grid_vector_types.h	/^inline void vone(Grid_simd<S, V> &ret) {$/;"	f	namespace:Grid
vpointers	lib/stencil/Stencil.h	/^    std::vector<cobj *> vpointers;$/;"	m	struct:Grid::CartesianStencil::Merge
vprefetch	lib/simd/Grid_vector_types.h	/^  friend inline void vprefetch(const Grid_simd &v) {$/;"	f	class:Grid::Grid_simd
vprefetch	lib/tensors/Tensor_class.h	/^void vprefetch(const iMatrix<v, N> &vv) {$/;"	f	namespace:Grid
vprefetch	lib/tensors/Tensor_class.h	/^void vprefetch(const iScalar<v> &vv) {$/;"	f	namespace:Grid
vprefetch	lib/tensors/Tensor_class.h	/^void vprefetch(const iVector<v, N> &vv) {$/;"	f	namespace:Grid
vreinterpretq_f64_u64	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^float64x2_t vreinterpretq_f64_u64(T a)$/;"	f	namespace:Eigen::internal
vreinterpretq_u64_f64	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^uint64x2_t vreinterpretq_u64_f64(T a)$/;"	f	namespace:Eigen::internal
vrsign	lib/simd/Grid_vector_types.h	/^inline void vrsign(Grid_simd<S, V> &ret) {$/;"	f	namespace:Grid
vset	lib/simd/Grid_vector_types.h	/^  friend inline void vset(Grid_simd &ret, Scalar_type *a) {$/;"	f	class:Grid::Grid_simd
vsplat	lib/simd/Grid_vector_types.h	/^inline void vsplat(Grid_simd<S, V> &ret, ABtype a, ABtype b) {$/;"	f	namespace:Grid
vsplat	lib/simd/Grid_vector_types.h	/^inline void vsplat(Grid_simd<S, V> &ret, EnableIf<is_complex<S>, S> c) {$/;"	f	namespace:Grid
vsplat	lib/simd/Grid_vector_types.h	/^inline void vsplat(Grid_simd<S, V> &ret, NotEnableIf<is_complex<S>, S> a) {$/;"	f	namespace:Grid
vst1_f32	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
vst1q_f32	lib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
vstore	lib/simd/Grid_vector_types.h	/^  friend inline void vstore(const Grid_simd &ret, Scalar_type *a) {$/;"	f	class:Grid::Grid_simd
vstream	lib/simd/Grid_vector_types.h	/^inline void vstream(Grid_simd<S, V> &out, const Grid_simd<S, V> &in) {$/;"	f	namespace:Grid
vstream	lib/simd/Simd.h	/^  inline void vstream(ComplexD &l, const ComplexD &r){ l=r;}$/;"	f	namespace:Grid
vstream	lib/simd/Simd.h	/^  inline void vstream(ComplexF &l, const ComplexF &r){ l=r;}$/;"	f	namespace:Grid
vstream	lib/simd/Simd.h	/^  inline void vstream(RealD &l, const RealD &r){ l=r;}$/;"	f	namespace:Grid
vstream	lib/simd/Simd.h	/^  inline void vstream(RealF &l, const RealF &r){ l=r;}$/;"	f	namespace:Grid
vstream	lib/tensors/Tensor_class.h	/^  friend strong_inline void vstream(iMatrix<vtype,N> &out,const iMatrix<vtype,N> &in){$/;"	f	class:Grid::iMatrix
vstream	lib/tensors/Tensor_class.h	/^  friend strong_inline void vstream(iScalar<vtype> &out,$/;"	f	class:Grid::iScalar
vstream	lib/tensors/Tensor_class.h	/^  friend strong_inline void vstream(iVector<vtype, N> &out,$/;"	f	class:Grid::iVector
vtrue	lib/simd/Grid_vector_types.h	/^inline void vtrue(Grid_simd<S, V> &ret) {$/;"	f	namespace:Grid
vzero	lib/simd/Grid_vector_types.h	/^inline void vzero(Grid_simd<S, V> &ret) {$/;"	f	namespace:Grid
w	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    w() const$/;"	f	class:Eigen::DenseCoeffsBase
w	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    w()$/;"	f	class:Eigen::DenseCoeffsBase
w	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase
w	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar& w() { return this->derived().coeffs().coeffRef(3); }$/;"	f	class:Eigen::QuaternionBase
wchar_counter	lib/pugixml/pugixml.cc	/^	typedef wchar_selector<sizeof(wchar_t)>::counter wchar_counter;$/;"	t	file:
wchar_selector	lib/pugixml/pugixml.cc	/^	template <> struct wchar_selector<2>$/;"	s	file:
wchar_selector	lib/pugixml/pugixml.cc	/^	template <> struct wchar_selector<4>$/;"	s	file:
wchar_writer	lib/pugixml/pugixml.cc	/^	typedef wchar_selector<sizeof(wchar_t)>::writer wchar_writer;$/;"	t	file:
what	lib/pugixml/pugixml.cc	/^	PUGI__FN const char* xpath_exception::what() const throw()$/;"	f	class:pugi::xpath_exception
whereWolf	lib/lattice/Lattice_where.h	/^inline Lattice<vobj> whereWolf(const Lattice<iobj> &predicate,Lattice<vobj> &iftrue,Lattice<vobj> &iffalse)$/;"	f	namespace:Grid
whereWolf	lib/lattice/Lattice_where.h	/^inline void whereWolf(Lattice<vobj> &ret,const Lattice<iobj> &predicate,Lattice<vobj> &iftrue,Lattice<vobj> &iffalse)$/;"	f	namespace:Grid
wide_stream	lib/pugixml/pugixml.h	/^		std::basic_ostream<wchar_t, std::char_traits<wchar_t> >* wide_stream;$/;"	m	class:pugi::xml_writer_stream
widen_ascii	lib/pugixml/pugixml.cc	/^	PUGI__FN void widen_ascii(wchar_t* dest, const char* source)$/;"	f
wilsonLoop	extras/qed-fvol/WilsonLoops.h	/^  static void wilsonLoop(GaugeMat &wl, const std::vector<GaugeMat> &U,$/;"	f	class:NewWilsonLoops
workaround_msvc_stl_support	lib/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	lib/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	lib/Eigen/src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal
write	lib/pugixml/pugixml.cc	/^		void write(char_t d0)$/;"	f	class:xml_buffered_writer
write	lib/pugixml/pugixml.cc	/^		void write(char_t d0, char_t d1)$/;"	f	class:xml_buffered_writer
write	lib/pugixml/pugixml.cc	/^		void write(char_t d0, char_t d1, char_t d2)$/;"	f	class:xml_buffered_writer
write	lib/pugixml/pugixml.cc	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3)$/;"	f	class:xml_buffered_writer
write	lib/pugixml/pugixml.cc	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)$/;"	f	class:xml_buffered_writer
write	lib/pugixml/pugixml.cc	/^		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)$/;"	f	class:xml_buffered_writer
write	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_writer_file::write(const void* data, size_t size)$/;"	f	class:pugi::xml_writer_file
write	lib/pugixml/pugixml.cc	/^	PUGI__FN void xml_writer_stream::write(const void* data, size_t size)$/;"	f	class:pugi::xml_writer_stream
write	lib/serialisation/BaseIO.h	/^    static inline void write(Writer<T> &WR,const std::string &s,$/;"	f	class:Grid::Serializable
write	lib/serialisation/BaseIO.h	/^  Writer<T>::write(const std::string &s, const U &output)$/;"	f	class:Grid::Writer
write	lib/serialisation/BaseIO.h	/^  inline void write(Writer<T> &w, const std::string& s, const U &output)$/;"	f	namespace:Grid
writeConfiguration	lib/parallelIO/IldgIO.h	/^  void writeConfiguration(Lattice<iLorentzColourMatrix<vsimd> > &Umu,int sequence,std::string LFN,std::string description) $/;"	f	class:Grid::QCD::IldgWriter
writeConfiguration	lib/parallelIO/NerscIO.h	/^      static inline void writeConfiguration(Lattice<iLorentzColourMatrix<vsimd> > &Umu,$/;"	f	class:Grid::QCD::NerscIO
writeDefault	lib/serialisation/BinaryIO.cc	/^void BinaryWriter::writeDefault(const string &s, const char *x)$/;"	f	class:BinaryWriter
writeDefault	lib/serialisation/BinaryIO.cc	/^void BinaryWriter::writeDefault(const string &s, const string &x)$/;"	f	class:BinaryWriter
writeDefault	lib/serialisation/BinaryIO.h	/^  void BinaryWriter::writeDefault(const std::string &s, const U &x)$/;"	f	class:Grid::BinaryWriter
writeDefault	lib/serialisation/BinaryIO.h	/^  void BinaryWriter::writeDefault(const std::string &s, const std::vector<U> &x)$/;"	f	class:Grid::BinaryWriter
writeDefault	lib/serialisation/Hdf5IO.cc	/^void Hdf5Writer::writeDefault(const std::string &s, const char *x)$/;"	f	class:Hdf5Writer
writeDefault	lib/serialisation/Hdf5IO.cc	/^void Hdf5Writer::writeDefault(const std::string &s, const std::string &x)$/;"	f	class:Hdf5Writer
writeDefault	lib/serialisation/Hdf5IO.h	/^  Hdf5Writer::writeDefault(const std::string &s, const std::vector<U> &x)$/;"	f	class:Grid::Hdf5Writer
writeDefault	lib/serialisation/Hdf5IO.h	/^  void Hdf5Writer::writeDefault(const std::string &s, const U &x)$/;"	f	class:Grid::Hdf5Writer
writeDefault	lib/serialisation/JSON_IO.cc	/^  void JSONWriter::writeDefault(const std::string &s,$/;"	f	class:Grid::JSONWriter
writeDefault	lib/serialisation/JSON_IO.h	/^  void JSONWriter::writeDefault(const std::string &s, const U &x)$/;"	f	class:Grid::JSONWriter
writeDefault	lib/serialisation/JSON_IO.h	/^  void JSONWriter::writeDefault(const std::string &s, const char(&x)[N]){$/;"	f	class:Grid::JSONWriter
writeDefault	lib/serialisation/JSON_IO.h	/^  void JSONWriter::writeDefault(const std::string &s, const std::complex<U> &x)$/;"	f	class:Grid::JSONWriter
writeDefault	lib/serialisation/JSON_IO.h	/^  void JSONWriter::writeDefault(const std::string &s, const std::vector<U> &x)$/;"	f	class:Grid::JSONWriter
writeDefault	lib/serialisation/TextIO.h	/^  void TextWriter::writeDefault(const std::string &s, const U &x)$/;"	f	class:Grid::TextWriter
writeDefault	lib/serialisation/TextIO.h	/^  void TextWriter::writeDefault(const std::string &s, const std::vector<U> &x)$/;"	f	class:Grid::TextWriter
writeDefault	lib/serialisation/XmlIO.h	/^  void XmlWriter::writeDefault(const std::string &s, const U &x)$/;"	f	class:Grid::XmlWriter
writeDefault	lib/serialisation/XmlIO.h	/^  void XmlWriter::writeDefault(const std::string &s, const std::vector<U> &x)$/;"	f	class:Grid::XmlWriter
writeHeader	lib/parallelIO/NerscIO.h	/^      static inline unsigned int writeHeader(FieldMetaData &field,std::string file)$/;"	f	class:Grid::QCD::NerscIO
writeLatticeObject	lib/parallelIO/BinaryIO.h	/^    static inline void writeLatticeObject(Lattice<vobj> &Umu,$/;"	f	class:Grid::BinaryIO
writeLimeIldgLFN	lib/parallelIO/IldgIO.h	/^  void writeLimeIldgLFN(std::string &LFN)$/;"	f	class:Grid::QCD::IldgWriter
writeLimeLatticeBinaryObject	lib/parallelIO/IldgIO.h	/^  void writeLimeLatticeBinaryObject(Lattice<vobj> &field,std::string record_name)$/;"	f	class:Grid::QCD::GridLimeWriter
writeLimeObject	lib/parallelIO/IldgIO.h	/^  void writeLimeObject(int MB,int ME,serialisable_object &object,std::string object_name,std::string record_name)$/;"	f	class:Grid::QCD::GridLimeWriter
writePacket	lib/Eigen/src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense
writePacket	lib/Eigen/src/Core/Block.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x) $/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::mapbase_evaluator
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x) $/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::mapbase_evaluator
writePacket	lib/Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	lib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	lib/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MapBase
writePacket	lib/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& val)$/;"	f	class:Eigen::MapBase
writePacket	lib/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	lib/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase
writePacket	lib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase
writeRNG	lib/parallelIO/BinaryIO.h	/^  static inline void writeRNG(GridSerialRNG &serial,$/;"	f	class:Grid::BinaryIO
writeRNGState	lib/parallelIO/NerscIO.h	/^      static inline void writeRNGState(GridSerialRNG &serial,GridParallelRNG &parallel,std::string file)$/;"	f	class:Grid::QCD::NerscIO
writeScidacFieldRecord	lib/parallelIO/IldgIO.h	/^  void writeScidacFieldRecord(Lattice<vobj> &field,userRecord _userRecord) $/;"	f	class:Grid::QCD::ScidacWriter
writeScidacFileRecord	lib/parallelIO/IldgIO.h	/^   void writeScidacFileRecord(GridBase *grid,SerialisableUserFile &_userFile)$/;"	f	class:Grid::QCD::ScidacWriter
writeSingleAttribute	lib/serialisation/Hdf5IO.h	/^  void Hdf5Writer::writeSingleAttribute(const U &x, const std::string &name,$/;"	f	class:Grid::Hdf5Writer
write_buffer	lib/pugixml/pugixml.cc	/^		void write_buffer(const char_t* data, size_t length)$/;"	f	class:xml_buffered_writer
write_direct	lib/pugixml/pugixml.cc	/^		void write_direct(const char_t* data, size_t length)$/;"	f	class:xml_buffered_writer
write_string	lib/pugixml/pugixml.cc	/^		void write_string(const char_t* data)$/;"	f	class:xml_buffered_writer
writer	lib/pugixml/pugixml.cc	/^		typedef utf16_writer writer;$/;"	t	struct:wchar_selector	file:
writer	lib/pugixml/pugixml.cc	/^		typedef utf32_writer writer;$/;"	t	struct:wchar_selector	file:
writer	lib/pugixml/pugixml.cc	/^		xml_writer& writer;$/;"	m	class:xml_buffered_writer	file:
writes	lib/perfmon/Stat.h	/^    uint64_t writes;    \/\/ memory writes$/;"	m	class:Grid::PmuStat
x	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	lib/Eigen/src/Core/arch/CUDA/Half.h	/^  unsigned short x;$/;"	m	struct:Eigen::half_impl::__half
x	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase
x	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar& x() { return this->derived().coeffs().coeffRef(0); }$/;"	f	class:Eigen::QuaternionBase
x	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	lib/algorithms/approx/bigfloat.h	/^  mpf_t x;$/;"	m	class:bigfloat
x	lib/algorithms/approx/bigfloat_double.h	/^  mfloat x;$/;"	m	class:bigfloat
x	lib/simd/Grid_sse4.h	/^    uint16_t x;$/;"	m	struct:Grid::Optimization::Grid_half
xbuf	lib/communicator/Communicator_mpi3_leader.cc	/^  uint64_t xbuf;$/;"	m	struct:Grid::Descriptor	file:
xi	lib/qcd/hmc/integrators/Integrator_algorithm.h	/^  const RealD xi = 0.0;$/;"	m	class:Grid::QCD::ForceGradient
xlsub	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlsub; \/\/ pointers to the beginning of each column in lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xlusup	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlusup; \/\/ pointers to the beginning of each column in lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xmemctrs	lib/perfmon/Stat.cc	/^void PmuStat::xmemctrs(uint64_t *mr, uint64_t *mw)$/;"	f	class:Grid::PmuStat
xml_allocator	lib/pugixml/pugixml.cc	/^		xml_allocator(xml_memory_page* root): _root(root), _busy_size(root->busy_size)$/;"	f	struct:xml_allocator
xml_allocator	lib/pugixml/pugixml.cc	/^	struct xml_allocator$/;"	s	file:
xml_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute::xml_attribute(): _attr(0)$/;"	f	class:pugi::xml_attribute
xml_attribute	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute::xml_attribute(xml_attribute_struct* attr): _attr(attr)$/;"	f	class:pugi::xml_attribute
xml_attribute	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_attribute$/;"	c	namespace:pugi
xml_attribute_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator()$/;"	f	class:pugi::xml_attribute_iterator
xml_attribute_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent): _wrap(attr), _parent(parent)$/;"	f	class:pugi::xml_attribute_iterator
xml_attribute_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_attribute_iterator::xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)$/;"	f	class:pugi::xml_attribute_iterator
xml_attribute_iterator	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_attribute_iterator$/;"	c	namespace:pugi
xml_attribute_struct	lib/pugixml/pugixml.cc	/^		xml_attribute_struct(impl::xml_memory_page* page): header(page, 0), namevalue_base(0)$/;"	f	struct:pugi::xml_attribute_struct
xml_attribute_struct	lib/pugixml/pugixml.cc	/^	struct xml_attribute_struct$/;"	s	namespace:pugi	file:
xml_buffered_writer	lib/pugixml/pugixml.cc	/^		xml_buffered_writer(xml_writer& writer_, xml_encoding user_encoding): writer(writer_), bufsize(0), encoding(get_write_encoding(user_encoding))$/;"	f	class:xml_buffered_writer
xml_buffered_writer	lib/pugixml/pugixml.cc	/^	class xml_buffered_writer$/;"	c	file:
xml_document	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_document::xml_document(): _buffer(0)$/;"	f	class:pugi::xml_document
xml_document	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_document: public xml_node$/;"	c	namespace:pugi
xml_document_struct	lib/pugixml/pugixml.cc	/^		xml_document_struct(xml_memory_page* page): xml_node_struct(page, node_document), xml_allocator(page), buffer(0), extra_buffers(0)$/;"	f	struct:xml_document_struct
xml_document_struct	lib/pugixml/pugixml.cc	/^	struct xml_document_struct: public xml_node_struct, public xml_allocator$/;"	s	file:
xml_encoding	lib/pugixml/pugixml.h	/^	enum xml_encoding$/;"	g	namespace:pugi
xml_extra_buffer	lib/pugixml/pugixml.cc	/^	struct xml_extra_buffer$/;"	s	file:
xml_memory	lib/pugixml/pugixml.cc	/^	typedef xml_memory_management_function_storage<int> xml_memory;$/;"	t	file:
xml_memory_block_alignment	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_block_alignment = 4;$/;"	v	file:
xml_memory_block_alignment	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_block_alignment = sizeof(void*);$/;"	v	file:
xml_memory_management_function_storage	lib/pugixml/pugixml.cc	/^	struct xml_memory_management_function_storage$/;"	s	file:
xml_memory_page	lib/pugixml/pugixml.cc	/^	struct xml_memory_page$/;"	s	file:
xml_memory_page_alignment	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_alignment = 64;$/;"	v	file:
xml_memory_page_alignment	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_alignment = sizeof(void*);$/;"	v	file:
xml_memory_page_contents_shared_mask	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_contents_shared_mask = 32;$/;"	v	file:
xml_memory_page_name_allocated_mask	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_name_allocated_mask = 16;$/;"	v	file:
xml_memory_page_name_allocated_or_shared_mask	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_name_allocated_or_shared_mask = xml_memory_page_name_allocated_mask | xml_memory_page_contents_shared_mask;$/;"	v	file:
xml_memory_page_pointer_mask	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_pointer_mask = ~(xml_memory_page_alignment - 1);$/;"	v	file:
xml_memory_page_size	lib/pugixml/pugixml.cc	/^	static const size_t xml_memory_page_size =$/;"	v	file:
xml_memory_page_type_mask	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_type_mask = 7;$/;"	v	file:
xml_memory_page_value_allocated_mask	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_value_allocated_mask = 8;$/;"	v	file:
xml_memory_page_value_allocated_or_shared_mask	lib/pugixml/pugixml.cc	/^	static const uintptr_t xml_memory_page_value_allocated_or_shared_mask = xml_memory_page_value_allocated_mask | xml_memory_page_contents_shared_mask;$/;"	v	file:
xml_memory_string_header	lib/pugixml/pugixml.cc	/^	struct xml_memory_string_header$/;"	s	file:
xml_named_node_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(): _name(0)$/;"	f	class:pugi::xml_named_node_iterator
xml_named_node_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(const xml_node& node, const char_t* name): _wrap(node), _parent(node.parent()), _name(name)$/;"	f	class:pugi::xml_named_node_iterator
xml_named_node_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_named_node_iterator::xml_named_node_iterator(xml_node_struct* ref, xml_node_struct* parent, const char_t* name): _wrap(ref), _parent(parent), _name(name)$/;"	f	class:pugi::xml_named_node_iterator
xml_named_node_iterator	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_named_node_iterator$/;"	c	namespace:pugi
xml_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node::xml_node(): _root(0)$/;"	f	class:pugi::xml_node
xml_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node::xml_node(xml_node_struct* p): _root(p)$/;"	f	class:pugi::xml_node
xml_node	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_node$/;"	c	namespace:pugi
xml_node_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_iterator::xml_node_iterator()$/;"	f	class:pugi::xml_node_iterator
xml_node_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_iterator::xml_node_iterator(const xml_node& node): _wrap(node), _parent(node.parent())$/;"	f	class:pugi::xml_node_iterator
xml_node_iterator	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_node_iterator::xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)$/;"	f	class:pugi::xml_node_iterator
xml_node_iterator	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_node_iterator$/;"	c	namespace:pugi
xml_node_struct	lib/pugixml/pugixml.cc	/^		xml_node_struct(impl::xml_memory_page* page, xml_node_type type): header(page, type - 1), namevalue_base(0)$/;"	f	struct:pugi::xml_node_struct
xml_node_struct	lib/pugixml/pugixml.cc	/^	struct xml_node_struct$/;"	s	namespace:pugi	file:
xml_node_type	lib/pugixml/pugixml.h	/^	enum xml_node_type$/;"	g	namespace:pugi
xml_object_range	lib/pugixml/pugixml.h	/^		xml_object_range(It b, It e): _begin(b), _end(e)$/;"	f	class:pugi::xml_object_range
xml_object_range	lib/pugixml/pugixml.h	/^	template <typename It> class xml_object_range$/;"	c	namespace:pugi
xml_parse_result	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_parse_result::xml_parse_result(): status(status_internal_error), offset(0), encoding(encoding_auto)$/;"	f	class:pugi::xml_parse_result
xml_parse_result	lib/pugixml/pugixml.h	/^	struct PUGIXML_CLASS xml_parse_result$/;"	s	namespace:pugi
xml_parse_status	lib/pugixml/pugixml.h	/^	enum xml_parse_status$/;"	g	namespace:pugi
xml_parser	lib/pugixml/pugixml.cc	/^		xml_parser(xml_allocator* alloc_): alloc(*alloc_), alloc_state(alloc_), error_offset(0), error_status(status_ok)$/;"	f	struct:xml_parser
xml_parser	lib/pugixml/pugixml.cc	/^	struct xml_parser$/;"	s	file:
xml_stream_chunk	lib/pugixml/pugixml.cc	/^		xml_stream_chunk(): next(0), size(0)$/;"	f	struct:xml_stream_chunk
xml_stream_chunk	lib/pugixml/pugixml.cc	/^	template <typename T> struct xml_stream_chunk$/;"	s	file:
xml_text	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text::xml_text(): _root(0)$/;"	f	class:pugi::xml_text
xml_text	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_text::xml_text(xml_node_struct* root): _root(root)$/;"	f	class:pugi::xml_text
xml_text	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_text$/;"	c	namespace:pugi
xml_tree_walker	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_tree_walker::xml_tree_walker(): _depth(0)$/;"	f	class:pugi::xml_tree_walker
xml_tree_walker	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_tree_walker$/;"	c	namespace:pugi
xml_writer	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_writer$/;"	c	namespace:pugi
xml_writer_file	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_writer_file::xml_writer_file(void* file_): file(file_)$/;"	f	class:pugi::xml_writer_file
xml_writer_file	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_writer_file: public xml_writer$/;"	c	namespace:pugi
xml_writer_stream	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream): narrow_stream(&stream), wide_stream(0)$/;"	f	class:pugi::xml_writer_stream
xml_writer_stream	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_writer_stream::xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream): narrow_stream(0), wide_stream(&stream)$/;"	f	class:pugi::xml_writer_stream
xml_writer_stream	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xml_writer_stream: public xml_writer$/;"	c	namespace:pugi
xpath_allocator	lib/pugixml/pugixml.cc	/^		xpath_allocator(xpath_memory_block* root, size_t root_size = 0): _root(root), _root_size(root_size)$/;"	f	class:xpath_allocator
xpath_allocator	lib/pugixml/pugixml.cc	/^	class xpath_allocator$/;"	c	file:
xpath_allocator_capture	lib/pugixml/pugixml.cc	/^		xpath_allocator_capture(xpath_allocator* alloc): _target(alloc), _state(*alloc)$/;"	f	struct:xpath_allocator_capture
xpath_allocator_capture	lib/pugixml/pugixml.cc	/^	struct xpath_allocator_capture$/;"	s	file:
xpath_ast_node	lib/pugixml/pugixml.cc	/^		xpath_ast_node(ast_type_t type, xpath_ast_node* left, axis_t axis, nodetest_t test, const char_t* contents):$/;"	f	class:xpath_ast_node
xpath_ast_node	lib/pugixml/pugixml.cc	/^		xpath_ast_node(ast_type_t type, xpath_ast_node* left, xpath_ast_node* right, predicate_t test):$/;"	f	class:xpath_ast_node
xpath_ast_node	lib/pugixml/pugixml.cc	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, const char_t* value):$/;"	f	class:xpath_ast_node
xpath_ast_node	lib/pugixml/pugixml.cc	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, double value):$/;"	f	class:xpath_ast_node
xpath_ast_node	lib/pugixml/pugixml.cc	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_ast_node* left = 0, xpath_ast_node* right = 0):$/;"	f	class:xpath_ast_node
xpath_ast_node	lib/pugixml/pugixml.cc	/^		xpath_ast_node(ast_type_t type, xpath_value_type rettype_, xpath_variable* value):$/;"	f	class:xpath_ast_node
xpath_ast_node	lib/pugixml/pugixml.cc	/^	class xpath_ast_node$/;"	c	file:
xpath_context	lib/pugixml/pugixml.cc	/^		xpath_context(const xpath_node& n_, size_t position_, size_t size_): n(n_), position(position_), size(size_)$/;"	f	struct:xpath_context
xpath_context	lib/pugixml/pugixml.cc	/^	struct xpath_context$/;"	s	file:
xpath_exception	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_exception::xpath_exception(const xpath_parse_result& result_): _result(result_)$/;"	f	class:pugi::xpath_exception
xpath_exception	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xpath_exception: public std::exception$/;"	c	namespace:pugi
xpath_first	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node xpath_first(const xpath_node* begin, const xpath_node* end, xpath_node_set::type_t type)$/;"	f
xpath_get_order	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::type_t xpath_get_order(const xpath_node* begin, const xpath_node* end)$/;"	f
xpath_lexer	lib/pugixml/pugixml.cc	/^		explicit xpath_lexer(const char_t* query): _cur(query)$/;"	f	class:xpath_lexer
xpath_lexer	lib/pugixml/pugixml.cc	/^	class xpath_lexer$/;"	c	file:
xpath_lexer_string	lib/pugixml/pugixml.cc	/^		xpath_lexer_string(): begin(0), end(0)$/;"	f	struct:xpath_lexer_string
xpath_lexer_string	lib/pugixml/pugixml.cc	/^	struct xpath_lexer_string$/;"	s	file:
xpath_memory_block	lib/pugixml/pugixml.cc	/^	struct xpath_memory_block$/;"	s	file:
xpath_memory_block_alignment	lib/pugixml/pugixml.cc	/^	static const uintptr_t xpath_memory_block_alignment = sizeof(double) > sizeof(void*) ? sizeof(double) : sizeof(void*);$/;"	v	file:
xpath_memory_page_size	lib/pugixml/pugixml.cc	/^	static const size_t xpath_memory_page_size =$/;"	v	file:
xpath_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node::xpath_node()$/;"	f	class:pugi::xpath_node
xpath_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node::xpath_node(const xml_attribute& attribute_, const xml_node& parent_): _node(attribute_ ? parent_ : xml_node()), _attribute(attribute_)$/;"	f	class:pugi::xpath_node
xpath_node	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node::xpath_node(const xml_node& node_): _node(node_)$/;"	f	class:pugi::xpath_node
xpath_node	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xpath_node$/;"	c	namespace:pugi
xpath_node_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::xpath_node_set(): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set
xpath_node_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::xpath_node_set(const xpath_node_set& ns): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set
xpath_node_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::xpath_node_set(const_iterator begin_, const_iterator end_, type_t type_): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set
xpath_node_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::xpath_node_set(xpath_node_set&& rhs): _type(type_unsorted), _begin(&_storage), _end(&_storage)$/;"	f	class:pugi::xpath_node_set
xpath_node_set	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xpath_node_set$/;"	c	namespace:pugi
xpath_node_set_raw	lib/pugixml/pugixml.cc	/^		xpath_node_set_raw(): _type(xpath_node_set::type_unsorted), _begin(0), _end(0), _eos(0)$/;"	f	class:xpath_node_set_raw
xpath_node_set_raw	lib/pugixml/pugixml.cc	/^	class xpath_node_set_raw$/;"	c	file:
xpath_parse_result	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_parse_result::xpath_parse_result(): error("Internal error"), offset(0)$/;"	f	class:pugi::xpath_parse_result
xpath_parse_result	lib/pugixml/pugixml.h	/^	struct PUGIXML_CLASS xpath_parse_result$/;"	s	namespace:pugi
xpath_parser	lib/pugixml/pugixml.cc	/^		xpath_parser(const char_t* query, xpath_variable_set* variables, xpath_allocator* alloc, xpath_parse_result* result): _alloc(alloc), _lexer(query), _query(query), _variables(variables), _result(result)$/;"	f	struct:xpath_parser
xpath_parser	lib/pugixml/pugixml.cc	/^	struct xpath_parser$/;"	s	file:
xpath_query	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_query::xpath_query(): _impl(0)$/;"	f	class:pugi::xpath_query
xpath_query	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_query::xpath_query(const char_t* query, xpath_variable_set* variables): _impl(0)$/;"	f	class:pugi::xpath_query
xpath_query	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_query::xpath_query(xpath_query&& rhs)$/;"	f	class:pugi::xpath_query
xpath_query	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xpath_query$/;"	c	namespace:pugi
xpath_query_impl	lib/pugixml/pugixml.cc	/^		xpath_query_impl(): root(0), alloc(&block)$/;"	f	struct:xpath_query_impl
xpath_query_impl	lib/pugixml/pugixml.cc	/^	struct xpath_query_impl$/;"	s	file:
xpath_sort	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::type_t xpath_sort(xpath_node* begin, xpath_node* end, xpath_node_set::type_t type, bool rev)$/;"	f
xpath_stack	lib/pugixml/pugixml.cc	/^	struct xpath_stack$/;"	s	file:
xpath_stack_data	lib/pugixml/pugixml.cc	/^		xpath_stack_data(): result(blocks + 0), temp(blocks + 1)$/;"	f	struct:xpath_stack_data
xpath_stack_data	lib/pugixml/pugixml.cc	/^	struct xpath_stack_data$/;"	s	file:
xpath_string	lib/pugixml/pugixml.cc	/^		xpath_string(): _buffer(PUGIXML_TEXT("")), _uses_heap(false), _length_heap(0)$/;"	f	class:xpath_string
xpath_string	lib/pugixml/pugixml.cc	/^		xpath_string(const char_t* buffer, bool uses_heap_, size_t length_heap): _buffer(buffer), _uses_heap(uses_heap_), _length_heap(length_heap)$/;"	f	class:xpath_string	file:
xpath_string	lib/pugixml/pugixml.cc	/^	class xpath_string$/;"	c	file:
xpath_type_boolean	lib/pugixml/pugixml.h	/^		xpath_type_boolean	  \/\/ Boolean$/;"	e	enum:pugi::xpath_value_type
xpath_type_node_set	lib/pugixml/pugixml.h	/^		xpath_type_node_set,  \/\/ Node set (xpath_node_set)$/;"	e	enum:pugi::xpath_value_type
xpath_type_none	lib/pugixml/pugixml.h	/^		xpath_type_none,	  \/\/ Unknown type (query failed to compile)$/;"	e	enum:pugi::xpath_value_type
xpath_type_number	lib/pugixml/pugixml.h	/^		xpath_type_number,	  \/\/ Number$/;"	e	enum:pugi::xpath_value_type
xpath_type_string	lib/pugixml/pugixml.h	/^		xpath_type_string,	  \/\/ String$/;"	e	enum:pugi::xpath_value_type
xpath_value_type	lib/pugixml/pugixml.h	/^	enum xpath_value_type$/;"	g	namespace:pugi
xpath_variable	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable::xpath_variable(xpath_value_type type_): _type(type_), _next(0)$/;"	f	class:pugi::xpath_variable
xpath_variable	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xpath_variable$/;"	c	namespace:pugi
xpath_variable_boolean	lib/pugixml/pugixml.cc	/^		xpath_variable_boolean(): xpath_variable(xpath_type_boolean), value(false)$/;"	f	struct:xpath_variable_boolean
xpath_variable_boolean	lib/pugixml/pugixml.cc	/^	struct xpath_variable_boolean: xpath_variable$/;"	s	file:
xpath_variable_node_set	lib/pugixml/pugixml.cc	/^		xpath_variable_node_set(): xpath_variable(xpath_type_node_set)$/;"	f	struct:xpath_variable_node_set
xpath_variable_node_set	lib/pugixml/pugixml.cc	/^	struct xpath_variable_node_set: xpath_variable$/;"	s	file:
xpath_variable_number	lib/pugixml/pugixml.cc	/^		xpath_variable_number(): xpath_variable(xpath_type_number), value(0)$/;"	f	struct:xpath_variable_number
xpath_variable_number	lib/pugixml/pugixml.cc	/^	struct xpath_variable_number: xpath_variable$/;"	s	file:
xpath_variable_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable_set::xpath_variable_set()$/;"	f	class:pugi::xpath_variable_set
xpath_variable_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable_set::xpath_variable_set(const xpath_variable_set& rhs)$/;"	f	class:pugi::xpath_variable_set
xpath_variable_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable_set::xpath_variable_set(xpath_variable_set&& rhs)$/;"	f	class:pugi::xpath_variable_set
xpath_variable_set	lib/pugixml/pugixml.h	/^	class PUGIXML_CLASS xpath_variable_set$/;"	c	namespace:pugi
xpath_variable_string	lib/pugixml/pugixml.cc	/^		xpath_variable_string(): xpath_variable(xpath_type_string), value(0)$/;"	f	struct:xpath_variable_string
xpath_variable_string	lib/pugixml/pugixml.cc	/^	struct xpath_variable_string: xpath_variable$/;"	s	file:
xsup	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xsup; \/\/First supernode column ... xsup(s) points to the beginning of the s-th supernode$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xtag	lib/communicator/Communicator_mpi3_leader.cc	/^  int xtag;$/;"	m	struct:Grid::Descriptor	file:
xusub	lib/Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xusub; \/\/ Pointers to the beginning of each column of U in ucol $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xx	lib/algorithms/approx/Remez.h	/^  bigfloat *xx, *mm, *step;$/;"	m	class:AlgRemez
y	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    y() const$/;"	f	class:Eigen::DenseCoeffsBase
y	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    y()$/;"	f	class:Eigen::DenseCoeffsBase
y	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase
y	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar& y() { return this->derived().coeffs().coeffRef(1); }$/;"	f	class:Eigen::QuaternionBase
y	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	lib/simd/Grid_vector_unops.h	/^  Integer y;$/;"	m	struct:Grid::DivIntFunctor
y	lib/simd/Grid_vector_unops.h	/^  Integer y;$/;"	m	struct:Grid::ModIntFunctor
y	lib/simd/Grid_vector_unops.h	/^  double y;$/;"	m	struct:Grid::PowRealFunctor
yes	lib/Eigen/src/Core/util/Meta.h	/^  struct yes {int a[1];};$/;"	s	struct:Eigen::internal::is_convertible_impl
yes	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct yes {int a[1];};$/;"	s	struct:Eigen::internal::is_ref_compatible_impl
z	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    z() const$/;"	f	class:Eigen::DenseCoeffsBase
z	lib/Eigen/src/Core/DenseCoeffsBase.h	/^    z()$/;"	f	class:Eigen::DenseCoeffsBase
z	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase
z	lib/Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar& z() { return this->derived().coeffs().coeffRef(2); }$/;"	f	class:Eigen::QuaternionBase
z	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
z	lib/Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
zCoeffs	lib/Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const HCoeffsType& zCoeffs() const { return m_zCoeffs; }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
zero	lib/simd/Simd.h	/^  static Zero zero;$/;"	m	namespace:Grid
zero_terminate_buffer	lib/pugixml/pugixml.cc	/^	PUGI__FN size_t zero_terminate_buffer(void* buffer, size_t size, xml_encoding encoding) $/;"	f
zeroit	lib/simd/Grid_vector_types.h	/^inline void zeroit(Grid_simd<S, V> &z) {$/;"	f	namespace:Grid
zeroit	lib/simd/Simd.h	/^  template<>            inline void zeroit(ComplexD &arg){ arg=0; };$/;"	f	namespace:Grid
zeroit	lib/simd/Simd.h	/^  template<>            inline void zeroit(ComplexF &arg){ arg=0; };$/;"	f	namespace:Grid
zeroit	lib/simd/Simd.h	/^  template<>            inline void zeroit(RealD &arg){ arg=0; };$/;"	f	namespace:Grid
zeroit	lib/simd/Simd.h	/^  template<>            inline void zeroit(RealF &arg){ arg=0; };$/;"	f	namespace:Grid
zeroit	lib/simd/Simd.h	/^  template<class itype> inline void zeroit(itype &arg){ arg=zero;};$/;"	f	namespace:Grid
zeroit	lib/tensors/Tensor_class.h	/^  friend strong_inline void zeroit(iMatrix<vtype,N> &that){$/;"	f	class:Grid::iMatrix
zeroit	lib/tensors/Tensor_class.h	/^  friend strong_inline void zeroit(iScalar<vtype> &that){$/;"	f	class:Grid::iScalar
zeroit	lib/tensors/Tensor_class.h	/^  friend strong_inline void zeroit(iVector<vtype, N> &that) {$/;"	f	class:Grid::iVector
zeta	lib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^zeta(const EIGEN_CURRENT_STORAGE_BASE_CLASS<DerivedQ> &q) const$/;"	f
zmScheme_	lib/qcd/action/gauge/Photon.h	/^    ZmScheme zmScheme_;$/;"	m	class:Grid::QCD::Photon
zmSub	lib/qcd/action/gauge/Photon.h	/^  void Photon<Gimpl>::zmSub(GaugeLinkField &out)$/;"	f	class:Grid::QCD::Photon
zolo_hi	tests/qdpxx/Test_qdpxx_munprec.cc	/^double zolo_hi = 2.0;$/;"	v
zolo_lo	tests/qdpxx/Test_qdpxx_munprec.cc	/^double zolo_lo = 0.1;$/;"	v
zolotarev	lib/algorithms/approx/Zolotarev.cc	/^zolotarev_data* zolotarev(PRECISION epsilon, int n, int type) {$/;"	f	namespace:Grid::Approx
zolotarev_cayley_eval	lib/algorithms/approx/Zolotarev.cc	/^static PRECISION zolotarev_cayley_eval(PRECISION x, zolotarev_data* rdata) {$/;"	f	file:
zolotarev_contfrac_eval	lib/algorithms/approx/Zolotarev.cc	/^static PRECISION zolotarev_contfrac_eval(PRECISION x, zolotarev_data* rdata) {$/;"	f	file:
zolotarev_eval	lib/algorithms/approx/Zolotarev.cc	/^static PRECISION zolotarev_eval(PRECISION x, zolotarev_data* rdata) {$/;"	f	file:
zolotarev_free	lib/algorithms/approx/Zolotarev.cc	/^void zolotarev_free(zolotarev_data *zdata)$/;"	f	namespace:Grid::Approx
zolotarev_partfrac_eval	lib/algorithms/approx/Zolotarev.cc	/^static PRECISION zolotarev_partfrac_eval(PRECISION x, zolotarev_data* rdata) {$/;"	f	file:
~Action	lib/qcd/action/ActionBase.h	/^  virtual ~Action(){}$/;"	f	class:Grid::QCD::Action
~AlgRemez	lib/algorithms/approx/Remez.cc	/^AlgRemez::~AlgRemez()$/;"	f	class:AlgRemez
~AlignedBox	lib/Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox
~AmbiVector	lib/Eigen/src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector
~BDCSVD	lib/Eigen/src/SVD/BDCSVD.h	/^  ~BDCSVD() $/;"	f	class:Eigen::BDCSVD
~BiCGSTAB	lib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB
~CholmodBase	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase
~CholmodDecomposition	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition
~CholmodSimplicialLDLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT
~CholmodSimplicialLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT
~CholmodSupernodalLLT	lib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT
~CompressedStorage	lib/Eigen/src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
~ConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient
~DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	lib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~FFT	lib/algorithms/FFT.h	/^    ~FFT ( void)  {$/;"	f	class:Grid::FFT
~HybridMonteCarlo	lib/qcd/hmc/HMC.h	/^  ~HybridMonteCarlo(){};$/;"	f	class:Grid::QCD::HybridMonteCarlo
~Hyperplane	lib/Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
~Integrator	lib/qcd/hmc/integrators/Integrator.h	/^  virtual ~Integrator() {}$/;"	f	class:Grid::QCD::Integrator
~IterativeSolverBase	lib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase
~JSONWriter	lib/serialisation/JSON_IO.cc	/^JSONWriter::~JSONWriter(void)$/;"	f	class:JSONWriter
~LeastSquaresConjugateGradient	lib/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  ~LeastSquaresConjugateGradient() {}$/;"	f	class:Eigen::LeastSquaresConjugateGradient
~LinearOperatorJacobi	tests/debug/test_Grid_jacobi.cc	/^  ~LinearOperatorJacobi()$/;"	f	class:LinearOperatorJacobi	file:
~Map	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline ~Map() {}$/;"	f	class:Eigen::Map
~MappedSparseMatrix	lib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix
~MappedSuperNodalMatrix	lib/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    ~MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
~ParametrizedLine	lib/Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
~PardisoImpl	lib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
~PastixBase	lib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase
~PerformanceCounter	lib/perfmon/PerfCount.h	/^  ~PerformanceCounter()$/;"	f	class:Grid::PerformanceCounter
~Ref	lib/Eigen/src/SparseCore/SparseRef.h	/^    ~Ref() {$/;"	f	class:Eigen::Ref
~SPQR	lib/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    ~SPQR()$/;"	f	class:Eigen::SPQR
~SimplicialCholeskyBase	lib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
~Smear	lib/qcd/smearing/BaseSmearing.h	/^  virtual ~Smear(){}$/;"	f	class:Smear
~Smear_APE	lib/qcd/smearing/APEsmearing.h	/^  				~Smear_APE(){}$/;"	f	class:Grid::QCD::Smear_APE
~Smear_Stout	lib/qcd/smearing/StoutSmearing.h	/^  ~Smear_Stout() {}  \/\/ delete SmearBase...$/;"	f	class:Grid::QCD::Smear_Stout
~SolverBase	lib/Eigen/src/Core/SolverBase.h	/^    ~SolverBase()$/;"	f	class:Eigen::SolverBase
~SparseLU	lib/Eigen/src/SparseLU/SparseLU.h	/^    ~SparseLU()$/;"	f	class:Eigen::SparseLU
~SparseMapBase	lib/Eigen/src/SparseCore/SparseMap.h	/^    inline ~SparseMapBase() {}$/;"	f	class:Eigen::SparseMapBase
~SparseMatrix	lib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
~SparseSolverBase	lib/Eigen/src/SparseCore/SparseSolverBase.h	/^    ~SparseSolverBase()$/;"	f	class:Eigen::SparseSolverBase
~SparseVector	lib/Eigen/src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector
~SuperILU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU
~SuperLU	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU
~SuperLUBase	lib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase
~UmfPackLU	lib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU
~XmlWriter	lib/serialisation/XmlIO.cc	/^XmlWriter::~XmlWriter(void)$/;"	f	class:XmlWriter
~alignedAllocator	lib/allocator/AlignedAllocator.h	/^    ~alignedAllocator() throw() {}$/;"	f	class:Grid::alignedAllocator
~aligned_allocator	lib/Eigen/src/Core/util/Memory.h	/^  ~aligned_allocator() {}$/;"	f	class:Eigen::aligned_allocator
~aligned_allocator_indirection	lib/Eigen/src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
~aligned_stack_memory_handler	lib/Eigen/src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
~auto_deleter	lib/pugixml/pugixml.cc	/^		~auto_deleter()$/;"	f	struct:auto_deleter
~basic_json	lib/json/json.hpp	/^    ~basic_json()$/;"	f	class:nlohmann::basic_json
~bigfloat	lib/algorithms/approx/bigfloat.h	/^  ~bigfloat(void) { mpf_clear(x); }$/;"	f	class:bigfloat
~bigfloat	lib/algorithms/approx/bigfloat_double.h	/^  ~bigfloat(void) { }$/;"	f	class:bigfloat
~commAllocator	lib/allocator/AlignedAllocator.h	/^  ~commAllocator() throw() { }$/;"	f	class:Grid::commAllocator
~gemm_blocking_space	lib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space
~noncopyable	lib/Eigen/src/Core/util/Meta.h	/^  EIGEN_DEVICE_FUNC ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
~scoped_array	lib/Eigen/src/Core/util/Memory.h	/^  ~scoped_array()$/;"	f	class:Eigen::internal::scoped_array
~xml_document	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_document::~xml_document()$/;"	f	class:pugi::xml_document
~xml_parser	lib/pugixml/pugixml.cc	/^		~xml_parser()$/;"	f	struct:xml_parser
~xml_tree_walker	lib/pugixml/pugixml.cc	/^	PUGI__FN xml_tree_walker::~xml_tree_walker()$/;"	f	class:pugi::xml_tree_walker
~xml_writer	lib/pugixml/pugixml.h	/^		virtual ~xml_writer() {}$/;"	f	class:pugi::xml_writer
~xpath_allocator_capture	lib/pugixml/pugixml.cc	/^		~xpath_allocator_capture()$/;"	f	struct:xpath_allocator_capture
~xpath_node_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_node_set::~xpath_node_set()$/;"	f	class:pugi::xpath_node_set
~xpath_query	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_query::~xpath_query()$/;"	f	class:pugi::xpath_query
~xpath_stack_data	lib/pugixml/pugixml.cc	/^		~xpath_stack_data()$/;"	f	struct:xpath_stack_data
~xpath_variable_set	lib/pugixml/pugixml.cc	/^	PUGI__FN xpath_variable_set::~xpath_variable_set()$/;"	f	class:pugi::xpath_variable_set
~xpath_variable_string	lib/pugixml/pugixml.cc	/^		~xpath_variable_string()$/;"	f	struct:xpath_variable_string
